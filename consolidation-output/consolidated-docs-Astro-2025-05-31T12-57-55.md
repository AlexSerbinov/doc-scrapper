# 📚 Consolidated Documentation - Astro

## 📊 Overview

- **Total Files**: 197
- **Total Size**: 2.13 MB
- **Estimated Tokens**: ~557,537
- **Generated**: 5/31/2025, 3:57:55 PM

## 🔧 Usage Instructions

This consolidated documentation file contains the complete content of your scraped documentation.

**Recommended for:**
- 🤖 **Google Gemini Flash/Pro** (2M+ token context)
- 🤖 **ChatGPT-4 Turbo** (128K+ token context)
- 🤖 **Claude 3.5 Sonnet** (200K+ token context)
- 🤖 **Other large context LLMs**

**Instructions:**
1. Copy this entire document
2. Paste into your preferred LLM
3. Ask questions about the documentation
4. Get instant, context-aware answers!

---

## 📁 Directory Structure

```text
📄 README.md
📁 en
  📁 basics
    📁 astro-components
      📄 .md
    📁 astro-pages
      📄 .md
    📁 layouts
      📄 .md
    📁 project-structure
      📄 .md
  📁 concepts
    📁 islands
      📄 .md
    📁 why-astro
      📄 .md
  📁 contribute
    📄 .md
  📁 editor-setup
    📄 .md
  📁 getting-started
    📄 .md
  📁 guides
    📁 actions
      📄 .md
    📁 astro-db
      📄 .md
    📁 authentication
      📄 .md
    📁 backend
      📄 .md
      📁 appwriteio
        📄 .md
      📁 google-firebase
        📄 .md
      📁 neon
        📄 .md
      📁 sentry
        📄 .md
      📁 supabase
        📄 .md
      📁 turso
        📄 .md
      📁 xata
        📄 .md
    📁 client-side-scripts
      📄 .md
    📁 cms
      📄 .md
      📁 apostrophecms
        📄 .md
      📁 buttercms
        📄 .md
      📁 caisy
        📄 .md
      📁 cloudcannon
        📄 .md
      📁 contentful
        📄 .md
      📁 cosmic
        📄 .md
      📁 craft-cms
        📄 .md
      📁 crystallize
        📄 .md
      📁 datocms
        📄 .md
      📁 decap-cms
        📄 .md
      📁 directus
        📄 .md
      📁 drupal
        📄 .md
      📁 flotiq
        📄 .md
      📁 frontmatter-cms
        📄 .md
      📁 ghost
        📄 .md
      📁 gitcms
        📄 .md
      📁 hashnode
        📄 .md
      📁 hygraph
        📄 .md
      📁 keystatic
        📄 .md
      📁 keystonejs
        📄 .md
      📁 kontent-ai
        📄 .md
      📁 microcms
        📄 .md
      📁 payload
        📄 .md
      📁 preprcms
        📄 .md
      📁 prismic
        📄 .md
      📁 sanity
        📄 .md
      📁 sitecore
        📄 .md
      📁 spinal
        📄 .md
      📁 statamic
        📄 .md
      📁 storyblok
        📄 .md
      📁 strapi
        📄 .md
      📁 studiocms
        📄 .md
      📁 tina-cms
        📄 .md
      📁 umbraco
        📄 .md
      📁 wordpress
        📄 .md
    📁 configuring-astro
      📄 .md
    📁 content-collections
      📄 .md
    📁 data-fetching
      📄 .md
    📁 deploy
      📄 .md
      📁 aws
        📄 .md
      📁 azion
        📄 .md
      📁 buddy
        📄 .md
      📁 cleavr
        📄 .md
      📁 clever-cloud
        📄 .md
      📁 cloudflare
        📄 .md
      📁 deno
        📄 .md
      📁 fleek
        📄 .md
      📁 flightcontrol
        📄 .md
      📁 flyio
        📄 .md
      📁 github
        📄 .md
      📁 gitlab
        📄 .md
      📁 google-cloud
        📄 .md
      📁 google-firebase
        📄 .md
      📁 heroku
        📄 .md
      📁 kinsta
        📄 .md
      📁 microsoft-azure
        📄 .md
      📁 netlify
        📄 .md
      📁 render
        📄 .md
      📁 sst
        📄 .md
      📁 stormkit
        📄 .md
      📁 surge
        📄 .md
      📁 vercel
        📄 .md
      📁 zeabur
        📄 .md
      📁 zerops
        📄 .md
    📁 dev-toolbar
      📄 .md
    📁 ecommerce
      📄 .md
    📁 endpoints
      📄 .md
    📁 environment-variables
      📄 .md
    📁 fonts
      📄 .md
    📁 framework-components
      📄 .md
    📁 images
      📄 .md
    📁 imports
      📄 .md
    📁 integrations-guide
      📄 .md
      📁 alpinejs
        📄 .md
      📁 cloudflare
        📄 .md
      📁 db
        📄 .md
      📁 markdoc
        📄 .md
      📁 mdx
        📄 .md
      📁 netlify
        📄 .md
      📁 node
        📄 .md
      📁 partytown
        📄 .md
      📁 preact
        📄 .md
      📁 react
        📄 .md
      📁 solid-js
        📄 .md
      📁 svelte
        📄 .md
      📁 vercel
        📄 .md
      📁 vue
        📄 .md
    📁 internationalization
      📄 .md
    📁 markdown-content
      📄 .md
    📁 media
      📄 .md
      📁 cloudinary
        📄 .md
    📁 middleware
      📄 .md
    📁 migrate-to-astro
      📄 .md
      📁 from-create-react-app
        📄 .md
      📁 from-docusaurus
        📄 .md
      📁 from-eleventy
        📄 .md
      📁 from-gatsby
        📄 .md
      📁 from-gitbook
        📄 .md
      📁 from-gridsome
        📄 .md
      📁 from-hugo
        📄 .md
      📁 from-jekyll
        📄 .md
      📁 from-nextjs
        📄 .md
      📁 from-nuxtjs
        📄 .md
      📁 from-pelican
        📄 .md
      📁 from-sveltekit
        📄 .md
      📁 from-vuepress
        📄 .md
      📁 from-wordpress
        📄 .md
    📁 on-demand-rendering
      📄 .md
    📁 prefetch
      📄 .md
    📁 routing
      📄 .md
    📁 server-islands
      📄 .md
    📁 sessions
      📄 .md
    📁 styling
      📄 .md
    📁 syntax-highlighting
      📄 .md
    📁 testing
      📄 .md
    📁 troubleshooting
      📄 .md
    📁 typescript
      📄 .md
    📁 upgrade-to
      📁 v1
        📄 .md
      📁 v2
        📄 .md
      📁 v3
        📄 .md
      📁 v4
        📄 .md
      📁 v5
        📄 .md
    📁 view-transitions
      📄 .md
  📁 install-and-setup
    📄 .md
  📁 recipes
    📄 .md
    📁 add-yaml-support
      📄 .md
    📁 analyze-bundle-size
      📄 .md
    📁 bun
      📄 .md
    📁 call-endpoints
      📄 .md
    📁 captcha
      📄 .md
    📁 docker
      📄 .md
    📁 dynamically-importing-images
      📄 .md
    📁 external-links
      📄 .md
    📁 i18n
      📄 .md
    📁 making-toolbar-apps
      📄 .md
    📁 modified-time
      📄 .md
    📁 reading-time
      📄 .md
    📁 sharing-state
      📄 .md
    📁 sharing-state-islands
      📄 .md
    📁 streaming-improve-page-performance
      📄 .md
    📁 tailwind-rendered-markdown
      📄 .md
  📁 reference
    📁 adapter-reference
      📄 .md
    📁 astro-syntax
      📄 .md
    📁 cli-reference
      📄 .md
    📁 configuration-reference
      📄 .md
    📁 container-reference
      📄 .md
    📁 content-loader-reference
      📄 .md
    📁 dev-toolbar-app-reference
      📄 .md
    📁 directives-reference
      📄 .md
    📁 error-reference
      📄 .md
    📁 experimental-flags
      📄 .md
      📁 client-prerender
        📄 .md
      📁 content-intellisense
        📄 .md
      📁 fonts
        📄 .md
      📁 heading-id-compat
        📄 .md
      📁 preserve-scripts-order
        📄 .md
      📁 responsive-images
        📄 .md
    📁 image-service-reference
      📄 .md
    📁 integrations-reference
      📄 .md
    📁 legacy-flags
      📄 .md
    📁 modules
      📁 astro-actions
        📄 .md
      📁 astro-assets
        📄 .md
      📁 astro-config
        📄 .md
      📁 astro-content
        📄 .md
      📁 astro-env
        📄 .md
      📁 astro-i18n
        📄 .md
      📁 astro-middleware
        📄 .md
      📁 astro-transitions
        📄 .md
    📁 programmatic-reference
      📄 .md
    📁 publish-to-npm
      📄 .md
    📁 routing-reference
      📄 .md
  📁 tutorial
    📁 0-introduction
      📄 .md
  📁 upgrade-astro
    📄 .md
📄 scraping-summary.json

```

## 📄 File Contents

### 1. `README.md`

```markdown
# Documentation Index

**Source**: https://docs.astro.build/en/getting-started/
**Scraped**: 5/31/2025
**Total Pages**: 200

---

## Basics

- [Components](en/basics/astro-components/.md)
- [Layouts](en/basics/layouts/.md)
- [Pages](en/basics/astro-pages/.md)
- [Project structure](en/basics/project-structure/.md)

## Concepts

- [Islands architecture](en/concepts/islands/.md)
- [Why Astro?](en/concepts/why-astro/.md)

## Contribute

- [Contribute to Astro](en/contribute/.md)

## Develop-and-build

- [Develop and build](en/develop-and-build/.md)

## Editor-setup

- [Editor setup](en/editor-setup/.md)

## Getting-started

- [Astro Docs](en/getting-started/.md)

## Guides

- [@astrojs/
					alpinejs](en/guides/integrations-guide/alpinejs/.md)
- [@astrojs/
					cloudflare](en/guides/integrations-guide/cloudflare/.md)
- [@astrojs/
					db](en/guides/integrations-guide/db/.md)
- [@astrojs/
					markdoc](en/guides/integrations-guide/markdoc/.md)
- [@astrojs/
					mdx](en/guides/integrations-guide/mdx/.md)
- [@astrojs/
					netlify](en/guides/integrations-guide/netlify/.md)
- [@astrojs/
					node](en/guides/integrations-guide/node/.md)
- [@astrojs/
					partytown](en/guides/integrations-guide/partytown/.md)
- [@astrojs/
					preact](en/guides/integrations-guide/preact/.md)
- [@astrojs/
					react](en/guides/integrations-guide/react/.md)
- [@astrojs/
					solid-js](en/guides/integrations-guide/solid-js/.md)
- [@astrojs/
					svelte](en/guides/integrations-guide/svelte/.md)
- [@astrojs/
					vercel](en/guides/integrations-guide/vercel/.md)
- [@astrojs/
					vue](en/guides/integrations-guide/vue/.md)
- [Actions](en/guides/actions/.md)
- [Add Integrations](en/guides/integrations-guide/.md)
- [ApostropheCMS & Astro](en/guides/cms/apostrophecms/.md)
- [Appwrite & Astro](en/guides/backend/appwriteio/.md)
- [Astro DB](en/guides/astro-db/.md)
- [Authentication](en/guides/authentication/.md)
- [Builder.io & Astro](en/guides/cms/builderio/.md)
- [ButterCMS & Astro](en/guides/cms/buttercms/.md)
- [Caisy & Astro](en/guides/cms/caisy/.md)
- [CloudCannon & Astro](en/guides/cms/cloudcannon/.md)
- [Cloudinary & Astro](en/guides/media/cloudinary/.md)
- [Configuration overview](en/guides/configuring-astro/.md)
- [Content collections](en/guides/content-collections/.md)
- [Contentful & Astro](en/guides/cms/contentful/.md)
- [Cosmic & Astro](en/guides/cms/cosmic/.md)
- [Craft CMS & Astro](en/guides/cms/craft-cms/.md)
- [Crystallize & Astro](en/guides/cms/crystallize/.md)
- [Data fetching](en/guides/data-fetching/.md)
- [DatoCMS & Astro](en/guides/cms/datocms/.md)
- [Decap CMS & Astro](en/guides/cms/decap-cms/.md)
- [Deploy your Astro Site](en/guides/deploy/.md)
- [Deploy your Astro Site to AWS](en/guides/deploy/aws/.md)
- [Deploy your Astro Site to AWS with Flightcontrol](en/guides/deploy/flightcontrol/.md)
- [Deploy your Astro Site to AWS with SST](en/guides/deploy/sst/.md)
- [Deploy your Astro Site to Azion](en/guides/deploy/azion/.md)
- [Deploy your Astro Site to Clever Cloud](en/guides/deploy/clever-cloud/.md)
- [Deploy your Astro Site to Cloudflare](en/guides/deploy/cloudflare/.md)
- [Deploy your Astro Site to Fleek](en/guides/deploy/fleek/.md)
- [Deploy your Astro Site to Fly.io](en/guides/deploy/flyio/.md)
- [Deploy your Astro Site to GitHub Pages](en/guides/deploy/github/.md)
- [Deploy your Astro Site to GitLab Pages](en/guides/deploy/gitlab/.md)
- [Deploy your Astro Site to Google Cloud](en/guides/deploy/google-cloud/.md)
- [Deploy your Astro Site to Google’s Firebase Hosting](en/guides/deploy/google-firebase/.md)
- [Deploy your Astro Site to Heroku](en/guides/deploy/heroku/.md)
- [Deploy your Astro Site to Kinsta Application Hosting](en/guides/deploy/kinsta/.md)
- [Deploy your Astro Site to Microsoft Azure](en/guides/deploy/microsoft-azure/.md)
- [Deploy your Astro Site to Netlify](en/guides/deploy/netlify/.md)
- [Deploy your Astro Site to Render](en/guides/deploy/render/.md)
- [Deploy your Astro Site to Stormkit](en/guides/deploy/stormkit/.md)
- [Deploy your Astro Site to Surge](en/guides/deploy/surge/.md)
- [Deploy your Astro Site to Vercel](en/guides/deploy/vercel/.md)
- [Deploy your Astro Site to Zeabur](en/guides/deploy/zeabur/.md)
- [Deploy your Astro Site to Zerops](en/guides/deploy/zerops/.md)
- [Deploy your Astro Site with Buddy](en/guides/deploy/buddy/.md)
- [Deploy your Astro Site with Cleavr](en/guides/deploy/cleavr/.md)
- [Deploy your Astro Site with Deno](en/guides/deploy/deno/.md)
- [Dev toolbar](en/guides/dev-toolbar/.md)
- [Directus & Astro](en/guides/cms/directus/.md)
- [Drupal & Astro](en/guides/cms/drupal/.md)
- [E-commerce](en/guides/ecommerce/.md)
- [Endpoints](en/guides/endpoints/.md)
- [Firebase & Astro](en/guides/backend/google-firebase/.md)
- [Flotiq & Astro](en/guides/cms/flotiq/.md)
- [Front Matter CMS & Astro](en/guides/cms/frontmatter-cms/.md)
- [Front-end frameworks](en/guides/framework-components/.md)
- [Ghost & Astro](en/guides/cms/ghost/.md)
- [GitCMS & Astro](en/guides/cms/gitcms/.md)
- [Hashnode & Astro](en/guides/cms/hashnode/.md)
- [Headless Statamic & Astro](en/guides/cms/statamic/.md)
- [Headless WordPress & Astro](en/guides/cms/wordpress/.md)
- [Hygraph & Astro](en/guides/cms/hygraph/.md)
- [Images](en/guides/images/.md)
- [Imports reference](en/guides/imports/.md)
- [Internationalization (i18n) Routing](en/guides/internationalization/.md)
- [Keystatic & Astro](en/guides/cms/keystatic/.md)
- [KeystoneJS & Astro](en/guides/cms/keystonejs/.md)
- [Kontent.ai & Astro](en/guides/cms/kontent-ai/.md)
- [Legacy v0.x Upgrade Guide](en/guides/upgrade-to/v1/.md)
- [Markdown in Astro](en/guides/markdown-content/.md)
- [microCMS & Astro](en/guides/cms/microcms/.md)
- [Middleware](en/guides/middleware/.md)
- [Migrate an existing project to Astro](en/guides/migrate-to-astro/.md)
- [Migrating from Create React App (CRA)](en/guides/migrate-to-astro/from-create-react-app/.md)
- [Migrating from Docusaurus](en/guides/migrate-to-astro/from-docusaurus/.md)
- [Migrating from Eleventy](en/guides/migrate-to-astro/from-eleventy/.md)
- [Migrating from Gatsby](en/guides/migrate-to-astro/from-gatsby/.md)
- [Migrating from GitBook](en/guides/migrate-to-astro/from-gitbook/.md)
- [Migrating from Gridsome](en/guides/migrate-to-astro/from-gridsome/.md)
- [Migrating from Hugo](en/guides/migrate-to-astro/from-hugo/.md)
- [Migrating from Jekyll](en/guides/migrate-to-astro/from-jekyll/.md)
- [Migrating from Next.js](en/guides/migrate-to-astro/from-nextjs/.md)
- [Migrating from NuxtJS](en/guides/migrate-to-astro/from-nuxtjs/.md)
- [Migrating from Pelican](en/guides/migrate-to-astro/from-pelican/.md)
- [Migrating from SvelteKit](en/guides/migrate-to-astro/from-sveltekit/.md)
- [Migrating from VuePress](en/guides/migrate-to-astro/from-vuepress/.md)
- [Migrating from WordPress](en/guides/migrate-to-astro/from-wordpress/.md)
- [Monitor your Astro Site with Sentry](en/guides/backend/sentry/.md)
- [Neon Postgres & Astro](en/guides/backend/neon/.md)
- [On-demand rendering](en/guides/on-demand-rendering/.md)
- [Payload CMS & Astro](en/guides/cms/payload/.md)
- [Prefetch](en/guides/prefetch/.md)
- [Prepr CMS & Astro](en/guides/cms/preprcms/.md)
- [Prismic & Astro](en/guides/cms/prismic/.md)
- [Routing](en/guides/routing/.md)
- [Sanity & Astro](en/guides/cms/sanity/.md)
- [Scripts and event handling](en/guides/client-side-scripts/.md)
- [Server islands](en/guides/server-islands/.md)
- [Sessions](en/guides/sessions/.md)
- [Sitecore Experience Manager & Astro](en/guides/cms/sitecore/.md)
- [Spinal & Astro](en/guides/cms/spinal/.md)
- [Storyblok & Astro](en/guides/cms/storyblok/.md)
- [Strapi & Astro](en/guides/cms/strapi/.md)
- [StudioCMS & Astro](en/guides/cms/studiocms/.md)
- [Styles and CSS](en/guides/styling/.md)
- [Supabase & Astro](en/guides/backend/supabase/.md)
- [Syntax Highlighting](en/guides/syntax-highlighting/.md)
- [Testing](en/guides/testing/.md)
- [Tina CMS & Astro](en/guides/cms/tina-cms/.md)
- [Troubleshooting](en/guides/troubleshooting/.md)
- [Turso & Astro](en/guides/backend/turso/.md)
- [TypeScript](en/guides/typescript/.md)
- [Umbraco & Astro](en/guides/cms/umbraco/.md)
- [Upgrade to Astro v2](en/guides/upgrade-to/v2/.md)
- [Upgrade to Astro v3](en/guides/upgrade-to/v3/.md)
- [Upgrade to Astro v4](en/guides/upgrade-to/v4/.md)
- [Upgrade to Astro v5](en/guides/upgrade-to/v5/.md)
- [Use a backend service with Astro](en/guides/backend/.md)
- [Use a CMS with Astro](en/guides/cms/.md)
- [Use a DAM with Astro](en/guides/media/.md)
- [Using custom fonts](en/guides/fonts/.md)
- [Using environment variables](en/guides/environment-variables/.md)
- [View transitions](en/guides/view-transitions/.md)
- [Xata & Astro](en/guides/backend/xata/.md)

## Install-and-setup

- [Install Astro](en/install-and-setup/.md)

## Recipes

- [Add i18n features](en/recipes/i18n/.md)
- [Add icons to external links](en/recipes/external-links/.md)
- [Add last modified time](en/recipes/modified-time/.md)
- [Add reading time](en/recipes/reading-time/.md)
- [Analyze bundle size](en/recipes/analyze-bundle-size/.md)
- [Astro recipes](en/recipes/.md)
- [Build a custom image component](en/recipes/build-custom-img-component/.md)
- [Build forms with API routes](en/recipes/build-forms-api/.md)
- [Build HTML forms in Astro pages](en/recipes/build-forms/.md)
- [Build your Astro site with Docker](en/recipes/docker/.md)
- [Call endpoints from the server](en/recipes/call-endpoints/.md)
- [Create a dev toolbar app](en/recipes/making-toolbar-apps/.md)
- [Dynamically import images](en/recipes/dynamically-importing-images/.md)
- [Installing a Vite or Rollup plugin](en/recipes/add-yaml-support/.md)
- [Share state between Astro components](en/recipes/sharing-state/.md)
- [Share state between islands](en/recipes/sharing-state-islands/.md)
- [Style rendered Markdown with Tailwind Typography](en/recipes/tailwind-rendered-markdown/.md)
- [Use Bun with Astro](en/recipes/bun/.md)
- [Using streaming to improve page performance](en/recipes/streaming-improve-page-performance/.md)
- [Verify a Captcha](en/recipes/captcha/.md)

## Reference

- [Actions API Reference](en/reference/modules/astro-actions/.md)
- [Astro Adapter API](en/reference/adapter-reference/.md)
- [Astro Container API (experimental)](en/reference/container-reference/.md)
- [Astro Content Loader API](en/reference/content-loader-reference/.md)
- [Astro Integration API](en/reference/integrations-reference/.md)
- [CLI Commands](en/reference/cli-reference/.md)
- [Config imports API Reference](en/reference/modules/astro-config/.md)
- [Configuration Reference](en/reference/configuration-reference/.md)
- [Configuring experimental flags](en/reference/experimental-flags/.md)
- [Content Collections API Reference](en/reference/modules/astro-content/.md)
- [Dev Toolbar App API](en/reference/dev-toolbar-app-reference/.md)
- [Environment Variables API Reference](en/reference/modules/astro-env/.md)
- [Error reference](en/reference/error-reference/.md)
- [Experimental client prerendering](en/reference/experimental-flags/client-prerender/.md)
- [Experimental fonts API](en/reference/experimental-flags/fonts/.md)
- [Experimental Intellisense for content collections](en/reference/experimental-flags/content-intellisense/.md)
- [Experimental Markdown heading ID compatibility](en/reference/experimental-flags/heading-id-compat/.md)
- [Experimental preserve scripts order](en/reference/experimental-flags/preserve-scripts-order/.md)
- [Experimental responsive images](en/reference/experimental-flags/responsive-images/.md)
- [Image and Assets API Reference](en/reference/modules/astro-assets/.md)
- [Image Service API](en/reference/image-service-reference/.md)
- [Internationalization API Reference](en/reference/modules/astro-i18n/.md)
- [Legacy flags](en/reference/legacy-flags/.md)
- [Middleware API Reference](en/reference/modules/astro-middleware/.md)
- [Programmatic Astro API (experimental)](en/reference/programmatic-reference/.md)
- [Publish to NPM](en/reference/publish-to-npm/.md)
- [Routing Reference](en/reference/routing-reference/.md)
- [Template directives reference](en/reference/directives-reference/.md)
- [Template expressions reference](en/reference/astro-syntax/.md)
- [View Transitions Router API Reference](en/reference/modules/astro-transitions/.md)

## Tutorial

- [Build your first Astro Blog](en/tutorial/0-introduction/.md)

## Upgrade-astro

- [Upgrade Astro](en/upgrade-astro/.md)
```

### 2. `en/basics/astro-components/.md`

```text
# Components


---
url: https://docs.astro.build/en/basics/astro-components/
description: An introduction to Astro components.
---


# Components


**Astro components** are the basic building blocks of any Astro project. They are HTML-only templating components with no client-side runtime and use the `.astro` file extension.

Note

If you know HTML, you already know enough to write your first Astro component.

Learn more in the [Astro syntax reference](/en/reference/astro-syntax/).

Astro components are extremely flexible. An Astro component can be as small as a snippet of HTML, like a collection of common `<meta>` tags that make SEO easy to work with. Components can be reusable UI elements, like a header or a profile card. Astro components can even contain an entire page layout or, when located in the special `src/pages/` folder, be an entire page itself.

The most important thing to know about Astro components is that they **don’t render on the client**. They render to HTML either at build-time or on-demand. You can include JavaScript code inside of your component frontmatter, and all of it will be stripped from the final page sent to your users’ browsers. The result is a faster site, with zero JavaScript footprint added by default.

When your Astro component does need client-side interactivity, you can add [standard HTML `<script>` tags](/en/guides/client-side-scripts/) or [UI Framework components](/en/guides/framework-components/#hydrating-interactive-components) as “client islands”.

For components that need to render personalized or dynamic content, you can defer their server rendering by adding a [server directive](/en/reference/directives-reference/#server-directives). These “server islands” will render their content when it is available, without delaying the entire page load.


## Component Structure


[Section titled Component Structure](#component-structure)

An Astro component is made up of two main parts: the **Component Script** and the **Component Template**. Each part performs a different job, but together they provide a framework that is both easy to use and expressive enough to handle whatever you might want to build.

src/components/EmptyComponent.astro

```
---// Component Script (JavaScript)---<!-- Component Template (HTML + JS Expressions) -->
```


### The Component Script


[Section titled The Component Script](#the-component-script)

Astro uses a code fence (`---`) to identify the component script in your Astro component. If you’ve ever written Markdown before, you may already be familiar with a similar concept called *frontmatter.* Astro’s idea of a component script was directly inspired by this concept.

You can use the component script to write any JavaScript code that you need to render your template. This can include:

-   importing other Astro components
-   importing other framework components, like React
-   importing data, like a JSON file
-   fetching content from an API or database
-   creating variables that you will reference in your template

src/components/MyComponent.astro

```
---import SomeAstroComponent from'../components/SomeAstroComponent.astro';import SomeReactComponent from'../components/SomeReactComponent.jsx';import someData from'../data/pokemon.json';// Access passed-in component props, like `<X title="Hello, World" />`const { title } = Astro.props;// Fetch external data, even from a private API or databaseconst data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json());---<!-- Your template here! -->
```

The code fence is designed to guarantee that the JavaScript that you write in it is “fenced in.” It won’t escape into your frontend application, or fall into your user’s hands. You can safely write code here that is expensive or sensitive (like a call to your private database) without worrying about it ever ending up in your user’s browser.

Note

The Astro component script is TypeScript, which allows you to add additional syntax to JavaScript for editor tooling, and error checking.

Read more about Astro’s [built-in TypeScript support](/en/guides/typescript/).


### The Component Template


[Section titled The Component Template](#the-component-template)

The component template is below the code fence and determines the HTML output of your component.

If you write plain HTML here, your component will render that HTML in any Astro page it is imported and used.

However, [Astro’s component template syntax](/en/reference/astro-syntax/) also supports **JavaScript expressions**, Astro [`<style>`](/en/guides/styling/#styling-in-astro) and [`<script>`](/en/guides/client-side-scripts/#using-script-in-astro) tags, **imported components**, and [**special Astro directives**](/en/reference/directives-reference/). Data and values defined in the component script can be used in the component template to produce dynamically-created HTML.

src/components/MyFavoritePokemon.astro

```
---// Your component script here!import Banner from'../components/Banner.astro';import Avatar from'../components/Avatar.astro';import ReactPokemonComponent from'../components/ReactPokemonComponent.jsx';const myFavoritePokemon = [/* ... */];const { title } = Astro.props;---<!-- HTML comments supported! -->{/* JS comment syntax is also valid! */}<Banner /><h1>Hello, world!</h1><!-- Use props and other variables from the component script: --><p>{title}</p><!-- Delay component rendering and provide fallback loading content: --><Avatarserver:defer><svgslot="fallback"class="generic-avatar"transition:name="avatar">...</svg></Avatar><!-- Include other UI framework components with a `client:` directive to hydrate: --><ReactPokemonComponentclient:visible /><!-- Mix HTML with JavaScript expressions, similar to JSX: --><ul>{myFavoritePokemon.map((data)=><li>{data.name}</li>)}</ul><!-- Use a template directive to build class names from multiple strings or even objects! --><pclass:list={["add", "dynamic", { classNames: true }]} />
```


## Component-based design


[Section titled Component-based design](#component-based-design)

Components are designed to be **reusable** and **composable**. You can use components inside of other components to build more and more advanced UI. For example, a `Button` component could be used to create a `ButtonGroup` component:

src/components/ButtonGroup.astro

```
---import Button from'./Button.astro';---<div><Buttontitle="Button 1" /><Buttontitle="Button 2" /><Buttontitle="Button 3" /></div>
```


## Component Props


[Section titled Component Props](#component-props)

An Astro component can define and accept props. These props then become available to the component template for rendering HTML. Props are available on the `Astro.props` global in your frontmatter script.

Here is an example of a component that receives a `greeting` prop and a `name` prop. Notice that the props to be received are destructured from the global `Astro.props` object.

src/components/GreetingHeadline.astro

```
---// Usage: <GreetingHeadline greeting="Howdy" name="Partner" />const { greeting, name } = Astro.props;---<h2>{greeting}, {name}!</h2>
```

This component, when imported and rendered in other Astro components, layouts or pages, can pass these props as attributes:

src/components/GreetingCard.astro

```
---import GreetingHeadline from'./GreetingHeadline.astro';const name = 'Astro';---<h1>Greeting Card</h1><GreetingHeadlinegreeting="Hi"name={name} /><p>I hope you have a wonderful day!</p>
```

You can also define your props with TypeScript with a `Props` type interface. Astro will automatically pick up the `Props` interface in your frontmatter and give type warnings/errors. These props can also be given default values when destructured from `Astro.props`.

src/components/GreetingHeadline.astro

```
---interface Props {name:string;greeting?:string;}const { greeting = "Hello", name } = Astro.props;---<h2>{greeting}, {name}!</h2>
```

Component props can be given default values to use when none are provided.

src/components/GreetingHeadline.astro

```
---const { greeting= "Hello", name= "Astronaut" } = Astro.props;---<h2>{greeting}, {name}!</h2>
```


## Slots


[Section titled Slots](#slots)

The `<slot />` element is a placeholder for external HTML content, allowing you to inject (or “slot”) child elements from other files into your component template.

By default, all child elements passed to a component will be rendered in its `<slot />`.

Note

Unlike *props*, which are attributes passed to an Astro component available for use throughout your component with `Astro.props`, *slots* render child HTML elements where they are written.

src/components/Wrapper.astro

```
---import Header from'./Header.astro';import Logo from'./Logo.astro';import Footer from'./Footer.astro';const { title } = Astro.props;---<divid="content-wrapper"><Header /><Logo /><h1>{title}</h1><slot /><!-- children will go here --><Footer /></div>
```

src/pages/fred.astro

```
---import Wrapper from'../components/Wrapper.astro';---<Wrappertitle="Fred's Page"><h2>All about Fred</h2><p>Here is some stuff about Fred.</p></Wrapper>
```

This pattern is the basis of an [Astro layout component](/en/basics/layouts/): an entire page of HTML content can be “wrapped” with `<SomeLayoutComponent></SomeLayoutComponent>` tags and sent to the component to render inside of common page elements defined there.


### Named Slots


[Section titled Named Slots](#named-slots)

An Astro component can also have named slots. This allows you to pass only HTML elements with the corresponding slot name into a slot’s location.

Slots are named using the `name` attribute:

src/components/Wrapper.astro

```
---import Header from'./Header.astro';import Logo from'./Logo.astro';import Footer from'./Footer.astro';const { title } = Astro.props;---<divid="content-wrapper"><Header /><!--  children with the `slot="after-header"` attribute will go here --><slotname="after-header" /><Logo /><h1>{title}</h1><!--  children without a `slot`, or with `slot="default"` attribute will go here --><slot /><Footer /><!--  children with the `slot="after-footer"` attribute will go here --><slotname="after-footer" /></div>
```

To inject HTML content into a particular slot, use the `slot` attribute on any child element to specify the name of the slot. All other child elements of the component will be injected into the default (unnamed) `<slot />`.

src/pages/fred.astro

```
---import Wrapper from'../components/Wrapper.astro';---<Wrappertitle="Fred's Page"><imgsrc="https://my.photo/fred.jpg"slot="after-header" /><h2>All about Fred</h2><p>Here is some stuff about Fred.</p><pslot="after-footer">Copyright 2022</p></Wrapper>
```

Tip

Use a `slot="my-slot"` attribute on the child element that you want to pass through to a matching `<slot name="my-slot" />` placeholder in your component.

To pass multiple HTML elements into a component’s `<slot/>` placeholder without a wrapping `<div>`, use the `slot=""` attribute on [Astro’s `<Fragment/>` component](/en/reference/astro-syntax/#fragments):

src/components/CustomTable.astro

```
---// Create a custom table with named slot placeholders for header and body content---<tableclass="bg-white"><theadclass="sticky top-0 bg-white"><slotname="header" /></thead><tbodyclass="[&_tr:nth-child(odd)]:bg-gray-100"><slotname="body" /></tbody></table>
```

Inject multiple rows and columns of HTML content using a `slot=""` attribute to specify the `"header"` and `"body"` content. Individual HTML elements can also be styled:

src/components/StockTable.astro

```
---import CustomTable from'./CustomTable.astro';---<CustomTable><Fragmentslot="header"><!-- pass table header --><tr><th>Product name</th><th>Stock units</th></tr></Fragment><Fragmentslot="body"><!-- pass table body --><tr><td>Flip-flops</td><td>64</td></tr><tr><td>Boots</td><td>32</td></tr><tr><td>Sneakers</td><tdclass="text-red-500">0</td></tr></Fragment></CustomTable>
```

Note that named slots must be an immediate child of the component. You cannot pass named slots through nested elements.

Tip

Named slots can also be passed to [UI framework components](/en/guides/framework-components/)!

Note

It is not possible to dynamically generate an Astro slot name, such as within a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) function. If this feature is needed within UI framework components, it might be best to generate these dynamic slots within the framework itself.


### Fallback Content for Slots


[Section titled Fallback Content for Slots](#fallback-content-for-slots)

Slots can also render **fallback content**. When there are no matching children passed to a slot, a `<slot />` element will render its own placeholder children.

src/components/Wrapper.astro

```
---import Header from'./Header.astro';import Logo from'./Logo.astro';import Footer from'./Footer.astro';const { title } = Astro.props;---<divid="content-wrapper"><Header /><Logo /><h1>{title}</h1><slot><p>This is my fallback content, if there is no child passed into slot</p></slot><Footer /></div>
```

Fallback content will only be displayed when there are no matching elements with the `slot="name"` attribute being passed in to a named slot.

Astro will pass an empty slot when a slot element exists but has no content to pass. Fallback content cannot be used as a default when an empty slot is passed. Fallback content is only displayed when no slot element can be found.


### Transferring slots


[Section titled Transferring slots](#transferring-slots)

Slots can be transferred to other components. For example, when creating nested layouts:

src/layouts/BaseLayout.astro

```
------<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><metaname="generator"content={Astro.generator} /><slotname="head" /></head><body><slot /></body></html>
```

src/layouts/HomeLayout.astro

```
---import BaseLayout from'./BaseLayout.astro';---<BaseLayout><slotname="head"slot="head" /><slot /></BaseLayout>
```

Note

Named slots can be transferred to another component using both the `name` and `slot` attributes on a `<slot />` tag.

Now, the default and `head` slots passed to `HomeLayout` will be transferred to the `BaseLayout` parent.

src/pages/index.astro

```
---import HomeLayout from'../layouts/HomeLayout.astro';---<HomeLayout><titleslot="head">Astro</title><h1>Astro</h1></HomeLayout>
```


## HTML Components


[Section titled HTML Components](#html-components)

Astro supports importing and using `.html` files as components or placing these files within the `src/pages/` subdirectory as pages. You may want to use HTML components if you’re reusing code from an existing site built without a framework, or if you want to ensure that your component has no dynamic features.

HTML components must contain only valid HTML, and therefore lack key Astro component features:

-   They don’t support frontmatter, server-side imports, or dynamic expressions.
-   Any `<script>` tags are left unbundled, treated as if they had an [`is:inline` directive](/en/reference/directives-reference/#isinline).
-   They can only [reference assets that are in the `public/` folder](/en/basics/project-structure/#public).

Note

A [`<slot />` element](/en/basics/astro-components/#slots) inside an HTML component will work as it would in an Astro component. In order to use the [HTML Web Component Slot](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot) element instead, add `is:inline` to your `<slot>` element.


## Next Steps


[Section titled Next Steps](#next-steps)

Read more about using [UI framework components](/en/guides/framework-components/) in your Astro project.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 3. `en/basics/astro-pages/.md`

```text
# Pages


---
url: https://docs.astro.build/en/basics/astro-pages/
description: An introduction to Astro pages.
---


# Pages


**Pages** are files that live in the `src/pages/` subdirectory of your Astro project. They are responsible for handling routing, data loading, and overall page layout for every page in your website.


## Supported page files


[Section titled Supported page files](#supported-page-files)

Astro supports the following file types in the `src/pages/` directory:

-   [`.astro`](#astro-pages)
-   [`.md`](#markdownmdx-pages)
-   `.mdx` (with the [MDX Integration installed](/en/guides/integrations-guide/mdx/#installation))
-   [`.html`](#html-pages)
-   `.js`/`.ts` (as [endpoints](/en/guides/endpoints/))


## File-based routing


[Section titled File-based routing](#file-based-routing)

Astro leverages a routing strategy called **file-based routing**. Each file in your `src/pages/` directory becomes an endpoint on your site based on its file path.

A single file can also generate multiple pages using [dynamic routing](/en/guides/routing/#dynamic-routes). This allows you to create pages even if your content lives outside of the special `/pages/` directory, such as in a [content collection](/en/guides/content-collections/) or a [CMS](/en/guides/cms/).

Read more about [Routing in Astro](/en/guides/routing/).


### Link between pages


[Section titled Link between pages](#link-between-pages)

Write standard HTML [`<a>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) in your Astro pages to link to other pages on your site. Use a **URL path relative to your root domain** as your link, not a relative file path.

For example, to link to `https://example.com/authors/sonali/` from any other page on `example.com`:

src/pages/index.astro

```
Read more <ahref="/authors/sonali/">about Sonali</a>.
```


## Astro Pages


[Section titled Astro Pages](#astro-pages)

Astro pages use the `.astro` file extension and support the same features as [Astro components](/en/basics/astro-components/).

src/pages/index.astro

```
------<htmllang="en"><head><title>My Homepage</title></head><body><h1>Welcome to my website!</h1></body></html>
```

A page must produce a full HTML document. If not explicitly included, Astro will add the necessary `<!DOCTYPE html>` declaration and `<head>` content to any `.astro` component located within `src/pages/` by default. You can opt-out of this behavior on a per-component basis by marking it as a [partial](#page-partials) page.

To avoid repeating the same HTML elements on every page, you can move common `<head>` and `<body>` elements into your own [layout components](/en/basics/layouts/). You can use as many or as few layout components as you’d like.

src/pages/index.astro

```
---import MySiteLayout from"../layouts/MySiteLayout.astro";---<MySiteLayout><p>My page content, wrapped in a layout!</p></MySiteLayout>
```

Read more about [layout components](/en/basics/layouts/) in Astro.


## Markdown/MDX Pages


[Section titled Markdown/MDX Pages](#markdownmdx-pages)

Astro also treats any Markdown (`.md`) files inside of `src/pages/` as pages in your final website. If you have the [MDX Integration installed](/en/guides/integrations-guide/mdx/#installation), it also treats MDX (`.mdx`) files the same way.

Tip

Consider creating [content collections](/en/guides/content-collections/) instead of pages for directories of related Markdown files that share a similar structure, such as blog posts or product items.

Markdown files can use the special `layout` frontmatter property to specify a [layout component](/en/basics/layouts/) that will wrap their Markdown content in a full `<html>...</html>` page document.

src/pages/page.md

```
---layout: ../layouts/MySiteLayout.astrotitle: My Markdown page---# TitleThis is my page, written in **Markdown.**
```

Read more about [Markdown](/en/guides/markdown-content/) in Astro.


## HTML Pages


[Section titled HTML Pages](#html-pages)

Files with the `.html` file extension can be placed in the `src/pages/` directory and used directly as pages on your site. Note that some key Astro features are not supported in [HTML Components](/en/basics/astro-components/#html-components).


## Custom 404 Error Page


[Section titled Custom 404 Error Page](#custom-404-error-page)

For a custom 404 error page, you can create a `404.astro` or `404.md` file in `src/pages`.

This will build to a `404.html` page. Most [deploy services](/en/guides/deploy/) will find and use it.


## Custom 500 Error Page


[Section titled Custom 500 Error Page](#custom-500-error-page)

For a custom 500 error page to show for pages that are [rendered on demand](/en/guides/on-demand-rendering/), create the file `src/pages/500.astro`. This custom page is not available for prerendered pages and can’t be prerendered.

If an error occurs rendering this page, your host’s default 500 error page will be shown to your visitor.

**Added in:** `astro@4.10.3`

During development, if you have a `500.astro`, the error thrown at runtime is logged in your terminal, as opposed to being shown in the error overlay.


### `error`


[Section titled error](#error)

**Added in:** `astro@4.11.0`

`src/pages/500.astro` is a special page that is automatically passed an `error` prop for any error thrown during rendering. This allows you to use the details of an error (e.g. from a page, from middleware, etc.) to display information to your visitor.

The `error` prop’s data type can be anything, which may affect how you type or use the value in your code:

src/pages/500.astro

```
---interface Props {error:unknown;}const { error } = Astro.props;---<div>{error instanceofError? error.message:"Unknown error"}</div>
```

To avoid leaking sensitive information when displaying content from the `error` prop, consider evaluating the error first, and returning appropriate content based on the error thrown. For example, you should avoid displaying the error’s stack as it contains information about how your code is structured on the server.


## Page Partials


[Section titled Page Partials](#page-partials)

**Added in:** `astro@3.4.0`

Caution

Page partials are intended to be used in conjunction with a front-end library, such as [htmx](https://htmx.org/) or [Unpoly](https://unpoly.com/). You can also use them if you are comfortable writing low-level front-end JavaScript. For this reason they are an advanced feature.

Additionally, partials should not be used if the component contains scoped styles or scripts, as these elements will be stripped from the HTML output. If you need scoped styles, it is better to use regular, non-partial pages along with a frontend library that knows how to merge the contents into the head.

Partials are page components located within `src/pages/` that are not intended to render as full pages.

Like components located outside of this folder, these files do not automatically include the `<!DOCTYPE html>` declaration, nor any `<head>` content such as scoped styles and scripts.

However, because they are located in the special `src/pages/` directory, the generated HTML is available at a URL corresponding to its file path. This allows a rendering library (e.g. [htmx](https://htmx.org/), [Stimulus](https://stimulus.hotwired.dev/), [jQuery](https://jquery.com/)) to access it on the client and load sections of HTML dynamically on a page without a browser refresh or page navigation.

Partials, when combined with a rendering library, provide an alternative to [Astro islands](/en/concepts/islands/) and [`<script>` tags](/en/guides/client-side-scripts/) for building dynamic content in Astro.

Page files that can export a value for [`partial`](/en/reference/routing-reference/#partial) (e.g. `.astro` and `.mdx`, but not `.md`) can be marked as partials.

src/pages/partial.astro

```
---export const partial = true;---<li>I'm a partial!</li>
```


### Using with a library


[Section titled Using with a library](#using-with-a-library)

Partials are used to dynamically update a section of a page using a library such as [htmx](https://htmx.org/).

The following example shows an `hx-post` attribute set to a partial’s URL. The content from the partial page will be used to update the targeted HTML element on this page.

src/pages/index.astro

```
<html><head><title>My page</title><scriptsrc="https://unpkg.com/htmx.org@1.9.6"integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni"crossorigin="anonymous"></script></head><body><section><divid="parent-div">Target here</div><buttonhx-post="/partials/clicked/"hx-trigger="click"hx-target="#parent-div"hx-swap="innerHTML">Click Me!</button></section></body></html>
```

The `.astro` partial must exist at the corresponding file path, and include an export defining the page as a partial:

src/pages/partials/clicked.astro

```
---export const partial = true;---<div>I was clicked!</div>
```

See the [htmx documentation](https://htmx.org/docs/) for more details on using htmx.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 4. `en/basics/layouts/.md`

```text
# Layouts


---
url: https://docs.astro.build/en/basics/layouts/
description: An introduction to layouts in Astro.
---


# Layouts


**Layouts** are [Astro components](/en/basics/astro-components/) used to provide a reusable UI structure, such as a page template.

We conventionally use the term “layout” for Astro components that provide common UI elements shared across pages such as headers, navigation bars, and footers. A typical Astro layout component provides [Astro, Markdown or MDX pages](/en/basics/astro-pages/) with:

-   a **page shell** (`<html>`, `<head>` and `<body>` tags)
-   a [**`<slot />`**](/en/basics/astro-components/#slots) to specify where individual page content should be injected.

But, there is nothing special about a layout component! They can [accept props](/en/basics/astro-components/#component-props) and [import and use other components](/en/basics/astro-components/#component-structure) like any other Astro component. They can include [UI frameworks components](/en/guides/framework-components/) and [client-side scripts](/en/guides/client-side-scripts/). They do not even have to provide a full page shell, and can instead be used as partial UI templates.

However, if a layout component does contain a page shell, its `<html>` element must be the parent of all other elements in the component.

Layout components are commonly placed in a `src/layouts` directory in your project for organization, but this is not a requirement; you can choose to place them anywhere in your project. You can even colocate layout components alongside your pages by [prefixing the layout names with `_`](/en/guides/routing/#excluding-pages).


## Sample Layout


[Section titled Sample Layout](#sample-layout)

src/layouts/MySiteLayout.astro

```
---import BaseHead from'../components/BaseHead.astro';import Footer from'../components/Footer.astro';const { title } = Astro.props;---<htmllang="en"><head><metacharset="utf-8"><metaname="viewport"content="width=device-width, initial-scale=1"><BaseHeadtitle={title}/></head><body><nav><ahref="#">Home</a><ahref="#">Posts</a><ahref="#">Contact</a></nav><h1>{title}</h1><article><slot /><!-- your content is injected here --></article><Footer /></body><style>h1 {font-size: 2rem;}</style></html>
```

src/pages/index.astro

```
---import MySiteLayout from'../layouts/MySiteLayout.astro';---<MySiteLayouttitle="Home Page"><p>My page content, wrapped in a layout!</p></MySiteLayout>
```

Learn more about [slots](/en/basics/astro-components/#slots).


## Using TypeScript with layouts


[Section titled Using TypeScript with layouts](#using-typescript-with-layouts)

Any Astro layout can be modified to introduce type safety & autocompletion by providing the types for your props:

src/components/MyLayout.astro

```
---interface Props {title:string;description:string;publishDate:string;viewCount:number;}const { title, description, publishDate, viewCount } = Astro.props;---<htmllang="en"><head><metacharset="UTF-8"><metaname="description"content={description}><title>{title}</title></head><body><header><p>Published on {publishDate}</p><p>Viewed by {viewCount} folks</p></header><main><slot /></main></body></html>
```


## Markdown Layouts


[Section titled Markdown Layouts](#markdown-layouts)

Page layouts are especially useful for individual Markdown pages which otherwise would not have any page formatting.

Astro provides a special `layout` frontmatter property intended for [individual `.md` files located within `src/pages/` using file-based routing](/en/guides/markdown-content/#individual-markdown-pages) to specify which `.astro` component to use as the page layout. This component allows you to provide `<head>` content like meta tags (e.g. `<meta charset="utf-8">`) and styles for the Markdown page. By default, this specified component can automatically access data from the Markdown file.

This is not recognized as a special property when using [content collections](/en/guides/content-collections/) to query and render your content.

src/pages/page.md

```
---layout: ../layouts/BlogPostLayout.astrotitle: "Hello, World!"author: "Matthew Phillips"date: "09 Aug 2022"---All frontmatter properties are available as props to an Astro layout component.The `layout` property is the only special one provided by Astro.You can use it in Markdown files located within `src/pages/`.
```

A typical layout for a Markdown page includes:

1.  The `frontmatter` prop to access the Markdown page’s frontmatter and other data.
2.  A default [`<slot />`](/en/basics/astro-components/#slots) to indicate where the page’s Markdown content should be rendered.

src/layouts/BlogPostLayout.astro

```
---// 1. The frontmatter prop gives access to frontmatter and other dataconst { frontmatter } = Astro.props;---<html><head><!-- Add other Head elements here, like styles and meta tags. --><metaname="viewport"content="width=device-width, initial-scale=1"><metacharset="utf-8"><title>{frontmatter.title}</title></head><body><!-- Add other UI components here, like common headers and footers. --><h1>{frontmatter.title} by {frontmatter.author}</h1><!-- 2. Rendered HTML will be passed into the default slot. --><slot /><p>Written on: {frontmatter.date}</p></body></html>
```

You can set a layout’s [`Props` type](/en/guides/typescript/#component-props) with the `MarkdownLayoutProps` helper:

src/layouts/BlogPostLayout.astro

```
---importtype { MarkdownLayoutProps } from'astro';type Props =MarkdownLayoutProps<{// Define frontmatter props heretitle:string;author:string;date:string;}>;// Now, `frontmatter`, `url`, and other Markdown layout properties// are accessible with type safetyconst { frontmatter, url } = Astro.props;---<html><head><metacharset="utf-8"><linkrel="canonical"href={newURL(url, Astro.site).pathname}><title>{frontmatter.title}</title></head><body><h1>{frontmatter.title} by {frontmatter.author}</h1><slot /><p>Written on: {frontmatter.date}</p></body></html>
```


### Markdown Layout Props


[Section titled Markdown Layout Props](#markdown-layout-props)

A Markdown layout will have access to the following information via `Astro.props`:

-   **`file`** - The absolute path of this file (e.g. `/home/user/projects/.../file.md`).
-   **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`).
-   **`frontmatter`** - All frontmatter from the Markdown or MDX document.
    -   **`frontmatter.file`** - The same as the top-level `file` property.
    -   **`frontmatter.url`** - The same as the top-level `url` property.
-   **`headings`** - A list of headings (`h1 -> h6`) in the Markdown or MDX document with associated metadata. This list follows the type: `{ depth: number; slug: string; text: string }[]`.
-   **`rawContent()`** - A function that returns the raw Markdown document as a string.
-   **`compiledContent()`** - An async function that returns the Markdown document compiled to an HTML string.

Note

A Markdown layout will have access to all the Markdown file’s [available properties](/en/guides/markdown-content/#available-properties) from `Astro.props` **with two key differences:**

-   Heading information (i.e. `h1 -> h6` elements) is available via the `headings` array, rather than a `getHeadings()` function.

-   `file` and `url` are *also* available as nested `frontmatter` properties (i.e. `frontmatter.url` and `frontmatter.file`).



### Importing Layouts Manually (MDX)


[Section titled Importing Layouts Manually (MDX)](#importing-layouts-manually-mdx)

You can also use the special Markdown layout property in the frontmatter of MDX files to pass `frontmatter` and `headings` props directly to a specified layout component in the same way.

To pass information to your MDX layout that does not (or cannot) exist in your frontmatter, you can instead import and use a `<Layout />` component. This works like any other Astro component, and will not receive any props automatically. Pass it any necessary props directly:

src/pages/posts/first-post.mdx

```
---layout: ../../layouts/BaseLayout.astrotitle: 'My first MDX post'publishDate: '21 September 2022'---import BaseLayout from'../../layouts/BaseLayout.astro';exportfunctionfancyJsHelper() {return"Try doing that with YAML!";}<BaseLayouttitle={frontmatter.title}fancyJsHelper={fancyJsHelper}>Welcome to my new Astro blog, using MDX!</BaseLayout>
```

Then, your values are available to you through `Astro.props` in your layout, and your MDX content will be injected into the page where your `<slot />` component is written:

src/layouts/BaseLayout.astro

```
---const { title, fancyJsHelper } = Astro.props;---<html><head><!-- --><metacharset="utf-8"></head><body><!-- --><h1>{title}</h1><slot /><!-- your content is injected here --><p>{fancyJsHelper()}</p><!-- --></body></html>
```

When using any layout (either through the frontmatter `layout` property or by importing a layout), you must include the `<meta charset="utf-8">` tag in your layout as Astro will no longer add it automatically to your MDX page.

Learn more about Astro’s Markdown and MDX support in our [Markdown guide](/en/guides/markdown-content/).


## Nesting Layouts


[Section titled Nesting Layouts](#nesting-layouts)

Layout components do not need to contain an entire page worth of HTML. You can break your layouts into smaller components, and combine layout components to create even more flexible, page templates. This pattern is useful when you want to share some code across multiple layouts.

For example, a `BlogPostLayout.astro` layout component could style a post’s title, date and author. Then, a site-wide `BaseLayout.astro` could handle the rest of your page template, like navigation, footers, SEO meta tags, global styles, and fonts. You can also pass props received from your post to another layout, just like any other nested component.

src/layouts/BlogPostLayout.astro

```
---import BaseLayout from'./BaseLayout.astro';const { frontmatter } = Astro.props;---<BaseLayouturl={frontmatter.url}><h1>{frontmatter.title}</h1><h2>Post author: {frontmatter.author}</h2><slot /></BaseLayout>
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 5. `en/basics/project-structure/.md`

```text
# Project structure


---
url: https://docs.astro.build/en/basics/project-structure/
description: An introduction to the basic file structure of an Astro project.
---


# Project structure


Your new Astro project generated from the `create astro` CLI wizard already includes some files and folders. Others, you will create yourself and add to Astro’s existing file structure.

Here’s how an Astro project is organized, and some files you will find in your new project.


## Directories and Files


[Section titled Directories and Files](#directories-and-files)

Astro leverages an opinionated folder layout for your project. Every Astro project root should include the following directories and files:

-   `src/*` - Your project source code (components, pages, styles, images, etc.)
-   `public/*` - Your non-code, unprocessed assets (fonts, icons, etc.)
-   `package.json` - A project manifest.
-   `astro.config.mjs` - An Astro configuration file. (recommended)
-   `tsconfig.json` - A TypeScript configuration file. (recommended)


### Example Project Tree


[Section titled Example Project Tree](#example-project-tree)

A common Astro project directory might look like this:

-   Directorypublic/

    -   robots.txt
    -   favicon.svg
    -   my-cv.pdf

-   Directorysrc/

    -   Directoryblog/

        -   post1.md
        -   post2.md
        -   post3.md

    -   Directorycomponents/

        -   Header.astro
        -   Button.jsx

    -   Directoryimages/

        -   image1.jpg
        -   image2.jpg
        -   image3.jpg

    -   Directorylayouts/

        -   PostLayout.astro

    -   Directorypages/

        -   Directoryposts/

            -   \[post\].astro

        -   about.astro
        -   **index.astro**
        -   rss.xml.js

    -   Directorystyles/

        -   global.css

    -   content.config.ts

-   astro.config.mjs
-   package.json
-   tsconfig.json


### `src/`


[Section titled src/](#src)

The `src/` folder is where most of your project source code lives. This includes:

-   [Pages](/en/basics/astro-pages/)
-   [Layouts](/en/basics/layouts/)
-   [Astro components](/en/basics/astro-components/)
-   [UI framework components (React, etc.)](/en/guides/framework-components/)
-   [Styles (CSS, Sass)](/en/guides/styling/)
-   [Markdown](/en/guides/markdown-content/)
-   [Images to be optimized and processed by Astro](/en/guides/images/)

Astro processes, optimizes, and bundles your `src/` files to create the final website that is shipped to the browser. Unlike the static `public/` directory, your `src/` files are built and handled for you by Astro.

Some files (like Astro components) are not even sent to the browser as written but are instead rendered to static HTML. Other files (like CSS) are sent to the browser but may be optimized or bundled with other CSS files for performance.

Tip

While this guide describes some popular conventions used in the Astro community, the only directory reserved by Astro is `src/pages/`. You are free to rename and reorganize any other directories in a way that works best for you.


### `src/pages`


[Section titled src/pages](#srcpages)

Pages routes are created for your site by adding [supported file types](/en/basics/astro-pages/#supported-page-files) to this directory.

Caution

`src/pages` is a **required** sub-directory in your Astro project. Without it, your site will have no pages or routes!


### `src/components`


[Section titled src/components](#srccomponents)

**Components** are reusable units of code for your HTML pages. These could be [Astro components](/en/basics/astro-components/), or [UI framework components](/en/guides/framework-components/) like React or Vue. It is common to group and organize all of your project components together in this folder.

This is a common convention in Astro projects, but it is not required. Feel free to organize your components however you like!


### `src/layouts`


[Section titled src/layouts](#srclayouts)

[Layouts](/en/basics/layouts/) are Astro components that define the UI structure shared by one or more [pages](/en/basics/astro-pages/).

Just like `src/components`, this directory is a common convention but not required.


### `src/styles`


[Section titled src/styles](#srcstyles)

It is a common convention to store your CSS or Sass files in a `src/styles` directory, but this is not required. As long as your styles live somewhere in the `src/` directory and are imported correctly, Astro will handle and optimize them.


### `public/`


[Section titled public/](#public)

The `public/` directory is for files and assets in your project that do not need to be processed during Astro’s build process. The files in this folder will be copied into the build folder untouched, and then your site will be built.

This behavior makes `public/` ideal for common assets that do not require any processing, like some images and fonts, or special files such as `robots.txt` and `manifest.webmanifest`.

You can place CSS and JavaScript in your `public/` directory, but be aware that those files will not be bundled or optimized in your final build.

Tip

As a general rule, any CSS or JavaScript that you write yourself should live in your `src/` directory.


### `package.json`


[Section titled package.json](#packagejson)

This is a file used by JavaScript package managers to manage your dependencies. It also defines the scripts that are commonly used to run Astro (ex: `npm run dev`, `npm run build`).

There are [two kinds of dependencies](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file) you can specify in a `package.json`: `dependencies` and `devDependencies`. In most cases, these work the same: Astro needs all dependencies at build time, and your package manager will install both. We recommend putting all of your dependencies in `dependencies` to start, and only use `devDependencies` if you find a specific need to do so.

For help creating a new `package.json` file for your project, check out the [manual setup](/en/install-and-setup/#manual-setup) instructions.


### `astro.config.mjs`


[Section titled astro.config.mjs](#astroconfigmjs)

This file is generated in every starter template and includes configuration options for your Astro project. Here you can specify integrations to use, build options, server options, and more.

Astro supports several file formats for its JavaScript configuration file: `astro.config.js`, `astro.config.mjs`, `astro.config.cjs` and `astro.config.ts`. We recommend using `.mjs` in most cases or `.ts` if you want to write TypeScript in your config file.

TypeScript config file loading is handled using [`tsm`](https://github.com/lukeed/tsm) and will respect your project’s `tsconfig` options.

See the [configuration reference](/en/reference/configuration-reference/) for complete details.


### `tsconfig.json`


[Section titled tsconfig.json](#tsconfigjson)

This file is generated in every starter template and includes TypeScript configuration options for your Astro project. Some features (like npm package imports) aren’t fully supported in the editor without a `tsconfig.json` file.

See the [TypeScript Guide](/en/guides/typescript/) for details on setting configurations.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 6. `en/concepts/islands/.md`

```text
# Islands architecture


---
url: https://docs.astro.build/en/concepts/islands/
description: Learn about how Astro's islands architecture helps keep sites fast.
---


# Islands architecture


Astro helped pioneer and popularize a new frontend architecture pattern called **Islands Architecture.** Islands architecture works by rendering the majority of your page to fast, static HTML with smaller “islands” of JavaScript added when interactivity or personalization is needed on the page (an image carousel, for example). This avoids the monolithic JavaScript payloads that slow down the responsiveness of many other, modern JavaScript web frameworks.


## A brief history


[Section titled A brief history](#a-brief-history)

The term “component island” was first coined by Etsy’s frontend architect [Katie Sylor-Miller](https://sylormiller.com/) in 2019. This idea was then expanded on and documented in [this post](https://jasonformat.com/islands-architecture/) by Preact creator Jason Miller on August 11, 2020.

> The general idea of an “Islands” architecture is deceptively simple: render HTML pages on the server, and inject placeholders or slots around highly dynamic regions \[…\] that can then be “hydrated” on the client into small self-contained widgets, reusing their server-rendered initial HTML. — Jason Miller, Creator of Preact

The technique that this architectural pattern builds on is also known as **partial** or **selective hydration.**

In contrast, most JavaScript-based web frameworks hydrate & render an entire website as one large JavaScript application (also known as a single-page application, or SPA). SPAs provide simplicity and power but suffer from page-load performance problems due to heavy client-side JavaScript usage.

SPAs have their place, even [embedded inside an Astro page](/en/guides/migrate-to-astro/from-create-react-app/). But, SPAs lack the native ability to selectively and strategically hydrate, making them a heavy-handed choice for most projects on the web today.

Astro became popular as the first mainstream JavaScript web framework with selective hydration built-in, using that same component islands pattern first coined by Sylor-Miller. We’ve since expanded and evolved on Sylor-Miller’s original work, which helped to inspire a similar component island approach to dynamically server-rendered content.


## What is an island?


[Section titled What is an island?](#what-is-an-island)

In Astro, an island is an enhanced UI component on an otherwise static page of HTML.

A [**client island**](#client-islands) is an interactive JavaScript UI component that is hydrated separately from the rest of the page, while a [**server island**](#server-islands) is a UI component that server-renders its dynamic content separately from the rest of the page.

Both islands run expensive or slower processes independently, on a per-component basis, for optimized page loads.


## Island components


[Section titled Island components](#island-components)

Astro components are the building blocks of your page template. They render to static HTML with no client-side runtime.

Think of a client island as an interactive widget floating in a sea of otherwise static, lightweight, server-rendered HTML. Server islands can be added for personalized or dynamic server-rendered elements, such as a logged in visitor’s profile picture.

Header (interactive island)

Static content like text, images, etc.

Image carousel (interactive island)

Footer (static HTML)

Source: [Islands Architecture: Jason Miller](https://jasonformat.com/islands-architecture/)

An island always runs in isolation from other islands on the page, and multiple islands can exist on a page. Client islands can still share state and communicate with each other, even though they run in different component contexts.

This flexibility allows Astro to support multiple UI frameworks like [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), and [SolidJS](https://www.solidjs.com/). Because they are independent, you can even mix several frameworks on each page.

Tip

Although most developers will stick to just one UI framework, Astro supports multiple frameworks in the same project. This allows you to:

-   Choose the framework that is best for each component.
-   Learn a new framework without needing to start a new project.
-   Collaborate with others even when working in different frameworks.
-   Incrementally convert an existing site to another framework with no downtime.


## Client Islands


[Section titled Client Islands](#client-islands)

By default, Astro will automatically render every UI component to just HTML & CSS, **stripping out all client-side JavaScript automatically.**

src/pages/index.astro

```
<MyReactComponent />
```

This may sound strict, but this behavior is what keeps Astro websites fast by default and protects developers from accidentally sending unnecessary or unwanted JavaScript that might slow down their website.

Turning any static UI component into an interactive island requires only a `client:*` directive. Astro then automatically builds and bundles your client-side JavaScript for optimized performance.

src/pages/index.astro

```
<!-- This component is now interactive on the page!The rest of your website remains static. --><MyReactComponentclient:load />
```

With islands, client-side JavaScript is only loaded for the explicit interactive components that you mark using `client:*` directives.

And because interaction is configured at the component-level, you can handle different loading priorities for each component based on its usage. For example, `client:idle` tells a component to load when the browser becomes idle, and `client:visible` tells a component to load only once it enters the viewport.


### Benefits of client islands


The most obvious benefit of building with Astro Islands is performance: the majority of your website is converted to fast, static HTML and JavaScript is only loaded for the individual components that need it. JavaScript is one of the slowest assets that you can load per-byte, so every byte counts.

Another benefit is parallel loading. In the example illustration above, the low-priority “image carousel” island doesn’t need to block the high-priority “header” island. The two load in parallel and hydrate in isolation, meaning that the header becomes interactive immediately without having to wait for the heavier carousel lower down the page.

Even better, you can tell Astro exactly how and when to render each component. If that image carousel is really expensive to load, you can attach a special [client directive](/en/reference/directives-reference/#client-directives) that tells Astro to only load the carousel when it becomes visible on the page. If the user never sees it, it never loads.

In Astro, it’s up to you as the developer to explicitly tell Astro which components on the page need to also run in the browser. Astro will only hydrate exactly what’s needed on the page and leave the rest of your site as static HTML.

**Client islands are the secret to Astro’s fast-by-default performance story!**

Read more about [using JavaScript framework components](/en/guides/framework-components/) in your project.


## Server islands


[Section titled Server islands](#server-islands)

Server islands are a way to move expensive or slow server-side code out of the way of the main rendering process, making it easy to combine high-performance static HTML and dynamic server-generated components.

Add the [`server:defer` directive](/en/reference/directives-reference/#server-directives) to any Astro component on your page to turn it into its own server island:

src/pages/index.astro

```
---import Avatar from"../components/Avatar.astro";---<Avatarserver:defer />
```

This breaks up your page with smaller areas of server-rendered content that each load in parallel.

Your page’s main content can be rendered immediately with placeholder content, such as a generic avatar until your island’s own content is available. With server islands, having small components of personalized content does not delay the rendering of an otherwise static page.

This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host, from a Node.js server in a Docker container to the serverless provider of your choice.


### Benefits of server islands


One benefit of server islands is the ability to render the more highly dynamic parts of your page on the fly. This allows the outer shell and main content to be more aggressively cached, providing faster performance.

Another benefit is providing a great visitor experience. Server islands are optimized and load quickly, often even before the browser has even painted the page. But in the short time it takes for your islands to render, you can display custom fallback content and prevent any layout shift.

An example of a site that benefits from Astro’s server islands is an e-commerce storefront. Although the main content of product pages change infrequently, these pages typically have some dynamic pieces:

-   The user’s avatar in the header.
-   Special deals and sales for the product.
-   User reviews.

Using server islands for these elements, your visitor will see the most important part of the page, your product, immediately. Generic avatars, loading spinners, and store announcements can be displayed as fallback content until the personalized parts are available.

Read more about [using server islands](/en/guides/server-islands/) in your project.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 7. `en/concepts/why-astro/.md`

```text
# Why Astro?


---
url: https://docs.astro.build/en/concepts/why-astro/
description: Astro is the web framework for building content-driven websites like blogs, marketing, and e-commerce. Learn why Astro might be a good choice for your next website.
---


# Why Astro?


**Astro** is the web framework for building **content-driven websites** like blogs, marketing, and e-commerce. Astro is best-known for pioneering a new [frontend architecture](/en/concepts/islands/) to reduce JavaScript overhead and complexity compared to other frameworks. If you need a website that loads fast and has great SEO, then Astro is for you.


## Features


[Section titled Features](#features)

**Astro is an all-in-one web framework.** It includes everything you need to create a website, built-in. There are also hundreds of different [integrations](https://astro.build/integrations/) and [API hooks](/en/reference/integrations-reference/) available to customize a project to your exact use case and needs.

Some highlights include:

-   **[Islands](/en/concepts/islands/):** A component-based web architecture optimized for content-driven websites.
-   **[UI-agnostic](/en/guides/framework-components/):** Supports React, Preact, Svelte, Vue, Solid, HTMX, web components, and more.
-   **[Server-first](/en/guides/on-demand-rendering/):** Moves expensive rendering off of your visitors’ devices.
-   **[Zero JS, by default](/en/basics/astro-components/):** Less client-side JavaScript to slow your site down.
-   **[Content collections](/en/guides/content-collections/):** Organize, validate, and provide TypeScript type-safety for your Markdown content.
-   **[Customizable](/en/guides/integrations-guide/):** Partytown, MDX, and hundreds of integrations to choose from.


## Design Principles


[Section titled Design Principles](#design-principles)

Here are five core design principles to help explain why we built Astro, the problems that it exists to solve, and why Astro may be the best choice for your project or team.

Astro is…

1.  **[Content-driven](#content-driven):** Astro was designed to showcase your content.
2.  **[Server-first](#server-first):** Websites run faster when they render HTML on the server.
3.  **[Fast by default](#fast-by-default):** It should be impossible to build a slow website in Astro.
4.  **[Easy to use](#easy-to-use):** You don’t need to be an expert to build something with Astro.
5.  **[Developer-focused](#developer-focused):** You should have the resources you need to be successful.


### Content-driven


[Section titled Content-driven](#content-driven)

**Astro was designed for building content-rich websites.** This includes marketing sites, publishing sites, documentation sites, blogs, portfolios, landing pages, community sites, and e-commerce sites. If you have content to show, it needs to reach your reader quickly.

By contrast, most modern web frameworks were designed for building *web applications*. These frameworks excel at building more complex, application-like experiences in the browser: logged-in admin dashboards, inboxes, social networks, todo lists, and even native-like applications like [Figma](https://figma.com/) and [Ping](https://ping.gg/). However with that complexity, they can struggle to provide great performance when delivering your content.

Astro’s focus on content from its beginnings as a static site builder have allowed Astro to **sensibly scale up to performant, powerful, dynamic web applications** that still respect your content and your audience. Astro’s unique focus on content lets Astro make tradeoffs and deliver unmatched performance features that wouldn’t make sense for more application-focused web frameworks to implement.


### Server-first


[Section titled Server-first](#server-first)

**Astro leverages server rendering over client-side rendering in the browser as much as possible.** This is the same approach that traditional server-side frameworks -- PHP, WordPress, Laravel, Ruby on Rails, etc. -- have been using for decades. But you don’t need to learn a second server-side language to unlock it. With Astro, everything is still just HTML, CSS, and JavaScript (or TypeScript, if you prefer).

This approach stands in contrast to other modern JavaScript web frameworks like Next.js, SvelteKit, Nuxt, Remix, and others. These frameworks were built for client-side rendering of your entire website and include server-side rendering mainly to address performance concerns. This approach has been dubbed the **Single-Page App (SPA)**, in contrast with Astro’s **Multi-Page App (MPA)** approach.

The SPA model has its benefits. However, these come at the expense of additional complexity and performance tradeoffs. These tradeoffs harm page performance -- critical metrics like [Time to Interactive (TTI)](https://web.dev/interactive/) -- which doesn’t make much sense for content-focused websites where first-load performance is essential.

Astro’s server-first approach allows you to opt in to client-side rendering only if, and exactly as, necessary. You can choose to add UI framework components that run on the client. You can take advantage of Astro’s view transitions router for finer control over select page transitions and animations. Astro’s server-first rendering, either pre-rendered or on-demand, provides performant defaults that you can enhance and extend.


### Fast by default


[Section titled Fast by default](#fast-by-default)

Good performance is always important, but it is *especially* critical for websites whose success depends on displaying your content. It has been well-proven that poor performance loses you engagement, conversions, and money. For example:

-   Every 100ms faster → 1% more conversions ([Mobify](https://web.dev/why-speed-matters/), earning +$380,000/yr)
-   50% faster → 12% more sales ([AutoAnything](https://www.digitalcommerce360.com/2010/08/19/web-accelerator-revs-conversion-and-sales-autoanything/))
-   20% faster → 10% more conversions ([Furniture Village](https://www.thinkwithgoogle.com/intl/en-gb/marketing-strategies/app-and-mobile/furniture-village-and-greenlight-slash-page-load-times-boosting-user-experience/))
-   40% faster → 15% more sign-ups ([Pinterest](https://medium.com/pinterest-engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7))
-   850ms faster → 7% more conversions ([COOK](https://web.dev/why-speed-matters/))
-   Every 1 second slower → 10% fewer users ([BBC](https://www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale))

In many web frameworks, it is easy to build a website that looks great during development only to load painfully slow once deployed. JavaScript is often the culprit, since many phones and lower-powered devices rarely match the speed of a developer’s laptop.

Astro’s magic is in how it combines the two values explained above -- a content focus with a server-first architecture -- to make tradeoffs and deliver features that other frameworks cannot. The result is amazing web performance for every website, out of the box. Our goal: **It should be nearly impossible to build a slow website with Astro.**

An Astro website can [load 40% faster with 90% less JavaScript](https://twitter.com/t3dotgg/status/1437195415439360003) than the same site built with the most popular React web framework. But don’t take our word for it: watch Astro’s performance leave Ryan Carniato (creator of Solid.js and Marko) [speechless](https://youtu.be/2ZEMb_H-LYE?t=8163).


### Easy to use


[Section titled Easy to use](#easy-to-use)

**Astro’s goal is to be accessible to every web developer.** Astro was designed to feel familiar and approachable regardless of skill level or past experience with web development.

The `.astro` UI language is a superset of HTML: any valid HTML is valid Astro templating syntax! So, if you can write HTML, you can write Astro components! But, it also combines some of our favorite features borrowed from other component languages like JSX expressions (React) and CSS scoping by default (Svelte and Vue). This closeness to HTML also makes it easier to use progressive enhancement and common accessibility patterns without any overhead.

We then made sure that you could also use your favorite UI component languages that you already know, and even reuse components you might already have. React, Preact, Svelte, Vue, Solid, and others, including web components, are all supported for authoring UI components in an Astro project.

Astro was designed to be less complex than other UI frameworks and languages. One big reason for this is that Astro was designed to render on the server, not in the browser. That means that you don’t need to worry about: hooks (React), stale closures (also React), refs (Vue), observables (Svelte), atoms, selectors, reactions, or derivations. There is no reactivity on the server, so all of that complexity melts away.

One of our favorite sayings is: **opt in to complexity.** We designed Astro to remove as much “required complexity” as possible from the developer experience, especially as you onboard for the first time. You can build a “Hello World” example website in Astro with just HTML and CSS. Then, when you need to build something more powerful, you can incrementally reach for new features and APIs as you go.


### Developer-focused


[Section titled Developer-focused](#developer-focused)

We strongly believe that Astro is only a successful project if people love using it. Astro has everything you need to support you as you build with Astro.

Astro invests in developer tools like a great CLI experience from the moment you open your terminal, an official VS Code extension for syntax highlighting, TypeScript and Intellisense, and documentation actively maintained by hundreds of community contributors and available in 14 languages.

Our welcoming, respectful, inclusive community on Discord is ready to provide support, motivation, and encouragement. Open a `#support` thread to get help with your project. Visit our dedicated `#showcase` channel for sharing your Astro sites, blog posts, videos, and even work-in-progress for safe feedback and constructive criticism. Participate in regular live events such as our weekly community call, “Talking and Doc’ing,” and API/bug bashes.

As an open-source project, we welcome contributions of all types and sizes from community members of all experience levels. You are invited to join in roadmap discussions to shape the future of Astro, and we hope you’ll contribute fixes and features to the core codebase, compiler, docs, language tools, websites, and other projects.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 8. `en/contribute/.md`

```text
# Contribute to Astro


---
url: https://docs.astro.build/en/contribute/
description: How to get involved and contribute to Astro.
---


# Contribute to Astro


We welcome contributions of any size and contributors of any skill level. As an open-source project, we believe in giving back to our contributors. We are happy to help with guidance on PRs, technical writing, and turning any feature idea into a reality.

Want to get even more involved? See our [Governance doc](https://github.com/withastro/.github/blob/main/GOVERNANCE.md) for detailed descriptions of different roles, maintainer nomination processes, code review processes, and Code of Conduct enforcement.


## Ways to Contribute


[Section titled Ways to Contribute](#ways-to-contribute)


### Project repositories


[Section titled Project repositories](#project-repositories)

There are lots of ways to contribute to the Astro Project! Every Astro repository has a README with a link to a `CONTRIBUTING.md` file in the root of the project.

Visit [Astro’s GitHub profile](https://github.com/withastro) to find the repositories for:

-   The [main Astro codebase](https://github.com/withastro/astro), including official integrations and starter templates.

-   [Astro Docs](https://github.com/withastro/docs), an entire Astro website! Contribute not just written content, but also Astro code addressing a11y, CSS, UI, and UX concerns. We also make our documentation available in several languages, so we need help translating the entire site.

-   The [Astro compiler](https://github.com/withastro/compiler), written in Go, distributed as WASM.

-   Astro’s [language tools](https://github.com/withastro/language-tools), the editor tooling required for the Astro language (`.astro` files).

-   [Starlight](https://github.com/withastro/starlight), Astro’s official documentation framework.

-   The [Astro Roadmap](https://github.com/withastro/roadmap) where the future of Astro is shaped! Ideas, suggestions, and formal RFC proposals for the Astro project.



### Types of contributions


[Section titled Types of contributions](#types-of-contributions)

In addition to contributing your own code or content, you can also make a huge contribution by getting involved by leaving review comments on PRs, adding ideas in existing GitHub Issues and Discussions, and participating in our “Pinned” issue maintenance tasks!

Every PR, especially translation PRs, needs reviewers! Reviewing PRs and leaving comments, suggestions, or an approving “LGTM!” (“Looks Good To Me!”) is a great way to get started in any repository, and to learn more about Astro.

We also have a very active [Discord](https://astro.build/chat) community! We value the contributions of those who welcome new members, answer support questions, and share what they have built with and for Astro! Beyond traditional GitHub contributions, Astro recognizes and supports community members who engage with our community, share Astro in blog posts, videos and conference talks, and help maintain the health of our community.


## Contributing to Docs


[Section titled Contributing to Docs](#contributing-to-docs)

We have several guides available to assist you with contributing to Astro Docs.

Whether it’s your very first contribution to open-source, or you need to add docs for the new Astro feature you just built, or you’re an experienced translator looking for the next page to translate, or you’d like to learn more about helping as a PR reviewer… we’ve got you covered!

Please visit our dedicated site [*Astro Docs* Docs](https://contribute.docs.astro.build), where you’ll find our documentation to help you contribute to Astro Docs as a typo-fixer, a writer, a translator, a feature-builder, and even as a PR reviewer.


## Our contributors


[Section titled Our contributors](#our-contributors)

These docs are brought to you by all these helpful people. [Join us on GitHub!](https://github.com/withastro/docs)

-   [](https://github.com/jsparkdev)
-   [](https://github.com/sarah11918)
-   [](https://github.com/ArmandPhilippot)
-   [](https://github.com/dreyfus92)
-   [](https://github.com/Nin3lee)
-   [](https://github.com/delucis)
-   [](https://github.com/astrobot-houston)
-   [](https://github.com/Waxer59)
-   [](https://github.com/liruifengv)
-   [](https://github.com/100gle)
-   [](https://github.com/huyikai)
-   [](https://github.com/yanthomasdev)
-   [](https://github.com/thomasbnt)
-   [](https://github.com/morinokami)
-   [](https://github.com/FredKSchott)
-   [](https://github.com/McFlyPartages)
-   [](https://github.com/mearashadowfax)
-   [](https://github.com/kevinzunigacuellar)
-   [](https://github.com/Jutanium)
-   [](https://github.com/hippotastic)
-   [](https://github.com/viniciusdeliz)
-   [](https://github.com/Alynva)
-   [](https://github.com/TheOtterlord)
-   [](https://github.com/bholmesdev)
-   [](https://github.com/Chrissdroid)
-   [](https://github.com/AitorMT)
-   [](https://github.com/kecrily)
-   [](https://github.com/trueberryless)
-   [](https://github.com/ematipico)
-   [](https://github.com/kyosuke)
-   [](https://github.com/Fryuni)
-   [](https://github.com/alexnguyennz)
-   [](https://github.com/jasikpark)
-   [](https://github.com/ElianCodes)
-   [](https://github.com/Princesseuh)
-   [](https://github.com/agustinmulet)
-   [](https://github.com/jonathantneal)
-   [](https://github.com/matthewp)
-   [](https://github.com/at-the-vr)
-   [](https://github.com/Genteure)
-   [](https://github.com/mingjunlu)
-   [](https://github.com/vrabe)
-   [](https://github.com/casungo)
-   [](https://github.com/bluwy)
-   [](https://github.com/Egpereira)
-   [](https://github.com/natemoo-re)
-   [](https://github.com/Hanawa02)
-   [](https://github.com/aFuzzyBear)
-   [](https://github.com/jp-knj)
-   [](https://github.com/MoustaphaDev)
-   [](https://github.com/JuanPabloDiaz)
-   [](https://github.com/fredoist)
-   [](https://github.com/pioupia)
-   [](https://github.com/sasoria)
-   [](https://github.com/maxchang3)
-   [](https://github.com/piro-hiroki)
-   [](https://github.com/sarasate)
-   [](https://github.com/JuanM04)
-   [](https://github.com/mrienstra)
-   [](https://github.com/florian-lefebvre)
-   [](https://github.com/HiDeoo)
-   [](https://github.com/VoxelMC)
-   [](https://github.com/CodeF1ow)
-   [](https://github.com/antonyfaris)
-   [](https://github.com/glopzel)
-   [](https://github.com/dragomano)
-   [](https://github.com/afucher)
-   [](https://github.com/shuuji3)
-   [](https://github.com/kimulaco)
-   [](https://github.com/DerTimonius)
-   [](https://github.com/helmerdx)
-   [](https://github.com/luoingly)
-   [](https://github.com/AbrahamX3)
-   [](https://github.com/mayank99)
-   [](https://github.com/itskitto)
-   [](https://github.com/ncvcz)
-   [](https://github.com/asgoshawk)
-   [](https://github.com/lilnasy)
-   [](https://github.com/CaptainOfPhB)
-   [](https://github.com/diegognt)
-   [](https://github.com/karolhas)
-   [](https://github.com/martrapp)
-   [](https://github.com/itsmatteomanf)
-   [](https://github.com/wpplumber)
-   [](https://github.com/zadeviggers)
-   [](https://github.com/yuto343)
-   [](https://github.com/Eric-llos)
-   [](https://github.com/XindiShang)
-   [](https://github.com/SnowDingo)
-   [](https://github.com/BryceRussell)
-   [](https://github.com/chuygil)
-   [](https://github.com/leoj3n)
-   [](https://github.com/codersjj)
-   [](https://github.com/ryuapp)
-   [](https://github.com/yeonjulee1005)
-   [](https://github.com/hkbertoson)
-   [](https://github.com/drixswe)
-   [](https://github.com/mottox2)
-   [](https://github.com/teinett)
-   [](https://github.com/apatel369)
-   [](https://github.com/agriffard)
-   [](https://github.com/alexanderniebuhr)
-   [](https://github.com/sujang958)
-   [](https://github.com/tejapaturu)
-   [](https://github.com/HashCookie)
-   [](https://github.com/n-tong009)
-   [](https://github.com/renovate[bot])
-   [](https://github.com/autroshot)
-   [](https://github.com/crutchcorn)
-   [](https://github.com/clearlyTHUYDOAN)
-   [](https://github.com/fhiromasa)
-   [](https://github.com/magnum-zx)
-   [](https://github.com/anaxite)
-   [](https://github.com/arisa-fukuzaki)
-   [](https://github.com/caioferrarezi)
-   [](https://github.com/Elib27)
-   [](https://github.com/jdwilkin4)
-   [](https://github.com/Jothsa)
-   [](https://github.com/Panelinio)
-   [](https://github.com/palmiak)
-   [](https://github.com/JusticeMatthew)
-   [](https://github.com/michaelbe812)
-   [](https://github.com/OliverSpeir)
-   [](https://github.com/NinuzIBZ)
-   [](https://github.com/pyronaur)
-   [](https://github.com/milovangudelj)
-   [](https://github.com/ascorbic)
-   [](https://github.com/staticWagomU)
-   [](https://github.com/manchan4869)
-   [](https://github.com/imbant)
-   [](https://github.com/Maxframe)
-   [](https://github.com/Adammatthiesen)
-   [](https://github.com/minjongbaek)
-   [](https://github.com/gacek1123)
-   [](https://github.com/chalkygames123)
-   [](https://github.com/chenxsan)
-   [](https://github.com/ralacerda)
-   [](https://github.com/RafidMuhymin)
-   [](https://github.com/angelmarfil)
-   [](https://github.com/bandantonio)
-   [](https://github.com/BassamXYZ)
-   [](https://github.com/wtchnm)
-   [](https://github.com/garysassano)
-   [](https://github.com/olets)
-   [](https://github.com/IgorKowalczyk)
-   [](https://github.com/Singebob)
-   [](https://github.com/Pukimaa)
-   [](https://github.com/Njong392)
-   [](https://github.com/NightFeather0615)
-   [](https://github.com/nermalcat69)
-   [](https://github.com/mogeko)
-   [](https://github.com/tinymachine)
-   [](https://github.com/mhstrkmp)
-   [](https://github.com/marsidev)
-   [](https://github.com/lorenzolewis)
-   [](https://github.com/chriswburke)
-   [](https://github.com/mitian233)
-   [](https://github.com/santiemanuel)
-   [](https://github.com/paulrudy)
-   [](https://github.com/nokazn)
-   [](https://github.com/miroim)
-   [](https://github.com/melon95)
-   [](https://github.com/mantaroh)
-   [](https://github.com/ktym4a)
-   [](https://github.com/lostra01)
-   [](https://github.com/dorasans)
-   [](https://github.com/dependabot[bot])
-   [](https://github.com/danielcuque)
-   [](https://github.com/florluzduarte)
-   [](https://github.com/AkashRajpurohit)
-   [](https://github.com/guidiego)
-   [](https://github.com/JavGuerra)
-   [](https://github.com/selfire1)
-   [](https://github.com/KoriIku)
-   [](https://github.com/louisescher)
-   [](https://github.com/lumamontes)
-   [](https://github.com/nbyx)
-   [](https://github.com/Hopelezz)
-   [](https://github.com/ohansemmanuel)
-   [](https://github.com/richeklein)
-   [](https://github.com/ItzRoBeerT)
-   [](https://github.com/seppegadeyne)
-   [](https://github.com/vuecat)
-   [](https://github.com/tordans)
-   [](https://github.com/simonswiss)
-   [](https://github.com/darusk)
-   [](https://github.com/vedxp)
-   [](https://github.com/tony-sull)
-   [](https://github.com/arty-name)
-   [](https://github.com/timfee)
-   [](https://github.com/Tc-001)
-   [](https://github.com/hexWars)
-   [](https://github.com/SatanshuMishra)
-   [](https://github.com/ManorSailor)
-   [](https://github.com/BlackdestinyXX)
-   [](https://github.com/DevRohit06)
-   [](https://github.com/radenpioneer)
-   [](https://github.com/thepassle)
-   [](https://github.com/Morritz)
-   [](https://github.com/emily-shen)
-   [](https://github.com/VLTHellolin)
-   [](https://github.com/Lilian97)
-   [](https://github.com/matdexir)
-   [](https://github.com/nadar)
-   [](https://github.com/okonomi)
-   [](https://github.com/neoki07)
-   [](https://github.com/renanleonel)
-   [](https://github.com/situ2001)
-   [](https://github.com/space-otter)
-   [](https://github.com/tobiasschmidt89)
-   [](https://github.com/ws-rush)
-   [](https://github.com/ykcory)
-   [](https://github.com/bengeois)
-   [](https://github.com/openscript)
-   [](https://github.com/fflaten)
-   [](https://github.com/favanso)
-   [](https://github.com/evadecker)
-   [](https://github.com/eric-burel)
-   [](https://github.com/dsomel21)
-   [](https://github.com/Dillonpw)
-   [](https://github.com/David-Large)
-   [](https://github.com/cravend)
-   [](https://github.com/CBID2)
-   [](https://github.com/csarnataro)
-   [](https://github.com/emjio)
-   [](https://github.com/breadadams)
-   [](https://github.com/Because789)
-   [](https://github.com/deining)
-   [](https://github.com/0xflotus)
-   [](https://github.com/ahmed-n-abdeltwab)
-   [](https://github.com/leen-neel)
-   [](https://github.com/nicdun)
-   [](https://github.com/pReya)
-   [](https://github.com/mhdcodes)
-   [](https://github.com/debiru)
-   [](https://github.com/baevm)
-   [](https://github.com/MartinFerret)
-   [](https://github.com/kannansuresh)
-   [](https://github.com/kanadgupta)
-   [](https://github.com/jdbruxelles)
-   [](https://github.com/Je12emy)
-   [](https://github.com/jhuleatt)
-   [](https://github.com/sunapi386)
-   [](https://github.com/swift502)
-   [](https://github.com/newtoallofthis123)
-   [](https://github.com/LiHowe)
-   [](https://github.com/RolginRoman)
-   [](https://github.com/ffxsam)
-   [](https://github.com/SandraRodgers)
-   [](https://github.com/SebasG22)
-   [](https://github.com/SergioDiez)
-   [](https://github.com/ShamarYarde)
-   [](https://github.com/surjithctly)
-   [](https://github.com/V3RON)
-   [](https://github.com/motss)
-   [](https://github.com/tem235)
-   [](https://github.com/tobySolutions)
-   [](https://github.com/inwardmovement)
-   [](https://github.com/XinChou16)
-   [](https://github.com/vitoriapena)
-   [](https://github.com/vivitt)
-   [](https://github.com/Zastinian)
-   [](https://github.com/Rolanddoda)
-   [](https://github.com/millette)
-   [](https://github.com/RobertAKARobin)
-   [](https://github.com/wobsoriano)
-   [](https://github.com/RezixDev)
-   [](https://github.com/Scalamando)
-   [](https://github.com/serhalp)
-   [](https://github.com/9thQuadrant)
-   [](https://github.com/dibaxu)
-   [](https://github.com/omarr45)
-   [](https://github.com/okikio)
-   [](https://github.com/Ekwuno)
-   [](https://github.com/nikhilhenry)
-   [](https://github.com/NavyStack)
-   [](https://github.com/stormynight9)
-   [](https://github.com/xun082)
-   [](https://github.com/my-astro)
-   [](https://github.com/pilcrowonpaper)
-   [](https://github.com/randomguy-2650)
-   [](https://github.com/ref-thomasledoux1)
-   [](https://github.com/sentisso)
-   [](https://github.com/t0yohei)
-   [](https://github.com/JPVan)
-   [](https://github.com/woshierha)
-   [](https://github.com/yiyuan9)
-   [](https://github.com/zreren)
-   [](https://github.com/dei8bit)
-   [](https://github.com/shinonomelon)
-   [](https://github.com/Tsukistar)
-   [](https://github.com/zhuchentong)
-   [](https://github.com/abhikjain360)
-   [](https://github.com/castarco)
-   [](https://github.com/peng)
-   [](https://github.com/AsazuTaiga)
-   [](https://github.com/magurotabetai)
-   [](https://github.com/Bluex-xx)
-   [](https://github.com/carsakiller)
-   [](https://github.com/djdeo)
-   [](https://github.com/fabriciodev26)
-   [](https://github.com/mardybardy)
-   [](https://github.com/gtnbssn)
-   [](https://github.com/guiguir68)
-   [](https://github.com/eiis)
-   [](https://github.com/inotelabs)
-   [](https://github.com/jose8a)
-   [](https://github.com/kikonavarro)
-   [](https://github.com/lhz960904)
-   [](https://github.com/lstephensca)
-   [](https://github.com/aaronlamz)
-   [](https://github.com/conradagramont)
-   [](https://github.com/WooDaeHyun)
-   [](https://github.com/DavidEGiraldo)
-   [](https://github.com/Sparkhand)
-   [](https://github.com/ekafyi)
-   [](https://github.com/estruyf)
-   [](https://github.com/emma-sg)
-   [](https://github.com/Erik-McKelvey)
-   [](https://github.com/PanConDev)
-   [](https://github.com/Franqsanz)
-   [](https://github.com/falvarador)
-   [](https://github.com/felixsanz)
-   [](https://github.com/ogabrielp)
-   [](https://github.com/gaeulbyul)
-   [](https://github.com/neotherapper)
-   [](https://github.com/TKDev7)
-   [](https://github.com/addonion)
-   [](https://github.com/AdamPrendergast)
-   [](https://github.com/afonsojramos)
-   [](https://github.com/Alex-S-Davies)
-   [](https://github.com/Astisme)
-   [](https://github.com/alfredogonzalezmartinez)
-   [](https://github.com/alvgaona)
-   [](https://github.com/alvinometric)
-   [](https://github.com/andremralves)
-   [](https://github.com/ArinaKosiakov)
-   [](https://github.com/atilafassina)
-   [](https://github.com/avilyre)
-   [](https://github.com/bartosztrusinski)
-   [](https://github.com/calebeby)
-   [](https://github.com/CheukTsai)
-   [](https://github.com/colbyfayock)
-   [](https://github.com/juanburg98)
-   [](https://github.com/juansemprun)
-   [](https://github.com/juliamrch)
-   [](https://github.com/jurajkapsz)
-   [](https://github.com/justinnoel)
-   [](https://github.com/yt-kevincarrera)
-   [](https://github.com/ixkaito)
-   [](https://github.com/yeskunall)
-   [](https://github.com/kylebutts)
-   [](https://github.com/leoxs22)
-   [](https://github.com/leohxj)
-   [](https://github.com/LuMiSxh)
-   [](https://github.com/Trombach)
-   [](https://github.com/lukemcdonald)
-   [](https://github.com/MaxTheTurtle0)
-   [](https://github.com/mingXta)
-   [](https://github.com/HALQME)
-   [](https://github.com/X7md)
-   [](https://github.com/HawtinZeng)
-   [](https://github.com/hfournier)
-   [](https://github.com/iainsimmons)
-   [](https://github.com/isaac-mcfadyen)
-   [](https://github.com/isamardzija)
-   [](https://github.com/AsyncBanana)
-   [](https://github.com/vandorsx)
-   [](https://github.com/DerYeger)
-   [](https://github.com/JEverhart383)
-   [](https://github.com/jeffdrumgod)
-   [](https://github.com/jazzypants1989)
-   [](https://github.com/Jhon-H)
-   [](https://github.com/jcha0713)
-   [](https://github.com/Jvictorvieira)
-   [](https://github.com/andrzeij)
-   [](https://github.com/Gelbotron)
-   [](https://github.com/unrevised6419)
-   [](https://github.com/madrus)
-   [](https://github.com/andersk)
-   [](https://github.com/ancaemcken)
-   [](https://github.com/grace-anand)
-   [](https://github.com/yoyo837)
-   [](https://github.com/amirzezo201)
-   [](https://github.com/amxmln)
-   [](https://github.com/gachikuku)
-   [](https://github.com/heldinz)
-   [](https://github.com/hrynko)
-   [](https://github.com/notjb)
-   [](https://github.com/andriesniemandt)
-   [](https://github.com/ap-1)
-   [](https://github.com/GalindoSVQ)
-   [](https://github.com/Antonytm)
-   [](https://github.com/theAnuragMishra)
-   [](https://github.com/ansango)
-   [](https://github.com/Aperezpe)
-   [](https://github.com/Apisathan)
-   [](https://github.com/aritraroy24)
-   [](https://github.com/ArnavK-09)
-   [](https://github.com/khattakdev)
-   [](https://github.com/artt)
-   [](https://github.com/artursopelnik)
-   [](https://github.com/3w36zj6)
-   [](https://github.com/aaronkai)
-   [](https://github.com/arafays)
-   [](https://github.com/alfawal)
-   [](https://github.com/abisekhsubedi)
-   [](https://github.com/adamlevoy)
-   [](https://github.com/AdamGEmerson)
-   [](https://github.com/adamgajzlerowicz)
-   [](https://github.com/adam-lynch)
-   [](https://github.com/armgitaar)
-   [](https://github.com/ADRlANO)
-   [](https://github.com/adrian-burkhart)
-   [](https://github.com/adrianlyjak)
-   [](https://github.com/apz-gh)
-   [](https://github.com/ahmedrowaihi)
-   [](https://github.com/AishaBlake)
-   [](https://github.com/aboudard)
-   [](https://github.com/altano)
-   [](https://github.com/wonderbeel)
-   [](https://github.com/albertogiunta)
-   [](https://github.com/amaimus)
-   [](https://github.com/alexpdraper)
-   [](https://github.com/AlexNodex)
-   [](https://github.com/haasal)
-   [](https://github.com/alex-drocks)
-   [](https://github.com/thekidisalright)
-   [](https://github.com/alextison)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 9. `en/editor-setup/.md`

```text
# Editor setup


---
url: https://docs.astro.build/en/editor-setup/
description: Set up your code editor to build with Astro.
---


# Editor setup


Customize your code editor to improve the Astro developer experience and unlock new features.


## VS Code


[Section titled VS Code](#vs-code)

[VS Code](https://code.visualstudio.com/) is a popular code editor for web developers, built by Microsoft. The VS Code engine also powers popular in-browser code editors like [GitHub Codespaces](https://github.com/features/codespaces) and [Gitpod](https://gitpod.io/).

Astro works with any code editor. However, VS Code is our recommended editor for Astro projects. We maintain an official [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) that unlocks several key features and developer experience improvements for Astro projects.

-   Syntax highlighting for `.astro` files.
-   TypeScript type information for `.astro` files.
-   [VS Code Intellisense](https://code.visualstudio.com/docs/editor/intellisense) for code completion, hints and more.

To get started, install the [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) today.

See how to [set up TypeScript](/en/guides/typescript/) in your Astro project.


## Zed


[Section titled Zed](#zed)

[Zed](https://zed.dev/) is an open-source code editor that added support for Astro in version 0.123.2. You can install the [Astro extension](https://github.com/zed-extensions/astro) in the IDE’s Extensions tab. This extension includes features like syntax highlighting, code completion, and formatting.


## JetBrains IDEs


[Section titled JetBrains IDEs](#jetbrains-ides)

[Webstorm](https://www.jetbrains.com/webstorm/) is a JavaScript and TypeScript IDE that added support for the Astro Language Server in version 2024.2. This update brings features like syntax highlighting, code completion, and formatting.

Install the official plugin through [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/20959-astro) or by searching for “Astro” in the IDE’s Plugins tab. You can toggle the language server in `Settings | Languages & Frameworks | TypeScript | Astro`.

For more information on Astro support in Webstorm, check out [the official Webstorm Astro Documentation](https://www.jetbrains.com/help/webstorm/astro.html).


## Other Code Editors


[Section titled Other Code Editors](#other-code-editors)

Our amazing community maintains several extensions for other popular editors, including:

-   [VS Code Extension on Open VSX](https://open-vsx.org/extension/astro-build/astro-vscode) Official - The official Astro VS Code Extension, available on the Open VSX registry for open platforms like [VSCodium](https://vscodium.com/)
-   [Nova Extension](https://extensions.panic.com/extensions/sciencefidelity/sciencefidelity.astro/) Community - Provides syntax highlighting and code completion for Astro inside of Nova
-   [Vim Plugin](https://github.com/wuelnerdotexe/vim-astro) Community - Provides syntax highlighting, indentation, and code folding support for Astro inside of Vim or Neovim
-   Neovim [LSP](https://github.com/neovim/nvim-lspconfig/blob/master/doc/configs.md#astro) and [TreeSitter](https://github.com/virchau13/tree-sitter-astro) Plugins Community - Provides syntax highlighting, treesitter parsing, and code completion for Astro inside of Neovim
-   Emacs - See instructions for [Configuring Emacs and Eglot](https://medium.com/@jrmjrm/configuring-emacs-and-eglot-to-work-with-astro-language-server-9408eb709ab0) Community to work with Astro
-   [Astro syntax highlighting for Sublime Text](https://packagecontrol.io/packages/Astro) Community - The Astro package for Sublime Text, available on the Sublime Text package manager.


## In-Browser Editors


[Section titled In-Browser Editors](#in-browser-editors)

In addition to local editors, Astro also runs well on in-browser hosted editors, including:

-   [StackBlitz](https://stackblitz.com/) and [CodeSandbox](https://codesandbox.io/) - online editors that run in your browser, with built-in syntax highlighting support for `.astro` files. No installation or configuration required!
-   [GitHub.dev](https://github.dev/) - allows you to install the Astro VS Code extension as a [web extension](https://code.visualstudio.com/api/extension-guides/web-extensions), which gives you access to only some of the full extension features. Currently, only syntax highlighting is supported.
-   [IDX](https://idx.dev) and [Gitpod](https://gitpod.io/) - a full dev environment in the cloud that can install the official Astro VS Code Extension from Open VSX.


## Other tools


[Section titled Other tools](#other-tools)


### ESLint


[Section titled ESLint](#eslint)

[ESLint](https://eslint.org/) is a popular linter for JavaScript and JSX. For Astro support, [a community maintained plugin](https://github.com/ota-meshi/eslint-plugin-astro) can be installed.

See [the project’s User Guide](https://ota-meshi.github.io/eslint-plugin-astro/user-guide/) for more information on how to install and set up ESLint for your project.


### Stylelint


[Section titled Stylelint](#stylelint)

[Stylelint](https://stylelint.io/) is a popular linter for CSS. [A community maintained Stylelint configuration](https://github.com/ota-meshi/stylelint-config-html) provides Astro support.

Installation instructions, editor integration, and additional information can be found in the project’s README.


### Prettier


[Section titled Prettier](#prettier)

[Prettier](https://prettier.io/) is a popular formatter for JavaScript, HTML, CSS, and more. If you’re using the [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) or [the Astro language server within another editor](#other-code-editors), code formatting with Prettier is included.

To add support for formatting `.astro` files outside of the editor (e.g. CLI) or inside editors that don’t support our editor tooling, install [the official Astro Prettier plugin](https://github.com/withastro/prettier-plugin-astro).

1.  Install `prettier` and `prettier-plugin-astro`.

    -   [npm](#tab-panel-1277)
    -   [pnpm](#tab-panel-1278)
    -   [Yarn](#tab-panel-1279)

    Terminal window

    ```
    npminstall--save-dev--save-exactprettierprettier-plugin-astro
    ```

    Terminal window

    ```
    pnpmadd--save-dev--save-exactprettierprettier-plugin-astro
    ```

    Terminal window

    ```
    yarnadd--dev--exactprettierprettier-plugin-astro
    ```

2.  Create a `.prettierrc` configuration file (or `.prettierrc.json`, `.prettierrc.mjs`, or [other supported formats](https://prettier.io/docs/configuration)) in the root of your project and add `prettier-plugin-astro` to it.

    In this file, also manually specify the parser for Astro files.

    .prettierrc

    ```
    {"plugins": ["prettier-plugin-astro"],"overrides": [{"files": "*.astro","options": {"parser": "astro",}}]}
    ```

3.  Run the following command in your terminal to format your files.

    -   [npm](#tab-panel-1280)
    -   [pnpm](#tab-panel-1281)
    -   [Yarn](#tab-panel-1282)

    Terminal window

    ```
    npxprettier.--write
    ```

    Terminal window

    ```
    pnpmexecprettier.--write
    ```

    Terminal window

    ```
    yarnexecprettier.--write
    ```


See the [Prettier plugin’s README](https://github.com/withastro/prettier-plugin-astro/blob/main/README.md) for more information about its supported options, how to set up Prettier inside VS Code, and more.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 10. `en/getting-started/.md`

```text
# Astro Docs


---
url: https://docs.astro.build/en/getting-started/
description: Guides, resources, and API references to help you build with Astro — the web framework for content-driven websites.
---

Astro v5 is here! [Learn how to upgrade your site](/en/guides/upgrade-to/v5/)


# Astro Docs


Guides, resources, and API references to help you build with Astro.

[Install Astro](/en/install-and-setup/) [Learn about Astro’s features](/en/concepts/why-astro/)

Powered by Astro and our open-source contributors. [Join us!](/en/contribute/)

Powered by Astro and our open-source contributors. [Join us!](/en/contribute/)

What will you build with Astro?

Explore [Astro starter themes](https://astro.build/themes/) for blogs, portfolios, docs, landing pages, SaaS, marketing, ecommerce sites, and more!

Take a guided tour

Complete our introductory [Build a Blog Tutorial](/en/tutorial/0-introduction/) to learn the basics and create your first Astro site.

Start a new project

Terminal window

```

# create a new project with npmnpmcreateastro@latest

```

Our [installation guide](/en/install-and-setup/) has step-by-step instructions for installing Astro using our CLI wizard, creating a new project from an existing Astro GitHub repository, and for installing Astro manually.

Learn

-   [Astro’s main features](/en/concepts/why-astro/)
-   [Islands architecture](/en/concepts/islands/)
-   [Astro components](/en/basics/astro-components/)
-   [The Astro template syntax](/en/reference/astro-syntax/)

Extend

-   [Add integrations like React and Partytown](/en/guides/integrations-guide/)
-   [Create type safe content collections](/en/guides/content-collections/)
-   [Enhance navigation with view transitions](/en/guides/view-transitions/)
-   [Connect a headless CMS to your project](/en/guides/cms/)


## Have a question or want to get involved?


[Join our Discord](https://astro.build/chat)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 11. `en/guides/actions/.md`

```text
# Actions


---
url: https://docs.astro.build/en/guides/actions/
description: Learn how to create type-safe server functions you can call from anywhere.
---


# Actions


**Added in:** `astro@4.15`

Astro Actions allow you to define and call backend functions with type-safety. Actions perform data fetching, JSON parsing, and input validation for you. This can greatly reduce the amount of boilerplate needed compared to using an [API endpoint](/en/guides/endpoints/).

Use actions instead of API endpoints for seamless communication between your client and server code and to:

-   Automatically validate JSON and form data inputs using [Zod validation](https://zod.dev/?id=primitives).
-   Generate type-safe functions to call your backend from the client and even [from HTML form actions](#call-actions-from-an-html-form-action). No need for manual `fetch()` calls.
-   Standardize backend errors with the [`ActionError`](/en/reference/modules/astro-actions/#actionerror) object.


## Basic usage


[Section titled Basic usage](#basic-usage)

Actions are defined in a `server` object exported from `src/actions/index.ts`:

src/actions/index.ts

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {myAction: defineAction({ /* ... */ })}
```

Your actions are available as functions from the `astro:actions` module. Import `actions` and call them client-side within a [UI framework component](/en/guides/framework-components/), [a form POST request](#call-actions-from-an-html-form-action), or by using a `<script>` tag in an Astro component.

When you call an action, it returns an object with either `data` containing the JSON-serialized result, or `error` containing thrown errors.

src/pages/index.astro

```
------<script>import { actions } from'astro:actions';async()=> {const { data, error } = await actions.myAction({ /* ... */ });}</script>
```


### Write your first action


[Section titled Write your first action](#write-your-first-action)

Follow these steps to define an action and call it in a `script` tag in your Astro page.

1.  Create a `src/actions/index.ts` file and export a `server` object.

    src/actions/index.ts

    ```
    export const server = {// action declarations}
    ```

2.  Import the `defineAction()` utility from `astro:actions`, and the `z` object from `astro:schema`.

    src/actions/index.ts

    ```
    import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {// action declarations}
    ```

3.  Use the `defineAction()` utility to define a `getGreeting` action. The `input` property will be used to validate input parameters with a [Zod](https://zod.dev) schema and the `handler()` function includes the backend logic to run on the server.

    src/actions/index.ts

    ```
    import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {getGreeting: defineAction({input: z.object({name: z.string(),}),handler: async (input) => {return `Hello, ${input.name}!`}})}
    ```

4.  Create an Astro component with a button that will fetch a greeting using your `getGreeting` action when clicked.

    src/pages/index.astro

    ```
    ------<button>Get greeting</button><script>const button = document.querySelector('button');button?.addEventListener('click', async()=> {// Show alert pop-up with greeting from action});</script>
    ```

5.  To use your action, import `actions` from `astro:actions` and then call `actions.getGreeting()` in the click handler. The `name` option will be sent to your action’s `handler()` on the server and, if there are no errors, the result will be available as the `data` property.

    src/pages/index.astro

    ```
    ------<button>Get greeting</button><script>import { actions } from'astro:actions';const button = document.querySelector('button');button?.addEventListener('click', async()=> {// Show alert pop-up with greeting from actionconst { data, error } = await actions.getGreeting({ name: "Houston" });if (!error) alert(data);})</script>
    ```


See the full Actions API documentation for details on [`defineAction()`](/en/reference/modules/astro-actions/#defineaction) and its properties.


## Organizing actions


[Section titled Organizing actions](#organizing-actions)

All actions in your project must be exported from the `server` object in the `src/actions/index.ts` file. You can define actions inline or you can move action definitions to separate files and import them. You can even group related functions in nested objects.

For example, to colocate all of your user actions, you can create a `src/actions/user.ts` file and nest the definitions of both `getUser` and `createUser` inside a single `user` object.

src/actions/user.ts

```
import { defineAction } from'astro:actions';export const user = {getUser: defineAction(/* ... */),createUser: defineAction(/* ... */),}
```

Then, you can import this `user` object into your `src/actions/index.ts` file and add it as a top-level key to the `server` object alongside any other actions:

src/actions/index.ts

```
import { user } from'./user';export const server = {myAction: defineAction({ /* ... */ }),user,}
```

Now, all of your user actions are callable from the `actions.user` object:

-   `actions.user.getUser()`
-   `actions.user.createUser()`


## Handling returned data


[Section titled Handling returned data](#handling-returned-data)

Actions return an object containing either `data` with the type-safe return value of your `handler()`, or an `error` with any backend errors. Errors may come from validation errors on the `input` property or thrown errors within the `handler()`.

Actions return a custom data format that can handle Dates, Maps, Sets, and URLs [using the Devalue library](https://github.com/Rich-Harris/devalue). Therefore, you can’t easily inspect the response from the network like you can with regular JSON. For debugging, you can instead inspect the `data` object returned by actions.

[See the `handler()` API reference](/en/reference/modules/astro-actions/#handler-property) for full details.


### Checking for errors


[Section titled Checking for errors](#checking-for-errors)

It’s best to check if an `error` is present before using the `data` property. This allows you to handle errors in advance and ensures `data` is defined without an `undefined` check.

```
const { data, error } = await actions.example();if (error) {// handle error casesreturn;}// use `data`
```


### Accessing `data` directly without an error check


[Section titled Accessing data directly without an error check](#accessing-data-directly-without-an-error-check)

To skip error handling, for example while prototyping or using a library that will catch errors for you, use the `.orThrow()` property on your action call to throw errors instead of returning an `error`. This will return the action’s `data` directly.

This example calls a `likePost()` action that returns the updated number of likes as a `number` from the action `handler`:

```
const updatedLikes = await actions.likePost.orThrow({ postId: 'example' });//    ^ type: number
```


### Handling backend errors in your action


[Section titled Handling backend errors in your action](#handling-backend-errors-in-your-action)

You can use the provided `ActionError` to throw an error from your action `handler()`, such as “not found” when a database entry is missing, or “unauthorized” when a user is not logged in. This has two main benefits over returning `undefined`:

-   You can set a status code like `404 - Not found` or `401 - Unauthorized`. This improves debugging errors in both development and in production by letting you see the status code of each request.

-   In your application code, all errors are passed to the `error` object on an action result. This avoids the need for `undefined` checks on data, and allows you to display targeted feedback to the user depending on what went wrong.



#### Creating an `ActionError`


[Section titled Creating an ActionError](#creating-an-actionerror)

To throw an error, import the `ActionError()` class from the `astro:actions` module. Pass it a human-readable status `code` (e.g. `"NOT_FOUND"` or `"BAD_REQUEST"`), and an optional `message` to provide further information about the error.

This example throws an error from a `likePost` action when a user is not logged in, after checking a hypothetical “user-session” cookie for authentication:

src/actions/index.ts

```
import { defineAction, ActionError } from"astro:actions";import { z } from"astro:schema";export const server = {likePost: defineAction({input: z.object({ postId: z.string() }),handler: async (input, ctx) => {if (!ctx.cookies.has('user-session')) {throw newActionError({code: "UNAUTHORIZED",message: "User must be logged in.",});}// Otherwise, like the post},}),};
```


#### Handling an `ActionError`


[Section titled Handling an ActionError](#handling-an-actionerror)

To handle this error, you can call the action from your application and check whether an `error` property is present. This property will be of type `ActionError` and will contain your `code` and `message`.

In the following example, a `LikeButton.tsx` component calls the `likePost()` action when clicked. If an authentication error occurs, the `error.code` attribute is used to determine whether to display a login link:

src/components/LikeButton.tsx

```
import { actions } from'astro:actions';import { useState } from'preact/hooks';exportfunctionLikeButton({ postId }: { postId:string }) {const [showLogin,setShowLogin] = useState(false);return (<>{showLogin &&<ahref="/signin">Log in to like a post.</a>}<buttononClick={async()=> {const { data,error } = await actions.likePost({ postId });if(error?.code==='UNAUTHORIZED')setShowLogin(true);// Early return for unexpected errorselseif(error)return;// update likes}}>Like</button></>)}
```


### Handling client redirects


[Section titled Handling client redirects](#handling-client-redirects)

When calling actions from the client, you can integrate with a client-side library like `react-router`, or you can use Astro’s [`navigate()` function](/en/guides/view-transitions/#trigger-navigation) to redirect to a new page when an action succeeds.

This example navigates to the homepage after a `logout` action returns successfully:

src/pages/LogoutButton.tsx

```
import { actions } from'astro:actions';import { navigate } from'astro:transitions/client';exportfunctionLogoutButton() {return (<buttononClick={async()=> {const { error } = await actions.logout();if(!error)navigate('/');}}>Logout</button>);}
```


## Accepting form data from an action


[Section titled Accepting form data from an action](#accepting-form-data-from-an-action)

Actions accept JSON data by default. To accept form data from an HTML form, set `accept: 'form'` in your `defineAction()` call:

src/actions/index.ts

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {comment: defineAction({accept: 'form',input: z.object(/* ... */),handler: async (input) => { /* ... */ },})}
```


### Validating form data


[Section titled Validating form data](#validating-form-data)

Actions will parse submitted form data to an object, using the value of each input’s `name` attribute as the object keys. For example, a form containing `<input name="search">` will be parsed to an object like `{ search: 'user input' }`. Your action’s `input` schema will be used to validate this object.

To receive the raw `FormData` object in your action handler instead of a parsed object, omit the `input` property in your action definition.

The following example shows a validated newsletter registration form that accepts a user’s email and requires a “terms of service” agreement checkbox.

1.  Create an HTML form component with unique `name` attributes on each input:

    src/components/Newsletter.astro

    ```
    <form><labelfor="email">E-mail</label><inputid="email"requiredtype="email"name="email" /><label><inputrequiredtype="checkbox"name="terms">I agree to the terms of service</label><button>Sign up</button></form>
    ```

2.  Define a `newsletter` action to handle the submitted form. Validate the `email` field using the `z.string().email()` validator, and the `terms` checkbox using `z.boolean()`:

    src/actions/index.ts

    ```
    import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {newsletter: defineAction({accept: 'form',input: z.object({email: z.string().email(),terms: z.boolean(),}),handler: async ({ email, terms }) => { /* ... */ },})}
    ```

    See the [`input` API reference](/en/reference/modules/astro-actions/#input-validator) for all available form validators.

3.  Add a `<script>` to the HTML form to submit the user input. This example overrides the form’s default submit behavior to call `actions.newsletter()`, and redirects to `/confirmation` using the `navigate()` function:

    src/components/Newsletter.astro

    ```
    <form>7 collapsed lines<labelfor="email">E-mail</label><inputid="email"requiredtype="email"name="email" /><label><inputrequiredtype="checkbox"name="terms">I agree to the terms of service</label><button>Sign up</button></form><script>import { actions } from'astro:actions';import { navigate } from'astro:transitions/client';const form = document.querySelector('form');form?.addEventListener('submit', async(event)=> {event.preventDefault();const formData = newFormData(form);const { error } = await actions.newsletter(formData);if (!error) navigate('/confirmation');})</script>
    ```

    See [“Call actions from an HTML form action”](#call-actions-from-an-html-form-action) for an alternative way to submit form data.



### Displaying form input errors


[Section titled Displaying form input errors](#displaying-form-input-errors)

You can validate form inputs before submission using [native HTML form validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) like `required`, `type="email"`, and `pattern`. For more complex `input` validation on the backend, you can use the provided [`isInputError()`](/en/reference/modules/astro-actions/#isinputerror) utility function.

To retrieve input errors, use the `isInputError()` utility to check whether an error was caused by invalid input. Input errors contain a `fields` object with messages for each input name that failed to validate. You can use these messages to prompt your user to correct their submission.

The following example checks the error with `isInputError()`, then checks whether the error is in the email field, before finally creating a message from the errors. You can use JavaScript DOM manipulation or your preferred UI framework to display this message to users.

```
import { actions, isInputError } from'astro:actions';const form = document.querySelector('form');const formData = newFormData(form);const { error } = await actions.newsletter(formData);if (isInputError(error)) {// Handle input errors.if (error.fields.email) {const message = error.fields.email.join(', ');}}
```


## Call actions from an HTML form action


[Section titled Call actions from an HTML form action](#call-actions-from-an-html-form-action)

Note

Pages must be on-demand rendered when calling actions using a form action. [Ensure prerendering is disabled on the page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering) before using this API.

You can enable zero-JS form submissions with standard attributes on any `<form>` element. Form submissions without client-side JavaScript may be useful both as a fallback for when JavaScript fails to load, or if you prefer to handle forms entirely from the server.

Calling [Astro.getActionResult()](/en/reference/api-reference/#getactionresult) on the server returns the result of your form submission (`data` or `error`), and can be used to dynamically redirect, handle form errors, update the UI, and more.

To call an action from an HTML form, add `method="POST"` to your `<form>`, then set the form’s `action` attribute using your action, for example `action={actions.logout}`. This will set the `action` attribute to use a query string that is handled by the server automatically.

For example, this Astro component calls the `logout` action when the button is clicked and reloads the current page:

src/components/LogoutButton.astro

```
---import { actions } from'astro:actions';---<formmethod="POST"action={actions.logout}><button>Log out</button></form>
```

Additional attributes on the `<form>` element may be necessary for proper schema validation with Zod. For example, to include file uploads, add `enctype="multipart/form-data"` to ensure that files are sent in a format correctly recognized by `z.instanceof(File)`:

src/components/FileUploadForm.astro

```
---import { actions } from'astro:actions';---<formmethod="POST"action={actions.upload}enctype="multipart/form-data" ><labelfor="file">Upload File</label><inputtype="file"id="file"name="file" /><buttontype="submit">Submit</button></form>
```


### Redirect on action success


[Section titled Redirect on action success](#redirect-on-action-success)

If you need to redirect to a new route on success, you can use an action’s result on the server. A common example is creating a product record and redirecting to the new product’s page, e.g. `/products/[id]`.

For example, say you have a `createProduct` action that returns the generated product id:

src/actions/index.ts

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {createProduct: defineAction({accept: 'form',input: z.object({ /* ... */ }),handler: async (input) => {const product = await persistToDatabase(input);return { id: product.id };},})}
```

You can retrieve the action result from your Astro component by calling `Astro.getActionResult()`. This returns an object containing `data` or `error` properties when an action is called, or `undefined` if the action was not called during this request.

Use the `data` property to construct a URL to use with `Astro.redirect()`:

src/pages/products/create.astro

```
---import { actions } from'astro:actions';const result = Astro.getActionResult(actions.createProduct);if (result &&!result.error) {return Astro.redirect(`/products/${result.data.id}`);}---<formmethod="POST"action={actions.createProduct}><!--...--></form>
```


### Handle form action errors


[Section titled Handle form action errors](#handle-form-action-errors)

Calling `Astro.getActionResult()` in the Astro component containing your form gives you access to the `data` and `error` objects for custom error handling.

The following example displays a general failure message when a `newsletter` action fails:

src/pages/index.astro

```
---import { actions } from'astro:actions';const result = Astro.getActionResult(actions.newsletter);---{result?.error&& (<pclass="error">Unable to sign up. Please try again later.</p>)}<formmethod="POST"action={actions.newsletter}><label>E-mail<inputrequiredtype="email"name="email" /></label><button>Sign up</button></form>
```

For more customization, you can [use the `isInputError()` utility](#displaying-form-input-errors) to check whether an error is caused by invalid input.

The following example renders an error banner under the `email` input field when an invalid email is submitted:

src/pages/index.astro

```
---import { actions, isInputError } from'astro:actions';const result = Astro.getActionResult(actions.newsletter);const inputErrors = isInputError(result?.error) ? result.error.fields : {};---<formmethod="POST"action={actions.newsletter}><label>E-mail<inputrequiredtype="email"name="email"aria-describedby="error" /></label>{inputErrors.email&&<pid="error">{inputErrors.email.join(',')}</p>}<button>Sign up</button></form>
```


#### Preserve input values on error


[Section titled Preserve input values on error](#preserve-input-values-on-error)

Inputs will be cleared whenever a form is submitted. To persist input values, you can [enable view transitions](/en/guides/view-transitions/#adding-view-transitions-to-a-page) on the page and apply the `transition:persist` directive to each input:

```
<inputtransition:persistrequiredtype="email"name="email" />
```


### Update the UI with a form action result


[Section titled Update the UI with a form action result](#update-the-ui-with-a-form-action-result)

To use an action’s return value to display a notification to the user on success, pass the action to `Astro.getActionResult()`. Use the returned `data` property to render the UI you want to display.

This example uses the `productName` property returned by an `addToCart` action to show a success message.

src/pages/products/\[slug\].astro

```
---import { actions } from'astro:actions';const result = Astro.getActionResult(actions.addToCart);---{result &&!result.error&& (<pclass="success">Added {result.data.productName} to cart</p>)}<!--...-->
```


### Advanced: Persist action results with a session


[Section titled Advanced: Persist action results with a session](#advanced-persist-action-results-with-a-session)

**Added in:** `astro@5.0.0`

Action results are displayed as a POST submission. This means that the result will be reset to `undefined` when a user closes and revisits the page. The user will also see a “confirm form resubmission?” dialog if they attempt to refresh the page.

To customize this behavior, you can add middleware to handle the result of the action manually. You may choose to persist the action result using a cookie or session storage.

Start by [creating a middleware file](/en/guides/middleware/) and importing [the `getActionContext()` utility](/en/reference/modules/astro-actions/#getactioncontext) from `astro:actions`. This function returns an `action` object with information about the incoming action request, including the action handler and whether the action was called from an HTML form. `getActionContext()` also returns the `setActionResult()` and `serializeActionResult()` functions to programmatically set the value returned by `Astro.getActionResult()`:

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action, setActionResult, serializeActionResult } = getActionContext(context);if (action?.calledFrom === 'form') {const result = await action.handler();// ... handle the action resultsetActionResult(action.name, serializeActionResult(result));}return next();});
```

A common practice to persist HTML form results is the [POST / Redirect / GET pattern](https://en.wikipedia.org/wiki/Post/Redirect/Get). This redirect removes the “confirm form resubmission?” dialog when the page is refreshed, and allows action results to be persisted throughout the user’s session.

This example applies the POST / Redirect / GET pattern to all form submissions using session storage with the [Netlify server adapter](/en/guides/integrations-guide/netlify/) installed. Action results are written to a session store using [Netlify Blob](https://docs.netlify.com/blobs/overview/), and retrieved after a redirect using a session ID:

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';import { randomUUID } from"node:crypto";import { getStore } from"@netlify/blobs";export const onRequest = defineMiddleware(async (context, next) => {// Skip requests for prerendered pagesif (context.isPrerendered) return next();const { action, setActionResult, serializeActionResult } =getActionContext(context);// Create a Blob store to persist action results with Netlify Blobconst actionStore = getStore("action-session");// If an action result was forwarded as a cookie, set the result// to be accessible from `Astro.getActionResult()`const sessionId = context.cookies.get("action-session-id")?.value;const session = sessionId? await actionStore.get(sessionId, {type: "json",}): undefined;if (session) {setActionResult(session.actionName, session.actionResult);// Optional: delete the session after the page is rendered.// Feel free to implement your own persistence strategyawait actionStore.delete(sessionId);context.cookies.delete("action-session-id");return next();}// If an action was called from an HTML form action,// call the action handler and redirect to the destination pageif (action?.calledFrom === "form") {const actionResult = await action.handler();// Persist the action result using session storageconst sessionId = randomUUID();await actionStore.setJSON(sessionId, {actionName: action.name,actionResult: serializeActionResult(actionResult),});// Pass the session ID as a cookie// to be retrieved after redirecting to the pagecontext.cookies.set("action-session-id", sessionId);// Redirect back to the previous page on errorif (actionResult.error) {const referer = context.request.headers.get("Referer");if (!referer) {throw newError("Internal: Referer unexpectedly missing from Action POST request.",);}return context.redirect(referer);}// Redirect to the destination page on successreturn context.redirect(context.originPathname);}return next();});
```


## Security when using actions


[Section titled Security when using actions](#security-when-using-actions)

Actions are accessible as public endpoints based on the name of the action. For example, the action `blog.like()` will be accessible from `/_actions/blog.like`. This is useful for unit testing action results and debugging production errors. However, this means you **must** use same authorization checks that you would consider for API endpoints and on-demand rendered pages.


### Authorize users from an action handler


[Section titled Authorize users from an action handler](#authorize-users-from-an-action-handler)

To authorize action requests, add an authentication check to your action handler. You may want to use [an authentication library](/en/guides/authentication/) to handle session management and user information.

Actions expose the full `APIContext` object to access properties passed from middleware using `context.locals`. When a user is not authorized, you can raise an `ActionError` with the `UNAUTHORIZED` code:

src/actions/index.ts

```
import { defineAction, ActionError } from'astro:actions';export const server = {getUserSettings: defineAction({handler: async (_input, context) => {if (!context.locals.user) {throw newActionError({ code: 'UNAUTHORIZED' });}return { /* data on success */ };}})}
```


### Gate actions from middleware


[Section titled Gate actions from middleware](#gate-actions-from-middleware)

**Added in:** `astro@5.0.0`

Astro recommends authorizing user sessions from your action handler to respect permission levels and rate-limiting on a per-action basis. However, you can also gate requests to all actions (or a subset of actions) from middleware.

Use the `getActionContext()` function from your middleware to retrieve information about any inbound action requests. This includes the action name and whether that action was called using a client-side remote procedure call (RPC) function (e.g. `actions.blog.like()`) or an HTML form.

The following example rejects all action requests that do not have a valid session token. If the check fails, a “Forbidden” response is returned. Note: this method ensures that actions are only accessible when a session is present, but is *not* a substitute for secure authorization.

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action } = getActionContext(context);// Check if the action was called from a client-side functionif (action?.calledFrom === 'rpc') {// If so, check for a user session tokenif (!context.cookies.has('user-session')) {return newResponse('Forbidden', { status: 403 });}}context.cookies.set('user-session', /* session token */);return next();});
```


## Call actions from Astro components and server endpoints


[Section titled Call actions from Astro components and server endpoints](#call-actions-from-astro-components-and-server-endpoints)

You can call actions directly from Astro component scripts using the `Astro.callAction()` wrapper (or `context.callAction()` when using a [server endpoint](/en/guides/endpoints/#server-endpoints-api-routes)). This is common to reuse logic from your actions in other server code.

Pass the action as the first argument and any input parameters as the second argument. This returns the same `data` and `error` objects you receive when calling actions on the client:

src/pages/products.astro

```
---import { actions } from'astro:actions';const searchQuery = Astro.url.searchParams.get('search');if (searchQuery) {const { data, error } = await Astro.callAction(actions.findProduct, { query: searchQuery });// handle result}---
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 12. `en/guides/astro-db/.md`

```text
# Astro DB


---
url: https://docs.astro.build/en/guides/astro-db/
description: Learn how to use Astro DB, a fully-managed SQL database designed exclusively for Astro.
---


# Astro DB


Astro DB is a fully-managed SQL database designed for the Astro ecosystem. Develop locally in Astro and deploy to any libSQL-compatible database.

Astro DB is a complete solution to configuring, developing, and querying your data. A local database is created in `.astro/content.db` whenever you run `astro dev` to manage your data without the need for Docker or a network connection.


## Installation


[Section titled Installation](#installation)

Install the [`@astrojs/db` integration](/en/guides/integrations-guide/db/) using the built-in `astro add` command:

-   [npm](#tab-panel-1767)
-   [pnpm](#tab-panel-1768)
-   [Yarn](#tab-panel-1769)

Terminal window

```
npxastroadddb
```

Terminal window

```
pnpmastroadddb
```

Terminal window

```
yarnastroadddb
```


## Define your database


[Section titled Define your database](#define-your-database)

Installing `@astrojs/db` with the `astro add` command will automatically create a `db/config.ts` file in your project where you will define your database tables:

db/config.ts

```
import { defineDb } from'astro:db';exportdefaultdefineDb({tables: { },})
```


### Tables


[Section titled Tables](#tables)

Data in Astro DB is stored using SQL tables. Tables structure your data into rows and columns, where columns enforce the type of each row value.

Define your tables in your `db/config.ts` file by providing the structure of the data in your existing libSQL database, or the data you will collect in a new database. This will allow Astro to generate a TypeScript interface to query that table from your project. The result is full TypeScript support when you access your data with property autocompletion and type-checking.

To configure a database table, import and use the `defineTable()` and `column` utilities from `astro:db`. Then, define a name (case-sensitive) for your table and the type of data in each column.

This example configures a `Comment` table with required text columns for `author` and `body`. Then, makes it available to your project through the `defineDb()` export.

db/config.ts

```
import { defineDb, defineTable, column } from'astro:db';const Comment = defineTable({columns: {author: column.text(),body: column.text(),}})exportdefaultdefineDb({tables: { Comment },})
```

See the [table configuration reference](/en/guides/integrations-guide/db/#table-configuration-reference) for a complete reference of table options.


### Columns


[Section titled Columns](#columns)

Astro DB supports the following column types:

db/config.ts

```
import { defineTable, column } from'astro:db';const Comment = defineTable({columns: {// A string of text.author: column.text(),// A whole integer value.likes: column.number(),// A true or false value.flagged: column.boolean(),// Date/time values queried as JavaScript Date objects.published: column.date(),// An untyped JSON object.metadata: column.json(),}});
```

See the [table columns reference](/en/guides/integrations-guide/db/#table-configuration-reference) for more details.


### Table References


[Section titled Table References](#table-references)

Relationships between tables are a common pattern in database design. For example, a `Blog` table may be closely related to other tables of `Comment`, `Author`, and `Category`.

You can define these relations between tables and save them into your database schema using **reference columns**. To establish a relationship, you will need:

-   An **identifier column** on the referenced table. This is usually an `id` column with the `primaryKey` property.
-   A column on the base table to **store the referenced `id`**. This uses the `references` property to establish a relationship.

This example shows a `Comment` table’s `authorId` column referencing an `Author` table’s `id` column.

db/config.ts

```
const Author = defineTable({columns: {id: column.number({ primaryKey: true }),name: column.text(),}});const Comment = defineTable({columns: {authorId: column.number({ references: () => Author.columns.id }),body: column.text(),}});
```


## Seed your database for development


[Section titled Seed your database for development](#seed-your-database-for-development)

In development, Astro will use your DB config to generate local types according to your schemas. These will be generated fresh from your seed file each time the dev server is started, and will allow you to query and work with the shape of your data with type safety and autocompletion.

You will not have access to production data during development unless you [connect to a remote database](#connecting-to-remote-databases) during development. This protects your data while allowing you to test and develop with a working database with type-safety.

To seed development data for testing and debugging into your Astro project, create a `db/seed.ts` file. Import both the `db` object and your tables defined in `astro:db`. `insert` some initial data into each table. This development data should match the form of both your database schema and production data.

The following example defines two rows of development data for a `Comment` table, and an `Author` table:

db/seed.ts

```
import { db, Comment, Author } from'astro:db';exportdefaultasyncfunction() {await db.insert(Author).values([{ id: 1, name: "Kasim" },{ id: 2, name: "Mina" },]);await db.insert(Comment).values([{ authorId: 1, body: 'Hope you like Astro DB!' },{ authorId: 2, body: 'Enjoy!'},])}
```

Your development server will automatically restart your database whenever this file changes, regenerating your types and seeding this development data from `seed.ts` fresh each time.


## Connect a libSQL database for production


[Section titled Connect a libSQL database for production](#connect-a-libsql-database-for-production)

Astro DB can connect to any local libSQL database or to any server that exposes the libSQL remote protocol, whether managed or self-hosted.

To connect Astro DB to a libSQL database, set the following environment variables obtained from your database provider:

-   `ASTRO_DB_REMOTE_URL`: the connection URL to the location of your local or remote libSQL DB. This may include [URL configuration options](#remote-url-configuration-options) such as sync and encryption as parameters.
-   `ASTRO_DB_APP_TOKEN`: the auth token to your libSQL server. This is required for remote databases, and not needed for [local DBs like files or in-memory](#url-scheme-and-host) databases

Depending on your service, you may have access to a CLI or web UI to retrieve these values. The following section will demonstrate connecting to Turso and setting these values as an example, but you are free to use any provider.


### Getting started with Turso


[Section titled Getting started with Turso](#getting-started-with-turso)

Turso is the company behind [libSQL](https://github.com/tursodatabase/libsql), the open-source fork of SQLite that powers Astro DB. They provide a fully managed libSQL database platform and are fully compatible with Astro.

The steps below will guide you through the process of installing the Turso CLI, logging in (or signing up), creating a new database, getting the required environmental variables, and pushing the schema to the remote database.

1.  Install the [Turso CLI](https://docs.turso.tech/cli/installation).

2.  [Log in or sign up](https://docs.turso.tech/cli/authentication) to Turso.

3.  Create a new database. In this example the database name is `andromeda`.

    Terminal window

    ```
    tursodbcreateandromeda
    ```

4.  Run the `show` command to see information about the newly created database:

    Terminal window

    ```
    tursodbshowandromeda
    ```

    Copy the `URL` value and set it as the value for `ASTRO_DB_REMOTE_URL`.

    .env

    ```
    ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
    ```

5.  Create a new token to authenticate requests to the database:

    Terminal window

    ```
    tursodbtokenscreateandromeda
    ```

    Copy the output of the command and set it as the value for `ASTRO_DB_APP_TOKEN`.

    .env

    ```
    ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.ioASTRO_DB_APP_TOKEN=eyJhbGciOiJF...3ahJpTkKDw
    ```

6.  Push your DB schema and metadata to the new Turso database.

    Terminal window

    ```
    astrodbpush--remote
    ```

7.  Congratulations, now you have a database connected! Give yourself a break. 👾

    Terminal window

    ```
    tursorelax
    ```


To explore more features of Turso, check out the [Turso docs](https://docs.turso.tech).


### Connecting to remote databases


[Section titled Connecting to remote databases](#connecting-to-remote-databases)

Astro DB allows you to connect to both local and remote databases. By default, Astro uses a local database file for `dev` and `build` commands, recreating tables and inserting development seed data each time.

To connect to a hosted remote database, use the `--remote` flag. This flag enables both readable and writable access to your remote database, allowing you to [accept and persist user data](#insert) in production environments.

Note

While remote connections are generally possible with any deployment platform using static or server rendering mode, there are currently some limitations. Non-Node runtimes like Cloudflare and Deno don’t currently support DB on server-rendered routes when using libSQL. Support for these platforms is planned for future implementation.

Configure your build command to use the `--remote` flag:

package.json

```
{"scripts": {"build": "astro build --remote"}}
```

You can also use the flag directly in the command line:

Terminal window

```

# Build with a remote connectionastrobuild--remote# Develop with a remote connectionastrodev--remote

```

Caution

Be careful when using `--remote` in development. This connects to your live production database, and all changes (inserts, updates, deletions) will be persisted.

The `--remote` flag uses the connection to the remote DB both locally during the build and on the server. Ensure you set the necessary environment variables in both your local development environment and your deployment platform.

When deploying your Astro DB project, make sure your deployment platform’s build command is set to `npm run build` (or the equivalent for your package manager) to utilize the `--remote` flag configured in your `package.json`.


### Remote URL configuration options


[Section titled Remote URL configuration options](#remote-url-configuration-options)

The `ASTRO_DB_REMOTE_URL` environment variable configures the location of your database as well as other options like sync and encryption.


#### URL scheme and host


[Section titled URL scheme and host](#url-scheme-and-host)

libSQL supports both HTTP and WebSockets as the transport protocol for a remote server. It also supports using a local file or an in-memory DB. Those can be configured using the following URL schemes in the connection URL:

-   `memory:` will use an in-memory DB. The host must be empty in this case.
-   `file:` will use a local file. The host is the path to the file (`file:path/to/file.db`).
-   `libsql:` will use a remote server through the protocol preferred by the library (this might be different across versions). The host is the address of the server (`libsql://your.server.io`).
-   `http:` will use a remote server through HTTP. `https:` can be used to enable a secure connection. The host is the same as for `libsql:`.
-   `ws:` will use a remote server through WebSockets. `wss:` can be used to enable a secure connection. The host is the same as for `libsql:`.

Details of the libSQL connection (e.g. encryption key, replication, sync interval) can be configured as query parameters in the remote connection URL.

For example, to have an encrypted local file work as an embedded replica to a libSQL server, you can set the following environment variables:

.env

```
ASTRO_DB_REMOTE_URL=file://local-copy.db?encryptionKey=your-encryption-key&syncInterval=60&syncUrl=libsql%3A%2F%2Fyour.server.ioASTRO_DB_APP_TOKEN=token-to-your-remote-url
```

Caution

Using a database file is an advanced feature, and care should be taken when deploying to prevent overriding your database and losing your production data.

Additionally, this method will not work in serverless deployments, as the file system is not persisted in those environments.


#### `encryptionKey`


[Section titled encryptionKey](#encryptionkey)

libSQL has native support for encrypted databases. Passing this search parameter will enable encryption using the given key:

.env

```
ASTRO_DB_REMOTE_URL=file:path/to/file.db?encryptionKey=your-encryption-key
```


#### `syncUrl`


[Section titled syncUrl](#syncurl)

Embedded replicas are a feature of libSQL clients that creates a full synchronized copy of your database on a local file or in memory for ultra-fast reads. Writes are sent to a remote database defined on the `syncUrl` and synchronized with the local copy.

Use this property to pass a separate connection URL to turn the database into an embedded replica of another database. This should only be used with the schemes `file:` and `memory:`. The parameter must be URL encoded.

For example, to have an in-memory embedded replica of a database on `libsql://your.server.io`, you can set the connection URL as such:

.env

```
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io
```


#### `syncInterval`


[Section titled syncInterval](#syncinterval)

Interval between embedded replica synchronizations in seconds. By default it only synchronizes on startup and after writes.

This property is only used when `syncUrl` is also set. For example, to set an in-memory embedded replica to synchronize every minute set the following environment variable:

.env

```
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io&syncInterval=60
```


## Query your database


[Section titled Query your database](#query-your-database)

You can query your database from any [Astro page](/en/basics/astro-pages/#astro-pages), [endpoint](/en/guides/endpoints/), or [action](/en/guides/actions/) in your project using the provided `db` ORM and query builder.


### Drizzle ORM


[Section titled Drizzle ORM](#drizzle-orm)

```
import { db } from'astro:db';
```

Astro DB includes a built-in [Drizzle ORM](https://orm.drizzle.team/) client. There is no setup or manual configuration required to use the client. The Astro DB `db` client is automatically configured to communicate with your database (local or remote) when you run Astro. It uses your exact database schema definition for type-safe SQL queries with TypeScript errors when you reference a column or table that doesn’t exist.


### Select


[Section titled Select](#select)

The following example selects all rows of a `Comment` table. This returns the complete array of seeded development data from `db/seed.ts` which is then available for use in your page template:

src/pages/index.astro

```
---import { db, Comment } from'astro:db';const comments = await db.select().from(Comment);---<h2>Comments</h2>{comments.map(({ author, body })=> (<article><p>Author: {author}</p><p>{body}</p></article>))}
```

See the [Drizzle `select()` API reference](https://orm.drizzle.team/docs/select) for a complete overview.


### Insert


[Section titled Insert](#insert)

To accept user input, such as handling form requests and inserting data into your remote hosted database, configure your Astro project for [on-demand rendering](/en/guides/on-demand-rendering/) and [add an adapter](/en/guides/on-demand-rendering/#add-an-adapter) for your deployment environment.

This example inserts a row into a `Comment` table based on a parsed form POST request:

src/pages/index.astro

```
---import { db, Comment } from'astro:db';if (Astro.request.method==='POST') {// Parse form dataconst formData = await Astro.request.formData();const author = formData.get('author');const body = formData.get('body');if (typeof author ==='string'&&typeof body ==='string') {// Insert form data into the Comment tableawait db.insert(Comment).values({ author, body });}}// Render the new list of comments on each requestconst comments = await db.select().from(Comment);---<formmethod="POST"style="display: grid"><labelfor="author">Author</label><inputid="author"name="author" /><labelfor="body">Body</label><textareaid="body"name="body"></textarea><buttontype="submit">Submit</button></form><!-- Render `comments` -->
```

You can also use [Astro actions](/en/guides/actions/) to insert data into an Astro DB table. The following example inserts a row into a `Comment` table using an action:

src/actions/index.ts

```
import { db, Comment } from'astro:db';import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {addComment: defineAction({// Actions include type safety with Zod, removing the need// to check if typeof {value} === 'string' in your pagesinput: z.object({author: z.string(),body: z.string(),}),handler: async (input) => {const updatedComments = await db.insert(Comment).values(input).returning(); // Return the updated commentsreturn updatedComments;},}),};
```

See the [Drizzle `insert()` API reference](https://orm.drizzle.team/docs/insert) for a complete overview.


### Delete


[Section titled Delete](#delete)

You can also query your database from an API endpoint. This example deletes a row from a `Comment` table by the `id` parameter:

src/pages/api/comments/\[id\].ts

```
importtype { APIRoute } from"astro";import { db, Comment, eq } from'astro:db';export const DELETE:APIRoute = async (ctx) => {await db.delete(Comment).where(eq(Comment.id, ctx.params.id));return newResponse(null, { status: 204 });}
```

See the [Drizzle `delete()` API reference](https://orm.drizzle.team/docs/delete) for a complete overview.


### Filtering


[Section titled Filtering](#filtering)

To query for table results by a specific property, use [Drizzle options for partial selects](https://orm.drizzle.team/docs/select#partial-select). For example, add [a `.where()` call](https://orm.drizzle.team/docs/select#filtering) to your `select()` query and pass the comparison you want to make.

The following example queries for all rows in a `Comment` table that contain the phrase “Astro DB.” Use [the `like()` operator](https://orm.drizzle.team/docs/operators#like) to check if a phrase is present within the `body`:

src/pages/index.astro

```
---import { db, Comment, like } from'astro:db';const comments = await db.select().from(Comment).where(like(Comment.body, '%Astro DB%'));---
```


### Drizzle utilities


[Section titled Drizzle utilities](#drizzle-utilities)

All Drizzle utilities for building queries are exposed from the `astro:db` module. This includes:

-   [Filter operators](https://orm.drizzle.team/docs/operators) like `eq()` and `gt()`
-   [Aggregation helpers](https://orm.drizzle.team/docs/select#aggregations-helpers) like `count()`
-   [The `sql` helper](https://orm.drizzle.team/docs/sql) for writing raw SQL queries

```
import { eq, gt, count, sql } from'astro:db';
```


### Relationships


[Section titled Relationships](#relationships)

You can query related data from multiple tables using a SQL join. To create a join query, extend your `db.select()` statement with a join operator. Each function accepts a table to join with and a condition to match rows between the two tables.

This example uses an `innerJoin()` function to join `Comment` authors with their related `Author` information based on the `authorId` column. This returns an array of objects with each `Author` and `Comment` row as top-level properties:

src/pages/index.astro

```
---import { db, eq, Comment, Author } from'astro:db';const comments = await db.select().from(Comment).innerJoin(Author, eq(Comment.authorId, Author.id));---<h2>Comments</h2>{comments.map(({ Author, Comment })=> (<article><p>Author: {Author.name}</p><p>{Comment.body}</p></article>))}
```

See the [Drizzle join reference](https://orm.drizzle.team/docs/joins#join-types) for all available join operators and config options.


### Batch Transactions


[Section titled Batch Transactions](#batch-transactions)

All remote database queries are made as a network request. You may need to “batch” queries together into a single transaction when making a large number of queries, or to have automatic rollbacks if any query fails.

This example seeds multiple rows in a single request using the `db.batch()` method:

db/seed.ts

```
import { db, Author, Comment } from'astro:db';exportdefaultasyncfunction() {const queries = [];// Seed 100 sample comments into your remote database// with a single network request.for (let i = 0; i <100; i++) {queries.push(db.insert(Comment).values({ body: `Test comment ${i}` }));}await db.batch(queries);}
```

See the [Drizzle `db.batch()`](https://orm.drizzle.team/docs/batch-api) docs for more details.


## Pushing changes to your database


[Section titled Pushing changes to your database](#pushing-changes-to-your-database)

You can push changes made during development to your database.


### Pushing table schemas


[Section titled Pushing table schemas](#pushing-table-schemas)

Your table schema may change over time as your project grows. You can safely test configuration changes locally and push to your remote database when you deploy.

You can push your local schema changes to your remote database via the CLI using the `astro db push --remote` command:

-   [npm](#tab-panel-1770)
-   [pnpm](#tab-panel-1771)
-   [Yarn](#tab-panel-1772)

Terminal window

```
npmrunastrodbpush--remote
```

Terminal window

```
pnpmastrodbpush--remote
```

Terminal window

```
yarnastrodbpush--remote
```

This command will verify that your local changes can be made without data loss and, if necessary, suggest how to safely make changes to your schema in order to resolve conflicts.


#### Pushing breaking schema changes


[Section titled Pushing breaking schema changes](#pushing-breaking-schema-changes)

Caution

**This will destroy your database**. Only perform this command if you do not need your production data.

If you must change your table schema in a way that is incompatible with your existing data hosted on your remote database, you will need to reset your production database.

To push a table schema update that includes a breaking change, add the `--force-reset` flag to reset all production data:

-   [npm](#tab-panel-1773)
-   [pnpm](#tab-panel-1774)
-   [Yarn](#tab-panel-1775)

Terminal window

```
npmrunastrodbpush--remote--force-reset
```

Terminal window

```
pnpmastrodbpush--remote--force-reset
```

Terminal window

```
yarnastrodbpush--remote--force-reset
```


### Renaming tables


[Section titled Renaming tables](#renaming-tables)

It is possible to rename a table after pushing your schema to your remote database.

If you **do not have any important production data**, then you can [reset your database](#pushing-breaking-schema-changes) using the `--force-reset` flag. This flag will drop all of the tables in the database and create new ones so that it matches your current schema exactly.

To rename a table while preserving your production data, you must perform a series of non-breaking changes to push your local schema to your remote database safely.

The following example renames a table from `Comment` to `Feedback`:

1.  In your database config file, add the `deprecated: true` property to the table you want to rename:

    db/config.ts

    ```
    const Comment = defineTable({deprecated: true,columns: {author: column.text(),body: column.text(),}});
    ```

2.  Add a new table schema (matching the existing table’s properties exactly) with the new name:

    db/config.ts

    ```
    const Comment = defineTable({deprecated: true,columns: {author: column.text(),body: column.text(),}});const Feedback = defineTable({columns: {author: column.text(),body: column.text(),}});
    ```

3.  [Push to your remote database](#pushing-table-schemas) with `astro db push --remote`. This will add the new table and mark the old as deprecated.

4.  Update any of your local project code to use the new table instead of the old table. You might need to migrate data to the new table as well.

5.  Once you are confident that the old table is no longer used in your project, you can remove the schema from your `config.ts`:

    db/config.ts

    ```
    const Comment = defineTable({deprecated: true,columns: {author: column.text(),body: column.text(),}});const Feedback = defineTable({columns: {author: column.text(),body: column.text(),}});
    ```

6.  Push to your remote database again with `astro db push --remote`. The old table will be dropped, leaving only the new, renamed table.



### Pushing table data


[Section titled Pushing table data](#pushing-table-data)

You may need to push data to your remote database for seeding or data migrations. You can author a `.ts` file with the `astro:db` module to write type-safe queries. Then, execute the file against your remote database using the command `astro db execute <file-path> --remote`:

The following Comments can be seeded using the command `astro db execute db/seed.ts --remote`:

db/seed.ts

```
import { Comment } from'astro:db';exportdefaultasyncfunction() {await db.insert(Comment).values([{ authorId: 1, body: 'Hope you like Astro DB!' },{ authorId: 2, body: 'Enjoy!' },])}
```

See the [CLI reference](/en/guides/integrations-guide/db/#astro-db-cli-reference) for a complete list of commands.


## Building Astro DB integrations


[Section titled Building Astro DB integrations](#building-astro-db-integrations)

[Astro integrations](/en/reference/integrations-reference/) can extend user projects with additional Astro DB tables and seed data.

Use the `extendDb()` method in the `astro:db:setup` hook to register additional Astro DB config and seed files. The `defineDbIntegration()` helper provides TypeScript support and auto-complete for the `astro:db:setup` hook.

my-integration/index.ts

```
import { defineDbIntegration } from'@astrojs/db/utils';exportdefaultfunctionMyIntegration() {returndefineDbIntegration({name: 'my-astro-db-powered-integration',hooks: {'astro:db:setup': ({ extendDb })=> {extendDb({configEntrypoint: '@astronaut/my-package/config',seedEntrypoint: '@astronaut/my-package/seed',});},// Other integration hooks...},});}
```

Integration [config](#define-your-database) and [seed](#seed-your-database-for-development) files follow the same format as their user-defined equivalents.


### Type safe operations in integrations


[Section titled Type safe operations in integrations](#type-safe-operations-in-integrations)

While working on integrations, you may not be able to benefit from Astro’s generated table types exported from `astro:db`. For full type safety, use the `asDrizzleTable()` utility to create a table reference object you can use for database operations.

For example, given an integration setting up the following `Pets` database table:

my-integration/config.ts

```
import { defineDb, defineTable, column } from'astro:db';export const Pets = defineTable({columns: {name: column.text(),species: column.text(),},});exportdefaultdefineDb({ tables: { Pets } });
```

The seed file can import `Pets` and use `asDrizzleTable()` to insert rows into your table with type checking:

my-integration/seed.ts

```
import { asDrizzleTable } from'@astrojs/db/utils';import { db } from'astro:db';import { Pets } from'./config';exportdefaultasyncfunction() {const typeSafePets = asDrizzleTable('Pets',Pets);awaitdb.insert(typeSafePets).values([{ name: 'Palomita', species: 'cat' },{ name: 'Pan', species: 'dog' },]);}
```

The value returned by `asDrizzleTable('Pets', Pets)` is equivalent to `import { Pets } from 'astro:db'`, but is available even when Astro’s type generation can’t run. You can use it in any integration code that needs to query or insert into the database.


## Migrate from Astro Studio to Turso


[Section titled Migrate from Astro Studio to Turso](#migrate-from-astro-studio-to-turso)

1.  In the [Studio dashboard](https://studio.astro.build/), navigate to the project you wish to migrate. In the settings tab, use the “Export Database” button to download a dump of your database.
2.  Follow the official instructions to [install the Turso CLI](https://docs.turso.tech/cli/installation) and [sign up or log in](https://docs.turso.tech/cli/authentication) to your Turso account.
3.  Create a new database on Turso using the `turso db create` command.

    Terminal window

    ```
    tursodbcreate [database-name]
    ```

4.  Fetch the database URL using the Turso CLI, and use it as the environment variable `ASTRO_DB_REMOTE_URL`.

    Terminal window

    ```
    tursodbshow [database-name]
    ```

    ```
    ASTRO_DB_REMOTE_URL=[your-database-url]
    ```

5.  Create a token to access your database, and use it as the environment variable `ASTRO_DB_APP_TOKEN`.

    Terminal window

    ```
    tursodbtokenscreate [database-name]
    ```

    ```
    ASTRO_DB_APP_TOKEN=[your-app-token]
    ```

6.  Push your DB schema and metadata to the new Turso database.

    Terminal window

    ```
    astrodbpush--remote
    ```

7.  Import the database dump from step 1 into your new Turso DB.

    Terminal window

    ```
    tursodbshell [database-name] < ./path/to/dump.sql
    ```

8.  Once you have confirmed your project connects to the new database, you can safely delete the project from Astro Studio.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 13. `en/guides/authentication/.md`

```text
# Authentication


---
url: https://docs.astro.build/en/guides/authentication/
description: An intro to authentication in Astro
---


# Authentication


Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor’s identity, while authorization grants access to protected areas and resources.

Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. [Auth.js](https://authjs.dev/), [Clerk](https://clerk.com)) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.

Tip

There is no official authentication solution for Astro, but you can find [community “auth” integrations](https://astro.build/integrations/?search=auth) in the integrations directory.

See how to [add authentication with Supabase](/en/guides/backend/supabase/#adding-authentication-with-supabase) or [add authentication with Firebase](/en/guides/backend/google-firebase/#adding-authentication-with-firebase) in our dedicated guides for these backend services.


## Auth.js


[Section titled Auth.js](#authjs)

Auth.js is a framework agnostic solution for authentication. A community framework adapter [`auth-astro`](https://www.npmjs.com/package/auth-astro) is available for Astro.


### Installation


[Section titled Installation](#installation)

Use the `astro add` command for your preferred package manager to add the `auth-astro` integration.

-   [npm](#tab-panel-1776)
-   [pnpm](#tab-panel-1777)
-   [Yarn](#tab-panel-1778)

Terminal window

```
npxastroaddauth-astro
```

Terminal window

```
pnpmastroaddauth-astro
```

Terminal window

```
yarnastroaddauth-astro
```


#### Manual installation


[Section titled Manual installation](#manual-installation)

To install `auth-astro` manually, install the required package for your package manager:

-   [npm](#tab-panel-1779)
-   [pnpm](#tab-panel-1780)
-   [Yarn](#tab-panel-1781)

Terminal window

```
npminstallauth-astro@auth/core@^0.18.6
```

Terminal window

```
pnpmaddauth-astro@auth/core@^0.18.6
```

Terminal window

```
yarnaddauth-astro@auth/core@^0.18.6
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import auth from'auth-astro';exportdefaultdefineConfig({// ...integrations: [auth()],});
```


### Configuration


[Section titled Configuration](#configuration)

Create an `auth.config.ts` file in your project’s root directory. Add any auth [providers](https://authjs.dev/getting-started/providers) or methods you wish to support, along with any environment variables they require.

auth.config.ts

```
import GitHub from'@auth/core/providers/github';import { defineConfig } from'auth-astro';exportdefaultdefineConfig({providers: [GitHub({clientId: import.meta.env.GITHUB_CLIENT_ID,clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,}),],});
```

Create a `.env` file in the root of your project if it does not already exist. Add the following two environment variables. `AUTH_SECRET` should be a private string with a minimum of 32 characters.

.env

```
AUTH_TRUST_HOST=trueAUTH_SECRET=<my-auth-secret>
```


### Usage


[Section titled Usage](#usage)

You can add sign-in and sign-out buttons using the `auth-astro/client` module in a script tag or client-side framework component.

src/pages/index.astro

```
---import Layout from'src/layouts/Base.astro';---<Layout><buttonid="login">Login</button><buttonid="logout">Logout</button><script>const { signIn, signOut } = await import("auth-astro/client")document.querySelector("#login").onclick=()=>signIn("github")document.querySelector("#logout").onclick=()=>signOut()</script></Layout>
```

You can fetch the user’s session using the `getSession` method.

src/pages/index.astro

```
---import Layout from'src/layouts/Base.astro';import { getSession } from'auth-astro/server';const session = await getSession(Astro.request);---<Layout>{session ? (<p>Welcome {session.user?.name}</p>) : (<p>Not logged in</p>)}</Layout>
```


### Next Steps


[Section titled Next Steps](#next-steps)

-   [`auth-astro` on GitHub](https://github.com/nowaythatworked/auth-astro?tab=readme-ov-file#auth-astro)
-   [Auth.js documentation](https://authjs.dev/)


## Better Auth


[Section titled Better Auth](#better-auth)

Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.

It supports Astro out of the box, and you can use it to add authentication to your astro project.


### Installation


[Section titled Installation](#installation-1)

-   [npm](#tab-panel-1782)
-   [pnpm](#tab-panel-1783)
-   [Yarn](#tab-panel-1784)

Terminal window

```
npminstallbetter-auth
```

Terminal window

```
pnpmaddbetter-auth
```

Terminal window

```
yarnaddbetter-auth
```

For detailed setup instructions, check out the [Better Auth Installation Guide](https://www.better-auth.com/docs/installation).


### Configuration


[Section titled Configuration](#configuration-1)

Configure your database table to store user data and your preferred authentication methods as described in the [Better Auth Installation Guide](https://www.better-auth.com/docs/installation#configure-database). Then, you’ll need to mount the Better Auth handler in your Astro project.

src/pages/api/auth/\[...all\].ts

```
import { auth } from"../../../lib/auth"; // import your Better Auth instanceimporttype { APIRoute } from"astro";export const ALL:APIRoute = async (ctx) => {return auth.handler(ctx.request);};
```

Follow the [Better Auth Astro Guide](https://www.better-auth.com/docs/integrations/astro) to learn more.


### Usage


[Section titled Usage](#usage-1)

Better Auth offers a `createAuthClient` helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.

For example, to create a client for React, import the helper from `'better-auth/react'`:

-   [React](#tab-panel-1788)
-   [Solid](#tab-panel-1789)
-   [Svelte](#tab-panel-1790)
-   [Vue](#tab-panel-1791)

src/lib/auth-client.ts

```
import { createAuthClient } from'better-auth/react';export const authClient = createAuthClient();export const { signIn, signOut } = authClient;
```

src/lib/auth-client.ts

```
import { createAuthClient } from'better-auth/solid';export const authClient = createAuthClient();export const { signIn, signOut } = authClient;
```

src/lib/auth-client.ts

```
import { createAuthClient } from'better-auth/svelte';export const authClient = createAuthClient();export const { signIn, signOut } = authClient;
```

src/lib/auth-client.ts

```
import { createAuthClient } from'better-auth/vue';export const authClient = createAuthClient();export const { signIn, signOut } = authClient;
```

Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured `signIn()` and `signOut()` functions.

src/pages/index.astro

```
---import Layout from'src/layouts/Base.astro';---<Layout><buttonid="login">Login</button><buttonid="logout">Logout</button><script>const { signIn, signOut } = await import("./lib/auth-client")document.querySelector("#login").onclick=()=>signIn.social({provider: "github",callbackURL: "/dashboard",})document.querySelector("#logout").onclick=()=>signOut()</script></Layout>
```

You can then use the `auth` object to get the user’s session data in your server-side code. The following example personalizes page content by displaying an authenticated user’s name:

src/pages/index.astro

```
---import { auth } from"../../../lib/auth"; // import your Better Auth instanceconst session = await auth.api.getSession({headers: Astro.request.headers,});---<p>{session.user?.name}</p>
```

You can also use the `auth` object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashboard route is authenticated, and redirects them to the home page if not.

src/middleware.ts

```
import { auth } from"../../../auth"; // import your Better Auth instanceimport { defineMiddleware } from"astro:middleware";export const onRequest = defineMiddleware(async (context, next) => {const isAuthed = await auth.api.getSession({headers: context.request.headers,})if (context.url.pathname === "/dashboard" && !isAuthed) {return context.redirect("/");}return next();});
```


### Next Steps


[Section titled Next Steps](#next-steps-1)

-   [Better Auth Astro Guide](https://www.better-auth.com/docs/integrations/astro)
-   [Better Auth Astro Example](https://github.com/better-auth/better-auth/tree/main/examples/astro-example)
-   [Better Auth Documentation](https://www.better-auth.com/docs)
-   [Better Auth GitHub Repository](https://github.com/better-auth/better-auth)


## Clerk


[Section titled Clerk](#clerk)

Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An [official Clerk SDK for Astro](https://clerk.com/docs/references/astro/overview) is available.


### Installation


[Section titled Installation](#installation-2)

Install `@clerk/astro` using the package manager of your choice.

-   [npm](#tab-panel-1785)
-   [pnpm](#tab-panel-1786)
-   [Yarn](#tab-panel-1787)

Terminal window

```
npminstall@clerk/astro
```

Terminal window

```
pnpmadd@clerk/astro
```

Terminal window

```
yarnadd@clerk/astro
```


### Configuration


[Section titled Configuration](#configuration-2)

Follow [Clerk’s own Astro Quickstart guide](https://clerk.com/docs/quickstarts/astro) to set up Clerk integration and middleware in your Astro project.


### Usage


[Section titled Usage](#usage-2)

Clerk provides components that allow you to control the visibility of pages based on your user’s authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:

src/pages/index.astro

```
---import Layout from'src/layouts/Base.astro';import { SignedIn, SignedOut, UserButton, SignInButton } from'@clerk/astro/components';---<Layout><SignedIn><UserButton /></SignedIn><SignedOut><SignInButton /></SignedOut></Layout>
```

Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:

src/middleware.ts

```
import { clerkMiddleware, createRouteMatcher } from'@clerk/astro/server';const isProtectedRoute = createRouteMatcher(['/dashboard(.*)','/forum(.*)',]);export const onRequest = clerkMiddleware((auth, context) => {if (!auth().userId && isProtectedRoute(context.request)) {return auth().redirectToSignIn();}});
```


### Next Steps


[Section titled Next Steps](#next-steps-2)

-   Read the [official `@clerk/astro` documentation](https://clerk.com/docs/references/astro/overview)
-   Start from a template with the [Clerk + Astro Quickstart project](https://github.com/clerk/clerk-astro-quickstart)


## Lucia


[Section titled Lucia](#lucia)

[Lucia](https://lucia-auth.com/) is a resource for implementing session-based authentication in a number of frameworks, including Astro.


### Guides


[Section titled Guides](#guides)

1.  Create a [basic sessions API](https://lucia-auth.com/sessions/basic-api/) with your chosen database.
2.  Add [session cookies](https://lucia-auth.com/sessions/cookies/astro) using endpoints and middleware.
3.  Implement [GitHub OAuth](https://lucia-auth.com/tutorials/github-oauth/astro) using the APIs you implemented.


### Examples


[Section titled Examples](#examples)

-   [GitHub OAuth example in Astro](https://github.com/lucia-auth/example-astro-github-oauth)
-   [Google OAuth example in Astro](https://github.com/lucia-auth/example-astro-google-oauth)
-   [Email and password example with 2FA in Astro](https://github.com/lucia-auth/example-astro-email-password-2fa)
-   [Email and password example with 2FA and WebAuthn in Astro](https://github.com/lucia-auth/example-astro-email-password-webauthn)


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App](https://agramont.net/blog/entra-id-easyauth-with-astro/)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 14. `en/guides/backend/.md`

```text
# Use a backend service with Astro


---
url: https://docs.astro.build/en/guides/backend/
description: How to use a backend service to add authentication, storage and data
---


# Use a backend service with Astro


**Ready to add features like authentication, monitoring, storage, or data to your Astro project?** Follow one of our guides to integrate a backend service.

Tip

Find [community-maintained integrations](https://astro.build/integrations/) for adding popular features to your project in our integrations directory.


## Backend service guides


[Section titled Backend service guides](#backend-service-guides)

Note that many of these pages are **stubs**: they’re collections of resources waiting for your contribution!

-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)



## What is a backend service?


[Section titled What is a backend service?](#what-is-a-backend-service)

A backend service is a cloud-based system that helps you build and manage your backend infrastructure. It provides a set of tools and services for managing databases, user authentication, and other server-side functionality. This enables you to focus on building your applications without having to worry about managing the underlying infrastructure.


## Why would I use a backend service?


[Section titled Why would I use a backend service?](#why-would-i-use-a-backend-service)

You might want to consider a backend service if your project has complex server-side needs, for example:

-   user sign-ups and authentication
-   persistent data storage
-   user-uploaded asset storage
-   API generation
-   realtime communication
-   application monitoring

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 15. `en/guides/backend/appwriteio/.md`

```text
# Appwrite & Astro


---
url: https://docs.astro.build/en/guides/backend/appwriteio/
description: Add a backend to your project with Appwrite
---


# Appwrite & Astro


[Appwrite](https://appwrite.io/) is a self-hosted backend-as-a-service platform that provides authentication and account management, user preferences, database and storage persistence, cloud functions, localization, image manipulation, and other server-side utilities.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Appwrite Demos for Astro](https://github.com/appwrite/demos-for-astro)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 16. `en/guides/backend/google-firebase/.md`

```text
# Firebase & Astro


---
url: https://docs.astro.build/en/guides/backend/google-firebase/
description: Add a backend to your project with Firebase
---


# Firebase & Astro


[Firebase](https://firebase.google.com/) is an app development platform that provides a NoSQL database, authentication, realtime subscriptions, functions, and storage.

See our separate guide for [deploying to Firebase hosting](/en/guides/deploy/google-firebase/).


## Initializing Firebase in Astro


[Section titled Initializing Firebase in Astro](#initializing-firebase-in-astro)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A [Firebase project with a web app configured](https://firebase.google.com/docs/web/setup).
-   An Astro project with [`output: 'server'` for on-demand rendering](/en/guides/on-demand-rendering/) enabled.
-   Firebase credentials: You will need two sets of credentials to connect Astro to Firebase:
    -   Web app credentials: These credentials will be used by the client side of your app. You can find them in the Firebase console under *Project settings > General*. Scroll down to the **Your apps** section and click on the **Web app** icon.
    -   Project credentials: These credentials will be used by the server side of your app. You can generate them in the Firebase console under *Project settings > Service accounts > Firebase Admin SDK > Generate new private key*.


### Adding Firebase credentials


[Section titled Adding Firebase credentials](#adding-firebase-credentials)

To add your Firebase credentials to Astro, create an `.env` file in the root of your project with the following variables:

.env

```
FIREBASE_PRIVATE_KEY_ID=YOUR_PRIVATE_KEY_IDFIREBASE_PRIVATE_KEY=YOUR_PRIVATE_KEYFIREBASE_PROJECT_ID=YOUR_PROJECT_IDFIREBASE_CLIENT_EMAIL=YOUR_CLIENT_EMAILFIREBASE_CLIENT_ID=YOUR_CLIENT_IDFIREBASE_AUTH_URI=YOUR_AUTH_URIFIREBASE_TOKEN_URI=YOUR_TOKEN_URIFIREBASE_AUTH_CERT_URL=YOUR_AUTH_CERT_URLFIREBASE_CLIENT_CERT_URL=YOUR_CLIENT_CERT_URL
```

Now, these environment variables are available for use in your project.

If you would like to have IntelliSense for your Firebase environment variables, edit or create the file `env.d.ts` in your `src/` directory and configure your types:

src/env.d.ts

```
interface ImportMetaEnv {readonly FIREBASE_PRIVATE_KEY_ID:string;readonly FIREBASE_PRIVATE_KEY:string;readonly FIREBASE_PROJECT_ID:string;readonly FIREBASE_CLIENT_EMAIL:string;readonly FIREBASE_CLIENT_ID:string;readonly FIREBASE_AUTH_URI:string;readonly FIREBASE_TOKEN_URI:string;readonly FIREBASE_AUTH_CERT_URL:stringreadonly FIREBASE_CLIENT_CERT_URL:string;}interface ImportMeta {readonly env:ImportMetaEnv;}
```

Tip

Read more about [environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your project should now include these new files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect Astro with Firebase, install the following packages using the single command below for your preferred package manager:

-   `firebase` - the Firebase SDK for the client side
-   `firebase-admin` - the Firebase Admin SDK for the server side

-   [npm](#tab-panel-3042)
-   [pnpm](#tab-panel-3043)
-   [Yarn](#tab-panel-3044)

Terminal window

```
npminstallfirebasefirebase-admin
```

Terminal window

```
pnpmaddfirebasefirebase-admin
```

Terminal window

```
yarnaddfirebasefirebase-admin
```

Next, create a folder named `firebase` in the `src/` directory and add two new files to this folder: `client.ts` and `server.ts`.

In `client.ts`, add the following code to initialize Firebase in the client using your web app credentials and the `firebase` package:

src/firebase/client.ts

```
import { initializeApp } from"firebase/app";const firebaseConfig = {apiKey: "my-public-api-key",authDomain: "my-auth-domain",projectId: "my-project-id",storageBucket: "my-storage-bucket",messagingSenderId: "my-sender-id",appId: "my-app-id",};export const app = initializeApp(firebaseConfig);
```

Note

Remember to replace the `firebaseConfig` object with your own web app credentials.

In `server.ts`, add the following code to initialize Firebase in the server using your project credentials and the `firebase-admin` package:

src/firebase/server.ts

```
importtype { ServiceAccount } from"firebase-admin";import { initializeApp, cert, getApps } from"firebase-admin/app";const activeApps = getApps();const serviceAccount = {type: "service_account",project_id: import.meta.env.FIREBASE_PROJECT_ID,private_key_id: import.meta.env.FIREBASE_PRIVATE_KEY_ID,private_key: import.meta.env.FIREBASE_PRIVATE_KEY,client_email: import.meta.env.FIREBASE_CLIENT_EMAIL,client_id: import.meta.env.FIREBASE_CLIENT_ID,auth_uri: import.meta.env.FIREBASE_AUTH_URI,token_uri: import.meta.env.FIREBASE_TOKEN_URI,auth_provider_x509_cert_url: import.meta.env.FIREBASE_AUTH_CERT_URL,client_x509_cert_url: import.meta.env.FIREBASE_CLIENT_CERT_URL,};const initApp = () => {if (import.meta.env.PROD) {console.info('PROD env detected. Using default service account.')// Use default config in firebase functions. Should be already injected in the server by Firebase.return initializeApp()}console.info('Loading service account from env.')return initializeApp({credential: cert(serviceAccount as ServiceAccount)})}export const app = activeApps.length === 0 ? initApp() : activeApps[0];
```

Note

Remember to replace the `serviceAccount` object with your own project credentials.

Finally, your project should now include these new files:

-   Directorysrc

    -   env.d.ts
    -   Directoryfirebase

        -   **client.ts**
        -   **server.ts**


-   .env
-   astro.config.mjs
-   package.json


## Adding authentication with Firebase


[Section titled Adding authentication with Firebase](#adding-authentication-with-firebase)


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

-   An Astro project [initialized with Firebase](#initializing-firebase-in-astro).
-   A Firebase project with email/password authentication enabled in the Firebase console under *Authentication > Sign-in* method.


### Creating auth server endpoints


[Section titled Creating auth server endpoints](#creating-auth-server-endpoints)

Firebase authentication in Astro requires the following three [Astro server endpoints](/en/guides/endpoints/):

-   `GET /api/auth/signin` - to sign in a user
-   `GET /api/auth/signout` - to sign out a user
-   `POST /api/auth/register` - to register a user

Create three endpoints related to authentication in a new directory `src/pages/api/auth/`: `signin.ts`, `signout.ts` and `register.ts`.

`signin.ts` contains the code to sign in a user using Firebase:

src/pages/api/auth/signin.ts

```
importtype { APIRoute } from"astro";import { app } from"../../../firebase/server";import { getAuth } from"firebase-admin/auth";export const GET:APIRoute = async ({ request, cookies, redirect }) => {const auth = getAuth(app);/* Get token from request headers */const idToken = request.headers.get("Authorization")?.split("Bearer ")[1];if (!idToken) {return newResponse("No token found",{ status: 401 });}/* Verify id token */try {await auth.verifyIdToken(idToken);} catch (error) {return newResponse("Invalid token",{ status: 401 });}/* Create and set session cookie */const fiveDays = 60 * 60 * 24 * 5 * 1000;const sessionCookie = await auth.createSessionCookie(idToken, {expiresIn: fiveDays,});cookies.set("__session", sessionCookie, {path: "/",});return redirect("/dashboard");};
```

Caution

Firebase only allows the use of [one cookie, and it must be named `__session`](https://firebase.google.com/docs/hosting/manage-cache#using_cookies). Any other cookies the client sends will not be visible to your application.

Note

This is a basic implementation of the signin endpoint. You can add more logic to this endpoint to suit your needs.

`signout.ts` contains the code to log out a user by deleting the session cookie:

src/pages/api/auth/signout.ts

```
importtype { APIRoute } from"astro";export const GET:APIRoute = async ({ redirect, cookies }) => {cookies.delete("__session", {path: "/",});return redirect("/signin");};
```

Note

This is a basic implementation of the signout endpoint. You can add more logic to this endpoint to suit your needs.

`register.ts` contains the code to register a user using Firebase:

src/pages/api/auth/register.ts

```
importtype { APIRoute } from"astro";import { getAuth } from"firebase-admin/auth";import { app } from"../../../firebase/server";export const POST:APIRoute = async ({ request, redirect }) => {const auth = getAuth(app);/* Get form data */const formData = await request.formData();const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();const name = formData.get("name")?.toString();if (!email | !password | !name) {return newResponse("Missing form data",{ status: 400 });}/* Create user */try {await auth.createUser({email,password,displayName: name,});} catch (error:any) {return newResponse("Something went wrong",{ status: 400 });}return redirect("/signin");};
```

Note

This is a basic implementation of the register endpoint. You can add more logic to this endpoint to suit your needs.

After creating server endpoints for authentication, your project directory should now include these new files:

-   Directorysrc

    -   env.d.ts
    -   Directoryfirebase

        -   client.ts
        -   server.ts

    -   Directorypages

        -   Directoryapi

            -   Directoryauth

                -   **signin.ts**
                -   **signout.ts**
                -   **register.ts**




-   .env
-   astro.config.mjs
-   package.json


### Creating pages


[Section titled Creating pages](#creating-pages)

Create the pages that will use the Firebase endpoints:

-   `src/pages/register` - will contain a form to register a user
-   `src/pages/signin` - will contain a form to sign in a user
-   `src/pages/dashboard` - will contain a dashboard that can only be accessed by authenticated users

The example `src/pages/register.astro` below includes a form that will send a `POST` request to the `/api/auth/register` endpoint. This endpoint will create a new user using the data from the form and then will redirect the user to the `/signin` page.

src/pages/register.astro

```
---import Layout from"../layouts/Layout.astro";---<Layouttitle="Register"><h1>Register</h1><p>Already have an account? <ahref="/signin">Sign in</a></p><formaction="/api/auth/register"method="post"><labelfor="name">Name</label><inputtype="text"name="name"id="name" /><labelfor="email"for="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Login</button></form></Layout>
```

`src/pages/signin.astro` uses the Firebase server app to verify the user’s session cookie. If the user is authenticated, the page will redirect the user to the `/dashboard` page.

The example page below contains a form that will send a `POST` request to the `/api/auth/signin` endpoint with the ID token generated by the Firebase client app.

The endpoint will verify the ID token and create a new session cookie for the user. Then, the endpoint will redirect the user to the `/dashboard` page.

src/pages/signin.astro

```
---import { app } from"../firebase/server";import { getAuth } from"firebase-admin/auth";import Layout from"../layouts/Layout.astro";/* Check if the user is authenticated */const auth = getAuth(app);if (Astro.cookies.has("__session")) {const sessionCookie = Astro.cookies.get("__session")!.value;const decodedCookie = await auth.verifySessionCookie(sessionCookie);if (decodedCookie) {return Astro.redirect("/dashboard");}}---<Layouttitle="Sign in"><h1>Sign in</h1><p>New here? <ahref="/register">Create an account</a></p><formaction="/api/auth/signin"method="post"><labelfor="email"for="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Login</button></form></Layout><script>import {getAuth,inMemoryPersistence,signInWithEmailAndPassword,} from"firebase/auth";import { app } from"../firebase/client";const auth = getAuth(app);// This will prevent the browser from storing session dataauth.setPersistence(inMemoryPersistence);const form = document.querySelector("form") as HTMLFormElement;form.addEventListener("submit", async(e)=> {e.preventDefault();const formData = newFormData(form);const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();if (!email|!password) {return;}const userCredential = await signInWithEmailAndPassword(auth,email,password);const idToken = await userCredential.user.getIdToken();const response = await fetch("/api/auth/signin", {method: "GET",headers: {Authorization: `Bearer ${idToken}`,},});if (response.redirected) {window.location.assign(response.url);}});</script>
```

`src/pages/dashboard.astro` will verify the user’s session cookie using the Firebase server app. If the user is not authenticated, the page will redirect the user to the `/signin` page.

The example page below display the user’s name and a button to sign out. Clicking the button will send a `GET` request to the `/api/auth/signout` endpoint.

The endpoint will delete the user’s session cookie and redirect the user to the `/signin` page.

src/pages/dashboard.astro

```
---import { app } from"../firebase/server";import { getAuth } from"firebase-admin/auth";import Layout from"../layouts/Layout.astro";const auth = getAuth(app);/* Check current session */if (!Astro.cookies.has("__session")) {return Astro.redirect("/signin");}const sessionCookie = Astro.cookies.get("__session")!.value;const decodedCookie = await auth.verifySessionCookie(sessionCookie);const user = await auth.getUser(decodedCookie.uid);if (!user) {return Astro.redirect("/signin");}---<Layouttitle="dashboard"><h1>Welcome {user.displayName}</h1><p>We are happy to see you here</p><formaction="/api/auth/signout"><buttontype="submit">Sign out</button></form></Layout>
```


### Adding OAuth providers


[Section titled Adding OAuth providers](#adding-oauth-providers)

To add OAuth providers to your app, you need to enable them in the Firebase console.

In the Firebase console, go to the **Authentication** section and click on the **Sign-in method** tab. Then, click on the **Add a new provider** button and enable the providers you want to use.

The example below uses the **Google** provider.

Edit the `signin.astro` page to add:

-   a button to sign in with Google underneath the existing form
-   an event listener on the button to handle the sign in process in the existing `<script>`.

src/pages/signin.astro

```
---import { app } from"../firebase/server";import { getAuth } from"firebase-admin/auth";import Layout from"../layouts/Layout.astro";/* Check if the user is authenticated */const auth = getAuth(app);if (Astro.cookies.has("__session")) {const sessionCookie = Astro.cookies.get("__session")!.value;const decodedCookie = await auth.verifySessionCookie(sessionCookie);if (decodedCookie) {return Astro.redirect("/dashboard");}}---<Layouttitle="Sign in"><h1>Sign in</h1><p>New here? <ahref="/register">Create an account</a></p><formaction="/api/auth/signin"method="post"><labelfor="email"for="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Login</button></form><buttonid="google">Sign in with Google</button></Layout><script>import {getAuth,inMemoryPersistence,signInWithEmailAndPassword,GoogleAuthProvider,signInWithPopup,} from"firebase/auth";import { app } from"../firebase/client";const auth = getAuth(app);auth.setPersistence(inMemoryPersistence);const form = document.querySelector("form") as HTMLFormElement;form.addEventListener("submit", async(e)=> {e.preventDefault();const formData = newFormData(form);const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();if (!email|!password) {return;}const userCredential = await signInWithEmailAndPassword(auth,email,password);const idToken = await userCredential.user.getIdToken();const response = await fetch("/api/auth/signin", {headers: {Authorization: `Bearer ${idToken}`,},});if (response.redirected) {window.location.assign(response.url);}});const googleSignin = document.querySelector("#google") as HTMLButtonElement;googleSignin.addEventListener("click", async()=> {const provider = newGoogleAuthProvider();const userCredential = await signInWithPopup(auth, provider);const idToken = await userCredential.user.getIdToken();const res = await fetch("/api/auth/signin", {headers: {Authorization: `Bearer ${idToken}`,},});if (res.redirected) {window.location.assign(res.url);}});</script>
```

When clicked, the Google sign in button will open a popup window to sign in with Google. Once the user signs in, it will send a `POST` request to the `/api/auth/signin` endpoint with the ID token generated by OAuth provider.

The endpoint will verify the ID token and create a new session cookie for the user. Then, the endpoint will redirect the user to the `/dashboard` page.


## Connecting to Firestore database


[Section titled Connecting to Firestore database](#connecting-to-firestore-database)


### Prerequisites


[Section titled Prerequisites](#prerequisites-2)

-   An Astro project initialized with Firebase as described in the [Initializing Firebase in Astro](#initializing-firebase-in-astro) section.

-   A Firebase project with a Firestore database. You can follow the [Firebase documentation to create a new project and set up a Firestore database](https://firebase.google.com/docs/firestore/quickstart).


In this recipe, the Firestore collection will be called **friends** and will contain documents with the following fields:

-   `id`: autogenerated by Firestore
-   `name`: a string field
-   `age`: a number field
-   `isBestFriend`: a boolean field


### Creating the server endpoints


[Section titled Creating the server endpoints](#creating-the-server-endpoints)

Create two new files in a new directory `src/pages/api/friends/`: `index.ts` and `[id].ts`. These will create two server endpoints to interact with the Firestore database in the following ways:

-   `POST /api/friends`: to create a new document in the friends collection.
-   `POST /api/friends/:id`: to update a document in the friends collection.
-   `DELETE /api/friends/:id`: to delete a document in the friends collection.

`index.ts` will contain the code to create a new document in the friends collection:

src/pages/api/friends/index.ts

```
importtype { APIRoute } from"astro";import { app } from"../../../firebase/server";import { getFirestore } from"firebase-admin/firestore";export const POST:APIRoute = async ({ request, redirect }) => {const formData = await request.formData();const name = formData.get("name")?.toString();const age = formData.get("age")?.toString();const isBestFriend = formData.get("isBestFriend") === "on";if (!name | !age) {return newResponse("Missing required fields", {status: 400,});}try {const db = getFirestore(app);const friendsRef = db.collection("friends");await friendsRef.add({name,age: parseInt(age),isBestFriend,});} catch (error) {return newResponse("Something went wrong", {status: 500,});}return redirect("/dashboard");};
```

Note

This is a basic implementation of the `friends` endpoint. You can add more logic to this endpoint to suit your needs.

`[id].ts` will contain the code to update and delete a document in the friends collection:

src/pages/api/friends/\[id\].ts

```
importtype { APIRoute } from"astro";import { app } from"../../../firebase/server";import { getFirestore } from"firebase-admin/firestore";const db = getFirestore(app);const friendsRef = db.collection("friends");export const POST:APIRoute = async ({ params, redirect, request }) => {const formData = await request.formData();const name = formData.get("name")?.toString();const age = formData.get("age")?.toString();const isBestFriend = formData.get("isBestFriend") === "on";if (!name | !age) {return newResponse("Missing required fields", {status: 400,});}if (!params.id) {return newResponse("Cannot find friend", {status: 404,});}try {await friendsRef.doc(params.id).update({name,age: parseInt(age),isBestFriend,});} catch (error) {return newResponse("Something went wrong", {status: 500,});}return redirect("/dashboard");};export const DELETE:APIRoute = async ({ params, redirect }) => {if (!params.id) {return newResponse("Cannot find friend", {status: 404,});}try {await friendsRef.doc(params.id).delete();} catch (error) {return newResponse("Something went wrong", {status: 500,});}return redirect("/dashboard");};
```

Note

This is a basic implementation of the `friends/:id` endpoint. You can add more logic to this endpoint to suit your needs.

After creating server endpoints for Firestore, your project directory should now include these new files:

-   Directorysrc

    -   env.d.ts
    -   Directoryfirebase

        -   client.ts
        -   server.ts

    -   Directorypages

        -   Directoryapi

            -   Directoryfriends

                -   **index.ts**
                -   **\[id\].ts**




-   .env
-   astro.config.mjs
-   package.json


### Creating pages


[Section titled Creating pages](#creating-pages-1)

Create the pages that will use the Firestore endpoints:

-   `src/pages/add.astro` - will contain a form to add a new friend.
-   `src/pages/edit/[id].astro` - will contain a form to edit a friend and a button to delete a friend.
-   `src/pages/friend/[id].astro` - will contain the details of a friend.
-   `src/pages/dashboard.astro` - will display a list of friends.


#### Add a new record


[Section titled Add a new record](#add-a-new-record)

The example `src/pages/add.astro` below includes a form that will send a `POST` request to the `/api/friends` endpoint. This endpoint will create a new friend using the data from the form and then will redirect the user to the `/dashboard` page.

src/pages/add.astro

```
---import Layout from"../layouts/Layout.astro";---<Layouttitle="Add a new friend"><h1>Add a new friend</h1><formmethod="post"action="/api/friends"><labelfor="name">Name</label><inputtype="text"id="name"name="name" /><labelfor="age">Age</label><inputtype="number"id="age"name="age" /><labelfor="isBestFriend">Is best friend?</label><inputtype="checkbox"id="isBestFriend"name="isBestFriend" /><buttontype="submit">Add friend</button></form></Layout>
```


#### Edit or Delete a record


[Section titled Edit or Delete a record](#edit-or-delete-a-record)

`src/pages/edit/[id].astro` will contain a form to edit a friend data and a button to delete a friend. On submit, this page will send a `POST` request to the `/api/friends/:id` endpoint to update a friend data.

If the user clicks the delete button, this page will send a `DELETE` request to the `/api/friends/:id` endpoint to delete a friend.

src/pages/edit/\[id\].astro

```
---import Layout from"../../layouts/Layout.astro";import { app } from"../../firebase/server";import { getFirestore } from"firebase-admin/firestore";interface Friend {name:string;age:number;isBestFriend:boolean;}const { id } = Astro.params;if (!id) {return Astro.redirect("/404");}const db = getFirestore(app);const friendsRef = db.collection("friends");const friendSnapshot = await friendsRef.doc(id).get();if (!friendSnapshot.exists) {return Astro.redirect("/404");}const friend = friendSnapshot.data() as Friend;---<Layouttitle="Edit {friend.name}"><h1>Edit {friend.name}</h1><p>Here you can edit or delete your friend's data.</p><formmethod="post"action={`/api/friends/${id}`}><labelfor="name">Name</label><inputtype="text"id="name"name="name"value={friend.name} /><labelfor="age">Age</label><inputtype="number"id="age"name="age"value={friend.age} /><labelfor="isBestFriend">Is best friend?</label><inputtype="checkbox"id="isBestFriend"name="isBestFriend"checked={friend.isBestFriend}/><buttontype="submit">Edit friend</button></form><buttontype="button"id="delete-document">Delete</button></Layout><script>const deleteButton = document.getElementById("delete-document") as HTMLButtonElement;const url = document.querySelector("form")?.getAttribute("action") as string;deleteButton.addEventListener("click", async()=> {const response = await fetch(url, {method: "DELETE",});if (response.redirected) {window.location.assign(response.url);}});</script>
```


#### Display an individual record


[Section titled Display an individual record](#display-an-individual-record)

`src/pages/friend/[id].astro` will display the details of a friend.

src/pages/friend/\[id\].astro

```
---import Layout from"../../layouts/Layout.astro";import { app } from"../../firebase/server";import { getFirestore } from"firebase-admin/firestore";interface Friend {name:string;age:number;isBestFriend:boolean;}const { id } = Astro.params;if (!id) {return Astro.redirect("/404");}const db = getFirestore(app);const friendsRef = db.collection("friends");const friendSnapshot = await friendsRef.doc(id).get();if (!friendSnapshot.exists) {return Astro.redirect("/404");}const friend = friendSnapshot.data() as Friend;---<Layouttitle={friend.name}><h1>{friend.name}</h1><p>Age: {friend.age}</p><p>Is best friend: {friend.isBestFriend?"Yes":"No"}</p></Layout>
```


#### Display a list of records with an edit button


[Section titled Display a list of records with an edit button](#display-a-list-of-records-with-an-edit-button)

Finally, `src/pages/dashboard.astro` will display a list of friends. Each friend will have a link to their details page and an edit button that will redirect the user to the edit page.

src/pages/dashboard.astro

```
---import { app } from"../firebase/server";import { getFirestore } from"firebase-admin/firestore";import Layout from"../layouts/Layout.astro";interface Friend {id:string;name:string;age:number;isBestFriend:boolean;}const db = getFirestore(app);const friendsRef = db.collection("friends");const friendsSnapshot = await friendsRef.get();const friends = friendsSnapshot.docs.map((doc) => ({id: doc.id,...doc.data(),})) as Friend[];---<Layouttitle="My friends"><h1>Friends</h1><ul>{friends.map((friend)=> (<li><ahref={`/friend/${friend.id}`}>{friend.name}</a><span>({friend.age})</span><strong>{friend.isBestFriend?"Bestie":"Friend"}</strong><ahref={`/edit/${friend.id}`}>Edit</a></li>))}</ul></Layout>
```

After creating all the pages, you should have the following file structure:

-   Directorysrc

    -   env.d.ts
    -   Directoryfirebase

        -   client.ts
        -   server.ts

    -   Directorypages

        -   dashboard.astro
        -   add.astro
        -   Directoryedit

            -   \[id\].astro

        -   Directoryfriend

            -   \[id\].astro

        -   Directoryapi

            -   Directoryfriends

                -   index.ts
                -   \[id\].ts




-   .env
-   astro.config.mjs
-   package.json


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Astro and Firebase SSR app example](https://github.com/kevinzunigacuellar/astro-firebase)
-   [Using Firebase Realtime Database in Astro with Vue: A Step-by-Step Guide](https://www.launchfa.st/blog/vue-astro-firebase-realtime-database)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 17. `en/guides/backend/neon/.md`

```text
# Neon Postgres & Astro


---
url: https://docs.astro.build/en/guides/backend/neon/
description: Add a serverless Postgres database to your Astro project with Neon
---


# Neon Postgres & Astro


[Neon](https://neon.tech) is a fully managed serverless Postgres database. It separates storage and compute to offer autoscaling, branching, and bottomless storage.


## Adding Neon to your Astro project


[Section titled Adding Neon to your Astro project](#adding-neon-to-your-astro-project)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A [Neon](https://console.neon.tech/signup) account with a created project
-   Neon database connection string
-   An Astro project with [on-demand rendering (SSR)](/en/guides/on-demand-rendering/) enabled


### Environment configuration


[Section titled Environment configuration](#environment-configuration)

To use Neon with Astro, you will need to set a Neon environment variable. Create or edit the `.env` file in your project root, and add the following code, replacing your own project details:

.env

```
NEON_DATABASE_URL="postgresql://<user>:<password>@<endpoint_hostname>.neon.tech:<port>/<dbname>?sslmode=require"
```

For better TypeScript support, define environment variables in a `src/env.d.ts` file:

src/env.d.ts

```
interface ImportMetaEnv {readonly NEON_DATABASE_URL:string;}interface ImportMeta {readonly env:ImportMetaEnv;}
```

Learn more about [environment variables](/en/guides/environment-variables/) and `.env` files in Astro.


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

Install the `@neondatabase/serverless` package to connect to Neon:

Terminal window

```
npminstall@neondatabase/serverless
```


### Creating a Neon client


[Section titled Creating a Neon client](#creating-a-neon-client)

Create a new file `src/lib/neon.ts` with the following code to initialize your Neon client:

src/lib/neon.ts

```
import { neon } from'@neondatabase/serverless';export const sql = neon(import.meta.env.NEON_DATABASE_URL);
```


## Querying your Neon database


[Section titled Querying your Neon database](#querying-your-neon-database)

You can now use the Neon client to query your database from any `.astro` component. The following example fetches the current time from the Postgres database:

src/pages/index.astro

```
---import { sql } from'../lib/neon';const response =  await  sql`SELECT NOW() as current_time`;const currentTime = response[0].current_time;---<h1>Current Time</h1><p>The time is: {currentTime}</p>
```


## Database branching with Neon


[Section titled Database branching with Neon](#database-branching-with-neon)

Neon’s branching feature lets you create copies of your database for development or testing. Use this in your Astro project by creating different environment variables for each branch:

.env.development

```
NEON_DATABASE_URL=your_development_branch_url
```

.env.production

```
NEON_DATABASE_URL=your_production_branch_url
```


## Resources


[Section titled Resources](#resources)

-   [Neon documentation](https://neon.tech/docs/introduction)
-   [Neon serverless driver GitHub](https://github.com/neondatabase/serverless)
-   [Connect an Astro site or application to Neon Postgres](https://neon.tech/docs/guides/astro)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 18. `en/guides/backend/sentry/.md`

```text
# Monitor your Astro Site with Sentry


---
url: https://docs.astro.build/en/guides/backend/sentry/
description: How to monitor your Astro site with Sentry
---


# Monitor your Astro Site with Sentry


[Sentry](https://sentry.io) offers a comprehensive application monitoring and error tracking service designed to help developers identify, diagnose, and resolve issues in real-time.

Read more on our blog about [Astro’s partnership with Sentry](https://astro.build/blog/sentry-official-monitoring-partner/) and Sentry’s Spotlight dev toolbar app that brings a rich debug overlay into your Astro development environment. Spotlight shows errors, traces, and important context right in your browser during local development.

Sentry’s Astro SDK enables automatic reporting of errors and tracing data in your Astro application.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

A full list of prerequisites can be found in [the Sentry guide for Astro](https://docs.sentry.io/platforms/javascript/guides/astro/#prerequisites).


## Install


[Section titled Install](#install)

Sentry captures data by using an SDK within your application’s runtime.

Install the SDK by running the following command for the package manager of your choice in the Astro CLI:

-   [npm](#tab-panel-3045)
-   [pnpm](#tab-panel-3046)
-   [Yarn](#tab-panel-3047)

Terminal window

```
npxastroadd@sentry/astro
```

Terminal window

```
pnpmastroadd@sentry/astro
```

Terminal window

```
yarnastroadd@sentry/astro
```

The astro CLI installs the SDK package and adds the Sentry integration to your `astro.config.mjs` file.


## Configure


[Section titled Configure](#configure)

To configure the Sentry integration, you need to provide the following credentials in your `astro.config.mjs` file.

1.  **Client key (DSN)** - You can find the DSN in your Sentry project settings under *Client keys (DSN)*.
2.  **Project name** - You can find the project name in your Sentry project settings under *General settings*.
3.  **Auth token** - You can create an auth token in your Sentry organization settings under *Auth tokens*.

Note

If you are creating a new Sentry project, select Astro as your platform to get all the necessary information to configure the SDK.

astro.config.mjs

```
import { defineConfig } from'astro/config';import sentry from'@sentry/astro';exportdefaultdefineConfig({integrations: [sentry({dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',sourceMapsUploadOptions: {project: 'example-project',authToken: process.env.SENTRY_AUTH_TOKEN,},}),],});
```

Once you’ve configured your `sourceMapsUploadOptions` and added your `dsn`, the SDK will automatically capture and send errors and performance events to Sentry.


## Test your setup


[Section titled Test your setup](#test-your-setup)

Add the following `<button>` element to one of your `.astro` pages. This will allow you to manually trigger an error so you can test the error reporting process.

src/pages/index.astro

```
<buttononclick="thrownewError('This is a test error')">Throw test error</button>
```

To view and resolve the recorded error, log into [sentry.io](https://sentry.io/) and open your project.


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 19. `en/guides/backend/supabase/.md`

```text
# Supabase & Astro


---
url: https://docs.astro.build/en/guides/backend/supabase/
description: Add a backend to your project with Supabase
---


# Supabase & Astro


[Supabase](https://supabase.com/) is an open source Firebase alternative. It provides a Postgres database, authentication, edge functions, realtime subscriptions, and storage.


## Initializing Supabase in Astro


[Section titled Initializing Supabase in Astro](#initializing-supabase-in-astro)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A Supabase project. If you don’t have one, you can sign up for free at [supabase.com](https://supabase.com/) and create a new project.
-   An Astro project with [`output: 'server'` for on-demand rendering](/en/guides/on-demand-rendering/) enabled.
-   Supabase credentials for your project. You can find these in the **Settings > API** tab of your Supabase project.
    -   `SUPABASE_URL`: The URL of your Supabase project.
    -   `SUPABASE_ANON_KEY`: The anonymous key for your Supabase project.


### Adding Supabase credentials


[Section titled Adding Supabase credentials](#adding-supabase-credentials)

To add your Supabase credentials to your Astro project, add the following to your `.env` file:

.env

```
SUPABASE_URL=YOUR_SUPABASE_URLSUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
```

Now, these environment variables are available in your project.

If you would like to have IntelliSense for your environment variables, edit or create the `env.d.ts` in your `src/` directory and add the following:

src/env.d.ts

```
interface ImportMetaEnv {readonly SUPABASE_URL:stringreadonly SUPABASE_ANON_KEY:string}interface ImportMeta {readonly env:ImportMetaEnv}
```

Tip

Read more about [environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your project should now include these files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect to Supabase, you will need to install `@supabase/supabase-js` in your project.

-   [npm](#tab-panel-3048)
-   [pnpm](#tab-panel-3049)
-   [Yarn](#tab-panel-3050)

Terminal window

```
npminstall@supabase/supabase-js
```

Terminal window

```
pnpmadd@supabase/supabase-js
```

Terminal window

```
yarnadd@supabase/supabase-js
```

Next, create a folder named `lib` in your `src/` directory. This is where you will add your Supabase client.

In `supabase.ts`, add the following to initialize your Supabase client:

src/lib/supabase.ts

```
import { createClient } from"@supabase/supabase-js";export const supabase = createClient(import.meta.env.SUPABASE_URL,import.meta.env.SUPABASE_ANON_KEY,);
```

Now, your project should include these files:

-   Directorysrc/

    -   Directorylib/

        -   **supabase.ts**

    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json


## Adding authentication with Supabase


[Section titled Adding authentication with Supabase](#adding-authentication-with-supabase)

Supabase provides authentication out of the box. It supports email/password authentication and OAuth authentication with many providers including GitHub, Google, and several others.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

-   An Astro project [initialized with Supabase](#initializing-supabase-in-astro).
-   A Supabase project with email/password authentication enabled. You can enable this in the **Authentication > Providers** tab of your Supabase project.


### Creating auth server endpoints


[Section titled Creating auth server endpoints](#creating-auth-server-endpoints)

To add authentication to your project, you will need to create a few server endpoints. These endpoints will be used to register, sign in, and sign out users.

-   `POST /api/auth/register`: to register a new user.
-   `POST /api/auth/signin`: to sign in a user.
-   `GET /api/auth/signout`: to sign out a user.

Create these endpoints in the `src/pages/api/auth` directory of your project. If you are using `static` rendering mode, you must specify `export const prerender = false` at the top of each file to render these endpoints on demand. Your project should now include these new files:

-   Directorysrc/

    -   Directorylib/

        -   supabase.ts

    -   Directorypages/

        -   Directoryapi/

            -   Directoryauth/

                -   **signin.ts**
                -   **signout.ts**
                -   **register.ts**



    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json

`register.ts` creates a new user in Supabase. It accepts a `POST` request with the an email and password. It then uses the Supabase SDK to create a new user.

src/pages/api/auth/register.ts

```
// With `output: 'static'` configured:// export const prerender = false;importtype { APIRoute } from"astro";import { supabase } from"../../../lib/supabase";export const POST:APIRoute = async ({ request, redirect }) => {const formData = await request.formData();const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();if (!email | !password) {return newResponse("Email and password are required", { status: 400 });}const { error } = await supabase.auth.signUp({email,password,});if (error) {return newResponse(error.message, { status: 500 });}return redirect("/signin");};
```

`signin.ts` signs in a user. It accepts a `POST` request with the an email and password. It then uses the Supabase SDK to sign in the user.

src/pages/api/auth/signin.ts

```
// With `output: 'static'` configured:// export const prerender = false;importtype { APIRoute } from"astro";import { supabase } from"../../../lib/supabase";export const POST:APIRoute = async ({ request, cookies, redirect }) => {const formData = await request.formData();const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();if (!email | !password) {return newResponse("Email and password are required", { status: 400 });}const { data, error } = await supabase.auth.signInWithPassword({email,password,});if (error) {return newResponse(error.message, { status: 500 });}const { access_token, refresh_token } = data.session;cookies.set("sb-access-token", access_token, {path: "/",});cookies.set("sb-refresh-token", refresh_token, {path: "/",});return redirect("/dashboard");};
```

`signout.ts` signs out a user. It accepts a `GET` request and removes the user’s access and refresh tokens.

src/pages/api/auth/signout.ts

```
// With `output: 'static'` configured:// export const prerender = false;importtype { APIRoute } from"astro";export const GET:APIRoute = async ({ cookies, redirect }) => {cookies.delete("sb-access-token", { path: "/" });cookies.delete("sb-refresh-token", { path: "/" });return redirect("/signin");};
```


### Creating auth pages


[Section titled Creating auth pages](#creating-auth-pages)

Now that you have created your server endpoints, create the pages that will use them.

-   `src/pages/register`: contains a form to register a new user.
-   `src/pages/signin`: contains a form to sign in a user.
-   `src/pages/dashboard`: contains a page that is only accessible to authenticated users.

Create these pages in the `src/pages` directory. Your project should now include these new files:

-   Directorysrc/

    -   Directorylib/

        -   supabase.ts

    -   Directorypages/

        -   Directoryapi/

            -   Directoryauth/

                -   signin.ts
                -   signout.ts
                -   register.ts


        -   **register.astro**
        -   **signin.astro**
        -   **dashboard.astro**

    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json

`register.astro` contains a form to register a new user. It accepts an email and password and sends a `POST` request to `/api/auth/register`.

src/pages/register.astro

```
---import Layout from"../layouts/Layout.astro";---<Layouttitle="Register"><h1>Register</h1><p>Already have an account? <ahref="/signin">Sign in</a></p><formaction="/api/auth/register"method="post"><labelfor="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Register</button></form></Layout>
```

`signin.astro` contains a form to sign in a user. It accepts an email and password and sends a `POST` request to `/api/auth/signin`. It also checks for the presence of the access and refresh tokens. If they are present, it redirects to the dashboard.

src/pages/signin.astro

```
---import Layout from"../layouts/Layout.astro";const { cookies, redirect } = Astro;const accessToken = cookies.get("sb-access-token");const refreshToken = cookies.get("sb-refresh-token");if (accessToken && refreshToken) {returnredirect("/dashboard");}---<Layouttitle="Sign in"><h1>Sign in</h1><p>New here? <ahref="/register">Create an account</a></p><formaction="/api/auth/signin"method="post"><labelfor="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Login</button></form></Layout>
```

`dashboard.astro` contains a page that is only accessible to authenticated users. It checks for the presence of the access and refresh tokens. If they are not present or are invalid, it redirects to the sign in page.

src/pages/dashboard.astro

```
---import Layout from"../layouts/Layout.astro";import { supabase } from"../lib/supabase";const accessToken = Astro.cookies.get("sb-access-token");const refreshToken = Astro.cookies.get("sb-refresh-token");if (!accessToken |!refreshToken) {return Astro.redirect("/signin");}let session;try {session =await supabase.auth.setSession({refresh_token: refreshToken.value,access_token: accessToken.value,});if (session.error) {Astro.cookies.delete("sb-access-token", {path: "/",});Astro.cookies.delete("sb-refresh-token", {path: "/",});return Astro.redirect("/signin");}} catch (error) {Astro.cookies.delete("sb-access-token", {path: "/",});Astro.cookies.delete("sb-refresh-token", {path: "/",});return Astro.redirect("/signin");}const email = session.data.user?.email;---<Layouttitle="dashboard"><h1>Welcome {email}</h1><p>We are happy to see you here</p><formaction="/api/auth/signout"><buttontype="submit">Sign out</button></form></Layout>
```


### Adding OAuth authentication


[Section titled Adding OAuth authentication](#adding-oauth-authentication)

To add OAuth authentication to your project, you will need to edit your Supabase client to enable authentication flow with `"pkce"`. You can read more about authentication flows in the [Supabase documentation](https://supabase.com/docs/guides/auth/server-side-rendering#understanding-the-authentication-flow).

src/lib/supabase.ts

```
import { createClient } from"@supabase/supabase-js";export const supabase = createClient(import.meta.env.SUPABASE_URL,import.meta.env.SUPABASE_ANON_KEY,{auth: {flowType: "pkce",},},);
```

Next, in the Supabase dashboard, enable the OAuth provider you would like to use. You can find the list of supported providers in the **Authentication > Providers** tab of your Supabase project.

The following example uses GitHub as the OAuth provider. To connect your project to GitHub, follow the steps in the [Supabase documentation](https://supabase.com/docs/guides/auth/social-login/auth-github).

Then, create a new server endpoint to handle the OAuth callback at `src/pages/api/auth/callback.ts`. This endpoint will be used to exchange the OAuth code for an access and refresh token.

src/pages/api/auth/callback.ts

```
importtype { APIRoute } from"astro";import { supabase } from"../../../lib/supabase";export const GET:APIRoute = async ({ url, cookies, redirect }) => {const authCode = url.searchParams.get("code");if (!authCode) {return newResponse("No code provided", { status: 400 });}const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);if (error) {return newResponse(error.message, { status: 500 });}const { access_token, refresh_token } = data.session;cookies.set("sb-access-token", access_token, {path: "/",});cookies.set("sb-refresh-token", refresh_token, {path: "/",});return redirect("/dashboard");};
```

Next, edit the sign in page to include a new button to sign in with the OAuth provider. This button should send a `POST` request to `/api/auth/signin` with the `provider` set to the name of the OAuth provider.

src/pages/signin.astro

```
---import Layout from"../layouts/Layout.astro";const { cookies, redirect } = Astro;const accessToken = cookies.get("sb-access-token");const refreshToken = cookies.get("sb-refresh-token");if (accessToken && refreshToken) {returnredirect("/dashboard");}---<Layouttitle="Sign in"><h1>Sign in</h1><p>New here? <ahref="/register">Create an account</a></p><formaction="/api/auth/signin"method="post"><labelfor="email">Email</label><inputtype="email"name="email"id="email" /><labelfor="password">Password</label><inputtype="password"name="password"id="password" /><buttontype="submit">Login</button><buttonvalue="github"name="provider"type="submit">Sign in with GitHub</button></form></Layout>
```

Finally, edit the sign in server endpoint to handle the OAuth provider. If the `provider` is present, it will redirect to the OAuth provider. Otherwise, it will sign in the user with the email and password.

src/pages/api/auth/signin.ts

```
importtype { APIRoute } from"astro";import { supabase } from"../../../lib/supabase";importtype { Provider } from"@supabase/supabase-js";export const POST:APIRoute = async ({ request, cookies, redirect }) => {const formData = await request.formData();const email = formData.get("email")?.toString();const password = formData.get("password")?.toString();const provider = formData.get("provider")?.toString();const validProviders = ["google", "github", "discord"];if (provider && validProviders.includes(provider)) {const { data, error } = await supabase.auth.signInWithOAuth({provider: provider as Provider,options: {redirectTo: "http://localhost:4321/api/auth/callback"},});if (error) {return newResponse(error.message, { status: 500 });}return redirect(data.url);}if (!email | !password) {return newResponse("Email and password are required", { status: 400 });}const { data, error } = await supabase.auth.signInWithPassword({email,password,});if (error) {return newResponse(error.message, { status: 500 });}const { access_token, refresh_token } = data.session;cookies.set("sb-access-token", access_token, {path: "/",});cookies.set("sb-refresh-token", refresh_token, {path: "/",});return redirect("/dashboard");};
```

After creating the OAuth callback endpoint and editing the sign in page and server endpoint, your project should have the following file structure:

-   Directorysrc/

    -   Directorylib/

        -   supabase.ts

    -   Directorypages/

        -   Directoryapi/

            -   Directoryauth/

                -   signin.ts
                -   signout.ts
                -   register.ts
                -   callback.ts


        -   register.astro
        -   signin.astro
        -   dashboard.astro

    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Getting into the holiday spirit with Astro, React, and Supabase](https://www.aleksandra.codes/astro-supabase)
-   [Astro and Supabase auth demo](https://github.com/kevinzunigacuellar/astro-supabase)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 20. `en/guides/backend/turso/.md`

```text
# Turso & Astro


---
url: https://docs.astro.build/en/guides/backend/turso/
description: Build locally with a SQLite file and deploy globally using Turso.
---


# Turso & Astro


[Turso](https://turso.tech) is a distributed database built on libSQL, a fork of SQLite. It is optimized for low query latency, making it suitable for global applications.


## Initializing Turso in Astro


[Section titled Initializing Turso in Astro](#initializing-turso-in-astro)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   The [Turso CLI](https://docs.turso.tech/cli/introduction) installed and signed in
-   A [Turso](https://turso.tech) Database with schema
-   Your Database URL
-   An Access Token


### Configure environment variables


[Section titled Configure environment variables](#configure-environment-variables)

Obtain your database URL using the following command:

Terminal window

```
tursodbshow<database-name>--url
```

Create an auth token for the database:

Terminal window

```
tursodbtokenscreate<database-name>
```

Add the output from both commands above into your `.env` file at the root of your project. If this file does not exist, create one.

.env

```
TURSO_DATABASE_URL=libsql://...TURSO_AUTH_TOKEN=
```

Caution

Do not use the `PUBLIC_` prefix when creating these private [environment variables](/en/guides/environment-variables/). This will expose these values on the client.


### Install LibSQL Client


[Section titled Install LibSQL Client](#install-libsql-client)

Install the `@libsql/client` to connect Turso to Astro:

-   [npm](#tab-panel-3051)
-   [pnpm](#tab-panel-3052)
-   [Yarn](#tab-panel-3053)

Terminal window

```
npminstall@libsql/client
```

Terminal window

```
pnpmadd@libsql/client
```

Terminal window

```
yarnadd@libsql/client
```


### Initialize a new client


[Section titled Initialize a new client](#initialize-a-new-client)

Create a file `turso.ts` in the `src` folder and invoke `createClient`, passing it `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN`:

src/turso.ts

```
import { createClient } from"@libsql/client/web";export const turso = createClient({url: import.meta.env.TURSO_DATABASE_URL,authToken: import.meta.env.TURSO_AUTH_TOKEN,});
```


## Querying your database


[Section titled Querying your database](#querying-your-database)

To access information from your database, import `turso` and [execute a SQL query](https://docs.turso.tech/sdk/ts/reference#simple-query) inside any `.astro` component.

The following example fetches all `posts` from your table, then displays a list of titles in a `<BlogIndex />` component:

src/components/BlogIndex.astro

```
---import { turso } from'../turso'const { rows } = await turso.execute('SELECT * FROM posts')---<ul>{rows.map((post)=> (<li>{post.title}</li>))}</ul>
```


### SQL Placeholders


[Section titled SQL Placeholders](#sql-placeholders)

The `execute()` method can take [an object to pass variables to the SQL statement](https://docs.turso.tech/sdk/ts/reference#placeholders), such as `slug`, or pagination.

The following example fetches a single entry from the `posts` table `WHERE` the `slug` is the retrieved value from `Astro.params`, then displays the title of the post.

src/pages/index.astro

```
---import { turso } from'../turso'const { slug } = Astro.paramsconst { rows } = await turso.execute({sql: 'SELECT * FROM posts WHERE slug = ?',args: [slug!]})---<h1>{rows[0].title}</h1>
```


## Turso Resources


[Section titled Turso Resources](#turso-resources)

-   [Turso Docs](https://docs.turso.tech)
-   [Turso on GitHub](https://github.com/tursodatabase)
-   [Using Turso to serve a Server-side Rendered Astro blog’s content](https://blog.turso.tech/using-turso-to-serve-a-server-side-rendered-astro-blogs-content-58caa6188bd5)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 21. `en/guides/backend/xata/.md`

```text
# Xata & Astro


---
url: https://docs.astro.build/en/guides/backend/xata/
description: Add a serverless database with full-text search to your project with Xata
---


# Xata & Astro


[Xata](https://xata.io) is a **Serverless Data Platform** that combines the features of a relational database, a search engine, and an analytics engine by exposing a single consistent REST API.


## Adding a database with Xata


[Section titled Adding a database with Xata](#adding-a-database-with-xata)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A [Xata](https://app.xata.io/signin) account with a created database. (You can use the sample database from the Web UI.)
-   An Access Token (`XATA_API_KEY`).
-   Your Database URL.

After you update and initialize the [Xata CLI](https://xata.io/docs/getting-started/installation), you will have your API token in your `.env` file and database URL defined.

By the end of the setup, you should have:

.env

```
XATA_API_KEY=hash_key# Xata branch that will be used# if there's not a xata branch with# the same name as your git branchXATA_BRANCH=main
```

And the `databaseURL` defined:

.xatarc

```
{"databaseUrl": "https://your-database-url"}
```


### Environment configuration


[Section titled Environment configuration](#environment-configuration)

To have IntelliSense and type safety for your environment variables, edit or create the file `env.d.ts` in your `src/` directory:

src/env.d.ts

```
interface ImportMetaEnv {readonly XATA_API_KEY:string;readonly XATA_BRANCH?:string;}interface ImportMeta {readonly env:ImportMetaEnv;}
```

Tip

Read more about [environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Using the code generation from the Xata CLI and choosing the TypeScript option, generated an instance of the SDK for you, with types tailored to your database schema. Additionally, `@xata.io/client` was added to your `package.json`.

Your Xata environment variables and database url were automatically pulled by the SDK instance, so there’s no more setup work needed.

Now, your project should have the following structure:

-   Directorysrc/

    -   **xata.ts**
    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json
-   **.xatarc**


## Create your queries


[Section titled Create your queries](#create-your-queries)

To query your posts, import and use `XataClient` class in a `.astro` file. The example below queries the first 50 posts from Xata’s Sample Blog Database.

src/pages/blog/index.astro

```
---import { XataClient } from'../../xata';const xata = newXataClient({apiKey: import.meta.env.XATA_API_KEY,branch: import.meta.env.XATA_BRANCH});const { records } = await xata.db.Posts.getPaginated({pagination: {size: 50}})---<ul>{records.map((post)=> (<li>{post.title}</li>))}</ul>
```

It’s important to note the SDK needs to be regenerated everytime your schema changes. So, avoid making changes to the generated files the Xata CLI creates because once schema updates, your changes will be overwritten.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Xata Astro Starter](https://github.com/xataio/examples/tree/main/apps/getting-started-astro)
-   [Xata Docs: Quick Start Guide](https://xata.io/docs/getting-started/quickstart-astro)


## More backend service guides


-   ### [Appwrite](/en/guides/backend/appwriteio/)

-   ### [Firebase](/en/guides/backend/google-firebase/)

-   ### [Neon](/en/guides/backend/neon/)

-   ### [Sentry](/en/guides/backend/sentry/)

-   ### [Supabase](/en/guides/backend/supabase/)

-   ### [Turso](/en/guides/backend/turso/)

-   ### [Xata](/en/guides/backend/xata/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 22. `en/guides/client-side-scripts/.md`

```text
# Scripts and event handling


---
url: https://docs.astro.build/en/guides/client-side-scripts/
description: How to add client-side interactivity to Astro components using native browser JavaScript APIs.
---


# Scripts and event handling


You can add interactivity to your Astro components without [using a UI framework](/en/guides/framework-components/) like React, Svelte, Vue, etc. using standard HTML `<script>` tags. This allows you to send JavaScript to run in the browser and add functionality to your Astro components.


## Client-Side Scripts


[Section titled Client-Side Scripts](#client-side-scripts)

Scripts can be used to add event listeners, send analytics data, play animations, and everything else JavaScript can do on the web.

src/components/ConfettiButton.astro

```
<buttondata-confetti-button>Celebrate!</button><script>// Import npm modules.import confetti from'canvas-confetti';// Find our component DOM on the page.const buttons = document.querySelectorAll('[data-confetti-button]');// Add event listeners to fire confetti when a button is clicked.buttons.forEach((button)=> {button.addEventListener('click', ()=>confetti());});</script>
```

By default, Astro processes and bundles `<script>` tags, adding support for importing npm modules, writing TypeScript, and more.


## Using `<script>` in Astro


[Section titled Using &lt;script&gt; in Astro](#using-script-in-astro)

In `.astro` files, you can add client-side JavaScript by adding one (or more) `<script>` tags.

In this example, adding the `<Hello />` component to a page will log a message to the browser console.

src/components/Hello.astro

```
<h1>Welcome, world!</h1><script>console.log('Welcome, browser console!');</script>
```


### Script processing


[Section titled Script processing](#script-processing)

By default, `<script>` tags are processed by Astro.

-   Any imports will be bundled, allowing you to import local files or Node modules.
-   The processed script will be injected at where it’s declared with [`type="module"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).
-   TypeScript is fully supported, including importing TypeScript files.
-   If your component is used several times on a page, the script will only be included once.

src/components/Example.astro

```
<script>// Processed! Bundled! TypeScript-supported!// Importing local scripts and Node modules works.</script>
```

The `type="module"` attribute makes the browser treat the script as a JavaScript module. This has several performance benefits:

-   Rendering is not blocked. The browser continues to process the rest of the HTML while the module script and its dependencies load.
-   The browser waits for HTML to be processed before executing module scripts. You do not need to listen for the “load” event.
-   `async` and `defer` attributes are unnecessary. Module scripts are always deferred.

Note

The `async` attribute is valuable for normal scripts because it prevents them from blocking rendering. However, module scripts already have this behavior. Adding `async` to a module script will cause it to execute before the page has fully loaded. This is probably not what you want.


### Opting out of processing


[Section titled Opting out of processing](#opting-out-of-processing)

To prevent Astro from processing a script, add the `is:inline` directive.

src/components/InlineScript.astro

```
<scriptis:inline>// Will be rendered into the HTML exactly as written!// Local imports are not resolved and will not work.// If in a component, repeats each time the component is used.</script>
```

Note

Astro will not process your script tags in some situations. In particular, adding `type="module"` or any attribute other than `src` to a `<script>` tag will cause Astro to treat the tag as if it had an `is:inline` directive.

See our [directives reference](/en/reference/directives-reference/#script--style-directives) page for more information about the directives available on `<script>` tags.


### Include JavaScript files on your page


[Section titled Include JavaScript files on your page](#include-javascript-files-on-your-page)

You may want to write your scripts as separate `.js`/`.ts` files or need to reference an external script on another server. You can do this by referencing these in a `<script>` tag’s `src` attribute.


#### Import local scripts


[Section titled Import local scripts](#import-local-scripts)

**When to use this:** when your script lives inside of `src/`.

Astro will build, optimize, and add these scripts to the page for you, following its [script processing rules](#script-processing).

src/components/LocalScripts.astro

```
<!-- relative path to script at `src/scripts/local.js` --><scriptsrc="../scripts/local.js"></script><!-- also works for local TypeScript files --><scriptsrc="./script-with-types.ts"></script>
```


#### Load external scripts


[Section titled Load external scripts](#load-external-scripts)

**When to use this:** when your JavaScript file lives inside of `public/` or on a CDN.

To load scripts outside of your project’s `src/` folder, include the `is:inline` directive. This approach skips the JavaScript processing, bundling, and optimizations that are provided by Astro when you import scripts as described above.

src/components/ExternalScripts.astro

```
<!-- absolute path to a script at `public/my-script.js` --><scriptis:inlinesrc="/my-script.js"></script><!-- full URL to a script on a remote server --><scriptis:inlinesrc="https://my-analytics.com/script.js"></script>
```


## Common script patterns


[Section titled Common script patterns](#common-script-patterns)


### Handle `onclick` and other events


[Section titled Handle onclick and other events](#handle-onclick-and-other-events)

Some UI frameworks use custom syntax for event handling like `onClick={...}` (React/Preact) or `@click="..."` (Vue). Astro follows standard HTML more closely and does not use custom syntax for events.

Instead, you can use [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) in a `<script>` tag to handle user interactions.

src/components/AlertButton.astro

```
<buttonclass="alert">Click me!</button><script>// Find all buttons with the `alert` class on the page.const buttons = document.querySelectorAll('button.alert');// Handle clicks on each button.buttons.forEach((button)=> {button.addEventListener('click', ()=> {alert('Button was clicked!');});});</script>
```

Note

If you have multiple `<AlertButton />` components on a page, Astro will not run the script multiple times. Scripts are bundled and only included once per page. Using `querySelectorAll` ensures that this script attaches the event listener to every button with the `alert` class found on the page.


### Web components with custom elements


[Section titled Web components with custom elements](#web-components-with-custom-elements)

You can create your own HTML elements with custom behavior using the Web Components standard. Defining a [custom element](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) in a `.astro` component allows you to build interactive components without needing a UI framework library.

In this example, we define a new `<astro-heart>` HTML element that tracks how many times you click the heart button and updates the `<span>` with the latest count.

src/components/AstroHeart.astro

```
<!-- Wrap the component elements in our custom element “astro-heart”. --><astro-heart><buttonaria-label="Heart">💜</button> × <span>0</span></astro-heart><script>// Define the behaviour for our new type of HTML element.classAstroHeartextendsHTMLElement {connectedCallback() {letcount = 0;constheartButton = this.querySelector('button');constcountSpan = this.querySelector('span');// Each time the button is clicked, update the count.heartButton.addEventListener('click', ()=> {count++;countSpan.textContent=count.toString();});}}// Tell the browser to use our AstroHeart class for <astro-heart> elements.customElements.define('astro-heart', AstroHeart);</script>
```

There are two advantages to using a custom element here:

1.  Instead of searching the whole page using `document.querySelector()`, you can use `this.querySelector()`, which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time.

2.  Although a `<script>` only runs once, the browser will run our custom element’s `connectedCallback()` method each time it finds `<astro-heart>` on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page.


You can learn more about custom elements in [web.dev’s Reusable Web Components guide](https://web.dev/custom-elements-v1/) and [MDN’s introduction to custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).


### Pass frontmatter variables to scripts


[Section titled Pass frontmatter variables to scripts](#pass-frontmatter-variables-to-scripts)

In Astro components, the code in [the frontmatter](/en/basics/astro-components/#the-component-script) between the `---` fences runs on the server and is not available in the browser. To send variables from the server to the client, we need a way to store our variables and then read them when JavaScript runs in the browser.

One way to do this is to use [`data-*` attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes) to store the value of variables in your HTML output. Scripts, including custom elements, can then read these attributes using an element’s `dataset` property once your HTML loads in the browser.

In this example component, a `message` prop is stored in a `data-message` attribute, so the custom element can read `this.dataset.message` and get the value of the prop in the browser.

src/components/AstroGreet.astro

```
---const { message = 'Welcome, world!' } = Astro.props;---<!-- Store the message prop as a data attribute. --><astro-greetdata-message={message}><button>Say hi!</button></astro-greet><script>classAstroGreetextendsHTMLElement {connectedCallback() {// Read the message from the data attribute.constmessage = this.dataset.message;constbutton = this.querySelector('button');button.addEventListener('click', ()=> {alert(message);});}}customElements.define('astro-greet', AstroGreet);</script>
```

Now we can use our component multiple times and be greeted by a different message for each one.

src/pages/example.astro

```
---import AstroGreet from'../components/AstroGreet.astro';---<!-- Use the default message: “Welcome, world!” --><AstroGreet /><!-- Use custom messages passed as a props. --><AstroGreetmessage="Lovely day to build components!" /><AstroGreetmessage="Glad you made it! 👋" />
```

Did you know?

This is actually what Astro does behind the scenes when you pass props to a component written using a UI framework like React! For components with a `client:*` directive, Astro creates an `<astro-island>` custom element with a `props` attribute that stores your server-side props in the HTML output.


### Combining scripts and UI Frameworks


[Section titled Combining scripts and UI Frameworks](#combining-scripts-and-ui-frameworks)

Elements rendered by a UI framework may not be available yet when a `<script>` tag executes. If your script also needs to handle [UI framework components](/en/guides/framework-components/), using a custom element is recommended.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 23. `en/guides/cms/.md`

```text
# Use a CMS with Astro


---
url: https://docs.astro.build/en/guides/cms/
description: How to use a CMS to add content to Astro
---


# Use a CMS with Astro


**Ready to connect a Headless CMS to your Astro project?** Follow one of our guides to integrate a CMS.

Tip

Find [community-maintained integrations](https://astro.build/integrations/?search=cms) for connecting a CMS to your project in our integrations directory.


## CMS Guides


[Section titled CMS Guides](#cms-guides)

Note that many of these pages are **stubs**: they’re collections of resources waiting for your contribution!

-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)



## Why use a CMS?


[Section titled Why use a CMS?](#why-use-a-cms)

A Content Management System lets you write content and manage assets outside of your Astro project.

This unlocks new features for working with content. Most CMSes give you a visual content editor, the ability to specify standard types of content, and a way to collaborate with others.

A CMS can be useful for content that follows a particular structure, often giving you a dashboard-like experience and WYSIWYG editing tools. You might use a CMS to write blog posts using a CMS’s rich text editor instead of Markdown files. Or you might use a CMS to maintain product listings for an eCommerce shop, making certain fields required to avoid incomplete listings.

Your Astro project can then fetch your content from your CMS and display it, wherever and however you want on your site.


## Which CMSes work well with Astro?


[Section titled Which CMSes work well with Astro?](#which-cmses-work-well-with-astro)

Because Astro takes care of the *presentation* of your content, you’ll want to choose a *headless* CMS, like those in the list above. This means that the CMS helps you write your content, but doesn’t generate a site that displays it. Instead, you fetch the content data and use in your Astro project.

Some headless CMSes, like Storyblok, provide an Astro [integration](/en/guides/integrations-guide/) that helps fetch the content specifically for an Astro site. Others provide a JavaScript SDK, a library that you install and use to fetch your remote content.

Explore a [list of over 100 headless content management systems](https://jamstack.org/headless-cms/) External where you can filter by type (e.g. Git-based, API driven) and license (open-source or closed-source).


## Can I use Astro without a CMS?


[Section titled Can I use Astro without a CMS?](#can-i-use-astro-without-a-cms)

Yes! Astro provides built-in support for [Markdown](/en/guides/markdown-content/).

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 24. `en/guides/cms/apostrophecms/.md`

```text
# ApostropheCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/apostrophecms/
description: Edit content on the page in your Astro project using Apostrophe as your CMS.
---


# ApostropheCMS & Astro


[ApostropheCMS](https://apostrophecms.com/) is a content management system supporting on-page editing in Astro.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, you will use the [Apostrophe integration](https://apostrophecms.com/extensions/astro-integration) to connect ApostropheCMS to Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An on-demand rendered Astro project** with the [Node.js adapter](/en/guides/integrations-guide/node/) installed and `output: 'server'` configured - If you don’t have an Astro project yet, our [installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **An ApostropheCMS project with a configured environment variable called `APOS_EXTERNAL_FRONT_KEY`** - This environment variable can be set to any random string. If you don’t have an ApostropheCMS project yet, the [installation guide](https://docs.apostrophecms.org/guide/development-setup.html) will get one setup quickly. We highly recommend using the [Apostrophe CLI tool](https://apostrophecms.com/extensions/apos-cli) to facilitate this.



### Setting up project communication


[Section titled Setting up project communication](#setting-up-project-communication)

Your Astro project needs to have an `APOS_EXTERNAL_FRONT_KEY` environment variable set to the same value as the one in your ApostropheCMS project to allow communication between the two. This shared key acts as a means to verify requests between the frontend (Astro) and the backend (ApostropheCMS).

Create a `.env` file in the root of your Astro project with the following variable:

.env

```
APOS_EXTERNAL_FRONT_KEY='RandomStrongString'
```

Your root directory should now include this new file:

-   Directorysrc/

    -   …

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect Astro with your ApostropheCMS project, install the official Apostrophe integration in your Astro project using the command below for your preferred package manager.

-   [npm](#tab-panel-3054)
-   [pnpm](#tab-panel-3055)
-   [Yarn](#tab-panel-3056)

Terminal window

```
npminstall@apostrophecms/apostrophe-astrovite@astro/node
```

Terminal window

```
pnpmadd@apostrophecms/apostrophe-astrovite@astro/node
```

Terminal window

```
yarnadd@apostrophecms/apostrophe-astrovite@astro/node
```


### Configuring Astro


[Section titled Configuring Astro](#configuring-astro)

Configure both the `apostrophe-astro` integration and `vite` in your `astro.config.mjs` file.

The following example provides the base URL of your Apostrophe instance and paths to folders in your project to map between the ApostropheCMS [widgets](https://docs.apostrophecms.org/guide/core-widgets.html) and [page template](https://docs.apostrophecms.org/guide/pages.html) types and your Astro project. It also configures Vite’s server-side rendering.

astro.config.mjs

```
import { defineConfig } from'astro/config';import node from'@astrojs/node';import apostrophe from'@apostrophecms/apostrophe-astro';import { loadEnv } from'vite';const env = loadEnv("", process.cwd(), 'APOS');exportdefaultdefineConfig({output: 'server',adapter: node({mode: 'standalone'}),integrations: [apostrophe({aposHost: 'http://localhost:3000',widgetsMapping: './src/widgets',templatesMapping: './src/templates'})],vite: {ssr: {// Do not externalize the @apostrophecms/apostrophe-astro plugin, we need// to be able to use virtual: URLs therenoExternal: [ '@apostrophecms/apostrophe-astro' ],},define: {'process.env.APOS_EXTERNAL_FRONT_KEY': JSON.stringify(env.APOS_EXTERNAL_FRONT_KEY),'process.env.APOS_HOST': JSON.stringify(env.APOS_HOST)}}});
```

For complete configuration options and explanations, see the [`apostrophe-astro` documentation](https://apostrophecms.com/extensions/astro-integration#configuration-astro).


### Connecting ApostropheCMS widgets to Astro components


[Section titled Connecting ApostropheCMS widgets to Astro components](#connecting-apostrophecms-widgets-to-astro-components)

ApostropheCMS widgets are blocks of structured content that can be added to the page such as layout columns, images, and text blocks. You will need to create an Astro component for each widget in your Apostrophe project, plus a file to map those components to the corresponding Apostrophe widget.

Create a new folder at `src/widgets/` for your Astro components and the mapping file, `index.js`.

Mapped components located in this folder receive a `widget` property containing your widget’s schema fields, and any custom props, through `Astro.props`. These values are then available for on-page editing.

The following example shows a `RichTextWidget.astro` component accessing the content from its corresponding ApostropheCMS widget to allow for in-context editing:

src/widgets/RichTextWidget.astro

```
---const { widget } = Astro.props;const { content } = widget;---<Fragmentset:html={content}></Fragment>
```

Some standard Apostrophe widgets, such as images and videos, require **placeholders** because they do not contain editable content by default. The following example creates a standard `ImageWidget.astro` component that sets the `src` value conditionally to either the value of the `aposPlaceholder` image passed by the widget, a fallback image from the Astro project, or the image selected by the content manager using the Apostrophe `attachment` helper:

src/widgets/ImageWidget.astro

```
---const { widget } = Astro.props;const placeholder = widget?.aposPlaceholder;const src = placeholder ?'/images/image-widget-placeholder.jpg' :widget?._image[0]?.attachment?._urls['full'];---<style>.img-widget {width: 100%;}</style><imgclass="img-widget"{src} />
```

For more examples, see [the `astro-frontend` starter project widget examples](https://github.com/apostrophecms/astro-frontend/tree/main/src/widgets).

Each `.astro` component must be mapped to the corresponding core Apostrophe widget in `src/widgets/index.js`.

The example below adds the previous two components to this file:

src/widgets/index.js

```
import RichTextWidget from'./RichTextWidget.astro';import ImageWidget from'./ImageWidget.astro';const widgetComponents = {'@apostrophecms/rich-text': RichTextWidget,'@apostrophecms/image': ImageWidget};exportdefaultwidgetComponents;
```

See [the ApostropheCMS documentation](https://apostrophecms.com/extensions/astro-integration) for naming conventions for standard, pro, and custom-project-level widgets

The project directory should now look like this:

-   Directorysrc/

    -   Directorywidgets/

        -   **index.js**
        -   **ImageWidget.astro**
        -   **RichTextWidget.astro**


-   .env
-   astro.config.mjs
-   package.json


### Adding page types


[Section titled Adding page types](#adding-page-types)

Much like widgets, any page type template in your ApostropheCMS project needs to have a corresponding template component in your Astro project. You will also need a file that maps the Apostrophe page types to individual components.

Create a new folder at `src/templates/` for your Astro components and the mapping file, `index.js`. Mapped components located in this folder receive a `page` property containing the schema fields of your page, and any custom props, through `Astro.props`. These components can also access an `AposArea` component to render Apostrophe areas.

The following example shows a `HomePage.astro` component rendering a page template from its corresponding `home-page` ApostropheCMS page type, including an area schema field named `main`:

src/templates/HomePage.astro

```
---import AposArea from'@apostrophecms/apostrophe-astro/components/AposArea.astro';const { page, user, query } = Astro.props.aposData;const { main } = page;---<sectionclass="bp-content"><h1>{page.title}</h1><AposAreaarea={main} /></section>
```

Each `.astro` component must be mapped to the corresponding core Apostrophe page type in `src/templates/index.js`.

The example below adds the previous `HomePage.astro` component to this file:

src/templates/index.js

```
import HomePage from'./HomePage.astro';const templateComponents = {'@apostrophecms/home-page': HomePage};exportdefaulttemplateComponents;
```

See [the ApostropheCMS documentation](https://apostrophecms.com/extensions/astro-integration/#how-apostrophe-template-names-work) for template naming conventions, including special pages and piece page types.

The project directory should now look like this:

-   Directorysrc/

    -   Directorywidgets/

        -   index.js
        -   ImageWidget.astro
        -   RichTextWidget.astro

    -   Directorytemplates/

        -   **HomePage.astro**
        -   **index.js**


-   .env
-   astro.config.mjs
-   package.json


### Creating the \[…slug.astro\] component and fetching Apostrophe data


[Section titled Creating the \[…slug.astro\] component and fetching Apostrophe data](#creating-the-slugastro-component-and-fetching-apostrophe-data)

Since Apostrophe is responsible for connecting URLs to content, including creating new content and pages on the fly, you will only need one top-level Astro page component: the `[...slug].astro` route.

The following example shows a minimal `[...slug].astro` component:

src/pages/\[...slug\].astro

```
---import aposPageFetch from'@apostrophecms/apostrophe-astro/lib/aposPageFetch.js';import AposLayout from'@apostrophecms/apostrophe-astro/components/layouts/AposLayout.astro';import AposTemplate from'@apostrophecms/apostrophe-astro/components/AposTemplate.astro';const aposData = await aposPageFetch(Astro.request);const bodyClass = `myclass`;if (aposData.redirect) {returnAstro.redirect(aposData.url, aposData.status);}if (aposData.notFound) {Astro.response.status=404;}---<AposLayouttitle={aposData.page?.title}{aposData}{bodyClass}><Fragmentslot="standardHead"><metaname="description"content={aposData.page?.seoDescription} /><metaname="viewport"content="width=device-width, initial-scale=1" /><metacharset="UTF-8" /></Fragment><AposTemplate{aposData}slot="main"/></AposLayout>
```

See [the ApostropheCMS documentation](https://apostrophecms.com/extensions/astro-integration#creating-the-slugastro-component-and-fetching-apostrophe-data) for additional templating options, including slots available in the `AposTemplate` component.


## Making a blog with Astro and ApostropheCMS


[Section titled Making a blog with Astro and ApostropheCMS](#making-a-blog-with-astro-and-apostrophecms)

With the integration set up, you can now create a blog with Astro and ApostropheCMS. Your blog will use an Apostrophe piece, a stand-alone content type that can be included on any page, and a piece page type, a specialized page type that is used for displaying those pieces either individually or collectively.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  **An ApostropheCMS project with the Apostrophe CLI tool installed** - You can create a new project or use an existing one. However, this tutorial will only show how to create a blog piece and piece page type. You will have to integrate any other existing project code independently. If you don’t have the CLI tool installed, consult the [Apostrophe CLI installation instructions](https://docs.apostrophecms.org/guide/setting-up.html#the-apostrophe-cli-tool).
2.  **An Astro project integrated with ApostropheCMS** - To create a project from scratch, see [integrating with Astro](#integrating-with-astro) for instructions on how to set up the integration, or use the [astro-frontend](https://github.com/apostrophecms/astro-frontend) starter project.


### Creating a blog piece and piece page type


[Section titled Creating a blog piece and piece page type](#creating-a-blog-piece-and-piece-page-type)

To create your blog piece and piece page type for their display, navigate to the root of your ApostropheCMS project in your terminal. Use the ApostropheCMS CLI tool to create the new piece and piece page type with the following command:

Terminal window

```
aposaddpieceblog--page
```

This will create two new modules in your project, one for the blog piece type and one for the corresponding piece page type. Next, open the `app.js` file at the root of your ApostropheCMS project in your code editor and add your new modules.

app.js

```
require('apostrophe')({// other configuration optionsmodules: {// other project modulesblog: {},'blog-page': {}}});
```

The `blog-page` module also needs to be added to the `@apostrophecms/page` module `types` option array so that it can be selected in the page creation modal. In your ApostropheCMS project, open the `modules/@apostrophecms/page/index.js` file and add the `blog-page`.

modules/@apostrophecms/page/index.js

```
module.exports= {options: {types: [{name: '@apostrophecms/home-page',label: 'Home'},// Any other project pages{name: 'blog-page',label: 'Blog'}]}};
```


### Creating the blog schema


[Section titled Creating the blog schema](#creating-the-blog-schema)

In an ApostropheCMS project, editors are offered a set of input fields for adding content. Here is an example of a simple blog post that adds three input fields, an `authorName`, `publicationDate` and `content` area where content managers can add multiple widget instances. In this case, we are specifying they can add the image and rich-text widgets we created during the [integration setup](#connecting-apostrophecms-widgets-to-astro-components).

modules/blog/index.js

```
module.exports= {extend: '@apostrophecms/piece-type',options: {label: 'Blog',// Additionally add a `pluralLabel` option if needed.},fields: {add: {authorName: {type: 'string',label: 'Author'},publicationDate: {type: 'date',label: 'Publication date'},content: {type: 'area',label: 'Content',options: {widgets: {'@apostrophecms/rich-text': {},'@apostrophecms/image': {}}}}},group: {basics: {label: 'Basic',fields: [ 'authorName', 'publicationDate', 'content' ]}}}};
```

At this point, all the components coming from the ApostropheCMS project are set up. Start the local site from the command line using `npm run dev`, making sure to pass in the `APOS_EXTERNAL_FRONT_KEY` environment variable set to your selected string:

Terminal window

```
APOS_EXTERNAL_FRONT_KEY='MyRandomString'npmrundev
```


### Displaying the blog posts


[Section titled Displaying the blog posts](#displaying-the-blog-posts)

To display a page with all the blog posts create a `BlogIndex.astro` component file in the `src/templates` directory of your Astro project and add the following code:

After fetching both the page and pieces data from the `aposData` prop, this component creates markup using both fields from the blog piece schema we created, but also from the `piece.title` and `piece._url` that is added to each piece by Apostrophe.

src/templates/BlogIndex.astro

```
---import dayjs from'dayjs';const { page, pieces } = Astro.props.aposData;---<sectionclass="bp-content"><h1>{page.title}</h1><h2>Blog Posts</h2>{pieces.map(piece=> (<h4>Released On {dayjs(piece.publicationDate).format('MMMM D, YYYY') }</h4><h3><ahref={piece._url}>{piece.title}</a></h3><h4>{piece.authorName}</h4>))}</section>
```

To display individual blog posts, create a `BlogShow.astro` file in the Astro project `src/templates` folder with the following code:

This component uses the `<AposArea>` component to display any widgets added to the `content` area and the `authorName` and `publicationDate` content entered into the fields of the same names.

src/templates/BlogShow.astro

```
---import AposArea from'@apostrophecms/apostrophe-astro/components/AposArea.astro';import dayjs from'dayjs';const { page, piece } = Astro.props.aposData;const { main } = piece;---<sectionclass="bp-content"><h1>{piece.title}</h1><h3>Created by: {piece.authorName}<h4>Released On {dayjs(piece.publicationDate).format('MMMM D, YYYY') }</h4><AposAreaarea={content} /></section>
```

Finally, these Astro components must be mapped to the corresponding ApostropheCMS page types. Open the Astro project `src/templates/index.js` file and modify it to contain the following code:

src/templates/index.js

```
import HomePage from'./HomePage.astro';import BlogIndexPage from'./BlogIndexPage.astro';import BlogShowPage from'./BlogShowPage.astro';const templateComponents = {'@apostrophecms/home-page': HomePage,'@apostrophecms/blog-page:index': BlogIndexPage,'@apostrophecms/blog-page:show': BlogShowPage};exportdefaulttemplateComponents;
```


### Creating blog posts


[Section titled Creating blog posts](#creating-blog-posts)

Adding blog posts to your site is accomplished by using the ApostropheCMS content and management tools to create those posts and by publishing at least one index page to display them.

With the Astro dev server running, navigate to the login page located at [http://localhost:4321/login](http://localhost:4321/login) in your browser preview. Use the credentials that were added during the [creation of the ApostropheCMS project](https://docs.apostrophecms.org/guide/development-setup.html#creating-a-project) to log in as an administrator. Your ApostropheCMS project should still be running.

Once you are logged in, your browser will be redirected to the home page of your project and will display an admin bar at the top for editing content and managing your project.

To add your first blog post, click on the `Blogs` button in the admin bar to open the blog piece creation modal. Clicking on the `New Blog` button in the upper right will open an editing modal where you can add content. The `content` area field will allow you to add as many image and rich text widgets as you desire.

You can repeat this step and add as many posts as you want. You will also follow these steps every time you want to add a new post.

To publish a page for displaying all your posts, click on the `Pages` button in the admin bar. From the page tree modal click on the `New Page` button. In the `Type` dropdown in the right column select `Blog`. Add a title for the page and then click `Publish and View`. You will only need to do this once.

Any new blog posts that are created will be automatically displayed on this page. Individual blog posts can be displayed by clicking on the link created on the index page.

The `content` area of individual posts can be edited directly on the page by navigating to the post and clicking `edit` in the admin bar. Other fields can be edited by using the editing modal opened when clicking the `Blogs` menu item in the admin bar.


### Deploying your site


[Section titled Deploying your site](#deploying-your-site)

To deploy your website, you need to host both your Astro and ApostropheCMS projects.

For Astro, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

For the ApostropheCMS project, follow the instructions for your hosting type in our [hosting guide](https://docs.apostrophecms.org/guide/hosting.html). Finally, you’ll need to supply an `APOS_HOST` environment variable to the Astro project to reflect the correct URL where your ApostropheCMS site has been deployed.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Astro integration for ApostropheCMS](https://apostrophecms.com/extensions/astro-integration) - ApostropheCMS Astro plugin, integration guide and starter projects for both Apostrophe and Astro
-   [Sample Astro project for use with ApostropheCMS](https://github.com/apostrophecms/astro-frontend) - A simple Astro project with several pages and Apostrophe widgets already created.
-   [Sample ApostropheCMS starter-kit for use with Astro](https://apostrophecms.com/starter-kits/astro-integration-starter-kit) - An ApostropheCMS project with core page modifications for use with Astro.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Integrating ApostropheCMS with Astro, Pt. 1](https://apostrophecms.com/blog/how-to-integrate-astro-with-apostrophecms-pt-1) by Antonello Zaini
-   [Integrating ApostropheCMS with Astro, Pt. 2](https://apostrophecms.com/blog/how-to-integrate-astro-with-apostrophecms-pt-2) by Antonello Zaini
-   [Show & Tell Live | Astro & Apostrophe](https://youtu.be/cwJhtJhAhwA?si=6iUU9EjidfdnOdCh)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 25. `en/guides/cms/buttercms/.md`

```text
# ButterCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/buttercms/
description: Add content to your Astro project using ButterCMS
---


# ButterCMS & Astro


[ButterCMS](https://buttercms.com/) is a headless CMS and blog engine that allows you to publish structured content to use in your project.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

Note

For a full blog site example, see the [Astro + ButterCMS Starter Project](https://buttercms.com/starters/astro-starter-project/).

In this section, we’ll use the [ButterCMS SDK](https://www.npmjs.com/package/buttercms) to bring your data into your Astro project. To get started, you will need to have the following:


### Prerequisites


[Section titled Prerequisites](#prerequisites)

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A ButterCMS account**. If you don’t have an account, you can [sign up](https://buttercms.com/join/) for a free trial.

3.  **Your ButterCMS API Token** - You can find your API Token on the [Settings](https://buttercms.com/settings/) page.



### Setup


[Section titled Setup](#setup)

1.  Create a `.env` file in the root of your project and add your API token as an environment variable:

    .env

    ```
    BUTTER_TOKEN=YOUR_API_TOKEN_HERE
    ```

    Tip

    Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

2.  Install the ButterCMS SDK as a dependency:

    -   [npm](#tab-panel-3060)
    -   [pnpm](#tab-panel-3061)
    -   [Yarn](#tab-panel-3062)

    Terminal window

    ```
    npminstallbuttercms
    ```

    Terminal window

    ```
    pnpmaddbuttercms
    ```

    Terminal window

    ```
    yarnaddbuttercms
    ```

3.  Create a `buttercms.js` file in a new `src/lib/` directory in your project:

    src/lib/buttercms.js

    ```
    import Butter from"buttercms";export const butterClient = Butter(import.meta.env.BUTTER_TOKEN);
    ```


**This authenticates the SDK using your API Token and exports it to be used across your project.**


### Fetching Data


[Section titled Fetching Data](#fetching-data)

To fetch content, import this client and use one of its `retrieve` functions.

In this example, we [retrieve a collection](https://buttercms.com/docs/api/#retrieve-a-collection) that has three fields: a short text `name`, a number `price`, and a WYSIWYG `description`.

src/pages/ShopItem.astro

```
---import { butterClient } from"../lib/buttercms";const response = await butterClient.content.retrieve(["shopitem"]);interface ShopItem {name:string,price:number,description:string,}const items = response.data.data.shopitem as ShopItem[];---<body>{items.map(item=><div><h2>{item.name} - ${item.price}</h2><pset:html={item.description}></p></div>)}</body>
```

The interface mirrors the field types. The WYSIWYG `description` field loads as a string of HTML, and [`set:html`](/en/reference/directives-reference/#sethtml) lets you render it.

Similarly, you can [retrieve a page](https://buttercms.com/docs/api/#get-a-single-page) and display its fields:

src/pages/ShopItem.astro

```
---import { butterClient } from"../lib/buttercms";const response = await butterClient.page.retrieve("*", "simple-page");const pageData = response.data.data;interface Fields {seo_title:string,headline:string,hero_image:string,}const fields = pageData.fields as Fields;---<html><title>{fields.seo_title}</title><body><h1>{fields.headline}</h1><imgsrc={fields.hero_image} /></body></html>
```


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Astro + ButterCMS Starter Project](https://buttercms.com/starters/astro-starter-project/)
-   The [full ButterCMS API documentation](https://buttercms.com/docs/api/)
-   ButterCMS’s [JavaScript Guide](https://buttercms.com/docs/api-client/javascript/)


## Community Resources


[Section titled Community Resources](#community-resources)

-   Add yours!


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 26. `en/guides/cms/caisy/.md`

```text
# Caisy & Astro


---
url: https://docs.astro.build/en/guides/cms/caisy/
description: Add content to your Astro project using Caisy as a CMS
---


# Caisy & Astro


[Caisy](https://caisy.io/) is a headless CMS that exposes a GraphQL API to access content.


## Using Caisy CMS with Astro


[Section titled Using Caisy CMS with Astro](#using-caisy-cms-with-astro)

Use `graphql-request` and Caisy’s rich text renderer for Astro to fetch your CMS data and display your content on an Astro page:

src/pages/blog/\[...slug\].astro

```
---import RichTextRenderer from'@caisy/rich-text-astro-renderer';import { gql, GraphQLClient } from'graphql-request';const params = Astro.params;const client = newGraphQLClient(`https://cloud.caisy.io/api/v3/e/${import.meta.env.CAISY_PROJECT_ID}/graphql`,{headers: {'x-caisy-apikey': import.meta.env.CAISY_API_KEY}});const gqlResponse = await client.request(gql`query allBlogArticle($slug: String) {allBlogArticle(where: { slug: { eq: $slug } }) {edges {node {text {json}titleslugid}}}}`,{ slug: params.slug });const post = gqlResponse?.allBlogArticle?.edges?.[0]?.node;---<h1>{post.title}</h1><RichTextRenderernode={post.text.json} />
```


## Official Resources


[Section titled Official Resources](#official-resources)

-   Check out the Caisy + Astro example on [GitHub](https://github.com/caisy-io/caisy-example-astro) or [StackBlitz](https://stackblitz.com/github/caisy-io/caisy-example-astro?file=src%2Fpages%2Fblog%2F%5B...slug%5D.astro)
-   Query your documents in [draft mode](https://caisy.io/developer/docs/external-api/localization-and-preview#preview-mode-15) and multiple [locales](https://caisy.io/developer/docs/external-api/localization-and-preview#localization-in-a-graphql-query-8).
-   Use [pagination](https://caisy.io/developer/docs/external-api/queries-pagination) to query large numbers of documents.
-   Use [filter](https://caisy.io/developer/docs/external-api/external-filter-and-sorting) in your queries and [order](https://caisy.io/developer/docs/external-api/external-filter-and-sorting#sorting-8) the results


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 27. `en/guides/cms/cloudcannon/.md`

```text
# CloudCannon & Astro


---
url: https://docs.astro.build/en/guides/cms/cloudcannon/
description: Add content to your Astro project using CloudCannon as a CMS
---


# CloudCannon & Astro


[CloudCannon](https://cloudcannon.com) is a Git-based headless content management system that provides a visual editor for your content.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Astro Starter Template](https://cloudcannon.com/templates/astro-starter/)
-   [Astro Multilingual Starter Template](https://cloudcannon.com/templates/astro-multilingual-starter/)
-   [Astro Starter Guide](https://cloudcannon.com/documentation/guides/astro-starter-guide/)
-   [Bookshop & Astro Guide](https://cloudcannon.com/documentation/guides/bookshop-astro-guide/)
-   [Astro Beginner Tutorial Series](https://cloudcannon.com/tutorials/astro-beginners-tutorial-series/)
-   Blog: [How CloudCannon’s live editing works with Astro and Bookshop](https://cloudcannon.com/blog/how-cloudcannons-live-editing-works-with-astro-and-bookshop/)
-   Blog: [Out-of-this-world support for all Astro users](https://cloudcannon.com/blog/out-of-this-world-support-for-all-astro-users/)


## Community Resources


[Section titled Community Resources](#community-resources)

-   [CloudCannon announces official support for Astro](https://astro.build/blog/astro-cloudcannon-support/)


## Themes


[Section titled Themes](#themes)

-   [Sendit](https://astro.build/themes/details/sendit/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 28. `en/guides/cms/contentful/.md`

```text
# Contentful & Astro


---
url: https://docs.astro.build/en/guides/cms/contentful/
description: Add content to your Astro project using Contentful as a CMS
---


# Contentful & Astro


[Contentful](https://www.contentful.com/) is a headless CMS that allows you to manage content, integrate with other services, and publish to multiple platforms.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, we’ll use the [Contentful SDK](https://github.com/contentful/contentful.js) to connect your Contentful space to Astro with zero client-side JavaScript.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A Contentful account and a Contentful space**. If you don’t have an account, you can [sign up](https://www.contentful.com/sign-up/) for a free account and create a new Contentful space. You can also use an existing space if you have one.

3.  **Contentful credentials** - You can find the following credentials in your Contentful dashboard **Settings > API keys**. If you don’t have any API keys, create one by selecting **Add API key**.

    -   **Contentful space ID** - The ID of your Contentful space.
    -   **Contentful delivery access token** - The access token to consume *published* content from your Contentful space.
    -   **Contentful preview access token** - The access token to consume *unpublished* content from your Contentful space.


### Setting up credentials


[Section titled Setting up credentials](#setting-up-credentials)

To add your Contentful space’s credentials to Astro, create an `.env` file in the root of your project with the following variables:

.env

```
CONTENTFUL_SPACE_ID=YOUR_SPACE_IDCONTENTFUL_DELIVERY_TOKEN=YOUR_DELIVERY_TOKENCONTENTFUL_PREVIEW_TOKEN=YOUR_PREVIEW_TOKEN
```

Now, you can use these environment variables in your project.

If you would like to have IntelliSense for your Contentful environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly CONTENTFUL_SPACE_ID:string;readonly CONTENTFUL_DELIVERY_TOKEN:string;readonly CONTENTFUL_PREVIEW_TOKEN:string;}
```

Tip

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your root directory should now include these new files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect with your Contentful space, install both of the following using the single command below for your preferred package manager:

-   [`contentful.js`](https://github.com/contentful/contentful.js), the official Contentful SDK for JavaScript
-   [`rich-text-html-renderer`](https://github.com/contentful/rich-text/tree/master/packages/rich-text-html-renderer), a package to render Contentful’s rich text fields to HTML.

-   [npm](#tab-panel-3057)
-   [pnpm](#tab-panel-3058)
-   [Yarn](#tab-panel-3059)

Terminal window

```
npminstallcontentful@contentful/rich-text-html-renderer
```

Terminal window

```
pnpmaddcontentful@contentful/rich-text-html-renderer
```

Terminal window

```
yarnaddcontentful@contentful/rich-text-html-renderer
```

Next, create a new file called `contentful.ts` in the `src/lib/` directory of your project.

src/lib/contentful.ts

```
import*as contentful from"contentful";export const contentfulClient = contentful.createClient({space: import.meta.env.CONTENTFUL_SPACE_ID,accessToken: import.meta.env.DEV? import.meta.env.CONTENTFUL_PREVIEW_TOKEN: import.meta.env.CONTENTFUL_DELIVERY_TOKEN,host: import.meta.env.DEV ? "preview.contentful.com" : "cdn.contentful.com",});
```

The above code snippet creates a new Contentful client, passing in credentials from the `.env` file.

Caution

While in development mode, your content will be fetched from the **Contentful preview API**. This means that you will be able to see unpublished content from the Contentful web app.

At build time, your content will be fetched from the **Contentful delivery API**. This means that only published content will be available at build time.

Finally, your root directory should now include these new files:

-   Directorysrc/

    -   env.d.ts
    -   Directorylib/

        -   **contentful.ts**


-   .env
-   astro.config.mjs
-   package.json


### Fetching data


[Section titled Fetching data](#fetching-data)

Astro components can fetch data from your Contentful account by using the `contentfulClient` and specifying the `content_type`.

For example, if you have a “blogPost” content type that has a text field for a title and a rich text field for content, your component might look like this:

```
---import { contentfulClient } from"../lib/contentful";import { documentToHtmlString } from"@contentful/rich-text-html-renderer";importtype { EntryFieldTypes } from"contentful";interface BlogPost {contentTypeId:"blogPost",fields: {title: EntryFieldTypes.Textcontent: EntryFieldTypes.RichText,}}const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});---<body>{entries.items.map((item)=> (<section><h2>{item.fields.title}</h2><articleset:html={documentToHtmlString(item.fields.content)}></article></section>))}</body>
```

Tip

If you have an empty Contentful space, check out [setting up a Contentful model](#setting-up-a-contentful-model) to learn how to create a basic blog model for your content.

You can find more querying options in the [Contentful documentation](https://contentful.github.io/contentful.js/).


## Making a blog with Astro and Contentful


[Section titled Making a blog with Astro and Contentful](#making-a-blog-with-astro-and-contentful)

With the setup above, you are now able to create a blog that uses Contentful as the CMS.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  **A Contentful space** - For this tutorial we recommend starting with an empty space. If you already have a content model, feel free to use it, but you will need to modify our code snippets to match your content model.
2.  **An Astro project integrated with the [Contentful SDK](https://github.com/contentful/contentful.js)** - See [integrating with Astro](#integrating-with-astro) for more details on how to set up an Astro project with Contentful.


### Setting up a Contentful model


[Section titled Setting up a Contentful model](#setting-up-a-contentful-model)

Inside your Contentful space, in the **Content model** section, create a new content model with the following fields and values:

-   **Name:** Blog Post
-   **API identifier:** `blogPost`
-   **Description:** This content type is for a blog post

In your newly created content type, use the **Add Field** button to add 5 new fields with the following parameters:

1.  Text field
    -   **Name:** title
    -   **API identifier:** `title` (leave the other parameters as their defaults)
2.  Date and time field
    -   **Name:** date
    -   **API identifier:** `date`
3.  Text field
    -   **Name:** slug
    -   **API identifier:** `slug` (leave the other parameters as their defaults)
4.  Text field
    -   **Name:** description
    -   **API identifier:** `description`
5.  Rich text field
    -   **Name:** content
    -   **API identifier:** `content`

Click **Save** to save your changes.

In the **Content** section of your Contentful space, create a new entry by clicking the **Add Entry** button. Then, fill in the fields:

-   **Title:** `Astro is amazing!`
-   **Slug:** `astro-is-amazing`
-   **Description:** `Astro is a new static site generator that is blazing fast and easy to use.`
-   **Date:** `2022-10-05`
-   **Content:** `This is my first blog post!`

Click **Publish** to save your entry. You have just created your first blog post.

Feel free to add as many blog posts as you want, then switch to your favorite code editor to start hacking with Astro!


### Displaying a list of blog posts


[Section titled Displaying a list of blog posts](#displaying-a-list-of-blog-posts)

Create a new interface called `BlogPost` and add it to your `contentful.ts` file in `src/lib/`. This interface will match the fields of your blog post content type in Contentful. You will use it to type your blog post entries response.

src/lib/contentful.ts

```
import*as contentful from"contentful";importtype { EntryFieldTypes }from"contentful";exportinterface BlogPost {contentTypeId:"blogPost",fields: {title: EntryFieldTypes.Textcontent: EntryFieldTypes.RichText,date: EntryFieldTypes.Date,description: EntryFieldTypes.Text,slug: EntryFieldTypes.Text}}export const contentfulClient = contentful.createClient({space: import.meta.env.CONTENTFUL_SPACE_ID,accessToken: import.meta.env.DEV? import.meta.env.CONTENTFUL_PREVIEW_TOKEN: import.meta.env.CONTENTFUL_DELIVERY_TOKEN,host: import.meta.env.DEV ? "preview.contentful.com" : "cdn.contentful.com",});
```

Next, go to the Astro page where you will fetch data from Contentful. We will use the home page `index.astro` in `src/pages/` in this example.

Import `BlogPost` interface and `contentfulClient` from `src/lib/contentful.ts`.

Fetch all the entries from Contentful with a content type of `blogPost` while passing the `BlogPost` interface to type your response.

src/pages/index.astro

```
---import { contentfulClient } from"../lib/contentful";importtype { BlogPost } from"../lib/contentful";const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});---
```

This fetch call will return an array of your blog posts at `entries.items`. You can use `map()` to create a new array (`posts`) that formats your returned data.

The example below returns the `items.fields` properties from our Content model to create a blog post preview, and at the same time, reformats the date to a more readable format.

src/pages/index.astro

```
---import { contentfulClient } from"../lib/contentful";importtype { BlogPost } from"../lib/contentful";const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});const posts = entries.items.map((item) => {const { title, date, description, slug } = item.fields;return {title,slug,description,date: newDate(date).toLocaleDateString()};});---
```

Finally, you can use `posts` in your template to show a preview of each blog post.

src/pages/index.astro

```
---import { contentfulClient } from"../lib/contentful";importtype { BlogPost } from"../lib/contentful";const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});const posts = entries.items.map((item) => {const { title, date, description, slug } = item.fields;return {title,slug,description,date: newDate(date).toLocaleDateString()};});---<htmllang="en"><head><title>My Blog</title></head><body><h1>My Blog</h1><ul>{posts.map((post)=> (<li><ahref={`/posts/${post.slug}/`}><h2>{post.title}</h2></a><time>{post.date}</time><p>{post.description}</p></li>))}</ul></body></html>
```


### Generating individual blog posts


[Section titled Generating individual blog posts](#generating-individual-blog-posts)

Use the same method to fetch your data from Contentful as above, but this time, on a page that will create a unique page route for each blog post.


#### Static site generation


[Section titled Static site generation](#static-site-generation)

If you’re using Astro’s default static mode, you’ll use [dynamic routes](/en/guides/routing/#dynamic-routes) and the `getStaticPaths()` function. This function will be called at build time to generate the list of paths that become pages.

Create a new file named `[slug].astro` in `src/pages/posts/`.

As you did on `index.astro`, import the `BlogPost` interface and `contentfulClient` from `src/lib/contentful.ts`.

This time, fetch your data inside a `getStaticPaths()` function.

src/pages/posts/\[slug\].astro

```
---import { contentfulClient } from"../../lib/contentful";importtype { BlogPost } from"../../lib/contentful";exportasyncfunctiongetStaticPaths() {const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});}---
```

Then, map each item to an object with a `params` and `props` property. The `params` property will be used to generate the URL of the page and the `props` property will be passed to the page component as props.

src/pages/posts/\[slug\].astro

```
---import { contentfulClient } from"../../lib/contentful";import { documentToHtmlString } from"@contentful/rich-text-html-renderer";importtype { BlogPost } from"../../lib/contentful";exportasyncfunctiongetStaticPaths() {const entries = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});const pages = entries.items.map((item) => ({params: { slug: item.fields.slug },props: {title: item.fields.title,content: documentToHtmlString(item.fields.content),date: newDate(item.fields.date).toLocaleDateString(),},}));return pages;}---
```

The property inside `params` must match the name of the dynamic route. Since our filename is `[slug].astro`, we use `slug`.

In our example, the `props` object passes three properties to the page:

-   title (a string)
-   content (a rich text Document converted to HTML using `documentToHtmlString`)
-   date (formatted using the `Date` constructor)

Finally, you can use the page `props` to display your blog post.

src/pages/posts/\[slug\].astro

```
---import { contentfulClient } from"../../lib/contentful";import { documentToHtmlString } from"@contentful/rich-text-html-renderer";importtype { BlogPost } from"../../lib/contentful";exportasyncfunctiongetStaticPaths() {const { items } = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost",});const pages = items.map((item) => ({params: { slug: item.fields.slug },props: {title: item.fields.title,content: documentToHtmlString(item.fields.content),date: newDate(item.fields.date).toLocaleDateString(),},}));return pages;}const { content, title, date } = Astro.props;---<htmllang="en"><head><title>{title}</title></head><body><h1>{title}</h1><time>{date}</time><articleset:html={content} /></body></html>
```

Navigate to [http://localhost:4321/](http://localhost:4321/) and click on one of your posts to make sure your dynamic route is working!


#### On-demand rendering


[Section titled On-demand rendering](#on-demand-rendering)

If you’ve [opted into on-demand rendering with an adapter](/en/guides/on-demand-rendering/), you will use a dynamic route that uses a `slug` parameter to fetch the data from Contentful.

Create a `[slug].astro` page in `src/pages/posts`. Use [`Astro.params`](/en/reference/api-reference/#params) to get the slug from the URL, then pass that to `getEntries`:

src/pages/posts/\[slug\].astro

```
---import { contentfulClient } from"../../lib/contentful";importtype { BlogPost } from"../../lib/contentful";const { slug } = Astro.params;const data = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost","fields.slug": slug,});---
```

If the entry is not found, you can redirect the user to the 404 page using [`Astro.redirect`](/en/guides/routing/#dynamic-redirects).

src/pages/posts/\[slug\].astro

```
---import { contentfulClient } from"../../lib/contentful";importtype { BlogPost } from"../../lib/contentful";const { slug } = Astro.params;try {const data = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost","fields.slug": slug,});} catch (error) {return Astro.redirect("/404");}---
```

To pass post data to the template section, create a `post` object outside the `try/catch` block.

Use `documentToHtmlString` to convert `content` from a Document to HTML, and use the Date constructor to format the date. `title` can be left as-is. Then, add these properties to your `post` object.

src/pages/posts/\[slug\].astro

```
---import Layout from"../../layouts/Layout.astro";import { contentfulClient } from"../../lib/contentful";import { documentToHtmlString } from"@contentful/rich-text-html-renderer";importtype { BlogPost } from"../../lib/contentful";let post;const { slug } = Astro.params;try {const data = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost","fields.slug": slug,});const { title, date, content } = data.items[0].fields;post = {title,date: newDate(date).toLocaleDateString(),content: documentToHtmlString(content),};} catch (error) {return Astro.redirect("/404");}---
```

Finally, you can reference `post` to display your blog post in the template section.

src/pages/posts/\[slug\].astro

```
---import Layout from"../../layouts/Layout.astro";import { contentfulClient } from"../../lib/contentful";import { documentToHtmlString } from"@contentful/rich-text-html-renderer";importtype { BlogPost } from"../../lib/contentful";let post;const { slug } = Astro.params;try {const data = await contentfulClient.getEntries<BlogPost>({content_type: "blogPost","fields.slug": slug,});const { title, date, content } = data.items[0].fields;post = {title,date: newDate(date).toLocaleDateString(),content: documentToHtmlString(content),};} catch (error) {return Astro.redirect("/404");}---<htmllang="en"><head><title>{post?.title}</title></head><body><h1>{post?.title}</h1><time>{post?.date}</time><articleset:html={post?.content} /></body></html>
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


#### Rebuild on Contentful changes


[Section titled Rebuild on Contentful changes](#rebuild-on-contentful-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Contentful events.


##### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



##### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



##### Adding a webhook to Contentful


[Section titled Adding a webhook to Contentful](#adding-a-webhook-to-contentful)

In your Contentful space **settings**, click on the **Webhooks** tab and create a new webhook by clicking the **Add Webhook** button. Provide a name for your webhook and paste the webhook URL you copied in the previous section. Finally, hit **Save** to create the webhook.

Now, whenever you publish a new blog post in Contentful, a new build will be triggered and your blog will be updated.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 29. `en/guides/cms/cosmic/.md`

```text
# Cosmic & Astro


---
url: https://docs.astro.build/en/guides/cms/cosmic/
description: Add content to your Astro project using Cosmic as a CMS
---


# Cosmic & Astro


[Cosmic](https://www.cosmicjs.com/) is a [headless CMS](https://www.cosmicjs.com/headless-cms) that provides an admin dashboard to manage content and an API that can integrate with a diverse range of frontend tools.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

1.  **An Astro project**\- If you’d like to start with a fresh Astro project, read the [installation guide](/en/install-and-setup/). This guide follows a simplified version of the [Astro Headless CMS Theme](https://astro.build/themes/details/cosmic-cms-blog/) with [Tailwind CSS](https://tailwindcss.com/) for styling.
2.  **A Cosmic account and Bucket** - [Create a free Cosmic account](https://app.cosmicjs.com/signup) if you don’t have one. After creating your account, you’ll be prompted to create a new empty project. There’s also a [Simple Astro Blog template](https://www.cosmicjs.com/marketplace/templates/simple-astro-blog) available (this is the same template as the Astro Headless CMS Theme) to automatically import all of the content used in this guide.
3.  **Your Cosmic API keys** - From your Cosmic dashboard, you will need to locate both the **Bucket slug** and **Bucket read key** in order to connect to Cosmic.


## Integrating Cosmic with Astro


[Section titled Integrating Cosmic with Astro](#integrating-cosmic-with-astro)


### Installing Necessary Dependencies


[Section titled Installing Necessary Dependencies](#installing-necessary-dependencies)

Add the [Cosmic JavaScript SDK](https://www.npmjs.com/package/@cosmicjs/sdk) to fetch data from your Cosmic Bucket.

-   [npm](#tab-panel-3063)
-   [pnpm](#tab-panel-3064)
-   [Yarn](#tab-panel-3065)

Terminal window

```
npminstall@cosmicjs/sdk
```

Terminal window

```
pnpmadd@cosmicjs/sdk
```

Terminal window

```
yarnadd@cosmicjs/sdk
```


### Configuring API Keys


[Section titled Configuring API Keys](#configuring-api-keys)

Create a `.env` file at the root of your Astro project (if it does not already exist). Add both the **Bucket slug** and **Bucket read key** available from your Cosmic dashboard as public environment variables.

.env

```
PUBLIC_COSMIC_BUCKET_SLUG=YOUR_BUCKET_SLUGPUBLIC_COSMIC_READ_KEY=YOUR_READ_KEY
```


## Fetching Data from Cosmic


[Section titled Fetching Data from Cosmic](#fetching-data-from-cosmic)

1.  Create a new file called `cosmic.js`. Place this file inside of the `src/lib` folder in your project.

2.  Add the following code to fetch data from Cosmic using the SDK and your environment variables.

    The example below creates a function called `getAllPosts()` to fetch metadata from Cosmic `posts` objects:

    src/lib/cosmic.js

    ```
    import { createBucketClient } from'@cosmicjs/sdk'const cosmic = createBucketClient({bucketSlug: import.meta.env.PUBLIC_COSMIC_BUCKET_SLUG,readKey: import.meta.env.PUBLIC_COSMIC_READ_KEY})exportasyncfunctiongetAllPosts() {const data = await cosmic.objects.find({type: 'posts'}).props('title,slug,metadata,created_at')returndata.objects}
    ```

    Read more about [queries in the Cosmic documentation](https://www.cosmicjs.com/docs/api/queries).

3.  Import your query function in a `.astro` component. After fetching data, the results from the query can be used in your Astro template.

    The following example shows fetching metadata from Cosmic `posts` and passing these values as props to a `<Card />` component to create a list of blog posts:

    src/pages/index.astro

    ```
    ---import Card from'../components/Card.astro'import { getAllPosts } from'../lib/cosmic'const data = await getAllPosts()---<section><ulclass="grid gap-8 md:grid-cols-2">{data.map((post)=> (<Cardtitle={post.title}href={post.slug}body={post.metadata.excerpt}tags={post.metadata.tags.map((tag)=>tag)}/>))}</ul></section>
    ```

    [View source code for the Card component](https://github.com/cosmicjs/simple-astro-blog/blob/main/src/components/Card.astro)



## Building a Blog with Astro and Cosmic


[Section titled Building a Blog with Astro and Cosmic](#building-a-blog-with-astro-and-cosmic)

You can manage your Astro blog’s content using Cosmic and create webhooks to automatically redeploy your website when you update or add new content.


### Cosmic Content Objects


[Section titled Cosmic Content Objects](#cosmic-content-objects)

The following instructions assume that you have an **Object Type** in Cosmic called **posts**. Each individual blog post is a `post` that is defined in the Cosmic dashboard with the following Metafields:

1.  **Text input** - Author
2.  **Image** - Cover Image
3.  **Repeater** - Tags
    -   **Text input** - Title
4.  **Text area** - Excerpt
5.  **Rich Text** - Content


### Displaying a List of Blog Posts in Astro


[Section titled Displaying a List of Blog Posts in Astro](#displaying-a-list-of-blog-posts-in-astro)

Using the same [data-fetching method](#fetching-data-from-cosmic) as above, import the `getAllPosts()` query from your script file and await the data. This function provides metadata about each `post` which can be displayed dynamically.

The example below passes these values to a `<Card />` component to display a formatted list of blog posts:

src/pages/index.astro

```
---import Card from'../components/Card.astro'import { getAllPosts } from'../lib/cosmic'const data = await getAllPosts()---<section><ulclass="grid gap-8 md:grid-cols-2">{data.map((post)=> (<Cardtitle={post.title}href={post.slug}body={post.metadata.excerpt}tags={post.metadata.tags.map((tag)=>tag)}/>))}</ul></section>
```


### Generating Individual Blog Posts with Astro


[Section titled Generating Individual Blog Posts with Astro](#generating-individual-blog-posts-with-astro)

To generate an individual page with full content for each blog post, create a [dynamic routing page](/en/guides/routing/#dynamic-routes) at `src/pages/blog/[slug].astro`.

This page will export a `getStaticPaths()` function to generate a page route at the `slug` returned from each `post` object. This function is called at build time and generates and renders all of your blog posts at once.

To access your data from Cosmic:

-   Query Cosmic inside of `getStaticPaths()` to fetch data about each post and provide it to the function.
-   Use each `post.slug` as a route parameter, creating the URLs for each blog post.
-   Return each `post` inside of `Astro.props`, making the post data available to HTML template portion of the page component for rendering.

The HTML markup below uses various data from Cosmic, such as the post title, cover image, and the **rich text content** (full blog post content). Use [set:html](/en/reference/directives-reference/#sethtml) on the element displaying the rich text content from Cosmic to render HTML elements on the page exactly as fetched from Cosmic.

src/pages/blog/\[slug\].astro

```
---import { getAllPosts } from'../../lib/cosmic'import { Image } from'astro:assets'exportasyncfunctiongetStaticPaths() {const data = (await getAllPosts()) | []return data.map((post)=> {return {params: { slug: post.slug },props: { post }}})}const { post } = Astro.props---<articleclass="mx-auto max-w-screen-md pt-20"><sectionclass="border-b pb-8"><h1class="text-4xl font-bold">{post.title}</h1><divclass="my-4"></div><spanclass="text-sm font-semibold">{post.metadata.author?.title}</span></section>{post.metadata.cover_image&& (<Imagesrc={post.metadata.cover_image.imgix_url}format="webp"width={1200}height={675}aspectRatio={16/9}quality={50}alt={`Cover image for the blog ${post.title}`}class={'my-12 rounded-md shadow-lg'}/>)}<divset:html={post.metadata.content} /></article>
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit the [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


#### Rebuild on Cosmic content updates


[Section titled Rebuild on Cosmic content updates](#rebuild-on-cosmic-content-updates)

You can set up a webhook in Cosmic directly to trigger a redeploy of your site on your hosting platform (e.g. Vercel) whenever you update or add content Objects.

Under “Settings” > “webhooks”, add the URL endpoint from Vercel and select the Object Type you would like to trigger the webhook. Click “Add webhook” to save it.


##### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



##### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



## Themes


[Section titled Themes](#themes)

-   [Astro Headless CMS Blog](https://astro.build/themes/details/cosmic-cms-blog/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 30. `en/guides/cms/craft-cms/.md`

```text
# Craft CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/craft-cms/
description: Add content to your Astro project using Craft CMS as a CMS
---


# Craft CMS & Astro


[Craft CMS](https://craftcms.com/) is a flexible open source CMS with an accessible authoring experience. It includes its own front end, but can also be used as a headless CMS to provide content to your Astro project.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Check out the official Craft CMS [GraphQL API guide](https://craftcms.com/docs/5.x/development/graphql.html)
-   The official documentation for Craft’s [`headlessMode` config setting](https://craftcms.com/docs/5.x/reference/config/general.html#headlessmode)


## Community Resources


[Section titled Community Resources](#community-resources)

-   [SSG Astro with Headless Craft CMS Content Fetched At Build Time](https://www.olets.dev/posts/ssg-astro-with-headless-craft-cms-content-fetched-at-build-time/)
-   [SSG Astro with Headless Craft CMS Content Fetched At Build Time Or Cached In Advance](https://www.olets.dev/posts/ssg-astro-with-headless-craft-cms-content-fetched-at-build-time-or-cached-in-advance/)
-   [SSR Astro With Headless Craft CMS](https://www.olets.dev/posts/ssr-astro-with-headless-craft-cms/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 31. `en/guides/cms/crystallize/.md`

```text
# Crystallize & Astro


---
url: https://docs.astro.build/en/guides/cms/crystallize/
description: Add content to your Astro project using Crystallize as a CMS
---


# Crystallize & Astro


[Crystallize](https://crystallize.com/) is a headless content management system for eCommerce that exposes a GraphQL API.


## Example


[Section titled Example](#example)

src/pages/index.astro

```
---// Fetch your catalogue paths from Crystallize GraphQL APIimport BaseLayout from'../../layouts/BaseLayout.astro';import { createClient } from'@crystallize/js-api-client';const apiClient = createClient({tenantIdentifier: 'furniture'});const query = `query getCataloguePaths{catalogue(language: "en", path: "/shop") {namechildren {namepath}}}`const { data: { catalogue } } = await apiClient.catalogueApi(query)---<BaseLayout><h1>{catalogue.name}</h1><nav><ul>{catalogue.children.map(child=> (<li><ahref={child.path}>{child.name}</a></li>))}</ul></nav></BaseLayout>
```


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 32. `en/guides/cms/datocms/.md`

```text
# DatoCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/datocms/
description: Add content to your Astro project using DatoCMS
---


# DatoCMS & Astro


[DatoCMS](https://datocms.com/) is a web-based, headless CMS to manage digital content for your sites and apps.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this guide, you will fetch content data from DatoCMS in your Astro project, then display it on a page.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

-   **An Astro project** - If you don’t have an Astro project yet, you can follow the instructions in our [Installation guide](/en/install-and-setup/).
-   **A DatoCMS account and project** - If you don’t have an account, you can [sign up for a free account](https://dashboard.datocms.com/signup).
-   **The read-only API Key for your DatoCMS project** - You can find it in the admin dashboard of your project, under “Settings” > “API Tokens”.


## Setting up the credentials


[Section titled Setting up the credentials](#setting-up-the-credentials)

Create a new file (if one does not already exist) named `.env` in the root of your Astro project. Add a new environment variable as follows, using the API key found in your DatoCMS admin dashboard:

.env

```
DATOCMS_API_KEY=YOUR_API_KEY
```

For TypeScript support, declare the typing of this environment variable in the `env.d.ts` file in the `src/` folder. If this file does not exist, you can create it and add the following:

src/env.d.ts

```
interface ImportMetaEnv {readonly DATOCMS_API_KEY:string;}
```

Your root directory should now include these files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


## Create a Model in DatoCMS


[Section titled Create a Model in DatoCMS](#create-a-model-in-datocms)

In the DatoCMS admin dashboard of your project, navigate to “Settings” > “Models” and create a new Model called “Home” with the “Single Instance” toggle selected. This will create a home page for your project. In this model, add a new text field for the page title.

Navigate to the “Content” tab in your project and click on your newly-created home page. You can now add a title. Save the page, and continue.


## Fetching data


[Section titled Fetching data](#fetching-data)

In your Astro project, navigate to the page that will fetch and display your CMS content. Add the following query to fetch the content for `home` using the DatoCMS GraphQL API.

This example displays the page title from DatoCMS on `src/pages/index.astro`:

src/pages/index.astro

```
---const response = await fetch('https://graphql.datocms.com/', {method: 'POST',headers: {'Content-Type': 'application/json',Accept: 'application/json',Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,},body: JSON.stringify({query: `query Homepage {home {title}}`,}),});const json = await response.json();const data = json.data.home;---<h1>{data.title}</h1>
```

This GraphQL query will fetch the `title` field in the `home` page from your DatoCMS Project. When you refresh your browser, you should see the title on your page.


## Adding Dynamic modular content blocks


[Section titled Adding Dynamic modular content blocks](#adding-dynamic-modular-content-blocks)

If your DatosCMS project includes [modular content](https://www.datocms.com/docs/content-modelling/modular-content), then you will need to build a corresponding `.astro` component for each block of content (e.g. a text section, a video, a quotation block, etc.) that the modular field allows in your project.

The example below is a `<Text />` Astro component for displaying a “Multiple-paragraph text” block from DatoCMS.

src/components/Text.astro

```
---exportinterface TextProps {text:string}exportinterface Props {item:TextProps}const { item } = Astro.props;---<divset:html={item.text} />
```

To fetch these blocks, edit your GraphQL query to include the modular content block you created in DatoCMS.

In this example, the modular content block is named **content** in DatoCMS. This query also includes the unique `_modelApiKey` of each item to check which block should be displayed in the modular field, based on which block was chosen by the content author in the DatoCMS editor. Use a switch statement in the Astro template to allow for dynamic rendering based on the data received from the query.

The following example represents a DatoCMS modular content block that allows an author to choose between a text field (`<Text />`) and an image (`<Image />`) rendered on the home page:

src/pages/index.astro

```
---import Image from'../components/Image.astro';import Text from'../components/Text.astro';const response = await fetch('https://graphql.datocms.com/', {method: 'POST',headers: {'Content-Type': 'application/json',Accept: 'application/json',Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,},body: JSON.stringify({query: `query Homepage {home {titlecontent {... on ImageRecord {_modelApiKeyimage{url}}... on TextRecord {_modelApiKeytext(markdown: true)}}}}`,}),});const json = await response.json();const data = json.data.home;---<h1>{data.title}</h1>{data.content.map((item:any)=> {switch (item._modelApiKey) {case'image':return<Imageitem={item} />;case'text':return<Textitem={item} />;default:returnnull;}})}
```


## Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Publish on DatoCMS content changes


[Section titled Publish on DatoCMS content changes](#publish-on-datocms-content-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build when you change content in DatoCMS.


### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



### Adding a webhook to DatoCMS


[Section titled Adding a webhook to DatoCMS](#adding-a-webhook-to-datocms)

In your DatoCMS project admin dashboard, navigate to the **Settings** tab and click **Webhooks**. Click the plus icon to create a new webhook and give it a name. In the URL field, paste the URL generated by your preferred hosting service. As Trigger, select whichever option suits your needs. (For example: build every time a new record is published.)


## Starter project


[Section titled Starter project](#starter-project)

You can also check out the [Astro blog template](https://www.datocms.com/marketplace/starters/astro-template-blog) on the DatoCMS marketplace to learn how to create a blog with Astro and DatoCMS.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 33. `en/guides/cms/decap-cms/.md`

```text
# Decap CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/decap-cms/
description: Add content to your Astro project using Decap as a CMS
---


# Decap CMS & Astro


[Decap CMS](https://www.decapcms.org/) (formerly Netlify CMS) is an open-source, Git-based content management system.

Decap allows you to take full advantage of all of Astro’s features, including image optimization and content collections.

Decap adds a route (typically `/admin`) to your project that will load a React app to allow authorized users to manage content directly from the deployed website. Decap will commit changes directly to your Astro project’s source repository.


## Installing DecapCMS


[Section titled Installing DecapCMS](#installing-decapcms)

There are two options for adding Decap to Astro:

1.  [Install Decap via a package manager](https://decapcms.org/docs/install-decap-cms/#installing-with-npm) with the following command:

    -   [npm](#tab-panel-3066)
    -   [pnpm](#tab-panel-3067)
    -   [Yarn](#tab-panel-3068)

    Terminal window

    ```
    npminstalldecap-cms-app
    ```

    Terminal window

    ```
    pnpmadddecap-cms-app
    ```

    Terminal window

    ```
    yarnadddecap-cms-app
    ```

2.  Import the package into a `<script>` tag in your page `<body>`

    /admin

    ```
    <body><!-- Include the script that builds the page and powers Decap CMS --><scriptsrc="https://unpkg.com/decap-cms@^3.1.2/dist/decap-cms.js"></script></body>
    ```



## Configuration


[Section titled Configuration](#configuration)

1.  Create a static admin folder at `public/admin/`

2.  Add `config.yml` to `public/admin/`:

    -   Directorypublic

        -   Directoryadmin

            -   config.yml



3.  To add support for content collections, configure each schema in `config.yml`. The following example configures a `blog` collection, defining a `label` for each entry’s frontmatter property:

    /public/admin/config.yml

    ```
    collections:- name: "blog"# Used in routes, e.g., /admin/collections/bloglabel: "Blog"# Used in the UIfolder: "src/content/blog"# The path to the folder where the documents are storedcreate: true# Allow users to create new documents in this collectionfields: # The fields for each document, usually in frontmatter- { label: "Layout", name: "layout", widget: "hidden", default: "blog" }- { label: "Title", name: "title", widget: "string" }- { label: "Publish Date", name: "date", widget: "datetime" }- { label: "Featured Image", name: "thumbnail", widget: "image" }- { label: "Rating (scale of 1-5)", name: "rating", widget: "number" }- { label: "Body", name: "body", widget: "markdown" }
    ```

4.  Add the `admin` route for your React app in `src/pages/admin.html`.

    -   Directorypublic

        -   Directoryadmin

            -   config.yml


    -   Directorysrc

        -   Directorypages

            -   admin.html



    /src/pages/admin.html

    ```
    <!doctypehtml><htmllang="en"><head><metacharset="utf-8" /><metaname="viewport"content="width=device-width, initial-scale=1.0" /><metaname="robots"content="noindex" /><linkhref="/admin/config.yml"type="text/yaml"rel="cms-config-url" /><title>Content Manager</title></head><body><scriptsrc="https://unpkg.com/decap-cms@^3.1.2/dist/decap-cms.js"></script></body></html>
    ```

5.  To enable media uploads to a specific folder via the Decap editor, add an appropriate path:

    /public/admin/config.yml

    ```
    media_folder: "src/assets/images"# Location where files will be stored in the repopublic_folder: "src/assets/images"# The src attribute for uploaded media
    ```


See [the Decap CMS configuration documentation](https://decapcms.org/docs/configure-decap-cms/) for full instructions and options.


## Usage


[Section titled Usage](#usage)

Navigate to `yoursite.com/admin/` to use the Decap CMS editor.


## Authentication


[Section titled Authentication](#authentication)


### Decap CMS with Netlify Identity


[Section titled Decap CMS with Netlify Identity](#decap-cms-with-netlify-identity)

Decap CMS was originally developed by Netlify and has first class support for [Netlify Identity](https://docs.netlify.com/security/secure-access-to-sites/identity/).

When deploying to Netlify, configure Identity for your project via the Netlify dashboard and include the [Netlify Identity Widget](https://github.com/netlify/netlify-identity-widget) on the `admin` route of your project. Optionally include the Identity Widget on the homepage of your site if you plan to invite new users via email.


### Decap CMS with External OAuth Clients


[Section titled Decap CMS with External OAuth Clients](#decap-cms-with-external-oauth-clients)

When deploying to hosting providers other than Netlify, you must create your own OAuth routes.

In Astro, this can be done with on-demand rendered routes in your project configured with [an adapter](/en/guides/on-demand-rendering/) enabled.

See [Decap’s OAuth Docs](https://decapcms.org/docs/external-oauth-clients/) for a list of compatible community-maintained OAuth clients.


## Community Resources


[Section titled Community Resources](#community-resources)

-   Netlify Identity Template: [astro-decap-ssg-netlify](https://github.com/OliverSpeir/astro-decap-ssg-netlify-identity)

-   On-demand rendering OAuth Routes with Astro Template: [astro-decap-starter-ssr](https://github.com/OliverSpeir/astro-decap-starter-ssr)

-   Blog Post: [Author your Astro site’s content with Git-based CMSs](https://aalam.vercel.app/blog/astro-and-git-cms-netlify) by Aftab Alam

-   Youtube Tutorial: [Create a Custom Blog with Astro & NetlifyCMS in MINUTES!](https://www.youtube.com/watch?v=3yip2wSRX_4) by Kumail Pirzada



## Production Sites


[Section titled Production Sites](#production-sites)

The following sites use Astro + Decap CMS in production:

-   [yunielacosta.com](https://www.yunielacosta.com/) by Yuniel Acosta — [source code on GitHub](https://github.com/yacosta738/yacosta738.github.io) (Netlify CMS)
-   [portfolioris.nl](https://www.portfolioris.nl/) by Joris Hulsbosch – [source code on GitHub](https://github.com/portfolioris/portfolioris.nl)


## Themes


[Section titled Themes](#themes)

-   [Astros](https://astro.build/themes/details/astros)
-   [Enhanced Astro Starter](https://astro.build/themes/details/enhanced-astro-starter)
-   [Astro Decap CMS Starter](https://astro.build/themes/details/astro-decap-cms-starter)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 34. `en/guides/cms/directus/.md`

```text
# Directus & Astro


---
url: https://docs.astro.build/en/guides/cms/directus/
description: Add content to your Astro project using Directus as a CMS
---


# Directus & Astro


[Directus](https://directus.io/) is a backend-as-a-service which can be used to host data and content for your Astro project.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Getting Started with Directus and Astro](https://docs.directus.io/blog/getting-started-directus-astro.html).


## Community Resources


[Section titled Community Resources](#community-resources)

[Using Directus CMS with Neon Postgres and Astro to build a blog](https://neon.tech/guides/directus-cms)

Have a resource to share?

If you found (or made!) a helpful video or blog post about using Directus with Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/cms/directus.mdx)!


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 35. `en/guides/cms/drupal/.md`

```text
# Drupal & Astro


---
url: https://docs.astro.build/en/guides/cms/drupal/
description: Add content to your Astro project using Drupal as a CMS
---


# Drupal & Astro


[Drupal](https://www.drupal.org/) is an open-source content management tool.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A Drupal site** - If you haven’t set up a Drupal site, you can follow the official guidelines [Installing Drupal](https://www.drupal.org/docs/getting-started/installing-drupal).



## Integrating Drupal with Astro


[Section titled Integrating Drupal with Astro](#integrating-drupal-with-astro)


### Installing the JSON:API Drupal module


[Section titled Installing the JSON:API Drupal module](#installing-the-jsonapi-drupal-module)

To be able to get content from Drupal you need to enable the [Drupal JSON:API module](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module).

1.  Navigate to the Extend page `admin/modules` via the Manage administrative menu
2.  Locate the JSON:API module and check the box next to it
3.  Click Install to install the new module

Now you can make `GET` requests to your Drupal application through JSON:API.


### Adding the Drupal URL in `.env`


[Section titled Adding the Drupal URL in .env](#adding-the-drupal-url-in-env)

To add your Drupal URL to Astro, create a `.env` file in the root of your project (if one does not already exist) and add the following variable:

.env

```
DRUPAL_BASE_URL="https://drupal.ddev.site/"
```

Restart the dev server to use this environment variable in your Astro project.


### Setting up Credentials


[Section titled Setting up Credentials](#setting-up-credentials)

By default, the Drupal JSON:API endpoint is accessible for external data-fetching requests without requiring authentication. This allows you to fetch data for your Astro project without credentials but it does not permit users to modify your data or site settings.

However, if you wish to restrict access and require authentication, Drupal provides [several authentication methods](https://www.drupal.org/docs/contributed-modules/api-authentication) including:

-   [Basic Authentication](https://www.drupal.org/docs/contributed-modules/api-authentication/setup-basic-authentication)
-   [API Key-based authentication](https://www.drupal.org/docs/contributed-modules/api-authentication/api-key-authentication)
-   [Access Token/OAuth-based authentication](https://www.drupal.org/docs/contributed-modules/api-authentication/setup-access-token-oauth-based-authentication)
-   [JWT Token-based authentication](https://www.drupal.org/docs/contributed-modules/api-authentication/jwt-authentication)
-   [Third-Party Provider token authentication](https://www.drupal.org/docs/contributed-modules/api-authentication/rest-api-authentication-using-external-identity-provider)

You can add your credentials to your `.env` file.

.env

```
DRUPAL_BASIC_USERNAME="editor"DRUPAL_BASIC_PASSWORD="editor"DRUPAL_JWT_TOKEN="abc123"...
```

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your root directory should now include this new files:

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

JSON:API requests and responses can often be complex and deeply nested. To simplify working with them, you can use two npm packages that streamline both the requests and the handling of responses:

-   [`JSONA`](https://www.npmjs.com/package/jsona): JSON API v1.0 specification serializer and deserializer for use on the server and in the browser.
-   [`Drupal JSON-API Params`](https://www.npmjs.com/package/drupal-jsonapi-params): This module provides a helper Class to create the required query. While doing so, it also tries to optimise the query by using the short form, whenever possible.

-   [npm](#tab-panel-3075)
-   [pnpm](#tab-panel-3076)
-   [Yarn](#tab-panel-3077)

Terminal window

```
npminstalljsonadrupal-jsonapi-params
```

Terminal window

```
pnpmaddjsonadrupal-jsonapi-params
```

Terminal window

```
yarnaddjsonadrupal-jsonapi-params
```


## Fetching data from Drupal


[Section titled Fetching data from Drupal](#fetching-data-from-drupal)

Your content is fetched from a JSON:API URL.


### Drupal JSON:API URL structure


[Section titled Drupal JSON:API URL structure](#drupal-jsonapi-url-structure)

The basic URL structure is: `/jsonapi/{entity_type_id}/{bundle_id}`

The URL is always prefixed by `jsonapi`.

-   The `entity_type_id` refers to the Entity Type, such as node, block, user, etc.
-   The `bundle_id` refers to the Entity Bundles. In the case of a Node entity type, the bundle could be article.
-   In this case, to get the list of all articles, the URL will be `[DRUPAL_BASE_URL]/jsonapi/node/article`.

To retrieve an individual entity, the URL structure will be `/jsonapi/{entity_type_id}/{bundle_id}/{uuid}`, where the uuid is the UUID of the entity. For example the URL to get a specific article will be of the form `/jsonapi/node/article/2ee9f0ef-1b25-4bbe-a00f-8649c68b1f7e`.


#### Retrieving only certain fields


[Section titled Retrieving only certain fields](#retrieving-only-certain-fields)

Retrieve only certain field by adding the Query String field to the request.

GET: `/jsonapi/{entity_type_id}/{bundle_id}?field[entity_type]=field_list`

Examples:

-   `/jsonapi/node/article?fields[node--article]=title,created`
-   `/jsonapi/node/article/2ee9f0ef-1b25-4bbe-a00f-8649c68b1f7e?fields[node--article]=title,created,body`


#### Filtering


[Section titled Filtering](#filtering)

Add a filter to your request by adding the filter Query String.

The simplest, most common filter is a key-value filter:

GET: `/jsonapi/{entity_type_id}/{bundle_id}?filter[field_name]=value&filter[field_other]=value`

Examples:

-   `/jsonapi/node/article?filter[title]=Testing JSON:API&filter[status]=1`
-   `/jsonapi/node/article/2ee9f0ef-1b25-4bbe-a00f-8649c68b1f7e?fields[node--article]=title&filter[title]=Testing JSON:API`

You can find more query options in the [JSON:API Documentation](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module).


### Building a Drupal query


[Section titled Building a Drupal query](#building-a-drupal-query)

Astro components can fetch data from your Drupal site by using `drupal-jsonapi-params` package to build the query.

The following example shows a component with a query for an “article” content type that has a text field for a title and a rich text field for content:

```
---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";// Get the Drupal base URLexport const baseUrl:string = import.meta.env.DRUPAL_BASE_URL;// Generate the JSON:API Query. Get all title and body from published articles.const params:DrupalJsonApiParams = newDrupalJsonApiParams();params.addFields("node--article", ["title","body",]).addFilter("status", "1");// Generates the query string.const path:string = params.getQueryString();const url:string = baseUrl + '/jsonapi/node/article?' + path;// Get the articlesconst request:Response = await fetch(url);const json:string|TJsonApiBody = await request.json();// Initiate Jsona.const dataFormatter:Jsona = newJsona();// Deserialise the response.const articles = dataFormatter.deserialize(json);---<body>{articles?.length? articles.map((article:any)=> (<section><h2>{article.title}</h2><articleset:html={article.body.value}></article></section>)):<div><h1>No Content found</h1></div>}</body>
```

You can find more querying options in the [Drupal JSON:API Documentation](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/jsonapi)


## Making a blog with Astro and Drupal


[Section titled Making a blog with Astro and Drupal](#making-a-blog-with-astro-and-drupal)

With the setup above, you are now able to create a blog that uses Drupal as the CMS.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  **An Astro project** with [`JSONA`](https://www.npmjs.com/package/jsona) and [`Drupal JSON-API Params`](https://www.npmjs.com/package/drupal-jsonapi-params) installed.

2.  **A Drupal site with at least one entry** - For this tutorial we recommend starting with a new Drupal site with Standard installation.

    In the **Content** section of your Drupal site, create a new entry by clicking the **Add** button. Then, choose Article and fill in the fields:

    -   **Title:** `My first article for Astro!`
    -   **Alias:** `/articles/first-article-for astro`
    -   **Description:** `This is my first Astro article! Let's see what it will look like!`

    Click **Save** to create your first Article. Feel free to add as many articles as you want.



### Displaying a list of articles


[Section titled Displaying a list of articles](#displaying-a-list-of-articles)

1.  Create `src/types.ts` if it does not already exist and add two new interfaces called `DrupalNode` and `Path` with the following code. These interfaces will match the fields of your article content type in Drupal and the Path fields. You will use it to type your article entries response.

    src/types.ts

    ```
    exportinterface Path {alias:stringpid:numberlangcode:string}exportinterface DrupalNode extendsRecord<string, any> {id:stringtype:stringlangcode:stringstatus:booleandrupal_internal__nid:numberdrupal_internal__vid:numberchanged:stringcreated:stringtitle:stringdefault_langcode:booleansticky:booleanpath:Path}
    ```

    Your src directory should now include the new file:

    -   .env
    -   astro.config.mjs
    -   package.json
    -   Directorysrc/

        -   **types.ts**


2.  Create a new file called `drupal.ts` under `src/api` and add the following code:

    src/api/drupal.ts

    ```
    import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {DrupalNode} from"../types.ts";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";// Get the Drupal Base Url.export const baseUrl:string = import.meta.env.DRUPAL_BASE_URL;
    ```

    This will import the required libraries such as `Jsona` to deserialize the response, `DrupalJsonApiParams` to format the request url and the Node and Jsona types. It will also get the `baseUrl` from the `.env` file.

    Your src/api directory should now include the new file:

    -   .env
    -   astro.config.mjs
    -   package.json
    -   Directorysrc/

        -   Directoryapi/

            -   **drupal.ts**

        -   types.ts


3.  In that same file, create the `fetchUrl` function to make the fetch request and deserialize the response.

    src/api/drupal.ts

    ```
    import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {DrupalNode} from"../types.ts";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";// Get the Drupal Base Url.export const baseUrl:string = import.meta.env.DRUPAL_BASE_URL;/*** Fetch url from Drupal.** @paramurl** @return Promise<TJsonaModel | TJsonaModel[]> as Promise<any>*/export const fetchUrl = async (url:string):Promise<any> => {const request:Response = await fetch(url);const json:string|TJsonApiBody = await request.json();const dataFormatter:Jsona = newJsona();return dataFormatter.deserialize(json);}
    ```

4.  Create the `getArticles()` function to get all published articles.

    src/api/drupal.ts

    ```
    import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {DrupalNode} from"../types.ts";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";// Get the Drupal Base Url.export const baseUrl:string = import.meta.env.DRUPAL_BASE_URL;/*** Fetch url from Drupal.** @paramurl** @return Promise<TJsonaModel | TJsonaModel[]> as Promise<any>*/export const fetchUrl = async (url:string):Promise<any> => {const request:Response = await fetch(url);const json:string|TJsonApiBody = await request.json();const dataFormatter:Jsona = newJsona();return dataFormatter.deserialize(json);}/*** Get all published articles.** @return Promise<DrupalNode[]>*/export const getArticles = async ():Promise<DrupalNode[]> => {const params:DrupalJsonApiParams = newDrupalJsonApiParams();params.addFields("node--article", ["title","path","body","created",]).addFilter("status", "1");const path:string = params.getQueryString();return await fetchUrl(baseUrl + '/jsonapi/node/article?' + path);}
    ```

    Now you can use the function `getArticles()` in an `.astro` component to get all published articles with data for each title, body, path and creation date.

5.  Go to the Astro page where you will fetch data from Drupal. The following example creates an articles landing page at `src/pages/articles/index.astro`.

    Import the necessary dependencies and fetch all the entries from Drupal with a content type of `article` using `getArticles()` while passing the `DrupalNode` interface to type your response.

    src/pages/articles/index.astro

    ```
    ---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";importtype { DrupalNode } from"../../types";import {getArticles} from"../../api/drupal";// Get all published articles.const articles = await getArticles();---
    ```

    This fetch call using getArticles() will return a typed array of entries that can be used in your page template.

    Your `src/pages/` directory should now include the new file, if you used the same page file:

    -   .env
    -   astro.config.mjs
    -   package.json
    -   Directorysrc/

        -   Directoryapi/

            -   drupal.ts

        -   Directorypages/

            -   Directoryarticles/

                -   **index.astro**


        -   types.ts


6.  Add content to your page, such as a title. Use `articles.map()` to show your Drupal entries as line items in a list.

    src/pages/articles/index.astro

    ```
    ---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";importtype { DrupalNode } from"../types";import {getArticles} from"../api/drupal";// Get all published articles.const articles = await getArticles();---<htmllang="en"><head><title>My news site</title></head><body><h1>My news site</h1><ul>{articles.map((article:DrupalNode)=> (<li><ahref={article.path.alias.replace("internal:en/", "")}><h2>{article.title}</h2><p>Published on {article.created}</p></a></li>))}</ul></body></html>
    ```



### Generating individual blog posts


[Section titled Generating individual blog posts](#generating-individual-blog-posts)

Use the same method to fetch your data from Drupal as above, but this time, on a page that will create a unique page route for each article.

This example uses Astro’s default static mode, and creates [a dynamic routing page file](/en/guides/routing/#dynamic-routes) with the `getStaticPaths()` function. This function will be called at build time to generate the list of paths that become pages.

1.  Create a new file `src/pages/articles/[path].astro` and import the `DrupalNode` interface and `getArticle()` from `src/api/drupal.ts`. Fetch your data inside a `getStaticPaths()` function to create routes for your blog.

    src/pages/articles/\[path\].astro

    ```
    ---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";importtype { DrupalNode } from"../../types";import {getArticles} from"../../api/drupal";// Get all published articles.exportasyncfunctiongetStaticPaths() {const articles = await getArticles();}---
    ```

    Your src/pages/articles directory should now include the new file:

    -   .env
    -   astro.config.mjs
    -   package.json
    -   Directorysrc/

        -   Directoryapi/

            -   drupal.ts

        -   Directorypages/

            -   Directoryarticles/

                -   index.astro
                -   **\[path\].astro**


        -   types.ts


2.  In the same file, map each Drupal entry to an object with a `params` and `props` property. The `params` property will be used to generate the URL of the page and the `props` values will be passed to the page component as props.

    src/pages/articles/\[path\].astro

    ```
    ---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";importtype { DrupalNode } from"../../types";import {getArticles} from"../../api/drupal";// Get all published articles.exportasyncfunctiongetStaticPaths() {const articles = await getArticles();return articles.map((article:DrupalNode)=> {return {params: {// Choose `path` to match the `[path]` routing valuepath: article.path.alias.split('/')[2]},props: {title: article.title,body: article.body,date: newDate(article.created).toLocaleDateString('en-EN', {day: "numeric",month: "long",year: "numeric"})}}});}---
    ```

    The property inside `params` must match the name of the dynamic route. Since the filename is `[path].astro`, the property name passed to `params` must be `path`.

    In our example, the `props` object passes three properties to the page:

    -   `title`: a string, representing the title of your post.
    -   `body`: a string, representing the content of your entry.
    -   `date`: a timestamp, based on your file creation date.
3.  Use the page `props` to display your blog post.

    src/pages/articles/\[path\].astro

    ```
    ---import {Jsona} from"jsona";import {DrupalJsonApiParams} from"drupal-jsonapi-params";importtype {TJsonApiBody} from"jsona/lib/JsonaTypes";importtype { DrupalNode } from"../../types";import {getArticles} from"../../api/drupal";// Get all published articles.exportasyncfunctiongetStaticPaths() {const articles = await getArticles();return articles.map((article:DrupalNode)=> {return {params: {path: article.path.alias.split('/')[2]},props: {title: article.title,body: article.body,date: newDate(article.created).toLocaleDateString('en-EN', {day: "numeric",month: "long",year: "numeric"})}}});}const {title, date, body} = Astro.props;---<htmllang="en"><head><title>{title}</title></head><body><h1>{title}</h1><time>{date}</time><articleset:html={body.value} /></body></html>
    ```

4.  Navigate to your dev server preview and click on one of your posts to make sure your dynamic route is working.



### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

[Create a web application with Astro and Drupal](https://www.linkedin.com/pulse/create-web-application-astrojs-website-generator-using-gambino-kx6cf)

Have a resource to share?

If you found (or made!) a helpful video or blog post about using Drupal with Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/cms/drupal.mdx)!


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 36. `en/guides/cms/flotiq/.md`

```text
# Flotiq & Astro


---
url: https://docs.astro.build/en/guides/cms/flotiq/
description: Add content to your Astro project using Flotiq as a CMS
---


# Flotiq & Astro


[Flotiq](https://flotiq.com?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro) is a headless CMS designed for various frontends, such as static sites, mobile, and web applications. Developers and content creators manage and deliver content through REST and GraphQL-based APIs.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

This guide will use the Flotiq headless CMS API with an Astro project to display content on your website.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need:

1.  **An Astro project** - You can create a new project using the `npm create astro@latest` command.
2.  **A Flotiq account** - If you don’t have an account, [sign up for free](https://editor.flotiq.com/register?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro).
3.  **Flotiq read-only API key** - Find out [how to obtain your key](https://flotiq.com/docs/API/?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro).


### Setting up the Environment variables


[Section titled Setting up the Environment variables](#setting-up-the-environment-variables)

Add the read-only API key from your Flotiq account to the `.env` file in the root of your Astro project:

.env

```
FLOTIQ_API_KEY=__YOUR_FLOTIQ_API_KEY__
```


### Defining a Content Type in Flotiq


[Section titled Defining a Content Type in Flotiq](#defining-a-content-type-in-flotiq)

First, you need to define an example [Content Type Definition](https://flotiq.com/docs/panel/content-types/?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro) in Flotiq to store data.

Log in to your Flotiq account and create a custom Content Type Definition with the following example `Blog Post` configuration:

-   **Label**: Blog Post
-   **API Name**: blogpost
-   **Fields**:
    -   **Title**: text, required
    -   **Slug**: text, required
    -   **Content**: rich text, required

Then, create one or more example [Content Objects](https://flotiq.com/docs/panel/content-objects/?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro) using this `Blog Post` type.


### Installing the Flotiq TypeScript SDK


[Section titled Installing the Flotiq TypeScript SDK](#installing-the-flotiq-typescript-sdk)

To connect your project with Flotiq, install the [Flotiq SDK](https://github.com/flotiq/flotiq-api-ts) using the package manager of your choice:

-   [npm](#tab-panel-3069)
-   [pnpm](#tab-panel-3070)
-   [Yarn](#tab-panel-3071)

Terminal window

```
npminstallflotiq-api-ts
```

Terminal window

```
pnpmaddflotiq-api-ts
```

Terminal window

```
yarnaddflotiq-api-ts
```

Next, configure the SDK using your credentials. Create a new file named `flotiq.ts` inside the `src/lib` directory of your project:

src/lib/flotiq.ts

```
import { FlotiqApi } from"flotiq-api-ts";export const flotiq = newFlotiqApi(import.meta.env.FLOTIQ_API_KEY);
```

This configuration can now be used throughout your project.


### Fetching and Displaying Data from Flotiq


[Section titled Fetching and Displaying Data from Flotiq](#fetching-and-displaying-data-from-flotiq)

1.  Fetch the `Blog Post` data on an Astro page using your content’s custom API `BlogpostAPI`:

    src/pages/index.astro

    ```
    ---import { flotiq } from"../lib/flotiq";const posts = await flotiq.BlogpostAPI.list();---
    ```

2.  Display the content in your Astro template. You will have access to the `title`, `slug`, and `content` of your posts as well as other `internal` post data:

    src/pages/index.astro

    ```
    ---import { flotiq } from"../lib/flotiq";const posts = await flotiq.BlogpostAPI.list();---<htmllang="en"><head><title>Astro</title></head><body>{posts.data?.map((post)=> (<section><ahref={`/posts/${post.slug}`}><h2>{post.title}</h2></a><div>{post.internal?.createdAt}</div><divset:html={post.content}/></section>))}</body></html>
    ```

3.  Start the dev server and visit your page preview at `http://localhost:4321` to see the list of your blog posts. Each post will link to a page that does not yet exist. These will be created in the next step.



### Generating Individual Pages


[Section titled Generating Individual Pages](#generating-individual-pages)

Astro supports both prerendering all your pages ahead of time, or creating routes on demand when they are requested. Follow the instructions for either [static site generation](#static-site-generation) or [on-demand rendering](#on-demand-rendering) to build the page routes for your blog posts.


#### Static Site Generation


[Section titled Static Site Generation](#static-site-generation)

In static site generation (SSG) mode, use the `getStaticPaths()` method to fetch all possible blog post paths from Flotiq.

1.  Create a new file `[slug].astro` in the `/src/pages/posts/` directory. Fetch all blog posts and return them within the `getStaticPaths()` method:

    src/pages/posts/\[slug\].astro

    ```
    ---importtype { Blogpost } from"flotiq-api-ts";import { flotiq } from"../../lib/flotiq";exportasyncfunctiongetStaticPaths() {const posts = await flotiq.BlogpostAPI.list();return posts.data?.map((post)=> ({params: { slug: post.slug },props: post})) | []}---
    ```

2.  Add the templating to display an individual post:

    src/pages/posts/\[slug\].astro

    ```
    ---importtype { Blogpost } from"flotiq-api-ts";import { flotiq } from"../../lib/flotiq";exportasyncfunctiongetStaticPaths() {const posts = await flotiq.BlogpostAPI.list();return posts.data?.map((post)=> ({params: { slug: post.slug },props: post})) | []}const post:Blogpost = Astro.props;---<htmllang="en"><title>{post.title}</title><body><h1>{post.title}</h1><divset:html={post.content}/></body></html>
    ```

3.  Visit `http://localhost:4321` and click on a linked blog post in your list. You will now be able to navigate to the individual post’s page.



#### On-demand Rendering


[Section titled On-demand Rendering](#on-demand-rendering)

If you are using [SSR](/en/guides/on-demand-rendering/) mode, you will need to fetch a single post based on its `slug`.

1.  Create a new file `[slug].astro` in the `/src/pages/posts/` directory. Fetch the post by its `slug` field, including logic to display a 404 page when the route is not found:

    src/pages/posts/\[slug\].astro

    ```
    ---importtype { Blogpost } from"flotiq-api-ts";import { flotiq } from"../../lib/flotiq";const { slug } = Astro.params;let post:Blogpost;const blogpostList = await flotiq.BlogpostAPI.list({filters: JSON.stringify({slug: {type: 'equals',filter: slug,}}),limit: 1});if (blogpostList.data?.[0]) {post = blogpostList.data[0]} else {return Astro.redirect('/404');}---
    ```

2.  Add the templating to display an individual post:

    src/pages/posts/\[slug\].astro

    ```
    ---importtype { Blogpost } from"flotiq-api-ts";import { flotiq } from"../../lib/flotiq";const { slug } = Astro.params;let post:Blogpost;const blogpostList = await flotiq.BlogpostAPI.list({filters: JSON.stringify({slug: {type: 'equals',filter: slug,}}),limit: 1});if (blogpostList.data?.[0]) {post = blogpostList.data[0]} else {return Astro.redirect('/404');}---<htmllang="en"><title>{post.title}</title><body><h1>{post.title}</h1><divset:html={post.content}/></body></html>
    ```

3.  Visit `http://localhost:4321` and click on a linked blog post in your list. You will now be able to navigate to the individual post’s page.



### Refreshing the SDK After Content Type Changes


[Section titled Refreshing the SDK After Content Type Changes](#refreshing-the-sdk-after-content-type-changes)

When using the Flotiq TypeScript SDK (`flotiq-api-ts`), all your data types are accurately mapped into the Astro project.

If you make changes to the structure of your content types (such as adding a new field or modifying an existing one), you’ll need to refresh the SDK to ensure that your project reflects the latest model updates.

To do this, run the rebuild command for your package manager:

-   [npm](#tab-panel-3072)
-   [pnpm](#tab-panel-3073)
-   [Yarn](#tab-panel-3074)

Terminal window

```
npmrebuildflotiq-api-ts
```

Terminal window

```
pnpmrebuildflotiq-api-ts
```

Terminal window

```
yarnrebuildflotiq-api-ts//foryarnv1 (Classic)://yarnaddflotiq-api-ts
```

This will update the SDK, aligning object types, fields, and API methods with your current data model.


## Publishing Your Site


[Section titled Publishing Your Site](#publishing-your-site)

To deploy your website, visit Astro’s [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


### Redeploy on Flotiq Changes


[Section titled Redeploy on Flotiq Changes](#redeploy-on-flotiq-changes)

To update your published site, configure Flotiq to send a webhook your hosting provider to trigger a rebuild whenever your content changes.

In Flotiq, you can define which Content Type and events it should trigger on, and configure it accordingly. See the [Flotiq Webhooks documentation](https://flotiq.com/docs/panel/webhooks/async-co-webhook/?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro) for more details.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Flotiq documentation](https://flotiq.com/docs/?utm_campaign=flotiq_at_astro_headless_cms&utm_medium=referral&utm_source=astro)


## Community resources


[Section titled Community resources](#community-resources)

-   [Flotiq x Astro](https://maciekpalmowski.dev/blog/flotiq-cms-astro/) by Maciek Palmowski


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 37. `en/guides/cms/frontmatter-cms/.md`

```text
# Front Matter CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/frontmatter-cms/
description: Add content to your Astro project using Front Matter CMS
---


# Front Matter CMS & Astro


[Front Matter CMS](https://frontmatter.codes/) brings the CMS to your editor, it runs within Visual Studio Code, Gitpod, and many more.


## Integration with Astro


[Section titled Integration with Astro](#integration-with-astro)

In this section, we’ll walk through how to add Front Matter CMS to your Astro project.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

-   Visual Studio Code
-   Use the [Astro Blog template](https://github.com/withastro/astro/tree/main/examples/blog) to provide the base configuration and sample content to start with Front Matter CMS.


### Install the Front Matter CMS extension


[Section titled Install the Front Matter CMS extension](#install-the-front-matter-cms-extension)

You can get the extension from the [Visual Studio Code Marketplace - Front Matter](https://marketplace.visualstudio.com/items?itemName=eliostruyf.vscode-front-matter) or by clicking on the following link: [open Front Matter CMS extension in VS Code](vscode:extension/eliostruyf.vscode-front-matter)


### Project initialization


[Section titled Project initialization](#project-initialization)

Once Front Matter CMS is installed, you will get a new icon in the Activity Bar. It will open the **Front Matter CMS** panel in the primary sidebar when you click on it. Follow the next steps to initialize your project:

-   Click on the **Initialize project** button in the Front Matter panel

-   The welcome screen will open, and you can start initializing the project

-   Click on the first step to **Initialize project**

-   As Astro is one of the supported frameworks, you can select it from the list

-   Register your content folders, in this case, the `src/content/blog` folder.

    Note

    Folder registration is required to let Front Matter CMS know where it can find and create your content. You can have multiple types of folders like pages, blog, docs, and many more.

-   You will be asked to enter the name of the folder. By default, it takes the folder name.

    Note

    The name gets used during the creation process of new content. For example, having multiple folder registrations allows you to choose the type of content you want to create.

-   Click on **Show the dashboard** to open the content dashboard

    Tip

    Once Front Matter CMS is initialized, you can open the dashboard as follows:

    -   Using the keyboard binding: alt + d (Windows & Linux) or options + d (macOS)
    -   Open the command palette and search for `Front Matter: Open dashboard`
    -   Click on the **Front Matter** icon on the panel’s title bar or files.



### Project configuration


[Section titled Project configuration](#project-configuration)

Once the project is initialized, you will get a `frontmatter.json` configuration file and a `.frontmatter` folder in the root of your project.

-   Directory.frontmatter/

    -   Directorydatabase/

        -   mediaDb.json


-   Directorysrc/

    -   …

-   astro.config.mjs
-   **frontmatter.json**
-   package.json


#### Content-type configuration


[Section titled Content-type configuration](#content-type-configuration)

Content-types are the way Front Matter CMS manages your content. Each content-type contains a set of fields, which can be defined per type of content you want to use for your website.

The fields correspond to the front matter of your page content.

You can configure the content-types in the `frontmatter.json` file.

-   Open the `frontmatter.json` file
-   Replace the `frontMatter.taxonomy.contentTypes` array with the following content-types configuration:

frontmatter.json

```
"frontMatter.taxonomy.contentTypes": [{"name": "default","pageBundle": false,"previewPath": "'blog'","filePrefix": null,"fields": [{"title": "Title","name": "title","type": "string","single": true},{"title": "Description","name": "description","type": "string"},{"title": "Publishing date","name": "pubDate","type": "datetime","default": "{{now}}","isPublishDate": true},{"title": "Content preview","name": "heroImage","type": "image","isPreviewImage": true}]}]
```

Note

This configuration ensures that the Front Matter content-type matches the content collection schema from the Astro blog template.

Tip

You can find more information on content-types and the supported fields in the [content creation docs section](https://frontmatter.codes/docs/content-creation) from Front Matter CMS.


### Preview your articles in the editor


[Section titled Preview your articles in the editor](#preview-your-articles-in-the-editor)

From the **Front Matter CMS** panel, click on the **Start server** button. This action starts the Astro local dev server. Once running, you can open the content dashboard, select one of the articles and click on the **Open preview** button to open the article in the editor.


### Create new articles


[Section titled Create new articles](#create-new-articles)

Open the **Front Matter CMS Dashboard**; you can do this as follows:

-   Open the Front Matter CMS’ content dashboard
-   Click on the **Create content** button
-   Front Matter will ask you for the title of the article. Fill it in and press enter
-   Your new article will be created and opened in the editor. You can start writing your article.


### Using Markdoc with Front Matter CMS


[Section titled Using Markdoc with Front Matter CMS](#using-markdoc-with-front-matter-cms)

To use Markdoc with Front Matter CMS, you must configure this in the `frontMatter.content.supportedFileTypes`. This setting lets the CMS know which types of files it can progress.

You can configure the setting as follows:

frontmatter.json

```
"frontMatter.content.supportedFileTypes": [ "md", "markdown", "mdx", "mdoc" ]
```

To allow your content to be created as Markdoc, specify the `fileType` property on the content-type.

frontmatter.json

```
"frontMatter.taxonomy.contentTypes": [{"name": "default","pageBundle": false,"previewPath": "'blog'","filePrefix": null,"fileType": "mdoc","fields": [{"title": "Title","name": "title","type": "string","single": true},{"title": "Description","name": "description","type": "string"},{"title": "Publishing date","name": "pubDate","type": "datetime","default": "{{now}}","isPublishDate": true},{"title": "Content preview","name": "heroImage","type": "image","isPreviewImage": true}]}]
```


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Front Matter CMS](https://frontmatter.codes/)
-   [Front Matter CMS - Documentation](https://frontmatter.codes/docs/)
-   [Getting started with Astro and Front Matter CMS](https://youtu.be/xb6pZiier_E)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 38. `en/guides/cms/ghost/.md`

```text
# Ghost & Astro


---
url: https://docs.astro.build/en/guides/cms/ghost/
description: Add content to your Astro project using Ghost as a CMS
---


# Ghost & Astro


[Ghost](https://github.com/TryGhost/Ghost) is an open-source, headless content management system built on Node.js.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, we’ll use the [Ghost content API](https://ghost.org/docs/content-api/) to bring your data into your Astro project.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A Ghost site** - It is assumed that you have a site set up with Ghost. If you don’t you can set one up on a [local environment.](https://ghost.org/docs/install/local/)

3.  **Content API Key** - You can make an integration under your site’s `Settings > Integrations`. From there you can find your `Content API key`



### Setting up credentials


[Section titled Setting up credentials](#setting-up-credentials)

To add your site’s credentials to Astro, create an `.env` file in the root of your project with the following variable:

.env

```
CONTENT_API_KEY=YOUR_API_KEY
```

Now, you should be able to use this environment variable in your project.

If you would like to have IntelliSense for your environment variable, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly CONTENT_API_KEY:string;}
```

Tip

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your root directory should now include these new files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect with Ghost, install the official content API wrapper [`@tryghost/content-api`](https://www.npmjs.com/package/@tryghost/content-api) using the command below for your preferred package manager, and optionally, a helpful package containing type definitions if you are using TypeScript:

-   [npm](#tab-panel-3078)
-   [pnpm](#tab-panel-3079)
-   [Yarn](#tab-panel-3080)

Terminal window

```
npminstall@tryghost/content-apinpminstall--save@types/tryghost__content-api
```

Terminal window

```
pnpmadd@tryghost/content-apipnpmadd--save-dev@types/tryghost__content-api
```

Terminal window

```
yarnadd@tryghost/content-apiyarnadd--dev@types/tryghost__content-api
```


## Making a blog with Astro and Ghost


[Section titled Making a blog with Astro and Ghost](#making-a-blog-with-astro-and-ghost)

With the setup above, you are now able to create a blog that uses Ghost as the CMS.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  A Ghost blog
2.  An Astro project integrated with the [Ghost content API](https://www.npmjs.com/package/@tryghost/content-api) - See [integrating with Astro](/en/guides/cms/ghost/#integrating-with-astro) for more details on how to set up an Astro project with Ghost.

This example will create an index page that lists posts with links to dynamically-generated individual post pages.


### Fetching Data


[Section titled Fetching Data](#fetching-data)

You can fetch your site’s data with the Ghost content API package.

First, create a `ghost.ts` file under a `lib` directory.

-   Directorysrc/

    -   Directorylib/

        -   **ghost.ts**

    -   Directorypages/

        -   index.astro


-   astro.config.mjs
-   package.json

Initialize an API instance with the Ghost API using the API key from the Ghost dashboard’s Integrations page.

src/lib/ghost.ts

```
import GhostContentAPI from'@tryghost/content-api';// Create API instance with site credentialsexport const ghostClient = newGhostContentAPI({url: 'http://127.0.0.1:2368', // This is the default URL if your site is running on a local environmentkey: import.meta.env.CONTENT_API_KEY,version: 'v5.0',});
```


### Displaying a list of posts


[Section titled Displaying a list of posts](#displaying-a-list-of-posts)

The page `src/pages/index.astro` will display a list of posts, each with a description and link to its own page.

-   Directorysrc/

    -   Directorylib/

        -   ghost.ts

    -   Directorypages/

        -   **index.astro**


-   astro.config.mjs
-   package.json

Import `ghostClient()` in the Astro frontmatter to use the `posts.browse()` method to access blog posts from Ghost. Set `limit: all` to retrieve all posts.

src/pages/index.astro

```
---import { ghostClient } from'../lib/ghost';const posts = await ghostClient.posts.browse({limit: 'all',}).catch((err)=> {console.error(err);});---
```

Fetching via the content API returns an array of objects containing the [properties for each post](https://ghost.org/docs/content-api/#posts) such as:

-   `title` - the title of the post
-   `html` - the HTML rendering of the content of the post
-   `feature_image` - the source URL of the featured image of the post
-   `slug` - the slug of the post

Use the `posts` array returned from the fetch to display a list of blog posts on the page.

src/pages/index.astro

```
---import { ghostClient } from'../lib/ghost';const posts = await ghostClient.posts.browse({limit: 'all',}).catch((err)=> {console.error(err);});---<htmllang="en"><head><title>Astro + Ghost 👻</title></head><body>{posts.map((post)=> (<ahref={`/post/${post.slug}`}><h1>{post.title}</h1></a>))}</body></html>
```


### Generating pages


[Section titled Generating pages](#generating-pages)

The page `src/pages/post/[slug].astro` [dynamically generates a page](/en/guides/routing/#dynamic-routes) for each post.

-   Directorysrc/

    -   Directorylib/

        -   ghost.ts

    -   Directorypages/

        -   index.astro
        -   Directorypost/

            -   **\[slug\].astro**



-   astro.config.mjs
-   package.json

Import `ghostClient()` to access blog posts using `posts.browse()` and return a post as props to each of your dynamic routes.

src/pages/post/\[slug\].astro

```
---import { ghostClient } from'../../lib/ghost';exportasyncfunctiongetStaticPaths() {const posts = await ghostClient.posts.browse({limit: 'all',}).catch((err)=> {console.error(err);});return posts.map((post)=> {return {params: {slug: post.slug,},props: {post: post,},};});}const { post } = Astro.props;---
```

Create the template for each page using the properties of each `post` object.

src/pages/post/\[slug\].astro

```
---import { ghostClient } from'../../lib/ghost';exportasyncfunctiongetStaticPaths() {const posts = await ghostClient.posts.browse({limit: 'all',}).catch((err)=> {console.error(err);});return posts.map((post)=> {return {params: {slug: post.slug,},props: {post: post,},};});}const { post } = Astro.props;---<!DOCTYPEhtml><htmllang="en"><head><title>{post.title}</title></head><body><imgsrc={post.feature_image}alt={post.title} /><h1>{post.title}</h1><p>{post.reading_time} min read</p><Fragmentset:html={post.html} /></body></html>
```

Note

`<Fragment />` is a built-in Astro component which allows you to avoid an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS (e.g. Ghost or [WordPress](/en/guides/cms/wordpress/)).


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your site visit our [deployment guide](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

[Ghost CMS & Astro Tutorial](https://matthiesen.xyz/blog/astro-ghostcms)

[Astro + Ghost + Tailwind CSS](https://andr.ec/posts/astro-ghost-blog/)

[Building a Corporate site with Astro and Ghost](https://artabric.com/post/building-a-corporate-site-with-astro-and-ghost/)

[\`astro-starter-ghost\`](https://github.com/PhilDL/astro-starter-ghost)

Have a resource to share?

If you found (or made!) a helpful video or blog post about using Ghost with Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/cms/ghost.mdx)!


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 39. `en/guides/cms/gitcms/.md`

```text
# GitCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/gitcms/
description: Integrate GitCMS into your Astro project for seamless content management
---


# GitCMS & Astro


[GitCMS](https://gitcms.blog) turns GitHub into a Git-based headless CMS, offering a Notion-like markdown editing experience right in your browser.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Introducing GitCMS](https://gitcms.blog/posts/introducing-gitcms/)
-   [How to Configure GitCMS for an Astro Site](https://gitcms.blog/posts/how-to-configure-gitcms/)
-   [Install GitCMS Chrome Extension](https://gitcms.blog/extension)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 40. `en/guides/cms/hashnode/.md`

```text
# Hashnode & Astro


---
url: https://docs.astro.build/en/guides/cms/hashnode/
description: Add content to your Astro project using Hashnode as a CMS
---


# Hashnode & Astro


[Hashnode](https://hashnode.com/) is a hosted CMS that allows you to create a blog or publication.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

The [Hashnode Public API](https://apidocs.hashnode.com/) is a GraphQL API that allows you to interact with Hashnode. This guide uses [`graphql-request`](https://github.com/jasonkuhrt/graphql-request), a minimal GraphQL client that works well with Astro, to bring your Hashnode data into your Astro project.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A Hashnode site** - You can create free personal site by visiting [Hashnode](https://hashnode.com/).



### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

Install the `graphql-request` package using the package manager of your choice:

-   [npm](#tab-panel-3081)
-   [pnpm](#tab-panel-3082)
-   [Yarn](#tab-panel-3083)

Terminal window

```
npminstallgraphql-request
```

Terminal window

```
pnpmaddgraphql-request
```

Terminal window

```
yarnaddgraphql-request
```


## Making a blog with Astro and Hashnode


[Section titled Making a blog with Astro and Hashnode](#making-a-blog-with-astro-and-hashnode)

This guide uses [`graphql-request`](https://github.com/jasonkuhrt/graphql-request), a minimal GraphQL client that works well with Astro, to bring your Hashnode data into your Astro project.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  A Hashnode Blog
2.  An Astro project integrated with the [graphql-request](https://github.com/jasonkuhrt/graphql-request) package installed.

This example will create an index page that lists posts with links to dynamically-generated individual post pages.


### Fetching Data


[Section titled Fetching Data](#fetching-data)

1.  To fetch your site’s data with the `graphql-request` package, make a `src/lib` directory and create two new files `client.ts` & `schema.ts`:

    -   Directorysrc/

        -   Directorylib/

            -   **client.ts**
            -   **schema.ts**

        -   Directorypages/

            -   index.astro


    -   astro.config.mjs
    -   package.json

2.  Initialize an API instance with the GraphQLClient using the URL from your Hashnode Website.

    src/lib/client.ts

    ```
    import { gql, GraphQLClient } from"graphql-request";importtype { AllPostsData, PostData } from"./schema";export const getClient = () => {return newGraphQLClient("https://gql.hashnode.com")}const myHashnodeURL = "astroplayground.hashnode.dev";export const getAllPosts = async () => {const client = getClient();const allPosts = await client.request<AllPostsData>(gql`query allPosts {publication(host: "${myHashnodeURL}") {idtitleposts(first: 20) {pageInfo{hasNextPageendCursor}edges {node {idauthor{nameprofilePicture}titlesubtitlebriefslugcoverImage {url}tags {nameslug}publishedAtreadTimeInMinutes}}}}}`);return allPosts;};export const getPost = async (slug:string) => {const client = getClient();const data = await client.request<PostData>(gql`query postDetails($slug: String!) {publication(host: "${myHashnodeURL}") {idpost(slug: $slug) {idauthor{nameprofilePicture}publishedAttitlesubtitlereadTimeInMinutescontent{html}tags {nameslug}coverImage {url}}}}`,{ slug: slug });return data.publication.post;};
    ```

3.  Configure `schema.ts` to define the shape of the data returned from the Hashnode API.

    src/lib/schema.ts

    ```
    import { z } from"astro/zod";export const PostSchema = z.object({id: z.string(),author: z.object({name: z.string(),profilePicture: z.string(),}),publishedAt: z.string(),title: z.string(),subtitle: z.string(),brief: z.string(),slug: z.string(),readTimeInMinutes: z.number(),content: z.object({html: z.string(),}),tags: z.array(z.object({name: z.string(),slug: z.string(),})),coverImage: z.object({url: z.string(),}),})export const AllPostsDataSchema = z.object({id: z.string(),publication: z.object({title: z.string(),posts: z.object({pageInfo: z.object({hasNextPage: z.boolean(),endCursor: z.string(),}),edges: z.array(z.object({node: PostSchema,})),}),}),})export const PostDataSchema = z.object({id: z.string(),publication: z.object({title: z.string(),post: PostSchema,}),})exporttype Post = z.infer<typeof PostSchema>exporttype AllPostsData = z.infer<typeof AllPostsDataSchema>exporttype PostData = z.infer<typeof PostDataSchema>
    ```



### Displaying a list of posts


[Section titled Displaying a list of posts](#displaying-a-list-of-posts)

Fetching via `getAllPosts()` returns an array of objects containing the properties for each post such as:

-   `title` - the title of the post
-   `brief` - the HTML rendering of the content of the post
-   `coverImage.url` - the source URL of the featured image of the post
-   `slug` - the slug of the post

Use the `posts` array returned from the fetch to display a list of blog posts on the page.

src/pages/index.astro

```
---import { getAllPosts } from'../lib/client';const data = await getAllPosts();const allPosts = data.publication.posts.edges;---<htmllang="en"><head><title>Astro + Hashnode</title></head><body>{allPosts.map((post)=> (<div><h2>{post.node.title}</h2><p>{post.node.brief}</p><imgsrc={post.node.coverImage.url}alt={post.node.title} /><ahref={`/post/${post.node.slug}`}>Read more</a></div>))}</body></html>
```


### Generating pages


[Section titled Generating pages](#generating-pages)

1.  Create the page `src/pages/post/[slug].astro` to [dynamically generate a page](/en/guides/routing/#dynamic-routes) for each post.

    -   Directorysrc/

        -   Directorylib/

            -   client.ts
            -   schema.ts

        -   Directorypages/

            -   index.astro
            -   Directorypost/

                -   **\[slug\].astro**



    -   astro.config.mjs
    -   package.json

2.  Import and use `getAllPosts()` and `getPost()` to fetch the data from Hashnode and generate individual page routes for each post.

    src/pages/post/\[slug\].astro

    ```
    ---import { getAllPosts, getPost } from'../../lib/client';exportasyncfunctiongetStaticPaths() {const data = await getAllPosts();const allPosts = data.publication.posts.edges;return allPosts.map((post)=> {return {params: { slug: post.node.slug },}})}const { slug } = Astro.params;const post = await getPost(slug);---
    ```

3.  Create the template for each page using the properties of each `post` object. The example below shows the post title and reading time, then the full post content:

    src/pages/post/\[slug\].astro

    ```
    ---import { getAllPosts, getPost } from'../../lib/client';exportasyncfunctiongetStaticPaths() {const data = await getAllPosts();const allPosts = data.publication.posts.edges;return allPosts.map((post)=> {return {params: { slug: post.node.slug },}})}const { slug } = Astro.params;const post = await getPost(slug);---<!DOCTYPEhtml><htmllang="en"><head><title>{post.title}</title></head><body><imgsrc={post.coverImage.url}alt={post.title} /><h1>{post.title}</h1><p>{post.readTimeInMinutes} min read</p><Fragmentset:html={post.content.html} /></body></html>
    ```

    Note

    `<Fragment />` is a built-in Astro component which allows you to avoid an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS (e.g. Hashnode or [WordPress](/en/guides/cms/wordpress/)).



### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your site visit our [deployment guide](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [`astro-hashnode`](https://github.com/matthiesenxyz/astro-hashnode) on GitHub


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 41. `en/guides/cms/hygraph/.md`

```text
# Hygraph & Astro


---
url: https://docs.astro.build/en/guides/cms/hygraph/
description: Add content to your Astro project using Hygraph as a CMS
---


# Hygraph & Astro


[Hygraph](https://hygraph.com/) is a federated content management platform. It exposes a GraphQL endpoint for fetching content.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, you’ll create a [Hygraph](https://hygraph.com/) GraphQL endpoint to fetch with Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **A Hygraph account and project**. If you don’t have an account, you can [sign up for free](https://app.hygraph.com/signup) and create a new project.

2.  **Hygraph access permissions** - In `Project Settings > API Access`, configure Public Content API permissions to allow read requests without authentication. If you haven’t set any permissions, you can click **Yes, initialize defaults** to add the required permissions to use the “High Performance Content API”.



### Setting up the endpoint


[Section titled Setting up the endpoint](#setting-up-the-endpoint)

To add your Hygraph endpoint to Astro, create a `.env` file in the root of your project with the following variable:

.env

```
HYGRAPH_ENDPOINT=YOUR_HIGH_PERFORMANCE_API
```

Now, you should be able to use this environment variable in your project.

If you would like to have IntelliSense for your environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly HYGRAPH_ENDPOINT:string;}
```

Note

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.

Your root directory should now include these new files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Fetching data


[Section titled Fetching data](#fetching-data)

Fetch data from your Hygraph project by using the `HYGRAPH_ENDPOINT`.

For example, to fetch entries of a `blogPosts` content type that has a string field `title`, create a GraphQL query to fetch that content. Then, define the type of the content, and set it as the type of the response.

src/pages/index.astro

```
---interface Post {title:string;}const query = {method: "POST",headers: { "Content-Type": "application/json" },body: JSON.stringify({query: `{blogPosts {title}}`,}),};const response = await fetch(import.meta.env.HYGRAPH_ENDPOINT, query);const json = await response.json();const posts:Post[] = json.data.blogPosts;---<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><metaname="generator"content={Astro.generator} /><title>Astro</title></head><body><h1>Astro</h1>{posts.map((post)=> (<div><h2>{post.title}</h2></div>))}</body></html>
```


## Deploy


[Section titled Deploy](#deploy)


### Configuring Netlify Webhook


[Section titled Configuring Netlify Webhook](#configuring-netlify-webhook)

To set up a webhook in Netlify:

1.  Deploy your site to Netlify with [this guide](/en/guides/deploy/netlify/). Remember to add your `HYGRAPH_ENDPOINT` to the environment variables.

2.  Then Go to your Hygraph project dashboard and click on **Apps**.

3.  Go to the marketplace and search for Netlify and follow the instructions provided.

4.  If all went good, now you can deploy your website with a click in the Hygraph interface.



## Community Resources


[Section titled Community Resources](#community-resources)

-   [Hygraph + Astro example with `marked` for markdown parsing](https://github.com/camunoz2/example-astrowithhygraph)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 42. `en/guides/cms/keystatic/.md`

```text
# Keystatic & Astro


---
url: https://docs.astro.build/en/guides/cms/keystatic/
description: Add content to your Astro project using Keystatic as a CMS
---


# Keystatic & Astro


[Keystatic](https://keystatic.com/) is an open source, headless content-management system that allows you to structure your content and sync it with GitHub.

Tip

If you’re starting a **new Astro + Keystatic project from scratch**, you can use the [Keystatic CLI](https://keystatic.com/docs/quick-start#keystatic-cli) to generate a new project in seconds:

-   [npm](#tab-panel-3084)
-   [pnpm](#tab-panel-3085)
-   [Yarn](#tab-panel-3086)

Terminal window

```
npmcreate@keystatic@latest
```

Terminal window

```
pnpmcreate@keystatic@latest
```

Terminal window

```
yarncreate@keystatic
```

Select the Astro template, and you’ll be ready to [deploy](#deploying-keystatic--astro)!


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   An existing Astro project [with an adapter configured](/en/guides/on-demand-rendering/).

Note

If you intend to sync Keystatic’s data with GitHub, you will also need **a GitHub account with `write` permissions** on the repository for this project.


## Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

Add both the Markdoc (for content entries) and the React (for the Keystatic Admin UI Dashboard) integrations to your Astro project, using the `astro add` command for your package manager.

-   [npm](#tab-panel-3087)
-   [pnpm](#tab-panel-3088)
-   [Yarn](#tab-panel-3089)

Terminal window

```
npxastroaddreactmarkdoc
```

Terminal window

```
pnpmastroaddreactmarkdoc
```

Terminal window

```
yarnastroaddreactmarkdoc
```

You will also need two Keystatic packages:

-   [npm](#tab-panel-3090)
-   [pnpm](#tab-panel-3091)
-   [Yarn](#tab-panel-3092)

Terminal window

```
npminstall@keystatic/core@keystatic/astro
```

Terminal window

```
pnpmadd@keystatic/core@keystatic/astro
```

Terminal window

```
yarnadd@keystatic/core@keystatic/astro
```


## Adding the Astro integration


[Section titled Adding the Astro integration](#adding-the-astro-integration)

Add the Astro integration from `@keystatic/astro` in your Astro config file:

astro.config.mjs

```
import { defineConfig } from'astro/config'import react from'@astrojs/react'import markdoc from'@astrojs/markdoc'import keystatic from'@keystatic/astro'// https://astro.build/configexportdefaultdefineConfig({integrations: [react(), markdoc(), keystatic()],output: 'static',})
```


## Creating a Keystatic config file


[Section titled Creating a Keystatic config file](#creating-a-keystatic-config-file)

A Keystatic config file is required to define your content schema. This file will also allow you to connect a project to a specific GitHub repository (if you decide to do so).

Create a file called `keystatic.config.ts` in the root of the project and add the following code to define both your storage type (`local`) and a single content collection (`posts`):

keystatic.config.ts

```
import { config, fields, collection } from'@keystatic/core';exportdefaultconfig({storage: {kind: 'local',},collections: {posts: collection({label: 'Posts',slugField: 'title',path: 'src/content/posts/*',format: { contentField: 'content' },schema: {title: fields.slug({ name: { label: 'Title' } }),content: fields.markdoc({label: 'Content',}),},}),},});
```

Already using content collections?

If you are already using [content collections](/en/guides/content-collections/) in your Astro project, then update the schema above to exactly match the collection(s) defined in your existing schema.

Keystatic is now configured to manage your content based on your schema.


## Running Keystatic locally


[Section titled Running Keystatic locally](#running-keystatic-locally)

To launch your Keystatic Admin UI dashboard, start Astro’s dev server:

Terminal window

```
npmrundev
```

Visit `http://127.0.0.1:4321/keystatic` in the browser to see the Keystatic Admin UI running.


## Creating a new post


[Section titled Creating a new post](#creating-a-new-post)

1.  In the Keystatic Admin UI dashboard, click on the “Posts” collection.

2.  Use the button to create a new post. Add the title “My First Post” and some content, then save the post.

3.  This post should now be visible from your “Posts” collection. You can view and edit your individual posts from this dashboard page.

4.  Return to view your Astro project files. You will now find a new `.mdoc` file inside the `src/content/posts` directory for this new post:

    -   Directorysrc/

        -   Directorycontent/

            -   Directoryposts/

                -   **my-first-post.mdoc**




5.  Navigate to that file in your code editor and verify that you can see the Markdown content you entered. For example:

    ```
    ---title: My First Post---This is my very first post. I am **super** excited!
    ```



## Rendering Keystatic content


[Section titled Rendering Keystatic content](#rendering-keystatic-content)

Use Astro’s Content Collections API to [query and display your posts and collections](/en/guides/content-collections/#querying-collections), just as you would in any Astro project.


### Displaying a collection list


[Section titled Displaying a collection list](#displaying-a-collection-list)

The following example displays a list of each post title, with a link to an individual post page.

```
---import { getCollection } from'astro:content'const posts = await getCollection('posts')---<ul>{posts.map(post=> (<li><ahref={`/posts/${post.slug}`}>{post.data.title}</a></li>))}</ul>
```


### Displaying a single entry


[Section titled Displaying a single entry](#displaying-a-single-entry)

To display content from an individual post, you can import and use the `<Content />` component to [render your content to HTML](/en/guides/content-collections/#rendering-body-content):

```
---import { getEntry } from'astro:content'const post = await getEntry('posts', 'my-first-post')const { Content } = await post.render()---<main><h1>{post.data.title}</h1><Content /></main>
```

For more information on querying, filtering, displaying your collections content and more, see the full content [collections documentation](/en/guides/content-collections/).


## Deploying Keystatic + Astro


[Section titled Deploying Keystatic + Astro](#deploying-keystatic--astro)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

You’ll also probably want to [connect Keystatic to GitHub](https://keystatic.com/docs/connect-to-github) so you can manage content on the deployed instance of the project.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Check out [the official Keystatic guide](https://keystatic.com/docs/installation-astro)
-   [Keystatic starter template](https://github.com/Thinkmill/keystatic/tree/main/templates/astro)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 43. `en/guides/cms/keystonejs/.md`

```text
# KeystoneJS & Astro


---
url: https://docs.astro.build/en/guides/cms/keystonejs/
description: Add content to your Astro project using KeystoneJS as a CMS
---


# KeystoneJS & Astro


[KeystoneJS](https://keystonejs.com/) is an open source, headless content-management system that allows you to describe the structure of your schema.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 44. `en/guides/cms/kontent-ai/.md`

```text
# Kontent.ai & Astro


---
url: https://docs.astro.build/en/guides/cms/kontent-ai/
description: Add content to your Astro project using Kontent.ai as CMS
---


# Kontent.ai & Astro


[Kontent.ai](https://www.kontent.ai/) is a headless CMS that allows you to manage content in a structured and modular way, supported by AI capabilities.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, you’ll use the [Kontent.ai TypeScript SDK](https://github.com/kontent-ai/delivery-sdk-js) to connect your Kontent.ai project to your Astro application.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you’ll need the following:

1.  **Kontent.ai project** - If you don’t have a Kontent.ai account yet, [sign up for free](https://app.kontent.ai/sign-up) and create a new project.

2.  **Delivery API keys** - You will need the Environment ID for published content and the Preview API key for fetching drafts (optional). Both keys are located in the **Environment Settings -> API keys** tab in Kontent.ai.



### Setting up credentials


[Section titled Setting up credentials](#setting-up-credentials)

To add your Kontent.ai credentials to Astro, create a `.env` file in the root of your project with the following variables:

.env

```
KONTENT_ENVIRONMENT_ID=YOUR_ENVIRONMENT_IDKONTENT_PREVIEW_API_KEY=YOUR_PREVIEW_API_KEY
```

Now, these environment variables can be used in your Astro project.

If you would like to get [TypeScript IntelliSense for these environment variables](/en/guides/environment-variables/#intellisense-for-typescript), you can create a new `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly KONTENT_ENVIRONMENT_ID:string;readonly KONTENT_PREVIEW_API_KEY:string;}
```

Your root directory should now include these new files:

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect Astro with your Kontent.ai project, install the [Kontent.ai TypeScript SDK](https://github.com/kontent-ai/delivery-sdk-js):

-   [npm](#tab-panel-3093)
-   [pnpm](#tab-panel-3094)
-   [Yarn](#tab-panel-3095)

Terminal window

```
npminstall@kontent-ai/delivery-sdk
```

Terminal window

```
pnpmadd@kontent-ai/delivery-sdk
```

Terminal window

```
yarnadd@kontent-ai/delivery-sdk
```

Next, create a new file called `kontent.ts` in the `src/lib/` directory of your Astro project.

src/lib/kontent.ts

```
import { createDeliveryClient } from"@kontent-ai/delivery-sdk";export const deliveryClient = createDeliveryClient({environmentId: import.meta.env.KONTENT_ENVIRONMENT_ID,previewApiKey: import.meta.env.KONTENT_PREVIEW_API_KEY,});
```

Note

Read more on [getting environment variables in Astro](/en/guides/environment-variables/#getting-environment-variables).

This implementation creates a new `DeliveryClient` object using credentials from the `.env` file.

Previews

The `previewApiKey` is optional. When used, you can [configure each query](https://github.com/kontent-ai/delivery-sdk-js#enable-preview-mode-per-query) to the Delivery API endpoint to return the latest versions of content items regardless of their state in the workflow. Otherwise, only published items are returned.

Finally, the root directory of your Astro project should now include these new files:

-   Directorysrc/

    -   Directorylib/

        -   **kontent.ts**

    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json


### Fetching data


[Section titled Fetching data](#fetching-data)

The `DeliveryClient` is now available to all components. To fetch content, use the `DeliveryClient` and method chaining to define your desired items. This example shows a basic fetch of blog posts and renders their titles in a list:

src/pages/index.astro

```
---import { deliveryClient } from"../lib/kontent";const blogPosts = await deliveryClient.items().type("blogPost").toPromise()---<htmllang="en"><head><metacharset="utf-8" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><ul>{blogPosts.data.items.map(blogPost=> (<li>{blogPost.elements.title.value}</li>))}</ul></body></html>
```

You can find more querying options in the [Kontent.ai documentation](https://kontent.ai/learn/develop/hello-world/get-content/javascript).


## Making a blog with Astro and Kontent.ai


[Section titled Making a blog with Astro and Kontent.ai](#making-a-blog-with-astro-and-kontentai)

With the setup above, you are now able to create a blog that uses Kontent.ai as the source of content.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  **Kontent.ai project** - For this tutorial, using a blank project is recommended. If you already have some content types in your content model, you may use them, but you will need to modify the code snippets to match your content model.

2.  **Astro project configured for content fetching from Kontent.ai** - see above for more details on how to set up an Astro project with Kontent.ai



### Setting up content model


[Section titled Setting up content model](#setting-up-content-model)

In Kontent.ai, navigate to **Content model** and create a new content type with the following fields and values:

-   **Name:** Blog Post
-   Elements:
    -   Text field
        -   **Name:** Title
        -   **Element Required:** yes
    -   Rich text field
        -   **Name:** Teaser
        -   **Element Required:** yes
        -   **Allowed in this element:** only check Text
    -   Rich text field
        -   **Name:** Content
        -   **Element Required:** yes
    -   Date & time field
        -   **Name:** Date
    -   URL slug field
        -   **Name:** URL slug
        -   **Element Required:** yes
        -   **Auto-generate from:** select “Title”

Then, click on **Save Changes**.


### Creating content


[Section titled Creating content](#creating-content)

Now, navigate to **Content & assets** tab and create a new content item of type **Blog Post**. Fill the fields using these values:

-   **Content item name:** Astro
-   **Title:** Astro is amazing
-   **Teaser:** Astro is an all-in-one framework for building fast websites faster.
-   **Content:** You can use JavaScript to implement the website functionality, but no client bundle is necessary.
-   **Date & time:** select today
-   **URL slug:** astro-is-amazing

When you’re finished, publish the blog post using the **Publish** button at the top.

*Note: Feel free to create as many blog posts as you like before moving to the next step.*


### Generating content model in TypeScript


[Section titled Generating content model in TypeScript](#generating-content-model-in-typescript)

Next, you’ll generate TypeScript types out of your content model.

Note

This step is optional but provides a much better developer experience and allows you to discover potential problems at build time rather than at runtime.

First, install the [Kontent.ai JS model generator](https://github.com/kontent-ai/model-generator-js), [ts-node](https://github.com/TypeStrong/ts-node), and [dotenv](https://github.com/motdotla/dotenv):

-   [npm](#tab-panel-3096)
-   [pnpm](#tab-panel-3097)
-   [Yarn](#tab-panel-3098)

Terminal window

```
npminstall@kontent-ai/model-generatorts-nodedotenv
```

Terminal window

```
pnpmadd@kontent-ai/model-generatorts-nodedotenv
```

Terminal window

```
yarnadd@kontent-ai/model-generatorts-nodedotenv
```

Then, add the following script to package.json:

package.json

```
{..."scripts": {..."regenerate:models": "ts-node --esm ./generate-models.ts"},}
```

Because the types require structural information about your project that is not available in the public API, you also need to add a Content Management API key to the `.env` file. You can generate the key under **Environment settings -> API keys -> Management API**.

.env

```
KONTENT_ENVIRONMENT_ID=YOUR_ENVIRONMENT_IDKONTENT_PREVIEW_API_KEY=YOUR_PREVIEW_API_KEYKONTENT_MANAGEMENT_API_KEY=YOUR_MANAGEMENT_API_KEY
```

Finally, add the script `generate-models.ts` that configures the model generator to generate the models:

generate-models.ts

```
import { generateModelsAsync, textHelper } from'@kontent-ai/model-generator'import { rmSync, mkdirSync } from'fs'import*as dotenv from'dotenv'dotenv.config()const runAsync = async () => {rmSync('./src/models', { force: true, recursive: true })mkdirSync('./src/models')// change working directory to modelsprocess.chdir('./src/models')await generateModelsAsync({sdkType: 'delivery',apiKey: process.env.KONTENT_MANAGEMENT_API_KEY ?? '',environmentId: process.env.KONTENT_ENVIRONMENT_ID ?? '',addTimestamp: false,isEnterpriseSubscription: false,})}// Self-invocation async function;(async()=> {awaitrunAsync()})().catch(err=> {console.error(err)throw err})
```

Now, execute it:

-   [npm](#tab-panel-3099)
-   [pnpm](#tab-panel-3100)
-   [Yarn](#tab-panel-3101)

Terminal window

```
npmrunregenerate:models
```

Terminal window

```
pnpmrunregenerate:models
```

Terminal window

```
yarnrunregenerate:models
```


### Displaying a list of blog posts


[Section titled Displaying a list of blog posts](#displaying-a-list-of-blog-posts)

Now you’re ready to fetch some content. Go to the Astro page where you want to display a list of all blog posts, for example, the homepage `index.astro` in `src/pages`.

Fetch all blog posts in the frontmatter of the Astro page:

src/pages/index.astro

```
---import { deliveryClient } from'../lib/kontent';importtype { BlogPost } from'../models';import { contentTypes } from'../models/project/contentTypes';const blogPosts = await deliveryClient.items<BlogPost>.type(contentTypes.blog_post.codename).toPromise()---
```

If you skipped the model generation, you can also use an untyped object and string literal to define the type:

```
const blogPosts = await deliveryClient.items().type("blogPost").toPromise()
```

The fetch call will return a `response` object which contains a list of all blog posts in `data.items`. In the HTML section of the Astro page, you can use the `map()` function to list the blog posts:

src/pages/index.astro

```
---import { deliveryClient } from'../lib/kontent';importtype { BlogPost } from'../models';import { contentTypes } from'../models/project/contentTypes';const blogPosts = await deliveryClient.items<BlogPost>.type(contentTypes.blogPost.codename).toPromise()---<htmllang="en"><head><metacharset="utf-8" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><h1>Blog posts</h1><ul>{blogPosts.data.items.map(blogPost=> (<li><ahref={`/blog/${blogPost.elements.url_slug.value}/`}title={blogPost.elements.title.value}>{blogPost.elements.title.value}</a></li>))}</ul></body></html>
```


### Generating individual blog posts


[Section titled Generating individual blog posts](#generating-individual-blog-posts)

The last step of the tutorial is to generate detailed blog post pages.


#### Static site generation


[Section titled Static site generation](#static-site-generation)

In this section, you’ll use the [Static (SSG) Mode](/en/guides/routing/#static-ssg-mode) with Astro.

First, create a file `[slug].astro` in `/src/pages/blog/` which needs to export a function `getStaticPaths` that collects all data from the CMS:

src/pages/blog/\[slug\].astro

```
---import { deliveryClient } from'../../lib/kontent';importtype { BlogPost } from'../../models';import { contentTypes } from'../../models/project/contentTypes';exportasyncfunctiongetStaticPaths() {const blogPosts = await deliveryClient.items<BlogPost>().type(contentTypes.blog_post.codename).toPromise()---
```

So far, the function fetches all blog posts from Kontent.ai. The code snippet is exactly the same as what you used on the home page.

Next, the function must export paths and data for each blog post. You named the file `[slug].astro`, so the param which represents the URL slug is called `slug`:

src/pages/blog/\[slug\].astro

```
---import { deliveryClient } from'../../lib/kontent';importtype { BlogPost } from'../../models';import { contentTypes } from'../../models/project/contentTypes';exportasyncfunctiongetStaticPaths() {const blogPosts = await deliveryClient.items<BlogPost>().type(contentTypes.blog_post.codename).toPromise()return blogPosts.data.items.map(blogPost=> ({params: { slug: blogPost.elements.url_slug.value },props: { blogPost }}))}---
```

The last part is to provide the HTML template and display each blog post:

src/pages/blog/\[slug\].astro

```
---import { deliveryClient } from'../../lib/kontent';importtype { BlogPost } from'../../models';import { contentTypes } from'../../models/project/contentTypes';exportasyncfunctiongetStaticPaths() {const blogPosts = await deliveryClient.items<BlogPost>().type(contentTypes.blog_post.codename).toPromise()return blogPosts.data.items.map(blogPost=> ({params: { slug: blogPost.elements.url_slug.value },props: { blogPost }}))}const blogPost:BlogPost = Astro.props.blogPost---<htmllang="en"><head><metacharset="utf-8" /><metaname="viewport"content="width=device-width" /><title>{blogPost.elements.title.value}</title></head><body><article><h1>{blogPost.elements.title.value}</h1><Fragmentset:html={blogPost.elements.teaser.value} /><Fragmentset:html={blogPost.elements.content.value} /><time>{newDate(blogPost.elements.date.value??"")}</time></body></html>
```

Navigate to your Astro preview ([http://localhost:4321/blog/astro-is-amazing/](http://localhost:4321/blog/astro-is-amazing/) by default) to see the rendered blog post.


#### On-demand rendering


[Section titled On-demand rendering](#on-demand-rendering)

If your routes are [rendered on demand](/en/guides/on-demand-rendering/), you will use dynamic routes to fetch the page data from Kontent.ai.

Create a new file `[slug].astro` in `/src/pages/blog/` and add the following code. The data fetching is very similar to previous use cases but adds an `equalsFilter` that lets us find the right blog post based on the used URL:

src/pages/blog/\[slug\].astro

```
---import { deliveryClient } from'../../lib/kontent';importtype { BlogPost } from'../../models';import { contentTypes } from'../../models/project/contentTypes';const { slug } = Astro.paramslet blogPost:BlogPost;try {const data = await deliveryClient.items<BlogPost>().equalsFilter(contentTypes.blog_post.elements.url_slug.codename, slug ??'').type(contentTypes.blog_post.codename).limitParameter(1).toPromise()blogPost = data.data.items[0]} catch (error) {return Astro.redirect('/404')}---
```

If you’re not using generated types, you can instead use string literals to define the content item type and the filtered element codename:

```
const data = await deliveryClient.items().equalsFilter("url_slug", slug ??'').type("blog_post").limitParameter(1).toPromise()
```

Lastly, add the HTML code to render the blog post. This part is the same as with static generation:

src/pages/blog/\[slug\].astro

```
---import { deliveryClient } from'../../lib/kontent';importtype { BlogPost } from'../../models';import { contentTypes } from'../../models/project/contentTypes';const { slug } = Astro.paramslet blogPost:BlogPost;try {const data = await deliveryClient.items<BlogPost>().equalsFilter(contentTypes.blog_post.elements.url_slug.codename, slug ??'').type(contentTypes.blog_post.codename).limitParameter(1).toPromise()blogPost = data.data.items[0]} catch (error) {return Astro.redirect('/404')}---<htmllang="en"><head><metacharset="utf-8" /><metaname="viewport"content="width=device-width" /><title>{blogPost.elements.title.value}</title></head><body><article><h1>{blogPost.elements.title.value}</h1><Fragmentset:html={blogPost.elements.teaser.value} /><Fragmentset:html={blogPost.elements.content.value} /><time>{newDate(blogPost.elements.date.value??'')}</time></body></html>
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit the [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


#### Rebuild on Kontent.ai changes


[Section titled Rebuild on Kontent.ai changes](#rebuild-on-kontentai-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Kontent.ai events.


##### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



##### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



##### Adding a webhook to Kontent.ai


[Section titled Adding a webhook to Kontent.ai](#adding-a-webhook-to-kontentai)

In the [Kontent.ai app](https://kontent.ai/learn/docs/webhooks/javascript), go to **Environment settings -> Webhooks**. Click on **Create new webhook** and provide a name for your new webhook. Paste in the URL you copied from Netlify or Vercel and select which events should trigger the webhook. By default, for rebuilding your site when published content changes, you only need **Publish** and **Unpublish** events under **Delivery API triggers**. When you’re finished, click on Save.

Now, whenever you publish a new blog post in Kontent.ai, a new build will be triggered and your blog will be updated.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 45. `en/guides/cms/microcms/.md`

```text
# microCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/microcms/
description: Add content to your Astro project using microCMS
---


# microCMS & Astro


[microCMS](https://microcms.io/en) is an API-based headless CMS that lets you define content using schemas, and manage it using the dashboard.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Check out [the official microCMS document](https://document.microcms.io/tutorial/astro/astro-top)
-   Blog: [Build a blog with microCMS](https://blog.microcms.io/astro-microcms-introduction/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 46. `en/guides/cms/payload/.md`

```text
# Payload CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/payload/
description: Add content to your Astro project using Payload as a CMS
---


# Payload CMS & Astro


[PayloadCMS](https://payloadcms.com/) is a headless open-source content management system that can be used to provide content for your Astro project.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)


### Prerequisites


[Section titled Prerequisites](#prerequisites)

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.
2.  **A MongoDB database** - PayloadCMS will ask you for a MongoDB connection string when creating a new project. You can set one up locally or use [MongoDBAtlas](https://www.mongodb.com/) to host a database on the web for free.
3.  **A PayloadCMS REST API** - Create a [PayloadCMS](https://payloadcms.com/docs/getting-started/installation) project and connect it to your MongoDB database during the setup.

Choosing a template

During the PayloadCMS installation, you will be asked if you want to use a template.

Choosing any of the available templates at this step (such as ‘blog’) automatically generates additional collections for you to use. Otherwise, you will need to manually create your PayloadCMS collections.


### Configuring Astro for your PayloadCMS collection


[Section titled Configuring Astro for your PayloadCMS collection](#configuring-astro-for-your-payloadcms-collection)

Your Payload project template will contain a file called Posts.ts in `src/collections/`. If you did not choose a template during installation that created a content collection for you, you can create a new Payload CMS Collection by adding this configuration file manually. The example below shows this file for a collection called `posts` that requires `title`, `content`, and `slug` fields:

src/collections/Posts.ts

```
import { CollectionConfig } from"payload/types";const Posts:CollectionConfig = {slug: "posts",admin: {useAsTitle: "title",},access: {read: () => true,},fields: [{name: "title",type: "text",required: true,},{name: "content",type: "text",required: true,},{name: "slug",type: "text",required: true,},],};exportdefault Posts;
```

1.  Import and add both `Users` (available in all PayloadCMS projects) and any other collections (e.g. `Posts`) to the available collections in the `payload.config.ts` file.

    src/payload.config.ts

    ```
    import { buildConfig } from"payload/config";import path from"path";import Users from"./collections/Users";import Posts from"./collections/Posts";exportdefaultbuildConfig({serverURL: "http://localhost:4321",admin: {user: Users.slug,},collections: [Users, Posts],typescript: {outputFile: path.resolve(__dirname, "payload-types.ts"),},graphQL: {schemaOutputFile: path.resolve(__dirname, "generated-schema.graphql"),},});
    ```

    This will make a new collection called “Posts” appear in your PayloadCMS Dashboard next to the “Users” collection.

2.  Enter the “Posts” collection and create a new post. After saving it, you will notice the API URL appear in the bottom right corner.

3.  With the dev server running, open `http://localhost:4321/api/posts` in your browser. You should see a JSON file containing the post you have created as an object.

    ```
    {"docs":[{"id":"64098b16483b0f06a7e20ed4","title":"Astro & PayloadCMS Title 🚀","content":"Astro & PayloadCMS Content","slug":"astro-payloadcms-slug","createdAt":"2023-03-09T07:30:30.837Z","updatedAt":"2023-03-09T07:30:30.837Z"}],"totalDocs":1,"limit":10,"totalPages":1,"page":1,"pagingCounter":1,"hasPrevPage":false,"hasNextPage":false,"prevPage":null,"nextPage":null}
    ```


Tip

By default, both Astro and PayloadCMS will use port 4321. You might want to change the PayloadCMS port in the `src/server.ts` file. Don’t forget to update the `serverURL` in `src/payload.config.ts` as well.


### Fetching Data


[Section titled Fetching Data](#fetching-data)

Fetch your PayloadCMS data through your site’s unique REST API URL and the route for your content. (By default, PayloadCMS will mount all routes through `/api`.) Then, you can render your data properties using Astro’s `set:html=""` directive.

Together with your post, PayloadCMS will return some top-level metadata. The actual documents are nested within the `docs` array.

For example, to display a list of post titles and their content:

src/pages/index.astro

```
---import HomeLayout from"../layouts/HomeLayout.astro";const res = await fetch("http://localhost:5000/api/posts")// http://localhost:4321/api/posts by defaultconst posts = await res.json()---<HomeLayouttitle='Astro Blog'>{posts.docs.map((post)=> (<h2set:html={post.title} /><pset:html={post.content} />))}</HomeLayout>
```


## Building a blog with PayloadCMS and Astro


[Section titled Building a blog with PayloadCMS and Astro](#building-a-blog-with-payloadcms-and-astro)

Create a blog index page `src/pages/index.astro` to list each of your posts with a link to its own page.

Fetching via the API returns an array of objects (posts) that include, among others, the following properties:

-   `title`
-   `content`
-   `slug`

src/pages/index.astro

```
---import HomeLayout from"../layouts/HomeLayout.astro";const res = await fetch("http://localhost:5000/api/posts")// http://localhost:4321/api/posts by defaultconst posts = await res.json()---<HomeLayouttitle='Astro Blog'><h1>Astro + PayloadCMS 🚀</h1><h2>Blog posts list:</h2><ul>{posts.docs.map((post)=>(<li><ahref={`posts/${post.slug}`}set:html={post.title} /></li>))}</ul></HomeLayout>
```


### Using the PayloadCMS API to generate pages


[Section titled Using the PayloadCMS API to generate pages](#using-the-payloadcms-api-to-generate-pages)

Create a page `src/pages/posts/[slug].astro` to [dynamically generate a page](/en/guides/routing/#dynamic-routes) for each post.

src/pages/posts/\[slug\].astro

```
---import PostLayout from"../../layouts/PostLayout.astro"const {title, content} = Astro.props// The getStaticPaths() is required for static Astro sites.// If using SSR, you will not need this function.exportasyncfunctiongetStaticPaths() {let data = await fetch("http://localhost:5000/api/posts")let posts = await data.json()return posts.docs.map((post)=> {return {params: {slug: post.slug},props: {title: post.title, content: post.content},};});}---<PostLayouttitle={title}><article><h1set:html={title} /><pset:html={content} /></article></PostLayout>
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your site visit our [deployment guide](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

-   Check out the [official Astro Payload CMS integration](https://github.com/payloadcms/payload/tree/main/examples/astro).
-   Try this [Payload CMS & Astro Template](https://github.com/Lambdo-Labs/payloadcms-astro-template).
-   Check out [Astroad](https://github.com/mooxl/astroad) for easy development and VPS deployment with Docker.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 47. `en/guides/cms/preprcms/.md`

```text
# Prepr CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/preprcms/
description: Add content to your Astro project using Prepr as a CMS
---


# Prepr CMS & Astro


[Prepr CMS](https://www.prepr.io/) is a headless CMS with built-in personalization.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

Prepr CMS provides a [GraphQL API](https://docs.prepr.io/reference/graphql/v1/overview) to connect your data to Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need the following:

-   A new or existing Astro project configured for [on-demand rendering](/en/guides/on-demand-rendering/).
-   [A free Prepr account](https://signup.prepr.io/)
-   [A Prepr environment with existing blog posts](https://docs.prepr.io/account/set-up-environments#create-an-envirntonment). These posts must include a `title` and `content`. Other fields are optional.


### Setting up credentials


[Section titled Setting up credentials](#setting-up-credentials)

To add the Prepr endpoint to your Astro project, create a `.env file` in the root of your project if one does not already exist and add the following variable:

.env

```
PREPR_ENDPOINT=YOUR_PREPR_API_URL
```

You will find your `YOUR_PREPR_API_URL` value from your Prepr account settings:

1.  Go to  **Settings > Access tokens** to view both your Preview and Production access tokens.

2.  Use the **API URL** value from the **GraphQL Production** access token to only retrieve published content items for your Astro site.



### Configuring the Prepr endpoint


[Section titled Configuring the Prepr endpoint](#configuring-the-prepr-endpoint)

Create a new folder `src/lib/` and add a new file called `prepr.js`. This is where you will configure the Prepr endpoint. Add the following code to fetch your data from Prepr CMS:

src/lib/prepr.js

```
exportasyncfunctionPrepr(query, variables) {const response = await fetch(import.meta.env.PREPR_ENDPOINT, {method: 'POST',headers: {'Content-Type': 'application/json'},body: JSON.stringify({ query,variables }),})returnresponse}
```

Your root directory should now include these files:

-   Directorysrc/

    -   Directorylib/

        -   **prepr.js**


-   **.env**
-   astro.config.mjs
-   package.json


### Fetching data


[Section titled Fetching data](#fetching-data)

You will fetch your data from Prepr by writing queries to interact with its GraphQL API.


#### Create a GraphQL query to retrieve your blog articles:


[Section titled Create a GraphQL query to retrieve your blog articles:](#create-a-graphql-query-to-retrieve-your-blog-articles)

1.  Create a new folder `src/queries/` and add a file named `get-articles.js`.

2.  Add the following query to this file to retrieve all articles:

    src/queries/get-articles.js

    ```
    const GetArticles = `query {Articles {items {_id_slugtitle}}}`exportdefaultGetArticles
    ```

3.  To display a linked list of your blog posts on a page, import and execute your query, including the necessary Prepr endpoint. You will then have access to all your posts titles and their slugs to render to the page. (In the next step, you will [create individual pages for your blog posts](#creating-individual-blog-post-pages).)

    src/pages/index.astro

    ```
    ---import Layout from'../layouts/Layout.astro';import { Prepr } from'../lib/prepr.js';import GetArticles from'../queries/get-articles.js';const response = await Prepr(GetArticles)const { data } = await response.json()const articles = data.Articles---<Layouttitle="My blog site"><h1>My blog site</h1><ul>{articles.items.map((post)=> (<li><ahref={post._slug}>{post.title}</a></li>))}</ul></Layout>
    ```


Your root directory should include these new files:

-   Directorysrc/

    -   Directorylib/

        -   prepr.js

    -   Directorypages/

        -   index.astro

    -   Directory**queries** /

        -   **get-articles.js**


-   .env
-   astro.config.mjs
-   package.json


#### Creating individual blog post pages


[Section titled Creating individual blog post pages](#creating-individual-blog-post-pages)

To create a page for each blog post, you will execute a new GraphQL query on a [dynamic routing](/en/guides/routing/#on-demand-dynamic-routes) `.astro` page. This query will fetch a specific article by its slug and a new page will be created for each individual blog post.

1.  Create a file called `get-article-by-slug.js` in the `queries` folder and add the following to query a specific article by its slug and return data such as the article `title` and `content`:

    src/lib/queries/get-article-by-slug.js

    ```
    const GetArticleBySlug = `query ($slug: String) {Article (slug: $slug) {_idtitlecontent {__typename... on Text {bodytext}... on Assets {items {url}}}}}`exportdefaultGetArticleBySlug
    ```

    Tip

    You can create and [test GraphQL queries](https://docs.prepr.io/reference/graphql/v1/test-queries) using the [Apollo explorer](https://studio.apollographql.com/sandbox/explorer) in Prepr. Open the API Explorer from the *Article* content item page in Prepr. The Article content is stored in a *Dynamic content field*. Check out the GraphQL docs for more details on [how to fetch the data within this field](https://docs.prepr.io/reference/graphql/v1/schema-field-types-dynamic-content-field).

2.  Inside the `src/pages` folder, create a file called `[…slug].astro`. Add the following code to import and execute the query from the previous step and display the retrieved article:

    src/pages/\[...slug\].astro

    ```
    ---import Layout from'../layouts/Layout.astro';import {Prepr} from'../lib/prepr.js';import GetArticleBySlug from'../queries/get-article-by-slug.js';const { slug } = Astro.params;const response = await Prepr(GetArticleBySlug, {slug})const { data } = await response.json()const article = data.Article---<Layouttitle={article.title}><main><h1>{article.title}</h1>{article.content.map((content)=> (<div>{content.__typename==="Assets"&&<imgsrc={content.items[0].url}width="300"height="250"/>}{content.__typename==='Text'&&<divset:html={content.body}></div>}</div>))}</main></Layout>
    ```


Your root directory should now include these new files:

-   Directorysrc/

    -   Directorylib/

        -   prepr.js

    -   Directorypages/

        -   index.astro
        -   **\[…slug\].astro**

    -   Directoryqueries/

        -   get-articles.js
        -   **get-article-by-slug.js**


-   .env
-   astro.config.mjs
-   package.json

Now, when you click an article link from the main list of blog posts, you will be taken to a page with its individual content.


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your Prepr blog, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Follow the [Prepr CMS Astro quickstart](https://github.com/preprio/astro-quick-start) guide to make a simple blog with Astro and Prepr CMS. 
-   Check out the [Connecting Prepr CMS to Astro](https://docs.prepr.io/connecting-front-end-apps/astro) for an overview of Astro and Prepr CMS resources.


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 48. `en/guides/cms/prismic/.md`

```text
# Prismic & Astro


---
url: https://docs.astro.build/en/guides/cms/prismic/
description: Add content to your Astro project using Prismic as a CMS
---


# Prismic & Astro


[Prismic](https://prismic.io/) is a headless content management system.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Building with Astro & Prismic - w/ Nate Moore](https://www.youtube.com/watch?v=qFUfuDSLdxM) (livestream) and the [repo from the show](https://github.com/natemoo-re/miles-of-code).


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 49. `en/guides/cms/sanity/.md`

```text
# Sanity & Astro


---
url: https://docs.astro.build/en/guides/cms/sanity/
description: Add content to your Astro project using Sanity as a CMS
---


# Sanity & Astro


[Sanity](https://www.sanity.io) is a headless content management system that focuses on [structured content](https://www.sanity.io/structured-content-platform).


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Official Sanity integration for Astro](https://www.sanity.io/plugins/sanity-astro)

-   [Build your blog with Astro and Sanity](https://www.sanity.io/guides/sanity-astro-blog)

-   [A minimal Astro site with a Sanity Studio](https://www.sanity.io/templates/astro-sanity-clean)



## Themes


[Section titled Themes](#themes)

-   [The Balanced Chef](https://astro.build/themes/details/the-balanced-chef/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 50. `en/guides/cms/sitecore/.md`

```text
# Sitecore Experience Manager & Astro


---
url: https://docs.astro.build/en/guides/cms/sitecore/
description: Add content to your project using Sitecore as your CMS.
---


# Sitecore Experience Manager & Astro


[Sitecore Experience Manager (XM)](https://www.sitecore.com/products/experience-manager) is an enterprise-level content management system built on ASP.NET.


## Getting started


[Section titled Getting started](#getting-started)

1.  [Create a Sitecore Headless website](https://doc.sitecore.com/xp/en/developers/sxa/103/sitecore-experience-accelerator/create-a-headless-tenant-and-site.html) following Sitecore’s official documentation.

2.  Run the following project initialization command in your terminal:

    Terminal window

    ```
    npx@astro-sitecore-jss/create-astro-sitecore-jss@latest
    ```

3.  Follow the instructions in the terminal to create your project.



## Community Resources


[Section titled Community Resources](#community-resources)

-   [Sitecore JavaScript Software Development Kit for Astro](https://github.com/exdst/jss-astro-public) on GitHub
-   [Introduction to Sitecore with Astro](https://exdst.com/posts/20231002-sitecore-astro)
-   [Starting Your First Sitecore Astro Project](https://exdst.com/posts/20240103-first-sitecore-astro-project)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 51. `en/guides/cms/spinal/.md`

```text
# Spinal & Astro


---
url: https://docs.astro.build/en/guides/cms/spinal/
description: Add content to your project using Spinal as your CMS.
---


# Spinal & Astro


[Spinal](https://spinalcms.com/cms-for-astro/) is a commercial, SaaS-focused, Git-based CMS.


## Getting started


[Section titled Getting started](#getting-started)

1.  [Create a Spinal account](https://spinalcms.com/signup/).

2.  Connect your GitHub account to Spinal.

3.  Select your Astro repository when prompted.


All Markdown content from the selected folder will be imported into your Spinal account and is ready to be edited.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Documentation theme built for Astro with Tailwind CSS](https://spinalcms.com/resources/astro-documentation-theme-with-tailwind-css/)


## Production Sites


[Section titled Production Sites](#production-sites)

The following sites use Astro + Spinal in production:

-   [spinalcms.com](https://spinalcms.com/) (all blog articles, documentation, changelog, feature pages, etc.)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 52. `en/guides/cms/statamic/.md`

```text
# Headless Statamic & Astro


---
url: https://docs.astro.build/en/guides/cms/statamic/
description: Add content to your Astro project using Statamic as a CMS
---


# Headless Statamic & Astro


[Statamic](https://statamic.com/) is a modern, flat-file CMS. It allows developers to easily create dynamic websites and applications while offering content editors an intuitive and user-friendly interface for managing content.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

Statamic comes with a built-in [REST API](https://statamic.dev/rest-api) and [GraphQL API](https://statamic.dev/graphql) to connect your data to Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  REST API and GraphQL API are only available in a pro version of Statamic. You can try the Pro version free on your [local machine](https://statamic.dev/tips/how-to-enable-statamic-pro#trial-mode).
2.  **An Astro project** - If you still need an Astro project, our [Installation guide](/en/install-and-setup/) will get you up and running quickly.
3.  **A Statamic site** - If you need a Statamic website, [this guide](https://statamic.dev/quick-start-guide) will help you get started. Remember to [enable REST API](https://statamic.dev/rest-api#enable-the-api) or [GraphQL API](https://statamic.dev/graphql#enable-graphql) by adding `STATAMIC_API_ENABLED=true` or `STATAMIC_GRAPHQL_ENABLED=true` in the `.env` file and enable required resources in the API configuration file.

Caution

All the examples assume that your website has a collection called `posts`, that has a blueprint called `post`, and this blueprint has a title field (fieldtype text) and content (fieldtype markdown).


### Fetching Data


[Section titled Fetching Data](#fetching-data)

Caution

If you are using Statamic and Astro on your local machine remember to use `127.0.0.1` instead of `localhost` when fetching the API.

When requesting from the Astro server `localhost` doesn’t resolve correctly like it does in the browser, and any fetch to either API will fail.


#### REST API


[Section titled REST API](#rest-api)

Fetch your Statamic data from your site’s REST API URL. By default, it’s `https://[YOUR-SITE]/api/`. Then, you can render your data properties using Astro’s `set:html={}` directive.

For example, to display a list of titles and their content from a selected [collection](https://statamic.dev/collections):

src/pages/index.astro

```
---const res = await fetch("https://[YOUR-SITE]/api/collections/posts/entries?sort=-date")const posts = await res.json()---<h1>Astro + Statamic 🚀</h1>{posts.map((post)=> (<h2set:html={post.title} /><pset:html={post.content} />))}
```


#### GraphQL


[Section titled GraphQL](#graphql)

Fetch your Statamic data with your site’s GraphQL API URL. By default, it’s `https://[YOUR-SITE]/graphql/`. Then, you can render your data properties using Astro’s `set:html={}` directive.

For example, to display a list of titles and their content from a selected [collection](https://statamic.dev/collections):

src/pages/index.astro

```
---const graphqlQuery = {query: `query Entries($page: Int, $locale: String) {entries(collection: "posts"sort: "date asc"limit: 20page: $pagefilter: { locale: $locale }) {current_pagehas_more_pagesdata {title... on Entry_Posts_Post {content}}}}`,variables: {page: page,locale: locale,},};const res = await fetch("https://[YOUR-SITE]/graphql", {method: "POST",headers: { "Content-Type": "application/json" },body: JSON.stringify(graphqlQuery),})const { data } = await res.json();const entries = data?.entries;---<h1>Astro + Statamic 🚀</h1>{entries.data.map((post)=> (<h2set:html={post.title} /><pset:html={post.content} />))}
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your Astro site visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [How to build a static site using Statamic as headless CMS](https://buddy.works/guides/statamic-rest-api)
-   [Implementing Astro live previews in headless Statamic](https://maciekpalmowski.dev/implementing-live-previews-in-headless-statamic-when-using-astro/)


## Themes


[Section titled Themes](#themes)

-   [Creek](https://astro.build/themes/details/creek/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 53. `en/guides/cms/storyblok/.md`

```text
# Storyblok & Astro


---
url: https://docs.astro.build/en/guides/cms/storyblok/
description: Add content to your Astro project using Storyblok as a CMS
---


# Storyblok & Astro


[Storyblok](https://www.storyblok.com/) is a component-based headless CMS that allows you to manage your content using reusable components called Bloks.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section, you will use the [Storyblok integration](https://github.com/storyblok/storyblok-astro) to connect Storyblok to Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

2.  **A Storyblok account and space** - If you don’t have an account yet, [sign up for free](https://app.storyblok.com/#/signup) and create a new space.

3.  **Storyblok Preview token** - This token will be used to fetch drafts and published versions of your content. You can find and generate your API token in the Access Tokens tab of your Storyblok space settings.



### Setting up credentials


[Section titled Setting up credentials](#setting-up-credentials)

To add your Storyblok credentials to Astro, create a `.env` file in the root of your project with the following variable:

.env

```
STORYBLOK_TOKEN=YOUR_PREVIEW_TOKEN
```

Now, you should be able to use these environment variables in your project.

Your root directory should now include this new file:

-   Directorysrc/

    -   …

-   **.env**
-   astro.config.mjs
-   package.json


### Installing dependencies


[Section titled Installing dependencies](#installing-dependencies)

To connect Astro with your Storyblok space, install the official [Storyblok integration](https://github.com/storyblok/storyblok-astro) using the command below for your preferred package manager:

-   [npm](#tab-panel-3102)
-   [pnpm](#tab-panel-3103)
-   [Yarn](#tab-panel-3104)

Terminal window

```
npminstall@storyblok/astrovite
```

Terminal window

```
pnpmadd@storyblok/astrovite
```

Terminal window

```
yarnadd@storyblok/astrovite
```


### Configuring Storyblok


[Section titled Configuring Storyblok](#configuring-storyblok)

Modify your Astro config file to include the Storyblok integration:

astro.config.mjs

```
import { defineConfig } from'astro/config';import { storyblok } from'@storyblok/astro';import { loadEnv } from'vite';const env = loadEnv("", process.cwd(), 'STORYBLOK');exportdefaultdefineConfig({integrations: [storyblok({accessToken: env.STORYBLOK_TOKEN,components: {// Add your components here},apiOptions: {// Choose your Storyblok space regionregion: 'us', // optional,  or 'eu' (default)},})],});
```

The Storyblok integration requires an object with the following properties:

1.  `accessToken` - This references the Storyblok API token that you added in the previous step.

    Tip

    Since the Astro config file does not normally support environment variables, use the `loadEnv` function from Vite to load them.

2.  `components` - An object that maps Storyblok component names to paths to your local components. This is required to render your Storyblok Bloks in Astro.

    Note

    The component paths are relative to the `src` directory. For example, if your component is located at `src/storyblok/MyComponent.astro`, the path would be `storyblok/MyComponent` (without the `.astro` extension).

3.  `apiOptions` - An object containing [Storyblok API options](https://github.com/storyblok/storyblok-astro#options).

    Caution

    By default, the region is `eu`. If your Storyblok space was created in the US region, you will need to set the region to `us`.



### Connecting Bloks to Astro components


[Section titled Connecting Bloks to Astro components](#connecting-bloks-to-astro-components)

To connect your Bloks to Astro, create a new folder named `storyblok` in the `src` directory. This folder will contain all the Astro components that will match your Bloks in your Storyblok Blok library.

In this example, you have a `blogPost` Blok content type in your Storyblok library with the following fields:

-   `title` - A text field
-   `description` - A text field
-   `content` - A rich text field

Our goal is to create the equivalent Astro component that will use these fields to render its content. To do this, create a new file named `BlogPost.astro` inside `src/storyblok` with the following content:

src/storyblok/BlogPost.astro

```
---import { storyblokEditable, renderRichText } from'@storyblok/astro'const { blok } = Astro.propsconst content = renderRichText(blok.content)---<article {...storyblokEditable(blok)}><h1>{blok.title}</h1><p>{blok.description}</p><Fragmentset:html={content} /></article>
```

The `blok` property contains the data that you will receive from Storyblok. It also contains the fields that were defined in the `blogPost` content type Blok in Storyblok.

To render our content, the integration provides utility functions such as:

-   `storyblokEditable` - it adds the necessary attributes to the elements so that you can edit them in Storyblok.
-   `renderRichText` - it transforms the rich text field into HTML.

Your root directory should include this new file:

-   Directorysrc/

    -   Directorystoryblok/

        -   **BlogPost.astro**


-   .env
-   astro.config.mjs
-   package.json

Finally, to connect the `blogPost` Blok to the `BlogPost` component, add a new property to your components object in your Astro config file.

-   The key is the name of the Blok in Storyblok. In this case, it is `blogPost`.
-   The value is the path to the component. In this case, it is `storyblok/BlogPost`.

Caution

The `key` should exactly match your Blok name in Storyblok to be referenced correctly. If these don’t match, or you’re trying to reference a component that doesn’t exist in Storyblok, you’ll get an error.

astro.config.mjs

```
import { defineConfig } from'astro/config';import { storyblok } from'@storyblok/astro';import { loadEnv } from'vite';const env = loadEnv("", process.cwd(), 'STORYBLOK');exportdefaultdefineConfig({integrations: [storyblok({accessToken: env.STORYBLOK_TOKEN,components: {blogPost: 'storyblok/BlogPost',},apiOptions: {region: 'us',},})],});
```


### Fetching data


[Section titled Fetching data](#fetching-data)

To test the setup, in Storyblok create a new story with the `blogPost` content type named `test-post`. In Astro, create a new page in the `src/pages/` directory named `test-post.astro` with the following content:

src/pages/test-post.astro

```
---import { useStoryblokApi } from'@storyblok/astro'import StoryblokComponent from'@storyblok/astro/StoryblokComponent.astro'const storyblokApi = useStoryblokApi()const { data } = await storyblokApi.get("cdn/stories/test-post", {version: import.meta.env.DEV ? "draft" : "published",});const content = data.story.content;---<StoryblokComponentblok={content} />
```

To query your data, use the `useStoryblokApi` hook. This will initialize a new client instance using your integration configuration.

To render your content, pass the `content` property of the Story to the `StoryblokComponent` as a `blok` prop. This component will render the Bloks that are defined inside the `content` property. In this case, it will render the `BlogPost` component.


## Making a blog with Astro and Storyblok


[Section titled Making a blog with Astro and Storyblok](#making-a-blog-with-astro-and-storyblok)

With the integration set up, you can now create a blog with Astro and Storyblok.


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

1.  **A Storyblok space** - For this tutorial, we recommend using a new space. If you already have a space with Bloks, feel free to use them, but you will need to modify the code to match the Blok names and content types.

2.  **An Astro project integrated with Storyblok** - See [integrating with Astro](#integrating-with-astro) for instructions on how to set up the integration.



### Creating a blok library


[Section titled Creating a blok library](#creating-a-blok-library)

To create Bloks, go to the Storyblok app and click on the **Block Library** tab. Click on the \+ New blok button and create the following Bloks:

1.  `blogPost` - A content type Blok with the following fields:

    -   `title` - A text field
    -   `description` - A text field
    -   `content` - A rich text field
2.  `blogPostList` - An empty nestable Blok

3.  `page` - A content type Blok with the following fields:

    -   `body` - A nestable Blok


### Creating content


[Section titled Creating content](#creating-content)

To add new content, go to the content section by clicking on the **Content** tab. Using the Blok library that you created in the previous step, create the following stories:

1.  `home` - A content type story with the `page` Blok. Inside the `body` field, add a `blogPostList` Blok.

2.  `blog/no-javascript` - A story with the `blogPost` content type inside the blog folder.

    ```
    title: No JavaScriptdescription: A sample blog postcontent: Hi there! This blog post doesn't use JavaScript.
    ```

3.  `blog/astro-is-amazing` - A story with the `blogPost` content type inside the blog folder.

    ```
    title: Astro is amazingdescription: We love Astrocontent: Hi there! This blog post was build with Astro.
    ```


Now that you have your content ready, return to your Astro project and start building your blog.


### Connecting Bloks to components


[Section titled Connecting Bloks to components](#connecting-bloks-to-components)

To connect your newly created Bloks to Astro components, create a new folder named `storyblok` in your `src` directory and add the following files:

`Page.astro` is a nestable Block content type component that will recursively render all the Bloks inside the `body` property of the `page` Blok. It also adds the `storyblokEditable` attributes to the parent element which will allow us to edit the page in Storyblok.

src/storyblok/Page.astro

```
---import { storyblokEditable } from'@storyblok/astro'import StoryblokComponent from"@storyblok/astro/StoryblokComponent.astro";const { blok } = Astro.props---<main {...storyblokEditable(blok)}>{blok.body?.map((blok)=> {return<StoryblokComponentblok={blok} />})}</main>
```

`BlogPost.astro` will render the `title`, `description` and `content` properties of the `blogPost` Blok.

To transform the `content` property from a rich text field to HTML, you can use the `renderRichText` helper function.

src/storyblok/BlogPost.astro

```
---import { storyblokEditable, renderRichText } from'@storyblok/astro'const { blok } = Astro.propsconst content = renderRichText(blok.content)---<article {...storyblokEditable(blok)}><h1>{blok.title}</h1><p>{blok.description}</p><Fragmentset:html={content} /></article>
```

`BlogPostList.astro` is a nestable Blok content type component that will render a list of blog post previews.

It uses the `useStoryblokApi` hook to fetch all the stories with the content type of `blogPost`. It uses the `version` query parameter to fetch the draft versions of the stories when in development mode and the published versions when building for production.

`Astro.props` is used to set up the editor in Storyblok. Additional props can also be passed to your component here, if needed.

src/storyblok/BlogPostList.astro

```
---import { storyblokEditable } from'@storyblok/astro'import { useStoryblokApi } from'@storyblok/astro'const storyblokApi = useStoryblokApi();const { data } = await storyblokApi.get('cdn/stories', {version: import.meta.env.DEV ? "draft" : "published",content_type: 'blogPost',})const posts = data.stories.map(story => {return {title: story.content.title,date: newDate(story.published_at).toLocaleDateString("en-US", {dateStyle: "full"}),description: story.content.description,slug: story.full_slug,}})const { blok } = Astro.props---<ul {...storyblokEditable(blok)}>{posts.map(post=> (<li><time>{post.date}</time><ahref={post.slug}>{post.title}</a><p>{post.description}</p></li>))}</ul>
```

Finally, add your components to the `components` property of the `storyblok` config object in `astro.config.mjs`. The key is the name of the Blok in Storyblok, and the value is the path to the component relative to `src`.

astro.config.mjs

```
import { defineConfig } from'astro/config';import { storyblok } from'@storyblok/astro';import { loadEnv } from'vite';const env = loadEnv("", process.cwd(), 'STORYBLOK');exportdefaultdefineConfig({integrations: [storyblok({accessToken: env.STORYBLOK_TOKEN,components: {blogPost: 'storyblok/BlogPost',blogPostList: 'storyblok/BlogPostList',page: 'storyblok/Page',},apiOptions: {region: 'us',},})],});
```


### Generating pages


[Section titled Generating pages](#generating-pages)

To create a route for a specific `page`, you can fetch its content directly from the Storyblok API and pass it to the `StoryblokComponent` component. Remember to make sure you have added the `Page` component to your astro.config.mjs.

Create an `index.astro` file in `src/pages/` to render the `home` page:

src/pages/index.astro

```
---import { useStoryblokApi } from'@storyblok/astro'import StoryblokComponent from'@storyblok/astro/StoryblokComponent.astro'import BaseLayout from'../layouts/BaseLayout.astro'const storyblokApi = useStoryblokApi();const { data } = await storyblokApi.get('cdn/stories/home', {version: import.meta.env.DEV ? "draft" : "published",});const content = data.story.content;---<htmllang="en"><head><title>Storyblok & Astro</title></head><body><StoryblokComponentblok={content} /></body></html>
```

To generate pages for all of your blog posts, create a `.astro` page that will create dynamic routes. This approach varies depending on whether your routes are prerendered (the default in Astro) or [rendered on demand](/en/guides/on-demand-rendering/).


#### Static site generation


[Section titled Static site generation](#static-site-generation)

If you are using Astro’s default static site generation, you will use [dynamic routes](/en/guides/routing/#dynamic-routes) and the `getStaticPaths` function to generate your project pages.

Create a new directory `src/pages/blog/` and add a new file called `[...slug].astro` with the following code:

src/pages/blog/\[...slug\].astro

```
---import { useStoryblokApi } from'@storyblok/astro'import StoryblokComponent from'@storyblok/astro/StoryblokComponent.astro'exportasyncfunctiongetStaticPaths() {const sbApi = useStoryblokApi();const { data } = await sbApi.get("cdn/stories", {content_type: "blogPost",version: import.meta.env.DEV ? "draft" : "published",});const stories = Object.values(data.stories);return stories.map((story)=> {return {params: { slug: story.slug },};});}const sbApi = useStoryblokApi();const { slug } = Astro.params;const { data } = await sbApi.get(`cdn/stories/blog/${slug}`, {version: import.meta.env.DEV ? "draft" : "published",});const story = data.story;---<htmllang="en"><head><title>Storyblok & Astro</title></head><body><StoryblokComponentblok={story.content} /></body></html>
```

This file will generate a page for each story, with the slug and content fetched from the Storyblok API.

Note

When adding folders inside of Storyblok, include them in the slug when interacting with the Storyblok API. For example, in the GET request above we can use **cdn/stories/blog**, with a blog folder inside rather than using them at the root.


#### On-demand rendering


[Section titled On-demand rendering](#on-demand-rendering)

If you are [rendering your routes on demand with an adapter](/en/guides/on-demand-rendering/), you will use dynamic routes to fetch the page data from Storyblok.

Create a new directory `src/pages/blog/` and add a new file called `[...slug].astro` with the following code:

src/pages/blog/\[...slug\].astro

```
---import { useStoryblokApi } from'@storyblok/astro'import StoryblokComponent from'@storyblok/astro/StoryblokComponent.astro'const storyblokApi = useStoryblokApi()const slug = Astro.params.slug;let content;try {const { data } = await storyblokApi.get(`cdn/stories/blog/${slug}`, {version: import.meta.env.DEV ? "draft" : "published",});content = data.story.content} catch (error) {return Astro.redirect('/404')}---<htmllang="en"><head><title>Storyblok & Astro</title></head><body><StoryblokComponentblok={content} /></body></html>
```

This file will fetch and render the page data from Storyblok that matches the dynamic `slug` parameter.

Since you are using a redirect to `/404`, create a 404 page in `src/pages`:

src/pages/404.astro

```
<htmllang="en"><head><title>Not found</title></head><body><p>Sorry, this page does not exist.</p></body></html>
```

If the story is not found, the request will be redirected to the 404 page.


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


#### Rebuild on Storyblok changes


[Section titled Rebuild on Storyblok changes](#rebuild-on-storyblok-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Storyblok events.


##### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



##### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



##### Adding a webhook to Storyblok


[Section titled Adding a webhook to Storyblok](#adding-a-webhook-to-storyblok)

In your Storyblok space **Settings**, click on the **Webhooks** tab. Paste the webhook URL you copied in the **Story published & unpublished** field and hit Save to create a webhook.

Now, whenever you publish a new story, a new build will be triggered and your blog will be updated.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Storyblok provides an [Astro Integration](https://www.storyblok.com/mp/announcing-storyblok-astro) to add Storyblok to your project.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Getting the Visual Editor to work for Storyblok + Astro](https://dev.to/sandrarodgers/getting-the-visual-editor-to-work-for-storyblok-astro-2gja) by Sandra Rodgers
-   [Astro + Storyblok: SSR preview for instant visual editing](https://dev.to/jgierer12/astro-storyblok-ssr-preview-for-instant-visual-editing-3g9m) by Jonas Gierer
-   [Astro-Storyblok Previews Site with Netlify’s Branch Deploys Feature](https://dev.to/sandrarodgers/astro-storyblok-previews-site-with-netlifys-branch-deploys-feature-44dh) by Sandra Rodgers


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 54. `en/guides/cms/strapi/.md`

```text
# Strapi & Astro


---
url: https://docs.astro.build/en/guides/cms/strapi/
description: Add content to your Astro project using Strapi Headless CMS
---


# Strapi & Astro


[Strapi](https://strapi.io/) is an open-source, customizable, headless CMS.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

This guide will build a wrapper function to connect Strapi with Astro.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.
2.  **A Strapi CMS server** - You can [set up a Strapi server on a local environment](https://docs.strapi.io/dev-docs/quick-start).


### Adding the Strapi URL in `.env`


[Section titled Adding the Strapi URL in .env](#adding-the-strapi-url-in-env)

To add your Strapi URL to Astro, create a `.env` file in the root of your project (if one does not already exist) and add the following variable:

.env

```
STRAPI_URL="http://127.0.0.1:1337"# or use your IP address
```

Restart the dev server to use this environment variable in your Astro project.

If you would like to have IntelliSense for your environment variable, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly STRAPI_URL:string;}
```

Your root directory should now include the new file(s):

-   Directorysrc/

    -   **env.d.ts**

-   **.env**
-   astro.config.mjs
-   package.json


### Creating the API wrapper


[Section titled Creating the API wrapper](#creating-the-api-wrapper)

Create a new file at `src/lib/strapi.ts` and add the following wrapper function to interact with the Strapi API:

src/lib/strapi.ts

```
interface Props {endpoint:string;query?:Record<string, string>;wrappedByKey?:string;wrappedByList?:boolean;}/*** Fetches data from the Strapi API* @paramendpoint - The endpoint to fetch from* @paramquery - The query parameters to add to the url* @paramwrappedByKey - The key to unwrap the response from* @paramwrappedByList - If the response is a list, unwrap it* @returns*/exportdefaultasyncfunctionfetchApi<T>({endpoint,query,wrappedByKey,wrappedByList,}:Props):Promise<T> {if (endpoint.startsWith('/')) {endpoint = endpoint.slice(1);}const url = newURL(`${import.meta.env.STRAPI_URL}/api/${endpoint}`);if (query) {Object.entries(query).forEach(([key,value])=> {url.searchParams.append(key, value);});}const res = await fetch(url.toString());let data = await res.json();if (wrappedByKey) {data = data[wrappedByKey];}if (wrappedByList) {data = data[0];}return data asT;}
```

This function requires an object with the following properties:

1.  `endpoint` - The endpoint you are fetching.
2.  `query` - The query parameters to add to the end of URL
3.  `wrappedByKey` - The `data` key in the object that wraps your `Response`.
4.  `wrappedByList` - A parameter to “unwrap” the list returned by Strapi, and return only the first item.


### Optional: Creating the Article interface


[Section titled Optional: Creating the Article interface](#optional-creating-the-article-interface)

If you are using TypeScript, create the following Article interface to correspond to the Strapi content types at `src/interfaces/article.ts`:

src/interfaces/article.ts

```
exportdefaultinterface Article {id:number;attributes: {title:string;description:string;content:string;slug:string;createdAt:string;updatedAt:string;publishedAt:string;};}
```

Note

You can modify this interface, or create multiple interfaces, to correspond to your own project data.

-   Directorysrc/

    -   Directoryinterfaces/

        -   **article.ts**

    -   Directorylib/

        -   strapi.ts

    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json


### Displaying a list of articles


[Section titled Displaying a list of articles](#displaying-a-list-of-articles)

1.  Update your home page `src/pages/index.astro` to display a list of blog posts, each with a description and a link to its own page.

2.  Import the wrapper function and the interface. Add the following API call to fetch your articles and return a list:

    src/pages/index.astro

    ```
    ---import fetchApi from'../lib/strapi';importtype Article from'../interfaces/article';const articles = await fetchApi<Article[]>({endpoint: 'articles', // the content type to fetchwrappedByKey: 'data', // the key to unwrap the response});---
    ```

    The API call requests data from `http://localhost:1337/api/articles` and returns `articles`: an array of json objects representing your data:

    ```
    [{id: 1,attributes: {title: "What's inside a Black Hole",description: "Maybe the answer is in this article, or not...",content: "Well, we don't know yet...",slug: "what-s-inside-a-black-hole",createdAt: "2023-05-28T13:19:46.421Z",updatedAt: "2023-05-28T13:19:46.421Z",publishedAt: "2023-05-28T13:19:45.826Z"}},// ...]
    ```

3.  Using data from the `articles` array returned by the API, display your Strapi blog posts in a list. These posts will link to their own individual pages, which you will create in the next step.

    src/pages/index.astro

    ```
    ---import fetchApi from'../lib/strapi';importtype Article from'../interfaces/article';const articles = await fetchApi<Article[]>({endpoint: 'articles?populate=image',wrappedByKey: 'data',});---<!DOCTYPEhtml><htmllang="en"><head><title>Strapi & Astro</title></head><body><main><ul>{articles.map((article)=> (<li><ahref={`/blog/${article.attributes.slug}/`}>{article.attributes.title}</a></li>))}</ul></main></body></html>
    ```



### Generating article pages


[Section titled Generating article pages](#generating-article-pages)

Create the file `src/pages/blog/[slug].astro` to [dynamically generate a page](/en/guides/routing/#dynamic-routes) for each article.

-   Directorysrc/

    -   Directoryinterfaces/

        -   article.ts

    -   Directorylib/

        -   strapi.ts

    -   Directorypages/

        -   index.astro
        -   Directoryblog/

            -   **\[slug\].astro**


    -   env.d.ts

-   .env
-   astro.config.mjs
-   package.json


#### Static site generation


[Section titled Static site generation](#static-site-generation)

In Astro’s default static mode (SSG), use [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) to fetch your list of articles from Strapi.

src/pages/blog/\[slug\].astro

```
---import fetchApi from'../../lib/strapi';importtype Article from'../../interfaces/article';exportasyncfunctiongetStaticPaths() {const articles = await fetchApi<Article[]>({endpoint: 'articles',wrappedByKey: 'data',});return articles.map((article)=> ({params: { slug: article.attributes.slug },props: article,}));}type Props =Article;const article = Astro.props;---
```

Create the template for each page using the properties of each post object.

src/pages/blog/\[slug\].astro

```
---import fetchApi from'../../lib/strapi';importtype Article from'../../interfaces/article';exportasyncfunctiongetStaticPaths() {const articles = await fetchApi<Article[]>({endpoint: 'articles',wrappedByKey: 'data',});return articles.map((article)=> ({params: { slug: article.attributes.slug },props: article,}));}type Props =Article;const article = Astro.props;---<!DOCTYPEhtml><htmllang="en"><head><title>{article.attributes.title}</title></head><body><main><imgsrc={import.meta.env.STRAPI_URL+article.attributes.image.data.attributes.url} /><h1>{article.attributes.title}</h1><!-- Render plain text --><p>{article.attributes.content}</p><!-- Render markdown --><MyMarkdownComponent>{article.attributes.content}</MyMarkdownComponent><!-- Render html --><Fragmentset:html={article.attributes.content} /></main></body></html>
```

Tip

Make sure to choose the right rendering for your content. For markdown check out our [markdown guide](/en/guides/markdown-content/). If you are rendering html refer to [this guide](/en/reference/directives-reference/#sethtml) for safety.


#### On-demand rendering


[Section titled On-demand rendering](#on-demand-rendering)

If you’ve [opted into on-demand rendering with an adapter](/en/guides/on-demand-rendering/), [generate your dynamic routes](/en/guides/routing/#on-demand-dynamic-routes) using the following code:

Create the `src/pages/blog/[slug].astro` file:

src/pages/blog/\[slug\].astro

```
---import fetchApi from'../../../lib/strapi';importtype Article from'../../../interfaces/article';const { slug } = Astro.params;let article:Article;try {article =awaitfetchApi<Article>({endpoint: 'articles',wrappedByKey: 'data',wrappedByList: true,query: {'filters[slug][$eq]': slug |'',},});} catch (error) {return Astro.redirect('/404');}---<!DOCTYPEhtml><htmllang="en"><head><title>{article.attributes.title}</title></head><body><main><imgsrc={import.meta.env.STRAPI_URL+article.attributes.image.data.attributes.url} /><h1>{article.attributes.title}</h1><!-- Render plain text --><p>{article.attributes.content}</p><!-- Render markdown --><MyMarkdownComponent>{article.attributes.content}</MyMarkdownComponent><!-- Render html --><Fragmentset:html={article.attributes.content} /></main></body></html>
```

This file will fetch and render the page data from Strapi that matches the dynamic `slug` parameter.

Since you are using a redirect to `/404`, create a 404 page in `src/pages`:

src/pages/404.astro

```
<htmllang="en"><head><title>Not found</title></head><body><p>Sorry, this page does not exist.</p><imgsrc="https://http.cat/404" /></body></html>
```

If the article is not found, the user will be redirected to this 404 page and be greeted by a lovely cat.


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


#### Rebuild on changes


[Section titled Rebuild on changes](#rebuild-on-changes)

If your project is using Astro’s default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Strapi.


##### Netlify


[Section titled Netlify](#netlify)

To set up a webhook in Netlify:

1.  Go to your site dashboard and click on **Build & deploy**.

2.  Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3.  Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.



##### Vercel


[Section titled Vercel](#vercel)

To set up a webhook in Vercel:

1.  Go to your project dashboard and click on **Settings**.

2.  Under the **Git** tab, find the **Deploy Hooks** section.

3.  Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.



##### Adding a webhook to Strapi


[Section titled Adding a webhook to Strapi](#adding-a-webhook-to-strapi)

Follow [the Strapi webhooks guide](https://strapi.io/blog/webhooks) to create a webhook in your Strapi admin panel.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Strapi Blog Guide For React](https://strapi.io/blog/build-a-blog-with-next-react-js-strapi) by Strapi


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 55. `en/guides/cms/studiocms/.md`

```text
# StudioCMS & Astro


---
url: https://docs.astro.build/en/guides/cms/studiocms/
description: Build and manage content for your Astro project using StudioCMS, a headless CMS designed specifically for Astro.
---


# StudioCMS & Astro


[StudioCMS](https://studiocms.dev/) is a headless CMS for Astro, built with Astro, that provides a user-friendly and configurable dashboard for content management as well as a custom rendering system to display your Astro components.


## Official resources


[Section titled Official resources](#official-resources)

-   [StudioCMS documentation](https://docs.studiocms.dev/)
-   [StudioCMS GitHub repository](https://github.com/withstudiocms/studiocms)
-   [StudioCMS Discord community](https://chat.studiocms.dev)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 56. `en/guides/cms/tina-cms/.md`

```text
# Tina CMS & Astro


---
url: https://docs.astro.build/en/guides/cms/tina-cms/
description: Add content to your Astro project using Tina as a CMS
---


# Tina CMS & Astro


[Tina CMS](https://tina.io/) is a Git-backed headless content management system.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

To get started, you’ll need an existing Astro project.

1.  Run the following command to install Tina into your Astro project.

    -   [npm](#tab-panel-3105)
    -   [pnpm](#tab-panel-3106)
    -   [Yarn](#tab-panel-3107)

    Terminal window

    ```
    npx@tinacms/cli@latestinit
    ```

    Terminal window

    ```
    pnpmdlx@tinacms/cli@latestinit
    ```

    Terminal window

    ```
    yarndlx@tinacms/cli@latestinit
    ```

    -   When prompted for a Cloud ID, press Enter to skip. You’ll generate one later if you want to use Tina Cloud.
    -   When prompted “What framework are you using”, choose **Other**.
    -   When asked where public assets are stored, press Enter.

    After this has finished, you should now have a `.tina` folder in the root of your project and a generated `hello-world.md` file at `content/posts`.

2.  Change the `dev` script in `package.json`:

    -   [npm](#tab-panel-3108)
    -   [pnpm](#tab-panel-3109)
    -   [Yarn](#tab-panel-3110)

    package.json

    ```
    {"scripts": {"dev": "astro dev","dev": "tinacms dev -c \"astro dev\""}}
    ```

    package.json

    ```
    {"scripts": {"dev": "astro dev","dev": "tinacms dev -c \"astro dev\""}}
    ```

    package.json

    ```
    {"scripts": {"dev": "astro dev","dev": "tinacms dev -c \"astro dev\""}}
    ```

3.  TinaCMS is now set up in local mode. Test this by running the `dev` script, then navigating to `/admin/index.html#/collections/post`.

    Editing the “Hello, World!” post will update the `content/posts/hello-world.md` file in your project directory.

4.  Set up your Tina collections by editing the `schema.collections` property in `.tina/config.ts`.

    For example, you can add a required “date posted” frontmatter property to our posts:

    .tina/config.ts

    ```
    import { defineConfig } from"tinacms";// Your hosting provider likely exposes this as an environment variableconst branch = process.env.HEAD | process.env.VERCEL_GIT_COMMIT_REF | "main";exportdefaultdefineConfig({branch,clientId: null, // Get this from tina.iotoken: null, // Get this from tina.iobuild: {outputFolder: "admin",publicFolder: "public",},media: {tina: {mediaRoot: "images",publicFolder: "public",},},schema: {collections: [{name: "posts",label: "Posts",path: "src/content/posts",format: 'mdx',fields: [{type: "string",name: "title",label: "Title",isTitle: true,required: true,},{type: "datetime",name: "posted",label: "Date Posted",required: true,},{type: "rich-text",name: "body",label: "Body",isBody: true,},],},],},});
    ```

    Learn more about Tina collections [in the Tina docs](https://tina.io/docs/reference/collections/).

5.  In production, TinaCMS can commit changes directly to your GitHub repository. To set up TinaCMS for production, you can choose to use [Tina Cloud](https://tina.io/docs/tina-cloud/) or self-host the [Tina Data Layer](https://tina.io/docs/self-hosted/overview/). You can [read more about registering for Tina Cloud](https://app.tina.io/register) in the Tina Docs.



## Official Resources


[Section titled Official Resources](#official-resources)

-   [TinaCMS Astro integration guide](https://tina.io/docs/frameworks/astro/).


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Astro Tina Starter with visual editing](https://github.com/dawaltconley/tina-astro) by Jeff See + Dylan Awalt-Conley
-   [Astro Tina Starter with basic editing](https://github.com/tombennet/astro-tina-starter/tree/main) by Tom Bennet
-   [Using Astro’s Image Optimization with Tina](https://joschua.io/posts/2023/08/16/how-to-use-astro-assets-with-tina-cms/)


## Themes


[Section titled Themes](#themes)

-   [Resume01](https://astro.build/themes/details/resume01/)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 57. `en/guides/cms/umbraco/.md`

```text
# Umbraco & Astro


---
url: https://docs.astro.build/en/guides/cms/umbraco/
description: Add content to your Astro project using Umbraco as a CMS
---


# Umbraco & Astro


[Umbraco CMS](https://umbraco.com/) is an open-source ASP.NET Core CMS. By default, Umbraco uses Razor pages for its front-end, but can be used as a headless CMS.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

In this section you will use Umbraco’s native [Content Delivery API](https://docs.umbraco.com/umbraco-cms/reference/content-delivery-api) to provide content to your Astro project.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.
2.  **An Umbraco (v12+) project** - If you don’t have an Umbraco project yet, please see this [Installation guide](https://docs.umbraco.com/umbraco-cms/fundamentals/setup/install/).


### Setting up the Content Delivery API


[Section titled Setting up the Content Delivery API](#setting-up-the-content-delivery-api)

To enable the Content Delivery API, update your Umbraco project’s `appsettings.json` file:

appsettings.json

```
{"Umbraco": {"CMS": {"DeliveryApi": {"Enabled": true,"PublicAccess": true}}}}
```

You can configure additional options as needed such as public access, API keys, allowed content types, membership authorisation, and more. See the [Umbraco Content Delivery API documentation](https://docs.umbraco.com/umbraco-cms/reference/content-delivery-api) for more information.


### Fetching Data


[Section titled Fetching Data](#fetching-data)

Use a `fetch()` call to the Content Delivery API to access your content and make it available to your Astro components.

The following example displays a list of fetched articles, including properties such as the article date and content.

src/pages/index.astro

```
---const res = await fetch('http://localhost/umbraco/delivery/api/v2/content?filter=contentType:article');const articles = await res.json();---<h1>Astro + Umbraco 🚀</h1>{articles.items.map((article)=> (<h1>{article.name}</h1><p>{article.properties.articleDate}</p><divset:html={article.properties.content?.markup}></div>))}
```

Read more about [data fetching in Astro](/en/guides/data-fetching/).


## Building a blog with Umbraco and Astro


[Section titled Building a blog with Umbraco and Astro](#building-a-blog-with-umbraco-and-astro)


### Prerequisites


[Section titled Prerequisites](#prerequisites-1)

-   **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.

-   **An Umbraco project (v12+)** with the Content Delivery API enabled - Follow this [Installation guide](https://docs.umbraco.com/umbraco-cms/fundamentals/setup/install/) to create a new project.



### Creating blog posts in Umbraco


[Section titled Creating blog posts in Umbraco](#creating-blog-posts-in-umbraco)

From the [Umbraco backoffice](https://docs.umbraco.com/umbraco-cms/fundamentals/backoffice), create a Document Type for a simple blog article called ‘Article’.

1.  Configure your ‘Article’ Document Type with the following properties:

    -   Title (DataType: Textstring)
    -   Article Date (DataType: Date Picker)
    -   Content (DataType: Richtext Editor)
2.  Toggle “Allow as root” to `true` on the ‘Article’ document type.

3.  From the “Content” section in the Umbraco backoffice, [create and publish your first blog post](https://docs.umbraco.com/umbraco-cms/fundamentals/data/defining-content). Repeat the process as many times as you like.


For more information, watch a [video guide on creating Document Types](https://www.youtube.com/watch?v=otRuIkN80qM).


### Displaying a list of blog posts in Astro


[Section titled Displaying a list of blog posts in Astro](#displaying-a-list-of-blog-posts-in-astro)

Create a `src/layouts/` folder, then add a new file `Layout.astro` with the following code:

src/layouts/Layout.astro

```
------<!DOCTYPEhtml><htmllang="en"><head><metacharset="utf-8"><title>My Blog with Astro and Umbraco</title></head><body><main><slot /></main></body></html>
```

Your project should now contain the following files:

-   Directorysrc/

    -   Directory**layouts/**

        -   **Layout.astro**

    -   Directorypages/

        -   index.astro



To create a list of blog posts, first `fetch` to call the Content Delivery API `content` endpoint and filter by contentType of ‘article’. The article objects will include the properties and content set in the CMS. You can then loop through the articles and display a each title with a link to its article.

Replace the default contents of `index.astro` with the following code:

src/pages/index.astro

```
---import Layout from'../layouts/Layout.astro';const res = await fetch('http://localhost/umbraco/delivery/api/v2/content?filter=contentType:article');const articles = await res.json();---<Layout><h2>Blog Articles</h2>{articles.items.map((article:any)=> (<div><h3>{article.properties.title}</h3><p>{article.properties.articleDate}</p><ahref={article.route.path}>Read more</a></div>))}</Layout>
```


### Generating individual blog posts


[Section titled Generating individual blog posts](#generating-individual-blog-posts)

Create the file `[...slug].astro` at the root of the `/pages/` directory. This file will be used to [generate the individual blog pages dynamically](/en/guides/routing/#dynamic-routes).

Note that the `params` property, which generates the URL path of the page, contains `article.route.path` from the API fetch. Similarly, the `props` property must include the entire `article` itself so that you can access all the information in your CMS entry.

Add the following code to `[...slug].astro` which will create your individual blog post pages:

\[...slug\].astro

```
---import Layout from'../layouts/Layout.astro';exportasyncfunctiongetStaticPaths() {let data = await fetch("http://localhost/umbraco/delivery/api/v2/content?filter=contentType:article");let articles = await data.json();return articles.items.map((article:any)=> ({params: { slug: article.route.path },props: { article: article },}));}const { article } = Astro.props;---<Layout><h1>{article.properties.title}</h1><p>{article.properties.articleDate}</p><divset:html={article.properties.content?.markup}></div></Layout>
```

Your project should now contain the following files:

-   Directorysrc/

    -   Directorylayouts/

        -   Layout.astro

    -   Directorypages/

        -   index.astro
        -   **\[…slug\].astro**



With the dev server running, you should now be able to view your Umbraco-created content in your browser preview of your Astro project. Congratulations! 🚀


## Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your site visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Local dev, HTTPS and self-signed SSL certificates


[Section titled Local dev, HTTPS and self-signed SSL certificates](#local-dev-https-and-self-signed-ssl-certificates)

If you are using the Umbraco HTTPS endpoint locally, any `fetch` queries will result in `fetch failed` with code `DEPTH_ZERO_SELF_SIGNED_CERT`. This is because Node (upon which Astro is built) won’t accept self-signed certificates by default. To avoid this, use the Umbraco HTTP endpoint for local dev.

Alternatively, you can set `NODE_TLS_REJECT_UNAUTHORIZED=0` in an `env.development` file and update `astro.config.js` as shown:

.env.development

```
NODE_TLS_REJECT_UNAUTHORIZED=0
```

astro.config.mjs

```
import { defineConfig } from'astro/config';import { loadEnv } from"vite";const { NODE_TLS_REJECT_UNAUTHORIZED } = loadEnv(process.env.NODE_ENV, process.cwd(), "");process.env.NODE_TLS_REJECT_UNAUTHORIZED=NODE_TLS_REJECT_UNAUTHORIZED;// https://astro.build/configexportdefaultdefineConfig({});
```

This method is described in more detail in this [blog post showing how to configure your project for self-signed certificates](https://kjac.dev/posts/jamstack-for-free-with-azure-and-cloudflare/), with an [accompanying repo](https://github.com/kjac/UmbracoAzureCloudflare).


## Official Documentation


[Section titled Official Documentation](#official-documentation)

-   [Content Delivery API - Umbraco Documentation](https://docs.umbraco.com/umbraco-cms/reference/content-delivery-api)


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Astro-nomically Performant Websites using the Content Delivery API - Louis Richardson](https://24days.in/umbraco-cms/2023/sustainable-performant/astronomically-performant/)
-   [Generating a TypeScript OpenAPI client from Umbraco’s Content Delivery API - Rick Butterfield](https://rickbutterfield.dev/blog/typescript-openapi-umbraco-content-delivery/)
-   [Jamstack For Free With Azure And CloudFlare - Kenn Jacobsen](https://kjac.dev/posts/jamstack-for-free-with-azure-and-cloudflare/)
-   [Quick n’ dirty blog with Astro and Umbraco - Kenn Jacobsen](https://kjac.dev/posts/quick-n-dirty-blog-with-astro-and-umbraco/)
-   [Talk: Bake, Don’t Fry - Astro & The Content Delivery API - Adam Prendergast](https://www.youtube.com/watch?v=zNxqI25dtx4)


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 58. `en/guides/cms/wordpress/.md`

```text
# Headless WordPress & Astro


---
url: https://docs.astro.build/en/guides/cms/wordpress/
description: Add content to your Astro project using WordPress as a CMS
---


# Headless WordPress & Astro


[WordPress](https://wordpress.org/) is a content management system that includes its own frontend, but can also be used as a headless CMS to provide content to your Astro project.


## Integrating with Astro


[Section titled Integrating with Astro](#integrating-with-astro)

WordPress comes with a built-in [WordPress REST API](https://developer.wordpress.org/rest-api/) to connect your WordPress data to Astro. You can optionally install [WPGraphQL](https://wordpress.org/plugins/wp-graphql/) or [Gato GraphQL](https://wordpress.org/plugins/gatographql/) on your site to use GraphQL.


### Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need to have the following:

1.  **An Astro project** - If you don’t have an Astro project yet, our [Installation guide](/en/install-and-setup/) will get you up and running in no time.
2.  **A WordPress site** - Your site’s REST API is `[YOUR_SITE]/wp-json/wp/v2/` and is available by default with any WordPress site. It is also possible to [set up WordPress on a local environment](https://wordpress.org/support/article/installing-wordpress-on-your-own-computer/).


### Setting up Credentials


[Section titled Setting up Credentials](#setting-up-credentials)

Your WordPress REST API is available to external requests for data fetching without authentication by default. This does not allow users to modify your data or site settings and allows you to use your data in your Astro project without any credentials.

You may choose to [require authentication](https://developer.wordpress.org/rest-api/frequently-asked-questions/#require-authentication-for-all-requests) if necessary.


### Fetching Data


[Section titled Fetching Data](#fetching-data)

Fetch your WordPress data through your site’s unique REST API URL and the route for your content. (For a blog, this will commonly be `posts`.) Then, you can render your data properties using Astro’s `set:html={}` directive.

For example, to display a list of post titles and their content:

src/pages/index.astro

```
---const res = await fetch("https://[YOUR-SITE]/wp-json/wp/v2/posts");const posts = await res.json();---<h1>Astro + WordPress 🚀</h1>{posts.map((post)=> (<h2set:html={post.title.rendered} /><pset:html={post.content.rendered} />))}
```

The WordPress REST API includes [global parameters](https://developer.wordpress.org/rest-api/using-the-rest-api/global-parameters/) such as `_fields` and `_embed`.

A large quantity of data is available to you via this API, so you may wish to only fetch certain fields. You can restrict your response by adding the [`_fields`](https://developer.wordpress.org/rest-api/using-the-rest-api/global-parameters/#_fields) parameter to the API URL, for example: `[YOUR-SITE]/wp/v2/posts?_fields=author,id,excerpt,title,link`

The API can also return content related to your post, such as a link to the parent post, or to comments on the post. You can add the [`_embed`](https://developer.wordpress.org/rest-api/using-the-rest-api/global-parameters/#_embed) parameter to the API URL (e.g. `[YOUR-SITE]/wp/v2/posts?_embed`) to indicate to the server that the response should include these embedded resources.


## Building a blog with WordPress and Astro


[Section titled Building a blog with WordPress and Astro](#building-a-blog-with-wordpress-and-astro)

This example fetches data from the public WordPress API of [https://norian.studio/dinosaurs/](https://norian.studio/dinosaurs/). This WordPress site stores information about individual dinosaurs under the `dinos` route, just as a blog would store individual blog posts under the `posts` route.

This example shows how to reproduce this site structure in Astro: an index page that lists dinosaurs with links to dynamically-generated individual dinosaur pages.

Note

To use [Custom Post Types (CPT)](https://learn.wordpress.org/lesson-plan/custom-post-types/) in your WordPress API (not just `post` and `page`), you will have to [configure them in your WordPress dashboard](https://stackoverflow.com/questions/48536646/how-can-i-get-data-from-custom-post-type-using-wp-rest-api) or [add REST API Support For Custom Content Types](https://developer.wordpress.org/rest-api/extending-the-rest-api/adding-rest-api-support-for-custom-content-types/) in WordPress.

This example fetches data from a WordPress site whose content types have already been configured and exposed to the REST API.


### Displaying a list of WordPress posts


[Section titled Displaying a list of WordPress posts](#displaying-a-list-of-wordpress-posts)

The page `src/pages/index.astro` lists each dinosaur, with a description and link to its own page.

-   Directorysrc/

    -   Directorypages/

        -   **index.astro**
        -   Directorydinos/

            -   \[slug\].astro



-   astro.config.mjs
-   package.json

Fetching via the API returns an object that includes the properties:

-   `title.rendered` - Contains the HTML rendering of the title of the post.
-   `content.rendered` - Contains the HTML rendering of the content of the post.
-   `slug` - Contains the slug of the post. (This provides the link to the dynamically-generated individual dinosaur pages.)

/src/pages/index.astro

```
---import Layout from"../layouts/Layout.astro";let res = await fetch("https://norian.studio/wp-json/wp/v2/dinos");let posts = await res.json();---<Layouttitle="Dinos!"><section><h1>List of Dinosaurs</h1>{posts.map((post)=> (<article><h2><ahref={`/dinos/${post.slug}/`}set:html={post.title.rendered} /></h2><Fragmentset:html={post.content.rendered} /></article>))}</section></Layout>
```


### Using the WordPress API to generate pages


[Section titled Using the WordPress API to generate pages](#using-the-wordpress-api-to-generate-pages)

The page `src/pages/dinos/[slug].astro` [dynamically generates a page](/en/guides/routing/#dynamic-routes) for each dinosaur.

/src/pages/dinos/\[slug\].astro

```
---import Layout from'../../layouts/Layout.astro';const { slug } = Astro.params;let res = await fetch(`https://norian.studio/wp-json/wp/v2/dinos?slug=${slug}`);let [post] = await res.json();// The getStaticPaths() is required for static Astro sites.// If using SSR, you will not need this function.exportasyncfunctiongetStaticPaths() {let data = await fetch("https://norian.studio/wp-json/wp/v2/dinos");let posts = await data.json();return posts.map((post)=> ({params: { slug: post.slug },props: { post: post },}));}---<Layouttitle={post.title.rendered}><article><h1set:html={post.title.rendered} /><Fragmentset:html={post.content.rendered} /></article></Layout>
```


### Returning embedded resources


[Section titled Returning embedded resources](#returning-embedded-resources)

The `_embed` query parameter instructs the server to return related (embedded) resources.

src/pages/dinos/\[slug\].astro

```
---const { slug } = Astro.params;let res = await fetch(`https://norian.studio/wp-json/wp/v2/dinos?slug=${slug}&_embed`);let [post] = await res.json();---
```

The `_embedded['wp:featuredmedia']['0'].media_details.sizes.medium.source_url` property is returned, and can be used to display the featured image on each dinosaur page. (Replace `medium` with your desired image size.)

/src/pages/dinos/\[slug\].astro

```
<Layouttitle={post.title.rendered}><article><imgsrc={post._embedded['wp:featuredmedia']['0'].media_details.sizes.medium.source_url} /><h1set:html={post.title.rendered} /><Fragmentset:html={post.content.rendered} /></article></Layout>
```


### Publishing your site


[Section titled Publishing your site](#publishing-your-site)

To deploy your site visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Building An Astro Website With WordPress As A Headless CMS](https://blog.openreplay.com/building-an-astro-website-with-wordpress-as-a-headless-cms/) by Chris Bongers.
-   [Building with Astro x WordPress](https://www.youtube.com/watch?v=Jstqgklvfnc) on Ben Holmes’s stream.
-   [Building a Headless WordPress Site with Astro](https://developers.wpengine.com/blog/building-a-headless-wordpress-site-with-astro) by Jeff Everhart.
-   [Astro and WordPress as an API](https://darko.io/posts/wp-as-an-api/) by Darko Bozhinovski.


## Production Sites


[Section titled Production Sites](#production-sites)

The following sites use Astro + WordPress in production:

-   [Dinos!](https://wc-dinos.netlify.app/) by Anindo Neel Dutta — [source code on GitHub](https://github.com/leen-neel/astro-wordpress)


## Themes


[Section titled Themes](#themes)

-   [Astro WordPress Starter](https://astro.build/themes/details/astro-wordpress-starter/)


## Community Resources


[Section titled Community Resources](#community-resources-1)

[Introduction to Astro + WordPress](https://dev.to/bngmnn/leveraging-wordpress-as-a-headless-cms-for-your-astro-website-a-comprehensive-guide-a4d)

[Astro + WPGraphQL for more secure WordPress sites](https://www.youtube.com/watch?v=fWxn-r83ygQ)

[Shattering Headless WordPress Build Times with Astro's Content Layer API](https://andrewkepson.com/blog/headless-wordpress/build-time-astro-content-layer-api/)

[How to Set Up a Headless WordPress Site with Astro](https://dev.to/mathiasahlgren/how-to-set-up-a-headless-wordpress-site-with-astro-3a2h)

[Build a static site with WordPress and Astro](https://kinsta.com/blog/wordpress-astro/)

[Going Headless WordPress with Astro](https://www.youtube.com/watch?v=MP2TR6Z_YTc)

[Leveraging WordPress as a Headless CMS for Your Astro Website: API Configuration & Data Fetching](https://medium.com/@bangemann.dev/configure-wordpress-rest-api-setup-data-fetching-4af5161095f6)

[WordPress Headless with Astro - Installing Astro and Fetching posts with WP-GraphQL](https://www.youtube.com/watch?v=2PSqABrME28)

[Make a Headless WordPress Site with Astro](https://www.youtube.com/watch?v=54U7dVmhyxE)

[WPEngine Astro Headless WordPress Starter Demo](https://www.youtube.com/watch?v=BcoxZZIfESI)

[Headless WordPress with Astro – Build a Simple Blog from Scratch with Tailwind CSS](https://fullstackdigital.io/blog/headless-wordpress-with-astro-build-a-simple-blog/)

[Building an E-commerce Website with Headless WordPress and Astro](https://shaxadd.medium.com/building-an-e-commerce-website-with-headless-wordpress-and-astro-2712d8c8b735)

[Building a Headless WordPress Site with Astro](https://wpengine.com/builders/building-headless-wordpress-site-astro/)

[Building an Astro Website with WordPress as a Headless CMS](https://blog.openreplay.com/building-an-astro-website-with-wordpress-as-a-headless-cms/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about using headless WordPress with Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/cms/wordpress.mdx)!


## More CMS guides


-   ### [Apostrophe](/en/guides/cms/apostrophecms/)

-   ### [Builder.io](/en/guides/cms/builderio/)

-   ### [ButterCMS](/en/guides/cms/buttercms/)

-   ### [Caisy](/en/guides/cms/caisy/)

-   ### [CloudCannon](/en/guides/cms/cloudcannon/)

-   ### [Contentful](/en/guides/cms/contentful/)

-   ### [Cosmic](/en/guides/cms/cosmic/)

-   ### [Craft CMS](/en/guides/cms/craft-cms/)

-   ### [Crystallize](/en/guides/cms/crystallize/)

-   ### [DatoCMS](/en/guides/cms/datocms/)

-   ### [Decap CMS](/en/guides/cms/decap-cms/)

-   ### [Directus](/en/guides/cms/directus/)

-   ### [Drupal](/en/guides/cms/drupal/)

-   ### [Flotiq](/en/guides/cms/flotiq/)

-   ### [Front Matter CMS](/en/guides/cms/frontmatter-cms/)

-   ### [Ghost](/en/guides/cms/ghost/)

-   ### [GitCMS](/en/guides/cms/gitcms/)

-   ### [Hashnode](/en/guides/cms/hashnode/)

-   ### [Hygraph](/en/guides/cms/hygraph/)

-   ### [Keystatic](/en/guides/cms/keystatic/)

-   ### [KeystoneJS](/en/guides/cms/keystonejs/)

-   ### [Kontent.ai](/en/guides/cms/kontent-ai/)

-   ### [microCMS](/en/guides/cms/microcms/)

-   ### [Payload CMS](/en/guides/cms/payload/)

-   ### [Prepr CMS](/en/guides/cms/preprcms/)

-   ### [Prismic](/en/guides/cms/prismic/)

-   ### [Sanity](/en/guides/cms/sanity/)

-   ### [Sitecore XM](/en/guides/cms/sitecore/)

-   ### [Spinal](/en/guides/cms/spinal/)

-   ### [Statamic](/en/guides/cms/statamic/)

-   ### [Storyblok](/en/guides/cms/storyblok/)

-   ### [Strapi](/en/guides/cms/strapi/)

-   ### [StudioCMS](/en/guides/cms/studiocms/)

-   ### [Tina CMS](/en/guides/cms/tina-cms/)

-   ### [Umbraco](/en/guides/cms/umbraco/)

-   ### [WordPress](/en/guides/cms/wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 59. `en/guides/configuring-astro/.md`

```text
# Configuration overview


---
url: https://docs.astro.build/en/guides/configuring-astro/
description: Get to know the ways you can configure and customize your new project and your development experience.
---


# Configuration overview


Astro is a flexible, unopinionated framework that allows you to configure your project in many different ways. This means that getting started with a new project might feel overwhelming: there is no “one best way” to set up your Astro project!

The guides in this “Configuration” section will help you familiarize yourself with the various files that allow you to configure and customize aspects of your project and development environment.

If this is your first Astro project, or if it’s been a while since you’ve set up a new project, use the following guides and reference in the documentation for assistance.


## The Astro config File


[Section titled The Astro config File](#the-astro-config-file)

The [Astro config file](/en/reference/configuration-reference/) is a JavaScript file included at the root of every starter project:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({// your configuration options here...});
```

It is only required if you have something to configure, but most projects will use this file. The `defineConfig()` helper provides automatic IntelliSense in your IDE and is where you will add all your configuration options to tell Astro how to build and render your project to HTML.

We recommend using the default file format `.mjs` in most cases, or `.ts` if you want to write TypeScript in your config file. However, `astro.config.js` and `astro.config.cjs` are also supported.

Read Astro’s [configuration reference](/en/reference/configuration-reference/) for a full overview of all supported configuration options.


## The TypeScript config File


[Section titled The TypeScript config File](#the-typescript-config-file)

Every Astro starter project includes a `tsconfig.json` file in your project. Astro’s [component script](/en/basics/astro-components/#the-component-script) is Typescript, which provides Astro’s editor tooling and allows you to optionally add syntax to your JavaScript for type checking of your own project code.

Use the `tsconfig.json` file to configure the TypeScript template that will perform type checks on your code, configure TypeScript plugins, set import aliases, and more.

Read Astro’s [TypeScript guide](/en/guides/typescript/) for a full overview of TypeScript options and Astro’s built-in utility types.


## Development Experience


[Section titled Development Experience](#development-experience)

While you work in development mode, you can take advantage of your code editor and other tools to improve the Astro developer experience.

Astro provides its own official VS Code extension and is compatible with several other popular editor tools. Astro also provides a customizable toolbar that displays in your browser preview while the dev server is running. You can install and even build your own toolbar apps for additional functionality.

Read Astro’s guides to [editor setup options](/en/editor-setup/) and [using the dev toolbar](/en/guides/dev-toolbar/) to learn how to customize your development experience.


## Common new project tasks


[Section titled Common new project tasks](#common-new-project-tasks)

Here are some first steps you might choose to take with a new Astro project.


### Add your deployment domain


[Section titled Add your deployment domain](#add-your-deployment-domain)

For generating your sitemap and creating canonical URLs, configure your deployment URL in the [`site`](/en/reference/configuration-reference/#site) option. If you are deploying to a path (e.g. `www.example/docs`), you can also configure a [`base`](/en/reference/configuration-reference/#base) for the root of your project.

Additionally, different deployment hosts may have different behavior regarding trailing slashes at the end of your URLs. (e.g. `example.com/about` vs `example.com/about/`). Once your site is deployed, you may need to configure your [`trailingSlash`](/en/reference/configuration-reference/#trailingslash) preference.

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({site: "https://www.example.com",base: "/docs",trailingSlash: "always",});
```


### Add site metadata


[Section titled Add site metadata](#add-site-metadata)

Astro does not use its configuration file for common SEO or meta data, only for information required to build your project code and render it to HTML.

Instead, this information is added to your page `<head>` in HTML `<link>` and `<meta>` tags, just as if you were writing plain HTML pages.

One common pattern for Astro sites is to create a `<Head />` [`.astro` component](/en/basics/astro-components/) that can be added to a common [layout component](/en/basics/layouts/) so it can apply to all your pages.

src/components/MainLayout.astro

```
---import Head from"./Head.astro";const { ...props } = Astro.props;---<html><head><metacharset="utf-8"><Head /><!-- Additional head elements --></head><body><!-- Page content goes here --></body></html>
```

Because `Head.astro` is just a regular Astro component, you can import files and receive props passed from other components, such as a specific page title.

src/components/Head.astro

```
---import Favicon from"../assets/Favicon.astro";import SomeOtherTags from"./SomeOtherTags.astro";const { title = "My Astro Website", ...props } = Astro.props;---<linkrel="sitemap"href="/sitemap-index.xml"><title>{title}</title><metaname="description"content="Welcome to my new Astro site!"><!-- Web analytics --><scriptdata-goatcounter="https://my-account.goatcounter.com/count"asyncsrc="//gc.zgo.at/count.js"></script><!-- Open Graph tags --><metaproperty="og:title"content="My New Astro Website" /><metaproperty="og:type"content="website" /><metaproperty="og:url"content="http://www.example.com/" /><metaproperty="og:description"content="Welcome to my new Astro site!" /><metaproperty="og:image"content="https://www.example.com/_astro/seo-banner.BZD7kegZ.webp"><metaproperty="og:image:alt"content=""><SomeOtherTags /><Favicon />
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 60. `en/guides/content-collections/.md`

```text
# Content collections


---
url: https://docs.astro.build/en/guides/content-collections/
description: Manage your content with type safety.
---


# Content collections


**Added in:** `astro@2.0.0`

**Content collections** are the best way to manage sets of content in any Astro project. Collections help to organize and query your documents, enable Intellisense and type checking in your editor, and provide automatic TypeScript type-safety for all of your content. Astro v5.0 introduced the Content Layer API for defining and querying content collections. This performant, scalable API provides built-in content loaders for your local collections. For remote content, you can use third-party and community-built loaders or create your own custom loader and pull in your data from any source.

Note

Projects may continue using the legacy Content Collections API introduced in Astro v2.0. However, we encourage you to [update any existing collections](/en/guides/upgrade-to/v5/#legacy-v20-content-collections-api) when you are able.


## What are Content Collections?


[Section titled What are Content Collections?](#what-are-content-collections)

You can define a **collection** from a set of data that is structurally similar. This can be a directory of blog posts, a JSON file of product items, or any data that represents multiple items of the same shape.

Collections stored locally in your project or on your filesystem can have entries of Markdown, MDX, Markdoc, YAML, or JSON files:

-   Directorysrc/

    -   …

-   Directory**newsletter/** the “newsletter” collection

    -   week-1.md a collection entry
    -   week-2.md a collection entry
    -   week-3.md a collection entry

-   Directory**authors/** the “author” collection

    -   authors.json a single file containing all collection entries


With an appropriate collection loader, you can fetch remote data from any external source, such as a CMS, database, or headless payment system.


## TypeScript configuration for collections


[Section titled TypeScript configuration for collections](#typescript-configuration-for-collections)

Content collections rely on TypeScript to provide Zod validation, Intellisense and type checking in your editor. If you are not extending one of Astro’s `strict` or `strictest` TypeScript settings, you will need to ensure the following `compilerOptions` are set in your `tsconfig.json`:

tsconfig.json

```
{// Included with "astro/tsconfigs/strict" or "astro/tsconfigs/strictest""extends": "astro/tsconfigs/base","compilerOptions": {"strictNullChecks": true, // add if using `base` template"allowJs": true// required, and included with all Astro templates}}
```


## Defining Collections


[Section titled Defining Collections](#defining-collections)

Individual collections use `defineCollection()` to configure:

-   a `loader` for a data source (required)
-   a `schema` for type safety (optional, but highly recommended!)


### The collection config file


[Section titled The collection config file](#the-collection-config-file)

To define collections, you must create a `src/content.config.ts` file in your project (`.js` and `.mjs` extensions are also supported.) This is a special file that Astro will use to configure your content collections based on the following structure:

src/content.config.ts

```
// 1. Import utilities from `astro:content`import { defineCollection, z } from'astro:content';// 2. Import loader(s)import { glob, file } from'astro/loaders';// 3. Define your collection(s)const blog = defineCollection({ /* ... */ });const dogs = defineCollection({ /* ... */ });// 4. Export a single `collections` object to register your collection(s)export const collections = { blog, dogs };
```


### Defining the collection `loader`


[Section titled Defining the collection loader](#defining-the-collection-loader)

The Content Layer API allows you to fetch your content (whether stored locally in your project or remotely) and uses a `loader` property to retrieve your data.


#### Built-in loaders


[Section titled Built-in loaders](#built-in-loaders)

Astro provides [two built-in loader functions](/en/reference/content-loader-reference/#built-in-loaders) (`glob()` and `file()`) for fetching your local content, as well as access to the API to construct your own loader and fetch remote data.

The [`glob()` loader](/en/reference/content-loader-reference/#glob-loader) creates entries from directories of Markdown, MDX, Markdoc, JSON, or YAML files from anywhere on the filesystem. It accepts a `pattern` of entry files to match using glob patterns supported by [micromatch](https://github.com/micromatch/micromatch#matching-features), and a base file path of where your files are located. Each entry’s `id` will be automatically generated from its file name. Use this loader when you have one file per entry.

The [`file()` loader](/en/reference/content-loader-reference/#file-loader) creates multiple entries from a single local file. Each entry in the file must have a unique `id` key property. It accepts a `base` file path to your file and optionally a [`parser` function](#parser-function) for data files it cannot parse automatically. Use this loader when your data file can be parsed as an array of objects.

src/content.config.ts

```
import { defineCollection, z } from'astro:content';import { glob, file } from'astro/loaders'; // Not available with legacy APIconst blog = defineCollection({loader: glob({ pattern: "**/*.md", base: "./src/data/blog" }),schema: /* ... */});const dogs = defineCollection({loader: file("src/data/dogs.json"),schema: /* ... */});const probes = defineCollection({// `loader` can accept an array of multiple patterns as well as string patterns// Load all markdown files in the space-probes directory, except for those that start with "voyager-"loader: glob({ pattern: ['*.md', '!voyager-*'], base: 'src/data/space-probes' }),schema: z.object({name: z.string(),type: z.enum(['Space Probe', 'Mars Rover', 'Comet Lander']),launch_date: z.date(),status: z.enum(['Active', 'Inactive', 'Decommissioned']),destination: z.string(),operator: z.string(),notable_discoveries: z.array(z.string()),}),});export const collections = { blog, dogs, probes };
```


##### `parser` function


[Section titled parser function](#parser-function)

The `file()` loader accepts a second argument that defines a `parser` function. This allows you to specify a custom parser (e.g. `toml.parse` or `csv-parse`) to create a collection from a file’s contents.

The `file()` loader will automatically detect and parse a single array of objects from JSON and YAML files (based on their file extension) with no need for a `parser` unless you have a [nested JSON document](#nested-json-documents). To use other files, such as `.toml` and `.csv`, you will need a to create a parser function.

The following example defines a content collection `dogs` using a `.toml` file:

src/data/dogs.toml

```
[[dogs]]id = "..."age = "..."[[dogs]]id = "..."age = "..."
```

After importing TOML’s parser, you can load the `dogs` collection into your project by passing both a file path and `parser` function to the `file()` loader. A similar process can be used to define a `cats` collection from a `.csv` file:

src/content.config.ts

```
import { defineCollection } from"astro:content";import { file } from"astro/loaders";import { parse as parseToml } from"toml";import { parse as parseCsv } from"csv-parse/sync";const dogs = defineCollection({loader: file("src/data/dogs.toml", { parser: (text) => parseToml(text).dogs }),schema: /* ... */})const cats = defineCollection({loader: file("src/data/cats.csv", { parser: (text) => parseCsv(text, { columns: true, skipEmptyLines: true })})});
```


###### Nested `.json` documents


[Section titled Nested .json documents](#nested-json-documents)

The `parser` argument also allows you to load a single collection from a nested JSON document. For example, this JSON file contains multiple collections:

src/data/pets.json

```
{"dogs": [{}], "cats": [{}]}
```

You can separate these collections by passing a custom `parser` to the `file()` loader for each collection:

src/content.config.ts

```
const dogs = defineCollection({loader: file("src/data/pets.json", { parser: (text) => JSON.parse(text).dogs })});const cats = defineCollection({loader: file("src/data/pets.json", { parser: (text) => JSON.parse(text).cats })});
```


#### Building a custom loader


[Section titled Building a custom loader](#building-a-custom-loader)

You can build a custom loader to fetch remote content from any data source, such as a CMS, a database, or an API endpoint.

Using a loader to fetch your data will automatically create a collection from your remote data. This gives you all the benefits of local collections, such as collection-specific API helpers such as `getCollection()` and `render()` to query and display your data, as well as schema validation.

Tip

Find community-built and third-party loaders in the [Astro integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=loaders).


##### Inline loaders


[Section titled Inline loaders](#inline-loaders)

You can define a loader inline, inside your collection, as an async function that returns an array of entries.

This is useful for loaders that don’t need to manually control how the data is loaded and stored. Whenever the loader is called, it will clear the store and reload all the entries.

src/content.config.ts

```
const countries = defineCollection({loader: async () => {const response = await fetch("https://restcountries.com/v3.1/all");const data = await response.json();// Must return an array of entries with an id property, or an object with IDs as keys and entries as valuesreturn data.map((country) => ({id: country.cca3,...country,}));},schema: /* ... */});
```

The returned entries are stored in the collection and can be queried using the `getCollection()` and `getEntry()` functions.


##### Loader objects


[Section titled Loader objects](#loader-objects)

For more control over the loading process, you can use the Content Loader API to create a loader object. For example, with access to the `load` method directly, you can create a loader that allows entries to be updated incrementally or clears the store only when necessary.

Similar to creating an Astro integration or Vite plugin, you can [distribute your loader as an NPM package](/en/reference/publish-to-npm/) that others can use in their projects.

See the full [Content Loader API](/en/reference/content-loader-reference/) and examples of how to build your own loader.


### Defining the collection schema


[Section titled Defining the collection schema](#defining-the-collection-schema)

Schemas enforce consistent frontmatter or entry data within a collection through Zod validation. A schema **guarantees** that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.

Schemas also power Astro’s automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking.

Every frontmatter or data property of your collection entries must be defined using a Zod data type:

src/content.config.ts

```
import { defineCollection, z } from'astro:content';import { glob, file } from'astro/loaders'; // Not available with legacy APIconst blog = defineCollection({loader: glob({ pattern: "**/*.md", base: "./src/data/blog" }),schema: z.object({title: z.string(),description: z.string(),pubDate: z.coerce.date(),updatedDate: z.coerce.date().optional(),})});const dogs = defineCollection({loader: file("src/data/dogs.json"),schema: z.object({id: z.string(),breed: z.string(),temperament: z.array(z.string()),}),});export const collections = { blog, dogs };
```


#### Defining datatypes with Zod


[Section titled Defining datatypes with Zod](#defining-datatypes-with-zod)

Astro uses [Zod](https://github.com/colinhacks/zod) to power its content schemas. With Zod, Astro is able to validate every file’s data within a collection *and* provide automatic TypeScript types when you go to query content from inside your project.

To use Zod in Astro, import the `z` utility from `"astro:content"`. This is a re-export of the Zod library, and it supports all of the features of Zod.

```
// Example: A cheatsheet of many common Zod datatypesimport { z, defineCollection } from'astro:content';defineCollection({schema: z.object({isDraft: z.boolean(),title: z.string(),sortOrder: z.number(),image: z.object({src: z.string(),alt: z.string(),}),author: z.string().default('Anonymous'),language: z.enum(['en', 'es']),tags: z.array(z.string()),footnote: z.string().optional(),// In YAML, dates written without quotes around them are interpreted as Date objectspublishDate: z.date(), // e.g. 2024-09-17// Transform a date string (e.g. "2022-07-08") to a Date objectupdatedDate: z.string().transform((str)=>newDate(str)),authorContact: z.string().email(),canonicalURL: z.string().url(),})})
```

See [Zod’s README](https://github.com/colinhacks/zod) for complete documentation on how Zod works and what features are available.


##### Zod schema methods


[Section titled Zod schema methods](#zod-schema-methods)

All [Zod schema methods](https://zod.dev/?id=schema-methods) (e.g. `.parse()`, `.transform()`) are available, with some limitations. Notably, performing custom validation checks on images using `image().refine()` is unsupported.


#### Defining collection references


[Section titled Defining collection references](#defining-collection-references)

Collection entries can also “reference” other related entries.

With the [`reference()` function](/en/reference/modules/astro-content/#reference) from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every `space-shuttle` entry includes a `pilot` property which uses the `pilot` collection’s own schema for type checking, autocomplete, and validation.

A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:

src/content.config.ts

```
import { defineCollection, reference, z } from'astro:content';import { glob } from'astro/loaders';const blog = defineCollection({loader: glob({ pattern: '**/[^_]*.md', base: "./src/data/blog" }),schema: z.object({title: z.string(),// Reference a single author from the `authors` collection by `id`author: reference('authors'),// Reference an array of related posts from the `blog` collection by `slug`relatedPosts: z.array(reference('blog')),})});const authors = defineCollection({loader: glob({ pattern: '**/[^_]*.json', base: "./src/data/authors" }),schema: z.object({name: z.string(),portfolio: z.string().url(),})});export const collections = { blog, authors };
```

This example blog post specifies the `id`s of related posts and the `id` of the post author:

src/data/blog/welcome.md

```
---title: "Welcome to my blog"author: ben-holmes# references `src/data/authors/ben-holmes.json`relatedPosts:- about-me# references `src/data/blog/about-me.md`- my-year-in-review# references `src/data/blog/my-year-in-review.md`---
```

These references will be transformed into objects containing a `collection` key and an `id` key, allowing you to easily [query them in your templates](/en/guides/content-collections/#accessing-referenced-data).


### Defining custom IDs


[Section titled Defining custom IDs](#defining-custom-ids)

When using the `glob()` loader with Markdown, MDX, Markdoc, or JSON files, every content entry [`id`](/en/reference/modules/astro-content/#id) is automatically generated in an URL-friendly format based on the content filename. The `id` is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.

You can override an entry’s generated `id` by adding your own `slug` property to the file frontmatter or data object for JSON files. This is similar to the “permalink” feature of other web frameworks.

src/blog/1.md

```
---title: My Blog Postslug: my-custom-id/supports/slashes---Your blog post content here.
```

src/categories/1.json

```
{"title": "My Category","slug": "my-custom-id/supports/slashes","description": "Your category description here."}
```


## Querying Collections


[Section titled Querying Collections](#querying-collections)

Astro provides helper functions to query a collection and return one (or more) content entries.

-   [`getCollection()`](/en/reference/modules/astro-content/#getcollection) fetches an entire collection and returns an array of entries.
-   [`getEntry()`](/en/reference/modules/astro-content/#getentry) fetches a single entry from a collection.

These return entries with a unique `id`, a `data` object with all defined properties, and will also return a `body` containing the raw, uncompiled body of a Markdown, MDX, or Markdoc document.

```
import { getCollection, getEntry } from'astro:content';// Get all entries from a collection.// Requires the name of the collection as an argument.const allBlogPosts = await getCollection('blog');// Get a single entry from a collection.// Requires the name of the collection and `id`const poodleData = await getEntry('dogs', 'poodle');
```

See the full list of properties returned by the [`CollectionEntry` type](/en/reference/modules/astro-content/#collectionentry).


### Using content in Astro templates


[Section titled Using content in Astro templates](#using-content-in-astro-templates)

After querying your collections, you can access each entry’s content directly inside of your Astro component template. For example, you can create a list of links to your blog posts, displaying information from your entry’s frontmatter using the `data` property.

src/pages/index.astro

```
---import { getCollection } from'astro:content';const posts = await getCollection('blog');---<h1>My posts</h1><ul>{posts.map(post=> (<li><ahref={`/blog/${post.id}`}>{post.data.title}</a></li>))}</ul>
```


#### Rendering body content


[Section titled Rendering body content](#rendering-body-content)

Once queried, you can render Markdown and MDX entries to HTML using the [`render()`](/en/reference/modules/astro-content/#render) function property. Calling this function gives you access to rendered HTML content, including both a `<Content />` component and a list of all rendered headings.

src/pages/blog/post-1.astro

```
---import { getEntry, render } from'astro:content';const entry = await getEntry('blog', 'post-1');if (!entry) {// Handle Error, for example:thrownewError('Could not find blog post 1');}const { Content, headings } = await render(entry);---<p>Published on: {entry.data.published.toDateString()}</p><Content />
```


#### Passing content as props


[Section titled Passing content as props](#passing-content-as-props)

A component can also pass an entire collection entry as a prop.

You can use the [`CollectionEntry`](/en/reference/modules/astro-content/#collectionentry) utility to correctly type your component’s props using TypeScript. This utility takes a string argument that matches the name of your collection schema and will inherit all of the properties of that collection’s schema.

src/components/BlogCard.astro

```
---importtype { CollectionEntry } from'astro:content';interface Props {post:CollectionEntry<'blog'>;}// `post` will match your 'blog' collection schema typeconst { post } = Astro.props;---
```


### Filtering collection queries


[Section titled Filtering collection queries](#filtering-collection-queries)

`getCollection()` takes an optional “filter” callback that allows you to filter your query based on an entry’s `id` or `data` properties.

You can use this to filter by any content criteria you like. For example, you can filter by properties like `draft` to prevent any draft blog posts from publishing to your blog:

```
// Example: Filter out content entries with `draft: true`import { getCollection } from'astro:content';const publishedBlogEntries = await getCollection('blog', ({ data }) => {return data.draft !== true;});
```

You can also create draft pages that are available when running the dev server, but not built in production:

```
// Example: Filter out content entries with `draft: true` only when building for productionimport { getCollection } from'astro:content';const blogEntries = await getCollection('blog', ({ data }) => {return import.meta.env.PROD ? data.draft !== true : true;});
```

The filter argument also supports filtering by nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory:

```
// Example: Filter entries by sub-directory in the collectionimport { getCollection } from'astro:content';const englishDocsEntries = await getCollection('docs', ({ id }) => {return id.startsWith('en/');});
```


### Accessing referenced data


[Section titled Accessing referenced data](#accessing-referenced-data)

Any [references defined in your schema](/en/guides/content-collections/#defining-collection-references) must be queried separately after first querying your collection entry. Since the [`reference()` function](/en/reference/modules/astro-content/#reference) transforms a reference to an object with `collection` and `id` as keys, you can use the `getEntry()` function to return a single referenced item, or `getEntries()` to retrieve multiple referenced entries from the returned `data` object.

src/pages/blog/welcome.astro

```
---import { getEntry, getEntries } from'astro:content';const blogPost = await getEntry('blog', 'welcome');// Resolve a singular reference (e.g. `{collection: "authors", id: "ben-holmes"}`)const author = await getEntry(blogPost.data.author);// Resolve an array of references// (e.g. `[{collection: "blog", id: "about-me"}, {collection: "blog", id: "my-year-in-review"}]`)const relatedPosts = await getEntries(blogPost.data.relatedPosts);---<h1>{blogPost.data.title}</h1><p>Author: {author.data.name}</p><!-- ... --><h2>You might also like:</h2>{relatedPosts.map(post=> (<ahref={post.id}>{post.data.title}</a>))}
```


## Generating Routes from Content


[Section titled Generating Routes from Content](#generating-routes-from-content)

Content collections are stored outside of the `src/pages/` directory. This means that no pages or routes are generated for your collection items by default.

You will need to manually create a new [dynamic route](/en/guides/routing/#dynamic-routes) if you want to generate HTML pages for each of your collection entries, such as individual blog posts. Your dynamic route will map the incoming request param (e.g. `Astro.params.slug` in `src/pages/blog/[...slug].astro`) to fetch the correct entry for each page.

The exact method for generating routes will depend on whether your pages are prerendered (default) or rendered on demand by a server.


### Building for static output (default)


[Section titled Building for static output (default)](#building-for-static-output-default)

If you are building a static website (Astro’s default behavior), use the [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) function to create multiple pages from a single page component (e.g. `src/pages/[slug]`) during your build.

Call `getCollection()` inside of `getStaticPaths()` to have your collection data available for building static routes. Then, create the individual URL paths using the `id` property of each content entry. Each page is passed the entire collection entry as a prop for [use in your page template](#using-content-in-astro-templates).

src/pages/posts/\[id\].astro

```
---import { getCollection, render } from'astro:content';// 1. Generate a new path for every collection entryexportasyncfunctiongetStaticPaths() {const posts = await getCollection('blog');return posts.map(post=> ({params: { id: post.id },props: { post },}));}// 2. For your template, you can get the entry directly from the propconst { post } = Astro.props;const { Content } = await render(post);---<h1>{post.data.title}</h1><Content />
```

This will generate a page route for every entry in the `blog` collection. For example, an entry at `src/blog/hello-world.md` will have an `id` of `hello-world`, and therefore its final URL will be `/posts/hello-world/`.

Note

If your custom slugs contain the `/` character to produce URLs with multiple path segments, you must use a [rest parameter (e.g. `[...slug]`)](/en/guides/routing/#rest-parameters) in the `.astro` filename for this dynamic routing page.


### Building for server output (SSR)


[Section titled Building for server output (SSR)](#building-for-server-output-ssr)

If you are building a dynamic website (using Astro’s SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using `Astro.request` or `Astro.params`) to find the `slug` on-demand, and then fetch it using [`getEntry()`](/en/reference/modules/astro-content/#getentry).

src/pages/posts/\[id\].astro

```
---import { getEntry, render } from"astro:content";// 1. Get the slug from the incoming server requestconst { id } = Astro.params;if (id ===undefined) {return Astro.redirect("/404");}// 2. Query for the entry directly using the request slugconst post = await getEntry("blog", id);// 3. Redirect if the entry does not existif (post ===undefined) {return Astro.redirect("/404");}// 4. Render the entry to HTML in the templateconst { Content } = await render(post);---<h1>{post.data.title}</h1><Content />
```

Tip

Explore the `src/pages/` folder of the [blog tutorial demo code on GitHub](https://github.com/withastro/blog-tutorial-demo/tree/content-collections/src/pages) to see full examples of creating pages from your collections for blog features like a list of blog posts, tags pages, and more!


## When to create a collection


[Section titled When to create a collection](#when-to-create-a-collection)

You can [create a collection](#defining-collections) any time you have a group of related data or content that shares a common structure.

Much of the benefit of using collections comes from:

-   Defining a common data shape to validate that an individual entry is “correct” or “complete”, avoiding errors in production.
-   Content-focused APIs designed to make querying intuitive (e.g. `getCollection()` instead of `import.meta.glob()`) when importing and rendering content on your pages.
-   A [Content Loader API](/en/reference/content-loader-reference/) for retrieving your content that provides both built-in loaders and access to the low-level API. There are several third-party and community-built loaders available, and you can build your own custom loader to fetch data from anywhere.
-   Performance and scalability. The Content Layer API allows data to be cached between builds and is suitable for tens of thousands of content entries.

[Define your data](#defining-collections) as a collection when:

-   You have multiple files or data to organize that share the same overall structure (e.g. blog posts written in Markdown which all have the same frontmatter properties).
-   You have existing content stored remotely, such as in a CMS, and want to take advantage of the collections helper functions and Content Layer API instead of using `fetch()` or SDKs.
-   You need to fetch (tens of) thousands of related pieces of data, and need a querying and caching method that handles at scale.


### When not to create a collection


[Section titled When not to create a collection](#when-not-to-create-a-collection)

Collections provide excellent structure, safety, and organization when you have **multiple pieces of content that must share the same properties**.

Collections **may not be your solution** if:

-   You have only one or a small number of different pages. Consider [making individual page components](/en/basics/astro-pages/) such as `src/pages/about.astro` with your content directly instead.
-   You are displaying files that are not processed by Astro, such as PDFs. Place these static assets in the [`public/` directory](/en/basics/project-structure/#public) of your project instead.
-   Your data source has its own SDK/client library for imports that is incompatible with or does not offer a content loader and you prefer to use it directly.
-   You are using APIs that need to be updated in real time. Content collections are only updated at build time, so if you need live data, use other methods of [importing files](/en/guides/imports/#import-statements) or [fetching data](/en/guides/data-fetching/) with [on-demand rendering](/en/guides/on-demand-rendering/).

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 61. `en/guides/data-fetching/.md`

```text
# Data fetching


---
url: https://docs.astro.build/en/guides/data-fetching/
description: Learn how to fetch remote data with Astro using the fetch API.
---


# Data fetching


`.astro` files can fetch remote data to help you generate your pages.


## `fetch()` in Astro


[Section titled fetch() in Astro](#fetch-in-astro)

All [Astro components](/en/basics/astro-components/) have access to the [global `fetch()` function](https://developer.mozilla.org/en-US/docs/Web/API/fetch) in their component script to make HTTP requests to APIs using the full URL (e.g. `https://example.com/api`). Additionally, you can construct a URL to your project’s pages and endpoints that are rendered on demand on the server using [`new URL("/api", Astro.url)`](/en/reference/api-reference/#url).

This fetch call will be executed at build time, and the data will be available to the component template for generating dynamic HTML. If [SSR](/en/guides/on-demand-rendering/) mode is enabled, any fetch calls will be executed at runtime.

💡 Take advantage of [**top-level `await`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await) inside of your Astro component script.

💡 Pass fetched data to both Astro and framework components, as props.

src/components/User.astro

```
---import Contact from"../components/Contact.jsx";import Location from"../components/Location.astro";const response = await fetch("https://randomuser.me/api/");const data = await response.json();const randomUser = data.results[0];---<!-- Data fetched at build can be rendered in HTML --><h1>User</h1><h2>{randomUser.name.first}{randomUser.name.last}</h2><!-- Data fetched at build can be passed to components as props --><Contactclient:loademail={randomUser.email} /><Locationcity={randomUser.location.city} />
```

Note

Remember, all data in Astro components is fetched when a component is rendered.

Your deployed Astro site will fetch data **once, at build time**. In dev, you will see data fetches on component refreshes. If you need to re-fetch data multiple times client-side, use a [framework component](/en/guides/framework-components/) or a [client-side script](/en/guides/client-side-scripts/) in an Astro component.


## `fetch()` in Framework Components


[Section titled fetch() in Framework Components](#fetch-in-framework-components)

The `fetch()` function is also globally available to any [framework components](/en/guides/framework-components/):

src/components/Movies.tsx

```
importtype { FunctionalComponent } from'preact';const data = await fetch('https://example.com/movies.json').then((response) => response.json());// Components that are build-time rendered also log to the CLI.// When rendered with a `client:*` directive, they also log to the browser console.console.log(data);const Movies:FunctionalComponent = () => {// Output the result to the pagereturn <div>{JSON.stringify(data)}</div>;};exportdefault Movies;
```


## GraphQL queries


[Section titled GraphQL queries](#graphql-queries)

Astro can also use `fetch()` to query a GraphQL server with any valid GraphQL query.

src/components/Film.astro

```
---const response = await fetch("https://swapi-graphql.netlify.app/.netlify/functions/index",{method: "POST",headers: { "Content-Type": "application/json" },body: JSON.stringify({query: `query getFilm ($id:ID!) {film(id: $id) {titlereleaseDate}}`,variables: {id: "ZmlsbXM6MQ==",},}),});const json = await response.json();const { film } = json.data;---<h1>Fetching information about Star Wars: A New Hope</h1><h2>Title: {film.title}</h2><p>Year: {film.releaseDate}</p>
```


## Fetch from a Headless CMS


[Section titled Fetch from a Headless CMS](#fetch-from-a-headless-cms)

Astro components can fetch data from your favorite CMS and then render it as your page content. Using [dynamic routes](/en/guides/routing/#dynamic-routes), components can even generate pages based on your CMS content.

See our [CMS Guides](/en/guides/cms/) for full details on integrating Astro with headless CMSes including Storyblok, Contentful, and WordPress.


## Community resources


[Section titled Community resources](#community-resources)

-   [Creating a fullstack app with Astro + GraphQL](https://robkendal.co.uk/blog/how-to-build-astro-site-with-graphql/)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 62. `en/guides/deploy/.md`

```text
# Deploy your Astro Site


---
url: https://docs.astro.build/en/guides/deploy/
description: How to deploy your Astro site to the web.
---


# Deploy your Astro Site


**Ready to build and deploy your Astro site?** Follow one of our guides to different deployment services or scroll down for general guidance about deploying an Astro site.


## Deployment Guides


[Section titled Deployment Guides](#deployment-guides)

-   ### [Netlify](/en/guides/deploy/netlify/)

    On demandStatic

-   ### [Vercel](/en/guides/deploy/vercel/)

    On demandStatic

-   ### [Deno Deploy](/en/guides/deploy/deno/)

    On demandStatic

-   ### [GitHub Pages](/en/guides/deploy/github/)

    Static

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

    Static

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

    On demandStatic

-   ### [AWS](/en/guides/deploy/aws/)

    On demandStatic

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

    On demandStatic

-   ### [AWS via SST](/en/guides/deploy/sst/)

    On demandStatic

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

    On demandStatic

-   ### [Azion](/en/guides/deploy/azion/)

    On demandStatic

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

    On demandStatic

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

    On demandStatic

-   ### [Heroku](/en/guides/deploy/heroku/)

    Static

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

    Static

-   ### [Buddy](/en/guides/deploy/buddy/)

    Static

-   ### [Fleek](/en/guides/deploy/fleek/)

    Static

-   ### [Fly.io](/en/guides/deploy/flyio/)

    On demandStatic

-   ### [Render](/en/guides/deploy/render/)

    Static

-   ### [Stormkit](/en/guides/deploy/stormkit/)

    Static

-   ### [Surge](/en/guides/deploy/surge/)

    Static

-   ### [Cleavr](/en/guides/deploy/cleavr/)

    On demandStatic

-   ### [Kinsta](/en/guides/deploy/kinsta/)

    On demandStatic

-   ### [Zeabur](/en/guides/deploy/zeabur/)

    On demandStatic

-   ### [Zerops](/en/guides/deploy/zerops/)

    On demandStatic



## Quick Deploy Options


[Section titled Quick Deploy Options](#quick-deploy-options)

You can build and deploy an Astro site to a number of hosts quickly using either their website’s dashboard UI or a CLI.


### Website UI


[Section titled Website UI](#website-ui)

A quick way to deploy your website is to connect your Astro project’s online Git repository (e.g. GitHub, GitLab, Bitbucket) to a host provider and take advantage of continuous deployment using Git.

These host platforms automatically detect pushes to your Astro project’s source repository, build your site and deploy it to the web at a custom URL or your personal domain. Often, setting up a deployment on these platforms will follow steps something like the following:

1.  Add your repository to an online Git provider (e.g. in GitHub, GitLab, Bitbucket)

2.  Choose a host that supports **continuous deployment** (e.g. [Netlify](/en/guides/deploy/netlify/) or [Vercel](/en/guides/deploy/vercel/)) and import your Git repository as a new site/project.

    Many common hosts will recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy your site as shown below. (If not, these settings can be changed.)

    Deploy settings

    -   **Build Command:** `astro build` or `npm run build`
    -   **Publish directory:** `dist`

3.  Click “Deploy” and your new website will be created at a unique URL for that host (e.g. `new-astro-site.netlify.app`).


The host will be automatically configured to watch your Git provider’s main branch for changes, and to rebuild and republish your site at each new commit. These settings can typically be configured in your host provider’s dashboard UI.


### CLI Deployment


[Section titled CLI Deployment](#cli-deployment)

Some hosts will have their own command line interface (CLI) you can install globally to your machine using npm. Often, using a CLI to deploy looks something like the following:

1.  Install your host’s CLI globally, for example:

    -   [npm](#tab-panel-3165)
    -   [pnpm](#tab-panel-3166)
    -   [Yarn](#tab-panel-3167)

    Terminal window

    ```
    npminstall--globalnetlify-cli
    ```

    Terminal window

    ```
    pnpmadd--globalnetlify-cli
    ```

    Terminal window

    ```
    yarnglobaladdnetlify-cli
    ```

2.  Run the CLI and follow any instructions for authorization, setup etc.

3.  Build your site and deploy to your host

    Many common hosts will build and deploy your site for you. They will usually recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy as shown below. (If not, these settings can be changed.)

    Deploy settings

    -   **Build Command:** `astro build` or `npm run build`
    -   **Publish directory:** `dist`

    Other hosts will require you to [build your site locally](#building-your-site-locally) and deploy using the command line.



## Building Your Site Locally


[Section titled Building Your Site Locally](#building-your-site-locally)

Many hosts like Netlify and Vercel will build your site for you and then publish that build output to the web. But, some sites will require you to build locally and then run a deploy command or upload your build output.

You may also wish to build locally to preview your site, or to catch any potential errors and warnings in your own environment.

Run the command `npm run build` to build your Astro site.

-   [npm](#tab-panel-3168)
-   [pnpm](#tab-panel-3169)
-   [Yarn](#tab-panel-3170)

Terminal window

```
npmrunbuild
```

Terminal window

```
pnpmrunbuild
```

Terminal window

```
yarnrunbuild
```

By default, the build output will be placed at `dist/`. This location can be changed using the [`outDir` configuration option](/en/reference/configuration-reference/#outdir).


## Adding an Adapter for on-demand rendering


[Section titled Adding an Adapter for on-demand rendering](#adding-an-adapter-for-on-demand-rendering)

Note

Before deploying your Astro site with [on-demand rendering](/en/guides/on-demand-rendering/) enabled, make sure you have:

-   Installed the [appropriate adapter](/en/guides/on-demand-rendering/) to your project dependencies (either manually, or using the adapter’s `astro add` command, e.g. `npx astro add netlify`).
-   [Added the adapter](/en/reference/configuration-reference/#integrations) to your `astro.config.mjs` file’s import and default export when installing manually. (The `astro add` command will take care of this step for you!)

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 63. `en/guides/deploy/aws/.md`

```text
# Deploy your Astro Site to AWS


---
url: https://docs.astro.build/en/guides/deploy/aws/
description: How to deploy your Astro site to the web using AWS.
---


# Deploy your Astro Site to AWS


[AWS](https://aws.amazon.com/) is a full-featured web app hosting platform that can be used to deploy an Astro site.

Deploying your project to AWS requires using the [AWS console](https://aws.amazon.com/console/). (Most of these actions can also be done using the [AWS CLI](https://aws.amazon.com/cli/)). This guide will walk you through the steps to deploy your site to AWS using [AWS Amplify](https://aws.amazon.com/amplify/), [S3 static website hosting](https://aws.amazon.com/s3/), and [CloudFront](https://aws.amazon.com/cloudfront/).


## AWS Amplify


[Section titled AWS Amplify](#aws-amplify)

AWS Amplify is a set of purpose-built tools and features that lets frontend web and mobile developers quickly and easily build full-stack applications on AWS. You can either deploy your Astro project as a static site, or as a server-rendered site.


### Static Site


[Section titled Static Site](#static-site)

Your Astro project is a static site by default.

1.  Create a new Amplify Hosting project.

2.  Connect your repository to Amplify.

3.  Modify your build settings to match your project’s build process.

    -   [npm](#tab-panel-3111)
    -   [pnpm](#tab-panel-3112)
    -   [Yarn](#tab-panel-3113)

    ```
    version: 1frontend:phases:preBuild:commands:- npm cibuild:commands:- npm run buildartifacts:baseDirectory: /distfiles:- '**/*'cache:paths:- node_modules/**/*
    ```

    ```
    version: 1frontend:phases:preBuild:commands:- npm i -g pnpm- pnpm config set store-dir .pnpm-store- pnpm ibuild:commands:- pnpm run buildartifacts:baseDirectory: /distfiles:- '**/*'cache:paths:- .pnpm-store/**/*
    ```

    ```
    version: 1frontend:phases:preBuild:commands:- yarn installbuild:commands:- yarn buildartifacts:baseDirectory: /distfiles:- '**/*'cache:paths:- node_modules/**/*
    ```


Amplify will automatically deploy your website and update it when you push a commit to your repository.


### Adapter for on-demand rendering


[Section titled Adapter for on-demand rendering](#adapter-for-on-demand-rendering)

In order to deploy your project as a server-rendered site, you will need to use the third-party, [community-maintained AWS Amplify adapter](https://github.com/alexnguyennz/astro-aws-amplify) and make some changes to your config.

First, install the Amplify adapter.

-   [npm](#tab-panel-3114)
-   [pnpm](#tab-panel-3115)
-   [Yarn](#tab-panel-3116)

Terminal window

```
npminstallastro-aws-amplify
```

Terminal window

```
pnpmaddastro-aws-amplify
```

Terminal window

```
yarnaddastro-aws-amplify
```

Then, in your `astro.config.*` file, add the adapter and set the output to `server`.

astro.config.mjs

```
import { defineConfig } from'astro/config';import awsAmplify from'astro-aws-amplify';exportdefaultdefineConfig({// ...output: "server",adapter: awsAmplify(),});
```

Once the adapter has been installed, you can set up your Amplify project.

1.  Create a new Amplify Hosting project.

2.  Connect your repository to Amplify.

3.  Modify your build settings to match the adapter’s build process by either editing the build settings in the AWS console, or by adding an `amplify.yaml` in the root of your project.

    -   [npm](#tab-panel-3117)
    -   [pnpm](#tab-panel-3118)
    -   [Yarn](#tab-panel-3119)

    ```
    version: 1frontend:phases:preBuild:commands:- npm ci --cache .npm --prefer-offlinebuild:commands:- npm run build- mv node_modules ./.amplify-hosting/compute/defaultartifacts:baseDirectory: .amplify-hostingfiles:- '**/*'cache:paths:- .npm/**/*
    ```

    ```
    version: 1frontend:phases:preBuild:commands:- npm i -g pnpm- pnpm config set store-dir .pnpm-store- pnpm ibuild:commands:- pnpm run build- mv node_modules ./.amplify-hosting/compute/defaultartifacts:baseDirectory: .amplify-hostingfiles:- '**/*'cache:paths:- .pnpm-store/**/*
    ```

    ```
    version: 1frontend:phases:preBuild:commands:- yarn installbuild:commands:- yarn build- mv node_modules ./.amplify-hosting/compute/defaultartifacts:baseDirectory: .amplify-hostingfiles:- '**/*'cache:paths:- node_modules/**/*
    ```


Amplify will automatically deploy your website and update it when you push a commit to your repository.

See [AWS’s Astro deployment guide](https://docs.aws.amazon.com/amplify/latest/userguide/get-started-astro.html) for more info.


## S3 static website hosting


[Section titled S3 static website hosting](#s3-static-website-hosting)

S3 is the starting point of any application. It is where your project files and other assets are stored. S3 charges for file storage and number of requests. You can find more information about S3 in the [AWS documentation](https://aws.amazon.com/s3/).

1.  Create an S3 bucket with your project’s name.

    Tip

    The bucket name should be globally unique. We recommend a combination of your project name and the domain name of your site.

2.  Disable **“Block all public access”**. By default, AWS sets all buckets to be private. To make it public, you need to uncheck the “Block public access” checkbox in the bucket’s properties.

3.  Upload your built files located in `dist` to S3. You can do this manually in the console or use the AWS CLI. If you use the AWS CLI, use the following command after [authenticating with your AWS credentials](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html):

    ```
    aws s3 cp dist/ s3://<BUCKET_NAME>/ --recursive
    ```

4.  Update your bucket policy to allow public access. You can find this setting in the bucket’s **Permissions > Bucket policy**.

    ```
    {"Version": "2012-10-17","Statement": [{"Sid": "PublicReadGetObject","Effect": "Allow","Principal": "*","Action": "s3:GetObject","Resource": "arn:aws:s3:::<BUCKET_NAME>/*"}]}
    ```

    Caution

    Do not forget to replace `<BUCKET_NAME>` with the name of your bucket.

5.  Enable website hosting for your bucket. You can find this setting in the bucket’s **Properties > Static website hosting**. Set your index document to `index.html` and your error document to `404.html`. Finally, you can find your new website URL in the bucket’s **Properties > Static website hosting**.

    Note

    If you are deploying a single-page application (SPA), set your error document to `index.html`.



## S3 with CloudFront


[Section titled S3 with CloudFront](#s3-with-cloudfront)

CloudFront is a web service that provides content delivery network (CDN) capabilities. It is used to cache content of a web server and distribute it to end users. CloudFront charges for the amount of data transferred. Adding CloudFront to your S3 bucket is more cost-effective and provides a faster delivery.

To connect S3 with CloudFront, create a CloudFront distribution with the following values:

-   **Origin domain:** Your S3 bucket static website endpoint. You can find your endpoint in your S3 bucket’s **Properties > Static website hosting**. Alternative, you can select your s3 bucket and click on the callout to replace your bucket address with your bucket static endpoint.
-   **Viewer protocol policy:** “Redirect to HTTPS”

This configuration will serve your site using the CloudFront CDN network. You can find your CloudFront distribution URL in the bucket’s **Distributions > Domain name**.

Note

When connecting CloudFront to an S3 static website endpoint, you rely on S3 bucket policies for access control. See [S3 static website hosting](#s3-static-website-hosting) section for more information about bucket policies.


## Continuous deployment with GitHub Actions


[Section titled Continuous deployment with GitHub Actions](#continuous-deployment-with-github-actions)

There are many ways to set up continuous deployment for AWS. One possibility for code hosted on GitHub is to use [GitHub Actions](https://github.com/features/actions) to deploy your website every time you push a commit.

1.  Create a new policy in your AWS account using [IAM](https://aws.amazon.com/iam/) with the following permissions. This policy will allow you to upload built files to your S3 bucket and invalidate the CloudFront distribution files when you push a commit.

    ```
    {"Version": "2012-10-17","Statement": [{"Sid": "VisualEditor0","Effect": "Allow","Action": ["s3:PutObject","s3:ListBucket","s3:DeleteObject","cloudfront:CreateInvalidation"],"Resource": ["<DISTRIBUTION_ARN>","arn:aws:s3:::<BUCKET_NAME>/*","arn:aws:s3:::<BUCKET_NAME>"]}]}
    ```

    Caution

    Do not forget to replace `<DISTRIBUTION_ARN>` and `<BUCKET_NAME>`. You can find the DISTRIBUTION\_ARN in **CloudFront > Distributions > Details**.

2.  Create a new IAM user and attach the policy to the user. This will provide your `AWS_SECRET_ACCESS_KEY` and `AWS_ACCESS_KEY_ID`.

3.  Add this sample workflow to your repository at `.github/workflows/deploy.yml` and push it to GitHub. You will need to add `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `BUCKET_ID`, and `DISTRIBUTION_ID` as “secrets” to your repository on GitHub under **Settings** > **Secrets** > **Actions**. Click New repository secret to add each one.

    ```
    name: Deploy Websiteon:push:branches:- mainjobs:deploy:runs-on: ubuntu-lateststeps:- name: Checkoutuses: actions/checkout@v4- name: Configure AWS Credentialsuses: aws-actions/configure-aws-credentials@v1with:aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}aws-region: us-east-1- name: Install modulesrun: npm ci- name: Build applicationrun: npm run build- name: Deploy to S3run: aws s3 sync --delete ./dist/ s3://${{ secrets.BUCKET_ID }}- name: Create CloudFront invalidationrun: aws cloudfront create-invalidation --distribution-id ${{ secrets.DISTRIBUTION_ID }} --paths "/*"
    ```

    Note

    Your `BUCKET_ID` is the name of your S3 bucket. Your `DISTRIBUTION_ID` is your CloudFront distribution ID. You can find your CloudFront distribution ID in **CloudFront > Distributions > ID**



## Community Resources


[Section titled Community Resources](#community-resources)

-   [Deploy Astro to AWS Amplify](https://www.launchfa.st/blog/deploy-astro-aws-amplify)
-   [Deploy Astro to AWS Elastic Beanstalk](https://www.launchfa.st/blog/deploy-astro-aws-elastic-beanstalk)
-   [Deploy Astro to Amazon ECS on AWS Fargate](https://www.launchfa.st/blog/deploy-astro-aws-fargate)
-   [Troubleshooting SSR Amplify Deployments](https://docs.aws.amazon.com/amplify/latest/userguide/troubleshooting-ssr-deployment.html)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 64. `en/guides/deploy/azion/.md`

```text
# Deploy your Astro Site to Azion


---
url: https://docs.astro.build/en/guides/deploy/azion/
description: How to deploy your Astro site to the web using Azion.
---


# Deploy your Astro Site to Azion


You can deploy your Astro project on [Azion](https://console.azion.com/), a platform for frontend developers to collaborate and deploy static (JAMstack) and SSR websites.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need:

-   An [Azion account](https://www.azion.com/). If you don’t have one, you can sign up for a free account.
-   Your app code stored in a [GitHub](https://github.com/) repository.
-   [Azion CLI](https://www.azion.com/en/documentation/products/azion-cli/overview/) installed for faster project setup and deployment.


## How to Deploy through Azion Console Dashboard


[Section titled How to Deploy through Azion Console Dashboard](#how-to-deploy-through-azion-console-dashboard)

To start building, follow these steps:

1.  Access [Azion Console](https://console.azion.com).
2.  On the homepage, click the **\+ Create** button.
    -   This opens a modal with the options to create new applications and resources.
3.  Select the **Import from GitHub** option and click the card.
    -   This action opens the settings page.
4.  Connect your Azion account with GitHub.
    -   A pop-up window will appear asking for authorization.
5.  Select the repository you want to import from GitHub.
6.  Configure the build settings:
    -   **Framework preset:** Select the appropriate framework (e.g., `Astro`).
    -   **Root Directory:** This refers to the directory in which your code is located. Your code must be located at the root directory, not a subdirectory. A ./ symbol appears in this field, indicating it’s a root directory.
    -   **Install Command:** the command that compiles your settings to build for production. Build commands are executed through scripts. For example: npm run build or npm install for an NPM package.
7.  Click **Save and Deploy**.
8.  Monitor the deployment using **Azion Real-Time Metrics** and verify your site is live on the edge.


## How to Deploy a Static Site Using the Azion CLI


[Section titled How to Deploy a Static Site Using the Azion CLI](#how-to-deploy-a-static-site-using-the-azion-cli)

1.  **Install the Azion CLI:**

    -   Download and install the [Azion CLI](https://www.azion.com/en/documentation/products/azion-cli/overview/) for easier management and deployment.

    Caution

    The Azion CLI does not currently support native Windows environments. However, you can use it on Windows through the Windows Subsystem for Linux (WSL). Follow the [WSL installation guide](https://docs.microsoft.com/en-us/windows/wsl/install) to set up a Linux environment on your Windows machine.

2.  **Authenticate the CLI:**

    -   Run the following command to authenticate your CLI with your Azion account.

    Terminal window

    ```
    azionlogin
    ```

3.  **Set Up Your Application:**

    -   Use the following commands to initialize and configure your project:

    Terminal window

    ```
    azioninit
    ```

4.  **Build Your Astro Project:**

    -   Run your build command locally:

    Terminal window

    ```
    azionbuild
    ```

5.  **Deploy Your Static Files:**

    -   Deploy your static files using the Azion CLI:

    Terminal window

    ```
    aziondeploy
    ```


This guide provides an overview of deploying static applications.


## Enabling Local Development Using Azion CLI


[Section titled Enabling Local Development Using Azion CLI](#enabling-local-development-using-azion-cli)

For the preview to work, you must execute the following command:

Terminal window

```
aziondev
```

Once you’ve initialized the local development server, the application goes through the `build` process.

Terminal window

```
BuildingyourEdgeApplication.ThisprocessmaytakeafewminutesRunningbuildstepcommand:...
```

Then, when the build is complete, the access to the application is prompted:

Terminal window

```
[Azion Bundler] [Server] › ✔  success   Function running on port http://localhost:3000
```


## Troubleshooting


[Section titled Troubleshooting](#troubleshooting)


### Node.js runtime APIs


[Section titled Node.js runtime APIs](#nodejs-runtime-apis)

A project using an NPM package fails to build with an error message such as `[Error] Could not resolve "XXXX. The package "XXXX" wasn't found on the file system but is built into node.`:

This means that a package or import you are using is not compatible with Azion’s runtime APIs.

If you are directly importing a Node.js runtime API, please refer to the [Azion Node.js compatibility](https://www.azion.com/en/documentation/products/azion-edge-runtime/compatibility/node/) for further steps on how to resolve this.

If you are importing a package that imports a Node.js runtime API, check with the author of the package to see if they support the `node:*` import syntax. If they do not, you may need to find an alternative package.


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 65. `en/guides/deploy/buddy/.md`

```text
# Deploy your Astro Site with Buddy


---
url: https://docs.astro.build/en/guides/deploy/buddy/
description: How to deploy your Astro site to the web using Buddy.
---


# Deploy your Astro Site with Buddy


You can deploy your Astro project using [Buddy](https://buddy.works/), a CI/CD solution that can build your site and push it to many different deploy targets including FTP servers and cloud hosting providers.

Note

Buddy itself will not host your site. Instead, it helps you manage the build process and deliver the result to a deploy platform of your choice.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  [Create a **Buddy** account](https://buddy.works/sign-up).

2.  Create a new project and connect it with a git repository (GitHub, GitLab, BitBucket, any private Git Repository or you can use Buddy Git Hosting).

3.  Add a new pipeline.

4.  In the newly created pipeline add a **[Node.js](https://buddy.works/actions/node-js)** action.

5.  In this action add:

    Terminal window

    ```
    npminstallnpmrunbuild
    ```

6.  Add a deployment action — there are many to choose from, you can browse them in [Buddy’s actions catalog](https://buddy.works/actions). Although their settings can differ, remember to set the **Source path** to `dist`.

7.  Press the **Run** button.



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 66. `en/guides/deploy/cleavr/.md`

```text
# Deploy your Astro Site with Cleavr


---
url: https://docs.astro.build/en/guides/deploy/cleavr/
description: How to deploy your Astro site to your VPS server using Cleavr.
---


# Deploy your Astro Site with Cleavr


You can deploy your Astro project to your own Virtual Private Server (VPS) using [Cleavr](https://cleavr.io/), a server and app deployment management tool.

Tip

Check out [the Astro guide in Cleavr’s docs](https://docs.cleavr.io/guides/astro)!


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need:

-   A Cleavr account
-   A server on your VPS provider using Cleavr


## Add your site


[Section titled Add your site](#add-your-site)

1.  In Cleavr, navigate to the server you want to add your Astro project to.

2.  Select **Add Site** and fill in the details for your application, such as domain name.

3.  For **App Type**, select ‘NodeJS Static’ or ‘NodeJS SSR’ according to how you are setting up your Astro app.

4.  For Static apps, set **Artifact Folder** to `dist`.

5.  For SSR apps:

    -   Set **Entry Point** to `entry.mjs`.
    -   Set **Artifact Folder** to `dist/server`.
6.  Select **Add** to add the site to your server.



## Setup and deploy


[Section titled Setup and deploy](#setup-and-deploy)

1.  Once your new site is added, click **Setup and deploy**.

2.  Select the **VC Profile**, **Repo**, and **Branch** for your Astro Project.

3.  Make any additional configurations necessary for your project.

4.  Click on the **Deployments** tab and then click on **Deploy**.


Congratulations, you’ve just deployed your Astro app!


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 67. `en/guides/deploy/clever-cloud/.md`

```text
# Deploy your Astro Site to Clever Cloud


---
url: https://docs.astro.build/en/guides/deploy/clever-cloud/
description: How to deploy your Astro site to the web on Clever Cloud.
---


# Deploy your Astro Site to Clever Cloud


[Clever Cloud](https://clever-cloud.com) is a European cloud platform that provides automated, scalable services.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

You can deploy both fully static and on-demand rendered Astro projects on Clever Cloud. Regardless of your `output` mode (pre-rendered or [on-demand](/en/guides/on-demand-rendering/)), you can choose to deploy as a **static application** which runs using a post-build hook, or as a **Node.js** application, which requires some manual configuration in your `package.json`.


### Scripts


[Section titled Scripts](#scripts)

If you’re running an on-demand Node.js application, update your `start` script to run the Node server. Applications on Clever Cloud listen on port **8080**.

package.json

```
"scripts": {"start": "node ./dist/server/entry.mjs --host 0.0.0.0 --port 8080",}
```


## Deploy Astro from the Console


[Section titled Deploy Astro from the Console](#deploy-astro-from-the-console)

To deploy your Astro project to Clever Cloud, you will need to **create a new application**. The application wizard will walk you through the necessary configuration steps.

1.  From the lateral menubar, click **Create** > **An application**

2.  Choose how to deploy:

    -   **Create a brand new app**: to deploy from a local repository with Git

    or

    -   **Select a GitHub repository**: to deploy from GitHub
3.  Select a **Node.js** application, or a **static** one.

4.  Set up the minimal size for your instance and scalability options. Astro sites can typically be deployed using the **Nano** instance. Depending on your project’s specifications and dependencies, you may need to adjust accordingly as you watch the metrics from the **Overview** page.

5.  Select a **region** to deploy your instance.

6.  Skip [connecting **Add-ons** to your Clever application](https://www.clever-cloud.com/developers/doc/addons/) unless you’re using a database or Keycloak.

7.  Inject **environment variables**:

    -   For **Node.js**, no specific environment variable is needed to deploy Astro if you’re using **npm**. If you’re using **yarn** or **pnpm**, set the following environment variables:

    -   [pnpm](#tab-panel-3120)
    -   [yarn](#tab-panel-3121)

    Terminal window

    ```
    CC_NODE_BUILD_TOOL="custom"CC_PRE_BUILD_HOOK="npm install -g pnpm && pnpm install"CC_CUSTOM_BUILD_TOOL="pnpm run astro telemetry disable && pnpm build"
    ```

    Terminal window

    ```
    CC_NODE_BUILD_TOOL="yarn"CC_PRE_BUILD_HOOK="yarn && yarn run astro telemetry disable && yarn build"
    ```

    -   For a **static** application, add these variables:

    -   [npm](#tab-panel-3122)
    -   [pnpm](#tab-panel-3123)
    -   [yarn](#tab-panel-3124)

    Terminal window

    ```
    CC_POST_BUILD_HOOK="npm run build"CC_PRE_BUILD_HOOK="npm install && npm run astro telemetry disable"CC_WEBROOT="/dist"
    ```

    Terminal window

    ```
    CC_POST_BUILD_HOOK="pnpm build"CC_PRE_BUILD_HOOK="npm install -g pnpm && pnpm install && pnpm run astro telemetry disable"CC_WEBROOT="/dist"
    ```

    Terminal window

    ```
    CC_POST_BUILD_HOOK="yarn build"CC_PRE_BUILD_HOOK="yarn && yarn run astro telemetry disable"CC_WEBROOT="/dist"
    ```

8.  **Deploy!** If you’re deploying from **GitHub**, your deployment should start automatically. If you’re using **Git**, copy the remote and push on the **master** branch.


Other Branches

To deploy from branches other than `master`, use `git push clever <branch>:master`.

For example, if you want to deploy your local `main` branch without renaming it, use `git push clever main:master`.


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Clever Cloud documentation for deploying a Node.js application](https://www.clever-cloud.com/developers/doc/applications/javascript/nodejs/)
-   [Clever Cloud documentation for deploying Astro as a static application](https://www.clever-cloud.com/developers/guides/astro/)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 68. `en/guides/deploy/cloudflare/.md`

```text
# Deploy your Astro Site to Cloudflare


---
url: https://docs.astro.build/en/guides/deploy/cloudflare/
description: How to deploy your Astro site to the web using Cloudflare
---


# Deploy your Astro Site to Cloudflare


You can deploy full-stack applications, including front-end static assets and back-end APIs, as well as on-demand rendered sites, to both [Cloudflare Workers](https://developers.cloudflare.com/workers/static-assets/) and [Cloudflare Pages](https://pages.cloudflare.com/).

This guide includes:

-   [How to deploy to Cloudflare Workers](#cloudflare-workers)
-   [How to deploy to Cloudflare Pages](#cloudflare-pages)

Note

Cloudflare recommends using Cloudflare Workers for new projects. For existing Pages projects, refer to [Cloudflare’s migration guide](https://developers.cloudflare.com/workers/static-assets/migration-guides/migrate-from-pages/) and [compatibility matrix](https://developers.cloudflare.com/workers/static-assets/migration-guides/migrate-from-pages/#compatibility-matrix).

Read more about [using the Cloudflare runtime](/en/guides/integrations-guide/cloudflare/) in your Astro project.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To get started, you will need:

-   A Cloudflare account. If you don’t already have one, you can create a free Cloudflare account during the process.


## Cloudflare Workers


[Section titled Cloudflare Workers](#cloudflare-workers)


### How to deploy with Wrangler


[Section titled How to deploy with Wrangler](#how-to-deploy-with-wrangler)

1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).

    Terminal window

    ```
    npminstallwrangler@latest--save-dev
    ```

2.  If your site uses on demand rendering, install the [`@astrojs/cloudflare` adapter](/en/guides/integrations-guide/cloudflare/).

    This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

    Terminal window

    ```
    npxastroaddcloudflare
    ```

    Then, create a `.assetsignore` file in your `public/` folder, and add the following lines to it:

    public/.assetsignore

    ```
    _worker.js_routes.json
    ```

    Read more about [on-demand rendering in Astro](/en/guides/on-demand-rendering/).

3.  Create a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).

    -   [Static](#tab-panel-3125)
    -   [On demand](#tab-panel-3126)

    wrangler.jsonc

    ```
    {"$schema": "node_modules/wrangler/config-schema.json","name": "my-astro-app",// Update to today's date"compatibility_date": "2025-03-25","assets": {"directory": "./dist"}}
    ```

    wrangler.jsonc

    ```
    {"$schema": "node_modules/wrangler/config-schema.json","name": "my-astro-app","main": "./dist/_worker.js/index.js",// Update to today's date"compatibility_date": "2025-03-25","compatibility_flags": ["nodejs_compat"],"assets": {"binding": "ASSETS","directory": "./dist"},"observability": {"enabled": true}}
    ```

4.  Preview your project locally with Wrangler.

    Terminal window

    ```
    npxastrobuild && npxwranglerdev
    ```

5.  Deploy using `npx wrangler deploy`.

    Terminal window

    ```
    npxastrobuild && npxwranglerdeploy
    ```


After your assets are uploaded, Wrangler will give you a preview URL to inspect your site.

Read more about using [Cloudflare runtime APIs](/en/guides/integrations-guide/cloudflare/) such as bindings.


### How to deploy with CI/CD


[Section titled How to deploy with CI/CD](#how-to-deploy-with-cicd)

You can also use a CI/CD system such as [Workers Builds (BETA)](https://developers.cloudflare.com/workers/ci-cd/builds/) to automatically build and deploy your site on push.

If you’re using Workers Builds:

1.  Follow Steps 1-3 from the Wrangler section above.

2.  Log in to the [Cloudflare dashboard](https://dash.cloudflare.com/) and navigate to `Workers & Pages`. Select `Create`.

3.  Under `Import a repository`, select a Git account and then the repository containing your Astro project.

4.  Configure your project with:

    -   Build command: `npx astro build`
    -   Deploy command: `npx wrangler deploy`
5.  Click `Save and Deploy`. You can now preview your Worker at its provided `workers.dev` subdomain.



## Cloudflare Pages


[Section titled Cloudflare Pages](#cloudflare-pages)


### How to deploy with Wrangler


[Section titled How to deploy with Wrangler](#how-to-deploy-with-wrangler-1)

1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).

    Terminal window

    ```
    npminstallwrangler@latest--save-dev
    ```

2.  If your site uses on demand rendering, install the [`@astrojs/cloudflare` adapter](/en/guides/integrations-guide/cloudflare/).

    This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

    Terminal window

    ```
    npxastroaddcloudflare
    ```

    Read more about [on demand rendering in Astro](/en/guides/on-demand-rendering/).

3.  Preview your project locally with Wrangler.

    Terminal window

    ```
    npxastrobuild && npxwranglerpagesdev./dist
    ```

4.  Deploy using `npx wrangler deploy`.

    Terminal window

    ```
    npxastrobuild && npxwranglerpagesdeploy./dist
    ```


After your assets are uploaded, Wrangler will give you a preview URL to inspect your site.


### How to deploy a site with Git


[Section titled How to deploy a site with Git](#how-to-deploy-a-site-with-git)

1.  Push your code to your git repository (e.g. GitHub, GitLab).

2.  Log in to the [Cloudflare dashboard](https://dash.cloudflare.com/) and navigate to **Compute (Workers) > Workers & Pages**. Select **Create** and then select the **Pages** tab. Connect your git repository.

3.  Configure your project with:

    -   **Framework preset**: `Astro`
    -   **Build command:** `npm run build`
    -   **Build output directory:** `dist`
    -   **Environment variables:** Set the `NODE_VERSION` variable to `20` or `22`. By default, Cloudflare Pages builds sites using Node.js `v18.17.1`, which is not compatible with the latest version of Astro.
4.  Click the **Save and Deploy** button.



## Troubleshooting


[Section titled Troubleshooting](#troubleshooting)


### Client-side hydration


[Section titled Client-side hydration](#client-side-hydration)

Client-side hydration may fail as a result of Cloudflare’s Auto Minify setting. If you see `Hydration completed but contains mismatches` in the console, make sure to disable Auto Minify under Cloudflare settings.


### Node.js runtime APIs


[Section titled Node.js runtime APIs](#nodejs-runtime-apis)

If you are building a project that is using on-demand rendering with [the Cloudflare adapter](/en/guides/integrations-guide/cloudflare/) and the server fails to build with an error message such as `[Error] Could not resolve "XXXX. The package "XXXX" wasn't found on the file system but is built into node.`:

-   This means that a package or import you are using in the server-side environment is not compatible with the [Cloudflare runtime APIs](https://developers.cloudflare.com/workers/runtime-apis/nodejs/).

-   If you are directly importing a Node.js runtime API, please refer to the Astro documentation on Cloudflare’s [Node.js compatibility](/en/guides/integrations-guide/cloudflare/#nodejs-compatibility) for further steps on how to resolve this.

-   If you are importing a package that imports a Node.js runtime API, check with the author of the package to see if they support the `node:*` import syntax. If they do not, you may need to find an alternative package.



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 69. `en/guides/deploy/deno/.md`

```text
# Deploy your Astro Site with Deno


---
url: https://docs.astro.build/en/guides/deploy/deno/
description: How to deploy your Astro site to the web using Deno.
---


# Deploy your Astro Site with Deno


You can deploy a static or on-demand rendered Astro site using Deno, either on your own server, or to [Deno Deploy](https://deno.com/deploy), a distributed system that runs JavaScript, TypeScript, and WebAssembly at the edge, worldwide.

This guide includes instructions for running your Astro site on your own server with Deno, and deploying to Deno Deploy through GitHub Actions or the Deno Deploy CLI.


## Requirements


[Section titled Requirements](#requirements)

This guide assumes you already have [Deno](https://deno.com/) installed.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

Your Astro project can be deployed as a static site, or as an on-demand rendered site.


### Static Site


[Section titled Static Site](#static-site)

Your Astro project is a static site by default. You don’t need any extra configuration to deploy a static Astro site with Deno, or to Deno Deploy.


### Adapter for on-demand rendering


[Section titled Adapter for on-demand rendering](#adapter-for-on-demand-rendering)

To enable on-demand rendering in your Astro project using Deno, and to deploy on Deno Deploy:

1.  Install [the `@deno/astro-adapter` adapter](https://github.com/denoland/deno-astro-adapter) to your project’s dependencies using your preferred package manager:

    -   [npm](#tab-panel-3135)
    -   [pnpm](#tab-panel-3136)
    -   [Yarn](#tab-panel-3137)

    Terminal window

    ```
    npminstall@deno/astro-adapter
    ```

    Terminal window

    ```
    pnpminstall@deno/astro-adapter
    ```

    Terminal window

    ```
    yarnadd@deno/astro-adapter
    ```

2.  Update your `astro.config.mjs` project configuration file with the changes below.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import deno from'@deno/astro-adapter';exportdefaultdefineConfig({output: 'server',adapter: deno(),});
    ```

3.  Update your `preview` script in `package.json` with the change below.

    package.json

    ```
    {// ..."scripts": {"dev": "astro dev","start": "astro dev","build": "astro build","preview": "astro preview""preview":"deno run --allow-net --allow-read --allow-env ./dist/server/entry.mjs"}}
    ```

    You can now use this command to preview your production Astro site locally with Deno.

    -   [npm](#tab-panel-3138)
    -   [pnpm](#tab-panel-3139)
    -   [Yarn](#tab-panel-3140)

    Terminal window

    ```
    npmrunpreview
    ```

    Terminal window

    ```
    pnpmrunpreview
    ```

    Terminal window

    ```
    yarnrunpreview
    ```



## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can run your Astro site on your own server, or deploy to Deno Deploy through GitHub Actions or using Deno Deploy’s CLI (command line interface).


### On your own server


[Section titled On your own server](#on-your-own-server)

1.  Copy your project onto your server.

2.  Install the project dependencies using your preferred package manager:

    -   [npm](#tab-panel-3141)
    -   [pnpm](#tab-panel-3142)
    -   [Yarn](#tab-panel-3143)

    Terminal window

    ```
    npminstall
    ```

    Terminal window

    ```
    pnpminstall
    ```

    Terminal window

    ```
    yarn
    ```

3.  Build your Astro site with your preferred package manager:

    -   [npm](#tab-panel-3144)
    -   [pnpm](#tab-panel-3145)
    -   [Yarn](#tab-panel-3146)

    Terminal window

    ```
    npmrunbuild
    ```

    Terminal window

    ```
    pnpmrunbuild
    ```

    Terminal window

    ```
    yarnrunbuild
    ```

4.  Start your application with the following command:

    -   [Static](#tab-panel-3127)
    -   [On demand](#tab-panel-3128)

    Terminal window

    ```
    denorun-Ajsr:@std/http/file-serverdist
    ```

    Terminal window

    ```
    denorun-A./dist/server/entry.mjs
    ```



### GitHub Actions Deployment


[Section titled GitHub Actions Deployment](#github-actions-deployment)

If your project is stored on GitHub, the [Deno Deploy website](https://dash.deno.com/) will guide you through setting up GitHub Actions to deploy your Astro site.

1.  Push your code to a public or private GitHub repository.

2.  Sign in on [Deno Deploy](https://dash.deno.com/) with your GitHub account, and click on [New Project](https://dash.deno.com).

3.  Select your repository, the branch you want to deploy from, and select **GitHub Action** mode. (Your Astro site requires a build step, and cannot use Automatic mode.)

4.  In your Astro project, create a new file at `.github/workflows/deploy.yml` and paste in the YAML below. This is similar to the YAML given by Deno Deploy, with the additional steps needed for your Astro site.

    -   [Static](#tab-panel-3129)
    -   [On demand](#tab-panel-3130)

    .github/workflows/deploy.yml

    ```
    name: Deployon: [push]jobs:deploy:name: Deployruns-on: ubuntu-latestpermissions:id-token: write# Needed for auth with Deno Deploycontents: read# Needed to clone the repositorysteps:- name: Clone repositoryuses: actions/checkout@v4# Not using npm? Change `npm ci` to `yarn install` or `pnpm i`- name: Install dependenciesrun: npm ci# Not using npm? Change `npm run build` to `yarn build` or `pnpm run build`- name: Build Astrorun: npm run build- name: Upload to Deno Deployuses: denoland/deployctl@v1with:project: my-deno-project# TODO: replace with Deno Deploy project nameentrypoint: jsr:@std/http/file-serverroot: dist
    ```

    .github/workflows/deploy.yml

    ```
    name: Deployon: [push]jobs:deploy:name: Deployruns-on: ubuntu-latestpermissions:id-token: write# Needed for auth with Deno Deploycontents: read# Needed to clone the repositorysteps:- name: Clone repositoryuses: actions/checkout@v4# Not using npm? Change `npm ci` to `yarn install` or `pnpm i`- name: Install dependenciesrun: npm ci# Not using npm? Change `npm run build` to `yarn build` or `pnpm run build`- name: Build Astrorun: npm run build- name: Upload to Deno Deployuses: denoland/deployctl@v1with:project: my-deno-project# TODO: replace with Deno Deploy project nameentrypoint: dist/server/entry.mjs
    ```

5.  After committing this YAML file, and pushing to GitHub on your configured deploy branch, the deploy should begin automatically!

    You can track the progress using the “Actions” tab on your GitHub repository page, or on [Deno Deploy](https://dash.deno.com).



### CLI Deployment


[Section titled CLI Deployment](#cli-deployment)

1.  Install the [Deno Deploy CLI](https://docs.deno.com/deploy/manual/deployctl).

    Terminal window

    ```
    denoinstall-gArfjsr:@deno/deployctl
    ```

2.  Build your Astro site with your preferred package manager:

    -   [npm](#tab-panel-3147)
    -   [pnpm](#tab-panel-3148)
    -   [Yarn](#tab-panel-3149)

    Terminal window

    ```
    npmrunbuild
    ```

    Terminal window

    ```
    pnpmrunbuild
    ```

    Terminal window

    ```
    yarnrunbuild
    ```

3.  Run `deployctl` to deploy!

    -   [Static](#tab-panel-3131)
    -   [On demand](#tab-panel-3132)

    Terminal window

    ```
    cddist && deployctldeployjsr:@std/http/file-server
    ```

    Terminal window

    ```
    deployctldeploy./dist/server/entry.mjs
    ```

    You can track all your deploys on [Deno Deploy](https://dash.deno.com).

4.  (Optional) To simplify the build and deploy into one command, add a `deploy-deno` script in `package.json`.

    -   [Static](#tab-panel-3133)
    -   [On demand](#tab-panel-3134)

    package.json

    ```
    {// ..."scripts": {"dev": "astro dev","start": "astro dev","build": "astro build","preview": "astro preview","deno-deploy": "npm run build && cd dist && deployctl deploy jsr:@std/http/file-server"}}
    ```

    package.json

    ```
    {// ..."scripts": {"dev": "astro dev","start": "astro dev","build": "astro build","preview": "deno run --allow-net --allow-read --allow-env ./dist/server/entry.mjs","deno-deploy": "npm run build && deployctl deploy ./dist/server/entry.mjs"}}
    ```

    Then you can use this command to build and deploy your Astro site in one step.

    Terminal window

    ```
    npmrundeno-deploy
    ```



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 70. `en/guides/deploy/fleek/.md`

```text
# Deploy your Astro Site to Fleek


---
url: https://docs.astro.build/en/guides/deploy/fleek/
description: How to deploy your Astro site to the web on Fleek.
---


# Deploy your Astro Site to Fleek


You can use [Fleek](http://fleek.xyz/) to deploy a static Astro site to their edge-optimized decentralized network.

This guide gives a complete walkthrough of deploying your Astro site to Fleek using the Fleek UI and CLI.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

Your Astro project can be deployed to Fleek as a static site.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy to Fleek through the website UI or using Fleek’s CLI (command line interface).


### Platform UI Deployment


[Section titled Platform UI Deployment](#platform-ui-deployment)

1.  Create a [Fleek](https://app.fleek.xyz) account.

2.  Push your code to your online Git repository (GitHub).

3.  Import your project into Fleek.

4.  Fleek will automatically detect Astro and then you can configure the correct settings.

5.  Your application is deployed!



### Fleek CLI


[Section titled Fleek CLI](#fleek-cli)

1.  Install the Fleek CLI.

    Terminal window

    ```
    # You need to have Nodejs >= 18.18.2npminstall-g@fleek-platform/cli
    ```

2.  Log in to your Fleek account from your terminal.

    Terminal window

    ```
    fleeklogin
    ```

3.  Run the build command to generate the static files. By default, these will be located in the `dist/` directory.

    Terminal window

    ```
    npmrunbuild
    ```

4.  Initialize your project. This will generate a configuration file.

    Terminal window

    ```
    fleeksitesinit
    ```

5.  You will be prompted to either create a new Fleek Site or use an existing one. Give the site a name and select the directory where your project is located.

6.  Deploy your site.

    Terminal window

    ```
    fleeksitesdeploy
    ```



## Learn more


[Section titled Learn more](#learn-more)

[Deploy site from Fleek UI](https://fleek.xyz/docs/platform/deployments/)

[Deploy site from Fleek CLI](https://fleek.xyz/docs/cli/hosting/)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 71. `en/guides/deploy/flightcontrol/.md`

```text
# Deploy your Astro Site to AWS with Flightcontrol


---
url: https://docs.astro.build/en/guides/deploy/flightcontrol/
description: How to deploy your Astro site to AWS with Flightcontrol
---


# Deploy your Astro Site to AWS with Flightcontrol


You can deploy an Astro site using [Flightcontrol](https://www.flightcontrol.dev?ref=astro), which provides fully-automated deployments to your AWS account.

Supports both static and SSR Astro sites.


## How to Deploy


[Section titled How to Deploy](#how-to-deploy)

1.  Create a Flightcontrol account at [app.flightcontrol.dev/signup](https://app.flightcontrol.dev/signup?ref=astro)

2.  Go to [app.flightcontrol.dev/projects/new/1](https://app.flightcontrol.dev/projects/new/1)

3.  Connect your GitHub account and select your repo

4.  Select your desired “Config Type”:

    -   `GUI` (all config managed through Flightcontrol dashboard) where you will select the `Astro Static` or `Astro SSR` preset
    -   `flightcontrol.json` (“infrastructure as code” option where all config is in your repo) where you will select an Astro example config, then add it to your codebase as `flightcontrol.json`
5.  Adjust any configuration as needed

6.  Click “Create Project” and complete any required steps (like linking your AWS account).



### SSR Setup


[Section titled SSR Setup](#ssr-setup)

To deploy with SSR support, make sure you first set up the [`@astrojs/node`](/en/guides/integrations-guide/node/) adapter. Then, follow the steps above, choosing the appropriate configurations for Astro SSR.


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 72. `en/guides/deploy/flyio/.md`

```text
# Deploy your Astro Site to Fly.io


---
url: https://docs.astro.build/en/guides/deploy/flyio/
description: How to deploy your Astro site to the web using Fly.io.
---


# Deploy your Astro Site to Fly.io


You can deploy your Astro project to [Fly.io](https://fly.io/), a platform for running full stack apps and databases close to your users.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

Your Astro project can be deployed to Fly.io as a static site, or as a server-side rendered site (SSR).


### Static Site


[Section titled Static Site](#static-site)

Your Astro project is a static site by default. You don’t need any extra configuration to deploy a static Astro site to Fly.io.


### Adapter for SSR


[Section titled Adapter for SSR](#adapter-for-ssr)

To enable on-demand rendering in your Astro project and deploy on Fly.io, add [the Node.js adapter](/en/guides/integrations-guide/node/).


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  [Sign up for Fly.io](https://fly.io/docs/getting-started/log-in-to-fly/#first-time-or-no-fly-account-sign-up-for-fly) if you haven’t already.

2.  [Install `flyctl`](https://fly.io/docs/hands-on/install-flyctl/), your Fly.io app command center.

3.  Run the following command in your terminal.

    Terminal window

    ```
    flylaunch
    ```

    `flyctl` will automatically detect Astro, configure the correct settings, build your image, and deploy it to the Fly.io platform.



## Generating your Astro Dockerfile


[Section titled Generating your Astro Dockerfile](#generating-your-astro-dockerfile)

If you don’t already have a Dockerfile, `fly launch` will generate one for you, as well as prepare a `fly.toml` file. For pages rendered on demand, this Dockerfile will include the appropriate start command and environment variables.

You can instead create your own Dockerfile using [Dockerfile generator](https://www.npmjs.com/package/@flydotio/dockerfile) and then run using the command `npx dockerfile` for Node applications or `bunx dockerfile` for Bun applications.


## Official Resources


[Section titled Official Resources](#official-resources)

-   Check out [the official Fly.io docs](https://fly.io/docs/js/frameworks/astro/)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 73. `en/guides/deploy/github/.md`

```text
# Deploy your Astro Site to GitHub Pages


---
url: https://docs.astro.build/en/guides/deploy/github/
description: How to deploy your Astro site to the web using GitHub Pages.
---


# Deploy your Astro Site to GitHub Pages


You can use [GitHub Pages](https://pages.github.com/) to host an Astro website directly from a repository on [GitHub.com](https://github.com/).


## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy an Astro site to GitHub Pages by using [GitHub Actions](https://github.com/features/actions) to automatically build and deploy your site. To do this, your source code must be hosted on GitHub.

Astro maintains the official `withastro/action` to deploy your project with very little configuration. Follow the instructions below to deploy your Astro site to GitHub pages, and see [the package README](https://github.com/withastro/action) if you need more information.


## Configure Astro for GitHub Pages


[Section titled Configure Astro for GitHub Pages](#configure-astro-for-github-pages)


### Deploying to a `github.io` URL


[Section titled Deploying to a github.io URL](#deploying-to-a-githubio-url)

Set the [`site`](/en/reference/configuration-reference/#site) and [`base`](/en/reference/configuration-reference/#base) options in `astro.config.mjs`.

astro.config.mjs

```
import { defineConfig } from'astro/config'exportdefaultdefineConfig({site: 'https://astronaut.github.io',base: 'my-repo',})
```


#### `site`


[Section titled site](#site)

The value for `site` must be one of the following:

-   The following URL based on your username: `https://<username>.github.io`
-   The random URL autogenerated for a [GitHub Organization’s private page](https://docs.github.com/en/enterprise-cloud@latest/pages/getting-started-with-github-pages/changing-the-visibility-of-your-github-pages-site): `https://<random-string>.pages.github.io/`


#### `base`


[Section titled base](#base)

A value for `base` may be required so that Astro will treat your repository name (e.g. `/my-repo`) as the root of your website.

Note

Don’t set a `base` parameter if:

-   Your page is served from the root folder.
-   Your repository is located at `https://github.com/<USERNAME>/<USERNAME>.github.io`.

The value for `base` should be your repository’s name starting with a forward slash, for example `/my-blog`. This is so that Astro understands your website’s root is `/my-repo`, rather than the default `/`.

Caution

When this value is configured, all of your internal page links must be prefixed with your `base` value:

```
<ahref="/my-repo/about">About</a>
```

See more about [configuring a `base` value](/en/reference/configuration-reference/#base)


### Using GitHub pages with a custom domain


[Section titled Using GitHub pages with a custom domain](#using-github-pages-with-a-custom-domain)

Set up a custom domain

You can set up a custom domain by adding the following `./public/CNAME` file to your project:

public/CNAME

```
sub.mydomain.com
```

This will deploy your site at your custom domain instead of `user.github.io`. Don’t forget to also [configure DNS for your domain provider](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain).

To configure Astro for using GitHub pages with a custom domain, set your domain as the value for `site`. Do not set a value for `base`:

astro.config.mjs

```
import { defineConfig } from'astro/config'exportdefaultdefineConfig({site: 'https://example.com',})
```


## Configure a GitHub Action


[Section titled Configure a GitHub Action](#configure-a-github-action)

1.  Create a new file in your project at `.github/workflows/deploy.yml` and paste in the YAML below.

    deploy.yml

    ```
    name: Deploy to GitHub Pageson:# Trigger the workflow every time you push to the `main` branch# Using a different branch name? Replace `main` with your branch’s namepush:branches: [ main ]# Allows you to run this workflow manually from the Actions tab on GitHub.workflow_dispatch:# Allow this job to clone the repo and create a page deploymentpermissions:contents: readpages: writeid-token: writejobs:build:runs-on: ubuntu-lateststeps:- name: Checkout your repository using gituses: actions/checkout@v4- name: Install, build, and upload your siteuses: withastro/action@v3# with:# path: . # The root location of your Astro project inside the repository. (optional)# node-version: 20 # The specific version of Node that should be used to build your site. Defaults to 20. (optional)# package-manager: pnpm@latest # The Node package manager that should be used to install dependencies and build your site. Automatically detected based on your lockfile. (optional)deploy:needs: buildruns-on: ubuntu-latestenvironment:name: github-pagesurl: ${{ steps.deployment.outputs.page_url }}steps:- name: Deploy to GitHub Pagesid: deploymentuses: actions/deploy-pages@v4
    ```

    Note

    The astro action takes a few optional inputs. These can be provided by uncommenting the `with:` line and the input you want to use.

    Caution

    The official Astro [action](https://github.com/withastro/action) scans for a lockfile to detect your preferred package manager (`npm`, `yarn`, `pnpm`, or `bun`). You should commit your package manager’s automatically generated `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, or `bun.lockb` file to your repository.

2.  (Optional) If you pass environment variables to your Astro project during local development or when previewing builds, you will need to define any public variables in the `deploy.yml` file in order for them to be processed when you deploy to GitHub Pages. (See the [GitHub documentation on setting secrets](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#creating-configuration-variables-for-a-repository) for adding private environment variables.)

    deploy.yml

    ```
    jobs:build:runs-on: ubuntu-lateststeps:- name: Checkout your repository using gituses: actions/checkout@v4- name: Install, build, and upload your siteuses: withastro/action@v3env:# Use single quotation marks for the variable valuePUBLIC_EVM_WALLET_ADDRESS: '0x4bFc229A40d41698154336aFF864f61083E76659'
    ```

3.  On GitHub, go to your repository’s **Settings** tab and find the **Pages** section of the settings.

4.  Choose **GitHub Actions** as the **Source** of your site.

5.  Commit the new workflow file and push it to GitHub.


Your site should now be published! When you push changes to your Astro project’s repository, the GitHub Action will automatically deploy them for you.


## Examples


[Section titled Examples](#examples)

-   [Github Pages Deployment](https://github.com/hkbertoson/github-pages)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 74. `en/guides/deploy/gitlab/.md`

```text
# Deploy your Astro Site to GitLab Pages


---
url: https://docs.astro.build/en/guides/deploy/gitlab/
description: How to deploy your Astro site to the web using GitLab Pages.
---


# Deploy your Astro Site to GitLab Pages


You can use [GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/) to host an Astro site for your [GitLab](https://about.gitlab.com/) projects, groups, or user account.

Looking for an example?

Check out [the official GitLab Pages Astro example project](https://gitlab.com/pages/astro)!


## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy an Astro site to GitLab Pages by using GitLab CI/CD to automatically build and deploy your site. To do this, your source code must be hosted on GitLab and you need to make the following changes to your Astro project:

1.  Set up [`site`](/en/reference/configuration-reference/#site) and [`base`](/en/reference/configuration-reference/#base) options in `astro.config.mjs`.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';exportdefaultdefineConfig({site: 'https://<username>.gitlab.io',base: '/<my-repo>',outDir: 'public',publicDir: 'static',});
    ```

    `site`

    The value for `site` must be one of the following:

    -   The following URL based on your username: `https://<username>.gitlab.io`
    -   The following URL based on your group name: `https://<groupname>.gitlab.io`
    -   Your custom domain if you have it configured in your GitLab project’s settings: `https://example.com`

    For GitLab self-managed instances, replace `gitlab.io` with your instance’s Pages domain.

    `base`

    A value for `base` may be required so that Astro will treat your repository name (e.g. `/my-repo`) as the root of your website.

    Note

    Don’t set a `base` parameter if your page is served from the root folder.

    The value for `base` should be your repository’s name starting with a forward slash, for example `/my-blog`. This is so that Astro understands your website’s root is `/my-repo`, rather than the default `/`.

    Caution

    When this value is configured, all of your internal page links must be prefixed with your `base` value:

    ```
    <ahref="/my-repo/about">About</a>
    ```

    See more about [configuring a `base` value](/en/reference/configuration-reference/#base)

2.  Rename the `public/` directory to `static/`.

3.  Set `outDir: 'public'` in `astro.config.mjs`. This setting instructs Astro to put the static build output in a folder called `public`, which is the folder required by GitLab Pages for exposed files.

    If you were using the [`public/` directory](/en/basics/project-structure/#public) as a source of static files in your Astro project, rename it and use that new folder name in `astro.config.mjs` for the value of `publicDir`.

    For example, here are the correct `astro.config.mjs` settings when the `public/` directory is renamed to `static/`:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';exportdefaultdefineConfig({outDir: 'public',publicDir: 'static',});
    ```

4.  Change the build output in `.gitignore`. In our example we need to change `dist/` to `public/`:

    .gitignore

    ```
    # build outputdist/public/
    ```

5.  Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:

    .gitlab-ci.yml

    ```
    pages:# The Docker image that will be used to build your appimage: node:ltsbefore_script:- npm ciscript:# Specify the steps involved to build your app here- npm run buildartifacts:paths:# The folder that contains the built files to be published.# This must be called "public".- publiconly:# Trigger a new build and deploy only when there is a push to the# branch(es) below- main
    ```

6.  Commit your changes and push them to GitLab.

7.  On GitLab, go to your repository’s **Deploy** menu and select **Pages**. Here you will see the full URL of your GitLab Pages website. To make sure you are using the URL format `https://username.gitlab.io/my-repo`, uncheck the **Use unique domain** setting on this page.


Your site should now be published! When you push changes to your Astro project’s repository, the GitLab CI/CD pipeline will automatically deploy them for you.


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 75. `en/guides/deploy/google-cloud/.md`

```text
# Deploy your Astro Site to Google Cloud


---
url: https://docs.astro.build/en/guides/deploy/google-cloud/
description: How to deploy your Astro site to the web using Google Cloud.
---


# Deploy your Astro Site to Google Cloud


[Google Cloud](https://cloud.google.com/) is a full-featured web app hosting platform that can be used to deploy an Astro site.


## How to deploy


[Section titled How to deploy](#how-to-deploy)


### Cloud Storage (static only)


[Section titled Cloud Storage (static only)](#cloud-storage-static-only)

1.  [Create a new GCP project](https://console.cloud.google.com/projectcreate), or select one you already have.

2.  Create a new bucket under [Cloud Storage](https://cloud.google.com/storage).

3.  Give it a name and the other required settings.

4.  Upload your `dist` folder into it or upload using [Cloud Build](https://cloud.google.com/build).

5.  Enable public access by adding a new permission to `allUsers` called `Storage Object Viewer`.

6.  Edit the website configuration and add `ìndex.html` as the entrypoint and `404.html` as the error page.



### Cloud Run (SSR and static)


[Section titled Cloud Run (SSR and static)](#cloud-run-ssr-and-static)

Cloud Run is a serverless platform that allows you to run a container without having to manage any infrastructure. It can be used to deploy both static and SSR sites.


#### Prepare the Service


[Section titled Prepare the Service](#prepare-the-service)

1.  [Create a new GCP project](https://console.cloud.google.com/projectcreate), or select one you already have.

2.  Make sure the [Cloud Run API](https://console.cloud.google.com/apis/library/run.googleapis.com) is enabled.

3.  Create a new service.



#### Create Dockerfile & Build the Container


[Section titled Create Dockerfile &amp; Build the Container](#create-dockerfile--build-the-container)

Before you can deploy your Astro site to Cloud Run, you need to create a Dockerfile that will be used to build the container. Find more information about [how to use Docker with Astro](/en/recipes/docker/#creating-a-dockerfile) in our recipe section.

Once the Dockerfile is created, build it into an image and push it to Google Cloud. There are a few ways to accomplish this:

**Build locally using Docker**:

Use the `docker build` command to build the image, `docker tag` to give it a tag, then `docker push` to push it to a registry. In the case of Google Cloud, [`Artifact Registry`](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling) is the easiest option, but you can also use [Docker Hub](https://hub.docker.com/).

Terminal window

```

# build your containerdockerbuild.dockertagSOURCE_IMAGEHOSTNAME/PROJECT-ID/TARGET-IMAGE:TAG# Push your image to a registrydockerpushHOSTNAME/PROJECT-ID/IMAGE:TAG

```

Change the following values in the commands above to match your project:

-   `SOURCE_IMAGE`: the local image name or image ID.
-   `HOSTNAME`: the registry host (`gcr.io`, `eu.gcr.io`, `asia.gcr.io`, `us.gcr.io`, `docker.io`).
-   `PROJECT`: your Google Cloud project ID.
-   `TARGET-IMAGE`: the name for the image when it’s stored in the registry.
-   `TAG` is the version associated with the image.

[Read more in the Google Cloud docs.](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling)

**Using another tool**:

You can use a CI/CD tool that supports Docker, like [GitHub Actions](https://github.com/marketplace/actions/push-to-gcr-github-action).

**Build using [Cloud Build](https://cloud.google.com/build)**:

Instead of building the Dockerfile locally, you can instruct Google Cloud to build the image remotely. See the [Google Cloud Build documentation here](https://cloud.google.com/build/docs/build-push-docker-image).


#### Deploying the container


[Section titled Deploying the container](#deploying-the-container)

Deployment can be handled manually in your terminal [using `gcloud`](https://cloud.google.com/run/docs/deploying#service) or automatically using [Cloud Build](https://cloud.google.com/build) or any other CI/CD system.

Need public access?

Don’t forget to add the permission `Cloud Run Invoker` to the `allUsers` group in the Cloud Run permissions settings!


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 76. `en/guides/deploy/google-firebase/.md`

```text
# Deploy your Astro Site to Google’s Firebase Hosting


---
url: https://docs.astro.build/en/guides/deploy/google-firebase/
description: How to deploy your Astro site to the web using Google’s Firebase Hosting.
---


# Deploy your Astro Site to Google’s Firebase Hosting


[Firebase Hosting](https://firebase.google.com/products/hosting) is a service provided by Google’s [Firebase](https://firebase.google.com/) app development platform, which can be used to deploy an Astro site.

See our separate guide for [adding Firebase backend services](/en/guides/backend/google-firebase/) such as databases, authentication, and storage.


## Project Configuration


[Section titled Project Configuration](#project-configuration)

Your Astro project can be deployed to Firebase as a static site, or as a server-side rendered site (SSR).


### Static Site


[Section titled Static Site](#static-site)

Your Astro project is a static site by default. You don’t need any extra configuration to deploy a static Astro site to Firebase.


### Adapter for SSR


[Section titled Adapter for SSR](#adapter-for-ssr)

To enable SSR in your Astro project and deploy on Firebase add the [Node.js adapter](/en/guides/integrations-guide/node/).

Note

Deploying an SSR Astro site to Firebase requires the [Blaze plan](https://firebase.google.com/pricing) or higher.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  Install the [Firebase CLI](https://github.com/firebase/firebase-tools). This is a command-line tool that allows you to interact with Firebase from the terminal.

    -   [npm](#tab-panel-3150)
    -   [pnpm](#tab-panel-3151)
    -   [Yarn](#tab-panel-3152)

    Terminal window

    ```
    npminstallfirebase-tools
    ```

    Terminal window

    ```
    pnpmaddfirebase-tools
    ```

    Terminal window

    ```
    yarnaddfirebase-tools
    ```

2.  Authenticate the Firebase CLI with your Google account. This will open a browser window where you can log in to your Google account.

    -   [npm](#tab-panel-3153)
    -   [pnpm](#tab-panel-3154)
    -   [Yarn](#tab-panel-3155)

    Terminal window

    ```
    npxfirebaselogin
    ```

    Terminal window

    ```
    pnpmexecfirebaselogin
    ```

    Terminal window

    ```
    yarnfirebaselogin
    ```

3.  Enable experimental web frameworks support. This is an experimental feature that allows the Firebase CLI to detect and configure your deployment settings for Astro.

    -   [npm](#tab-panel-3156)
    -   [pnpm](#tab-panel-3157)
    -   [Yarn](#tab-panel-3158)

    Terminal window

    ```
    npxfirebaseexperiments:enablewebframeworks
    ```

    Terminal window

    ```
    pnpmexecfirebaseexperiments:enablewebframeworks
    ```

    Terminal window

    ```
    yarnfirebaseexperiments:enablewebframeworks
    ```

4.  Initialize Firebase Hosting in your project. This will create a `firebase.json` and `.firebaserc` file in your project root.

    -   [npm](#tab-panel-3159)
    -   [pnpm](#tab-panel-3160)
    -   [Yarn](#tab-panel-3161)

    Terminal window

    ```
    npxfirebaseinithosting
    ```

    Terminal window

    ```
    pnpmexecfirebaseinithosting
    ```

    Terminal window

    ```
    yarnfirebaseinithosting
    ```

5.  Deploy your site to Firebase Hosting. This will build your Astro site and deploy it to Firebase.

    -   [npm](#tab-panel-3162)
    -   [pnpm](#tab-panel-3163)
    -   [Yarn](#tab-panel-3164)

    Terminal window

    ```
    npxfirebasedeploy--onlyhosting
    ```

    Terminal window

    ```
    pnpmexecfirebasedeploy--onlyhosting
    ```

    Terminal window

    ```
    yarnfirebasedeploy--onlyhosting
    ```



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 77. `en/guides/deploy/heroku/.md`

```text
# Deploy your Astro Site to Heroku


---
url: https://docs.astro.build/en/guides/deploy/heroku/
description: How to deploy your Astro site to the web using Heroku.
---


# Deploy your Astro Site to Heroku


[Heroku](https://www.heroku.com/) is a platform-as-a-service for building, running, and managing modern apps in the cloud. You can deploy an Astro site to Heroku using this guide.

Danger

The following instructions use [the deprecated `heroku-static-buildpack`](https://github.com/heroku/heroku-buildpack-static#warning-heroku-buildpack-static-is-deprecated). Please see [Heroku’s documentation for using `heroku-buildpack-nginx`](https://github.com/dokku/heroku-buildpack-nginx) instead.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  Install the [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli).

2.  Create a Heroku account by [signing up](https://signup.heroku.com/).

3.  Run `heroku login` and fill in your Heroku credentials:

    Terminal window

    ```
    $herokulogin
    ```

4.  Create a file called `static.json` in the root of your project with the below content:

    static.json

    ```
    {"root": "./dist"}
    ```

    This is the configuration of your site; read more at [heroku-buildpack-static](https://github.com/heroku/heroku-buildpack-static).

5.  Set up your Heroku git remote:

    Terminal window

    ```
    # version change$gitinit$gitadd.$gitcommit-m"My site ready for deployment."# creates a new app with a specified name$herokuapps:createexample# set buildpack for static sites$herokubuildpacks:sethttps://github.com/heroku/heroku-buildpack-static.git
    ```

6.  Deploy your site:

    Terminal window

    ```
    # publish site$gitpushherokumaster# opens a browser to view the Dashboard version of Heroku CI$herokuopen
    ```



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 78. `en/guides/deploy/kinsta/.md`

```text
# Deploy your Astro Site to Kinsta Application Hosting


---
url: https://docs.astro.build/en/guides/deploy/kinsta/
description: How to deploy your Astro site to the web on Kinsta Application Hosting.
---


# Deploy your Astro Site to Kinsta Application Hosting


You can use [Kinsta Application Hosting](https://kinsta.com/application-hosting/) to host an Astro site on their cloud hosting.


## Configuring your Astro project


[Section titled Configuring your Astro project](#configuring-your-astro-project)


### Static hosting


[Section titled Static hosting](#static-hosting)

Looking for an example?

Check out [the official Kinsta Application Hosting Starter project for Astro](https://github.com/kinsta/hello-world-astro)!

To host your project on **Kinsta Application Hosting**, you need to:

-   Include a `name` field in your `package.json`. (This can be anything, and will not affect your deployment.)
-   Include a `build` script in your `package.json`. (Your Astro project should already include this.)
-   Install the [`serve`](https://www.npmjs.com/package/serve) package and set the `start` script to `serve dist/`.

Here are the necessary lines in your `package.json` file:

package.json

```
{"name": "anything", // This is required, but the value does not matter."scripts": {"dev": "astro dev","start": "serve dist/","build": "astro build","preview": "astro preview","astro": "astro"},"dependencies": {"astro": "^2.2.0","serve": "^14.0.1"},}
```


### SSR


[Section titled SSR](#ssr)

Looking for an example?

Check out [the official Kinsta Application Hosting Starter project for Astro SSR](https://github.com/kinsta/hello-world-astro-ssr)!

To host your project on **Kinsta Application Hosting**, you need to:

-   Include a `name` field in your `package.json`. (This can be anything, and will not affect your deployment.)
-   Include a `build` script in your `package.json`. (Your Astro project should already include this.)
-   Install the [`@astrojs/node`](https://www.npmjs.com/package/@astrojs/node) package and set the `start` script to `node ./dist/server/entry.mjs`.
-   Set the `astro.config.mjs` to use `@astrojs/node` and to use `host: true`.

Here are the necessary lines in your `package.json` file:

package.json

```
{"name": "anything", // This is required, but the value does not matter."scripts": {"dev": "astro dev","start": "node ./dist/server/entry.mjs","build": "astro build","preview": "astro preview","astro": "astro"},"dependencies": {"astro": "^2.2.0","@astrojs/node": "^5.1.1"},}
```

Here are the necessary lines in your `astro.config.mjs` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';import node from"@astrojs/node";exportdefaultdefineConfig({output: 'server',adapter: node({mode: "standalone"}),server: {host: true}});
```


## How to deploy


[Section titled How to deploy](#how-to-deploy)

Once your project’s GitHub repository is connected, you can trigger manual deploys to Kinsta Application Hosting in the **MyKinsta Admin Panel**. You can also set up automatic deployments in your admin panel.


### Configuring a new Kinsta application


[Section titled Configuring a new Kinsta application](#configuring-a-new-kinsta-application)

1.  Go to the [My Kinsta](https://my.kinsta.com/) admin panel.

2.  Go to the **Applications** tab.

3.  Connect your GitHub repository.

4.  Press the **Add service** > **Application** button.

5.  Follow the wizard steps.

6.  Your application is deployed.



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 79. `en/guides/deploy/microsoft-azure/.md`

```text
# Deploy your Astro Site to Microsoft Azure


---
url: https://docs.astro.build/en/guides/deploy/microsoft-azure/
description: How to deploy your Astro site to the web using Microsoft Azure.
---


# Deploy your Astro Site to Microsoft Azure


[Azure](https://azure.microsoft.com/) is a cloud platform from Microsoft. You can deploy your Astro site with Microsoft Azure’s [Static Web Apps](https://aka.ms/staticwebapps) service.

This guide takes you through deploying your Astro site stored in GitHub using Visual Studio Code. Please see Microsoft guides for using an [Azure Pipelines Task](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/azure-static-web-app-v0?view=azure-pipelines) for other setups.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

To follow this guide, you will need:

-   An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).
-   Your app code pushed to [GitHub](https://github.com/).
-   The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com/).


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  Open your project in VS Code.

2.  Open the Static Web Apps extension, sign in to Azure, and click the **+** button to create a new Static Web App. You will be prompted to designate which subscription key to use.

3.  Follow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location (use `/dist`). Astro is not listed in the built-in templates in Azure so you will need to select `custom`. The wizard will run and will create a [GitHub Action](https://github.com/features/actions) in the `.github` folder of your repo. (This folder will be automatically created if it does not already exist.)


The GitHub Action will deploy your app (you can see its progress in your repo’s Actions tab on GitHub). When successfully completed, you can view your app at the address shown in the SWA Extension’s progress window by clicking the **Browse Website** button (this will appear after the GitHub Action has run).


## Known Issues


[Section titled Known Issues](#known-issues)

The GitHub action yaml that is created for you assumes the use of node 14. This means the Astro build fails. To resolve this update your projects package.json file with this snippet.

```
"engines": {"node": ">=18.0.0"},
```


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Microsoft Azure Static Web Apps documentation](https://learn.microsoft.com/en-us/azure/static-web-apps/)


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Deploying an Astro Website to Azure Static Web Apps](https://www.blueboxes.co.uk/deploying-an-astro-website-to-azure-static-web-apps)
-   [Deploying a Static Astro Site to Azure Static Web Apps using GitHub Actions](https://agramont.net/blog/create-static-site-astro-azure-ssg/#automate-deployment-with-github-actions)
-   [Astro site deployment to Azure Static Web Apps with the CLI from GitHub Actions](https://www.eliostruyf.com/deploy-astro-azure-static-web-apps-github-cli/)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 80. `en/guides/deploy/netlify/.md`

```text
# Deploy your Astro Site to Netlify


---
url: https://docs.astro.build/en/guides/deploy/netlify/
description: How to deploy your Astro site to the web on Netlify.
---


# Deploy your Astro Site to Netlify


[Netlify](https://netlify.com) offers hosting and serverless backend services for web applications and static websites. Any Astro site can be hosted on Netlify!

This guide includes instructions for deploying to Netlify through the website UI or Netlify’s CLI.


## Project configuration


[Section titled Project configuration](#project-configuration)

Your Astro project can be deployed to Netlify in three different ways: as a static site, a server-rendered site, or an edge-rendered site.


### Static site


[Section titled Static site](#static-site)

Your Astro project is a static site by default. You don’t need any extra configuration to deploy a static Astro site to Netlify.


### Adapter for on-demand rendering


[Section titled Adapter for on-demand rendering](#adapter-for-on-demand-rendering)

Add [the Netlify adapter](/en/guides/integrations-guide/netlify/) to enable on-demand rendering in your Astro project and deploy to Netlify with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

Terminal window

```
npxastroaddnetlify
```

See the [Netlify adapter guide](/en/guides/integrations-guide/netlify/) to install manually instead, or for more configuration options, such as deploying your project’s Astro middleware using Netlify’s Edge Functions.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy to Netlify through the website UI or using Netlify’s CLI (command line interface). The process is the same for both static and on-demand rendered Astro sites.


### Website UI deployment


[Section titled Website UI deployment](#website-ui-deployment)

If your project is stored in GitHub, GitLab, BitBucket, or Azure DevOps, you can use the Netlify website UI to deploy your Astro site.

1.  Click Add a new site in your [Netlify dashboard](https://app.netlify.com/)

2.  Choose Import an existing project

    When you import your Astro repository from your Git provider, Netlify should automatically detect and pre-fill the correct configuration settings for you.

3.  Make sure that the following settings are entered, then press the Deploy button:

    -   **Build Command:** `astro build` or `npm run build`
    -   **Publish directory:** `dist`

    After deploying, you will be redirected to the site overview page. There, you can edit the details of your site.


Any future changes to your source repository will trigger preview and production deploys based on your deployment configuration.


#### `netlify.toml` file


[Section titled netlify.toml file](#netlifytoml-file)

You can optionally create a new `netlify.toml` file at the top level of your project repository to configure your build command and publish directory, as well as other project settings including environment variables and redirects. Netlify will read this file and automatically configure your deployment.

To configure the default settings, create a `netlify.toml` file with the following contents:

```
[build]command = "npm run build"publish = "dist"
```

More info at [“Deploying an existing Astro Git repository”](https://www.netlify.com/blog/how-to-deploy-astro/#deploy-an-existing-git-repository-to-netlify) on Netlify’s blog


### CLI deployment


[Section titled CLI deployment](#cli-deployment)

You can also create a new site on Netlify and link up your Git repository by installing and using the [Netlify CLI](https://cli.netlify.com/).

1.  Install Netlify’s CLI globally

    Terminal window

    ```
    npminstall--globalnetlify-cli
    ```

2.  Run `netlify login` and follow the instructions to log in and authorize Netlify

3.  Run `netlify init` and follow the instructions

4.  Confirm your build command (`astro build`)

    The CLI will automatically detect the build settings (`astro build`) and deploy directory (`dist`), and will offer to automatically generate [a `netlify.toml` file](#netlifytoml-file) with those settings.

5.  Build and deploy by pushing to Git

    The CLI will add a deploy key to the repository, which means your site will be automatically rebuilt on Netlify every time you `git push`.


More details from Netlify on [Deploy an Astro site using the Netlify CLI](https://www.netlify.com/blog/how-to-deploy-astro/#link-your-astro-project-and-deploy-using-the-netlify-cli)


### Set a Node.js version


[Section titled Set a Node.js version](#set-a-nodejs-version)

If you are using a legacy [build image](https://docs.netlify.com/configure-builds/get-started/#build-image-selection) (Xenial) on Netlify, make sure that your Node.js version is set. Astro requires `v18.20.8` or `v20.3.0` or higher.

You can [specify your Node.js version in Netlify](https://docs.netlify.com/configure-builds/manage-dependencies/#node-js-and-javascript) using:

-   a [`.nvmrc`](https://github.com/nvm-sh/nvm#nvmrc) file in your base directory.
-   a `NODE_VERSION` environment variable in your site’s settings using the Netlify project dashboard.


## Using Netlify Functions


[Section titled Using Netlify Functions](#using-netlify-functions)

No special configuration is required to use Netlify Functions with Astro. Add a `netlify/functions` directory to your project root and follow [the Netlify Functions documentation](https://docs.netlify.com/functions/overview/) to get started!


## Examples


[Section titled Examples](#examples)

-   [Deploy An Astro site with Forms, Serverless Functions, and Redirects](https://www.netlify.com/blog/deploy-an-astro-site-with-forms-serverless-functions-and-redirects/) — Netlify Blog
-   [Deployment Walkthrough Video](https://youtu.be/GrSLYq6ZTes) — Netlify YouTube channel


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 81. `en/guides/deploy/render/.md`

```text
# Deploy your Astro Site to Render


---
url: https://docs.astro.build/en/guides/deploy/render/
description: How to deploy your Astro site to the web using Render.
---


# Deploy your Astro Site to Render


You can deploy your Astro project to [Render](https://render.com/), a service to build websites with free TLS certificates, a global CDN, DDoS protection, private networks, and auto deploys from Git.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  Create a [render.com account](https://dashboard.render.com/) and sign in

2.  Click the **New +** button from your dashboard and select **Static Site**

3.  Connect your [GitHub](https://github.com/) or [GitLab](https://about.gitlab.com/) repository or alternatively enter the public URL of a public repository

4.  Give your website a name, select the branch and specify the build command and publish directory

    -   **Build Command:** `npm run build`
    -   **Publish Directory:** `dist`, for static sites; `dist/client` if you have any pages rendered on demand.
5.  Click the **Create Static Site** button



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 82. `en/guides/deploy/sst/.md`

```text
# Deploy your Astro Site to AWS with SST


---
url: https://docs.astro.build/en/guides/deploy/sst/
description: How to deploy your Astro site to AWS with SST
---


# Deploy your Astro Site to AWS with SST


You can deploy an Astro site to AWS using [SST](https://sst.dev), an open-source framework for deploying modern full-stack applications with SSG and SSR support.

You can also use any additional SST components like cron jobs, Buckets, Queues, etc while maintaining type-safety.


## Quickstart


[Section titled Quickstart](#quickstart)

1.  Create an astro project.

2.  Run `npx sst@latest init`.

3.  It should detect that you are using Astro and ask you to confirm.

4.  Once you’re ready for deployment you can run `npx sst deploy --stage production`.


You can also read [the full Astro on AWS with SST tutorial](https://sst.dev/docs/start/aws/astro) that will guide you through the steps.


### SST components


[Section titled SST components](#sst-components)

To use any [additional SST components](https://sst.dev/docs/), add them to `sst.config.ts`.

sst.config.ts

```
const bucket = newsst.aws.Bucket("MyBucket", {access: "public",});new sst.aws.Astro("MyWeb", {link: [bucket],});
```

And then access them in your `.astro` file.

```
---import { Resource } from"sst"console.log(Resource.MyBucket.name)---
```

Consult the [SST docs on linking resources](https://sst.dev/docs/linking) to learn more.

If you have any questions, you can [ask in the SST Discord](https://discord.gg/sst).


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 83. `en/guides/deploy/stormkit/.md`

```text
# Deploy your Astro Site to Stormkit


---
url: https://docs.astro.build/en/guides/deploy/stormkit/
description: Deploy your Astro site to Stormkit
---


# Deploy your Astro Site to Stormkit


You can deploy your Astro project to [Stormkit](https://stormkit.io/), a deployment platform for static websites, single-page applications (SPAs), and serverless functions.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  [Log in to Stormkit](https://app.stormkit.io/auth).

2.  Using the user interface, import your Astro project from one of the three supported Git providers (GitHub, GitLab, or Bitbucket).

3.  Navigate to the project’s production environment in Stormkit or create a new environment if needed.

4.  Verify the build command in your [Stormkit configuration](https://stormkit.io/docs/deployments/configuration). By default, Stormkit CI will run `npm run build` but you can specify a custom build command on this page.

5.  Click the “Deploy Now” button to deploy your site.


Read more in the [Stormkit Documentation](https://stormkit.io/docs).


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 84. `en/guides/deploy/surge/.md`

```text
# Deploy your Astro Site to Surge


---
url: https://docs.astro.build/en/guides/deploy/surge/
description: How to deploy your Astro site to the web using Surge
---


# Deploy your Astro Site to Surge


You can deploy your Astro project to [Surge](https://surge.sh/), a single-command web publishing platform designed for front-end developers.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

1.  Install [the Surge CLI](https://www.npmjs.com/package/surge) globally from the terminal, if you haven’t already.

    Terminal window

    ```
    npminstall-gsurge
    ```

2.  Build your Astro site from your project’s root directory.

    Terminal window

    ```
    npmrunbuild
    ```

3.  Deploy to Surge using the CLI.

    Terminal window

    ```
    surgedist
    ```

    You can [use a custom domain with Surge](http://surge.sh/help/adding-a-custom-domain) when deploying by running `surge dist yourdomain.com`.



## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 85. `en/guides/deploy/vercel/.md`

```text
# Deploy your Astro Site to Vercel


---
url: https://docs.astro.build/en/guides/deploy/vercel/
description: How to deploy your Astro site to the web on Vercel.
---


# Deploy your Astro Site to Vercel


You can use [Vercel](http://vercel.com/) to deploy an Astro site to their global edge network with zero configuration.

This guide includes instructions for deploying to Vercel through the website UI or Vercel’s CLI.


## Project configuration


[Section titled Project configuration](#project-configuration)

Your Astro project can be deployed to Vercel as a static site, or a server-rendered site.


### Static site


[Section titled Static site](#static-site)

Your Astro project is a static site by default. You don’t need any extra configuration to deploy a static Astro site to Vercel.


### Adapter for on-demand rendering


[Section titled Adapter for on-demand rendering](#adapter-for-on-demand-rendering)

Add [the Vercel adapter](/en/guides/integrations-guide/vercel/) to enable [on-demand rendering](/en/guides/on-demand-rendering/) in your Astro project with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

-   [npm](#tab-panel-3171)
-   [pnpm](#tab-panel-3172)
-   [Yarn](#tab-panel-3173)

Terminal window

```
npxastroaddvercel
```

Terminal window

```
pnpmastroaddvercel
```

Terminal window

```
yarnastroaddvercel
```

See the [Vercel adapter guide](/en/guides/integrations-guide/vercel/) to install manually instead, or for more configuration options, such as deploying your project’s Astro middleware using Vercel Edge Functions.


## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy to Vercel through the website UI or using Vercel’s CLI (command line interface). The process is the same for both static and on-demand rendered Astro sites.


### Website UI deployment


[Section titled Website UI deployment](#website-ui-deployment)

1.  Push your code to your online Git repository (GitHub, GitLab, BitBucket).

2.  [Import your project](https://vercel.com/new) into Vercel.

3.  Vercel will automatically detect Astro and configure the right settings.

4.  Your application is deployed! (e.g. [astro.vercel.app](https://astro.vercel.app/))


After your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/preview-deployments), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).

Learn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).


### CLI deployment


[Section titled CLI deployment](#cli-deployment)

1.  Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.

    -   [npm](#tab-panel-3174)
    -   [pnpm](#tab-panel-3175)
    -   [Yarn](#tab-panel-3176)

    Terminal window

    ```
    npminstall-gvercelvercel
    ```

    Terminal window

    ```
    pnpmadd-gvercelvercel
    ```

    Terminal window

    ```
    yarnglobaladdvercelvercel
    ```

2.  Vercel will automatically detect Astro and configure the right settings.

3.  When asked `Want to override the settings? [y/N]`, choose `N`.

4.  Your application is deployed! (e.g. [astro.vercel.app](https://astro.vercel.app/))



### Project config with `vercel.json`


[Section titled Project config with vercel.json](#project-config-with-verceljson)

You can use `vercel.json` to override the default behavior of Vercel and to configure additional settings. For example, you may wish to attach headers to HTTP responses from your Deployments.

Learn more about [Vercel’s project configuration](https://vercel.com/docs/project-configuration).


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 86. `en/guides/deploy/zeabur/.md`

```text
# Deploy your Astro Site to Zeabur


---
url: https://docs.astro.build/en/guides/deploy/zeabur/
description: How to deploy your Astro site to the web on Zeabur.
---


# Deploy your Astro Site to Zeabur


[Zeabur](https://zeabur.com) offers hosting for full-stack web applications. Astro sites can be hosted as both SSR or static output.

This guide includes instructions for deploying to Zeabur through the website UI.


## Project Configuration


[Section titled Project Configuration](#project-configuration)


### Static Site


[Section titled Static Site](#static-site)

Astro outputs a static site by default. There is no need for any extra configuration to deploy a static Astro site to Zeabur.


### Adapter for SSR


[Section titled Adapter for SSR](#adapter-for-ssr)

To enable SSR in your Astro project and deploy on Zeabur:

1.  Install [the `@zeabur/astro-adapter` adapter](https://www.npmjs.com/package/@zeabur/astro-adapter) to your project’s dependencies using your preferred package manager. If you’re using npm or aren’t sure, run this in the terminal:

    Terminal window

    ```
    npminstall@zeabur/astro-adapter
    ```

2.  Add two new lines to your `astro.config.mjs` project configuration file.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import zeabur from'@zeabur/astro-adapter/serverless';exportdefaultdefineConfig({output: 'server',adapter: zeabur(),});
    ```



## How to deploy


[Section titled How to deploy](#how-to-deploy)

You can deploy your Astro site to Zeabur if the project is stored in GitHub.

1.  Click Create new project in the [Zeabur dashboard](https://dash.zeabur.com).

2.  Configure GitHub installation and import the repository.

3.  Zeabur will automatically detect that your project is an Astro project and will build it using the `astro build` command.

4.  Once the build is complete, you can bind a domain to your site and visit it.


After your project has been imported and deployed, all subsequent pushes to branches will generate new builds.

Learn more about Zeabur’s [Deployment Guide](https://zeabur.com/docs/get-started/).


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 87. `en/guides/deploy/zerops/.md`

```text
# Deploy your Astro Site to Zerops


---
url: https://docs.astro.build/en/guides/deploy/zerops/
description: How to deploy your Astro site to the web using Zerops.
---


# Deploy your Astro Site to Zerops


[Zerops](https://zerops.io/) is a dev-first cloud platform that can be used to deploy both Static and SSR Astro site.

This guide will walk you through setting up and deploying both Static and SSR Astro sites on Zerops.

Astro x Zerops Quickrun

Want to test running Astro on Zerops without installing or setting up anything? Using repositories [Zerops x Astro - Static](https://github.com/zeropsio/recipe-astro-static) or [Zerops x Astro - SSR on Node.js](https://github.com/zeropsio/recipe-astro-nodejs) you can deploy example Astro site with a single click.

Running apps on Zerops requires two steps:

1.  Creating a project
2.  Triggering build & deploy pipeline

Note

One Zerops project can contain multiple Astro sites.


## Astro Static site on Zerops


[Section titled Astro Static site on Zerops](#astro-static-site-on-zerops)


### Creating a project and a service for Astro Static


[Section titled Creating a project and a service for Astro Static](#creating-a-project-and-a-service-for-astro-static)

Projects and services can be added either through a [`Project add`](https://app.zerops.io/dashboard/project-add) wizard or imported using a yaml structure:

```

# see https://docs.zerops.io/references/import for full referenceproject:name: recipe-astroservices:- hostname: apptype: static

```

This will create a project called `recipe-astro` with a Zerops Static service called `app`.


### Deploying your Astro Static site


[Section titled Deploying your Astro Static site](#deploying-your-astro-static-site)

To tell Zerops how to build and run your site, add a `zerops.yml` to your repository:

-   [npm](#tab-panel-3233)
-   [pnpm](#tab-panel-3234)
-   [Yarn](#tab-panel-3235)

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- npm i- npm builddeployFiles:- dist/~run:base: static

```

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- pnpm i- pnpm builddeployFiles:- dist/~run:base: static

```

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- yarn- yarn builddeployFiles:- dist/~run:base: static

```

Now you can [trigger the build & deploy pipeline using the Zerops CLI](#trigger-the-pipeline-using-zerops-cli-zcli) or by connecting the `app` service with your [GitHub](https://docs.zerops.io/references/github-integration/) / [GitLab](https://docs.zerops.io/references/gitlab-integration) repository from inside the service detail.


## Astro SSR site on Zerops


[Section titled Astro SSR site on Zerops](#astro-ssr-site-on-zerops)


### Update scripts


[Section titled Update scripts](#update-scripts)

Update your `start` script to run the server output from the Node adapter.

package.json

```
"scripts": {"start": "node ./dist/server/entry.mjs",}
```


### Creating a project and a service for Astro SSR (Node.js)


[Section titled Creating a project and a service for Astro SSR (Node.js)](#creating-a-project-and-a-service-for-astro-ssr-nodejs)

Projects and services can be added either through a [`Project add`](https://app.zerops.io/dashboard/project-add) wizard or imported using a yaml structure:

```

# see https://docs.zerops.io/references/import for full referenceproject:name: recipe-astroservices:- hostname: apptype: nodejs@20

```

This will create a project called `recipe-astro` with Zerops Node.js service called `app`.


### Deploying your Astro SSR site


[Section titled Deploying your Astro SSR site](#deploying-your-astro-ssr-site)

To tell Zerops how to build and run your site using the official [Astro Node.js adapter](/en/guides/integrations-guide/node/) in `standalone` mode, add a `zerops.yml` file to your repository:

-   [npm](#tab-panel-3236)
-   [pnpm](#tab-panel-3237)
-   [Yarn](#tab-panel-3238)

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- npm i- npm run builddeployFiles:- dist- package.json- node_modulesrun:base: nodejs@20ports:- port: 3000httpSupport: trueenvVariables:PORT: 3000HOST: 0.0.0.0start: npm start

```

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- pnpm i- pnpm run builddeployFiles:- dist- package.json- node_modulesrun:base: nodejs@20ports:- port: 3000httpSupport: trueenvVariables:PORT: 3000HOST: 0.0.0.0start: pnpm start

```

zerops.yml

```

# see https://docs.zerops.io/zerops-yml/specification for full referencezerops:- setup: appbuild:base: nodejs@20buildCommands:- yarn- yarn builddeployFiles:- dist- package.json- node_modulesrun:base: nodejs@20ports:- port: 3000httpSupport: trueenvVariables:PORT: 3000HOST: 0.0.0.0start: yarn start

```

Now you can [trigger the build & deploy pipeline using the Zerops CLI](#trigger-the-pipeline-using-zerops-cli-zcli) or by connecting the `app` service with your [GitHub](https://docs.zerops.io/references/github-integration/) / [GitLab](https://docs.zerops.io/references/gitlab-integration) repository from inside the service detail.


## Trigger the pipeline using Zerops CLI (zcli)


[Section titled Trigger the pipeline using Zerops CLI (zcli)](#trigger-the-pipeline-using-zerops-cli-zcli)

1.  Install the Zerops CLI.

    Terminal window

    ```
    # To download the zcli binary directly,# use https://github.com/zeropsio/zcli/releasesnpmi-g@zerops/zcli
    ```

2.  Open [`Settings > Access Token Management`](https://app.zerops.io/settings/token-management) in the Zerops app and generate a new access token.

3.  Log in using your access token with the following command:

    Terminal window

    ```
    zclilogin<token>
    ```

4.  Navigate to the root of your app (where `zerops.yml` is located) and run the following command to trigger the deploy:

    Terminal window

    ```
    zclipush
    ```



## Resources


[Section titled Resources](#resources)


### Official


[Section titled Official](#official)

-   [Create Zerops account](https://app.zerops.io/registration)
-   [Zerops Documentation](https://docs.zerops.io)
-   [Zerops Astro recipe](https://app.zerops.io/recipe/astro)


### Community


[Section titled Community](#community)

-   [Deploying Astro to Zerops in 3 mins](https://medium.com/@arjunaditya/how-to-deploy-astro-to-zerops-4230816a62b4)
-   [Deploying Astro SSG with Node.js on Zerops with One Click Deploy](https://youtu.be/-4KTa4VWtBE)
-   [Deploying Astro SSR with Node.js on Zerops with One Click Deploy](https://youtu.be/eR6b_JnDH6g)


## More Deployment Guides


-   ### [Netlify](/en/guides/deploy/netlify/)

-   ### [Vercel](/en/guides/deploy/vercel/)

-   ### [Deno Deploy](/en/guides/deploy/deno/)

-   ### [GitHub Pages](/en/guides/deploy/github/)

-   ### [GitLab Pages](/en/guides/deploy/gitlab/)

-   ### [Cloudflare Pages](/en/guides/deploy/cloudflare/)

-   ### [AWS](/en/guides/deploy/aws/)

-   ### [AWS via Flightcontrol](/en/guides/deploy/flightcontrol/)

-   ### [AWS via SST](/en/guides/deploy/sst/)

-   ### [Clever Cloud](/en/guides/deploy/clever-cloud/)

-   ### [Azion](/en/guides/deploy/azion/)

-   ### [Google Cloud](/en/guides/deploy/google-cloud/)

-   ### [Google Firebase](/en/guides/deploy/google-firebase/)

-   ### [Heroku](/en/guides/deploy/heroku/)

-   ### [Microsoft Azure](/en/guides/deploy/microsoft-azure/)

-   ### [Buddy](/en/guides/deploy/buddy/)

-   ### [Fleek](/en/guides/deploy/fleek/)

-   ### [Fly.io](/en/guides/deploy/flyio/)

-   ### [Render](/en/guides/deploy/render/)

-   ### [Stormkit](/en/guides/deploy/stormkit/)

-   ### [Surge](/en/guides/deploy/surge/)

-   ### [Cleavr](/en/guides/deploy/cleavr/)

-   ### [Kinsta](/en/guides/deploy/kinsta/)

-   ### [Zeabur](/en/guides/deploy/zeabur/)

-   ### [Zerops](/en/guides/deploy/zerops/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 88. `en/guides/dev-toolbar/.md`

```text
# Dev toolbar


---
url: https://docs.astro.build/en/guides/dev-toolbar/
description: A guide to using the dev toolbar in Astro
---


# Dev toolbar


While the dev server is running, Astro includes a dev toolbar at the bottom of every page in your local browser preview.

This toolbar includes a number of useful tools for debugging and inspecting your site during development and can be [extended with more dev toolbar apps](#extending-the-dev-toolbar) found in the integrations directory. You can even [build your own toolbar apps](/en/recipes/making-toolbar-apps/) using the [Dev Toolbar API](/en/reference/dev-toolbar-app-reference/)!

This toolbar is enabled by default and appears when you hover over the bottom of the page. It is a development tool only and will not appear on your published site.


## Built-in apps


[Section titled Built-in apps](#built-in-apps)


### Astro Menu


[Section titled Astro Menu](#astro-menu)

The Astro Menu app provides easy access to various information about the current project and links to extra resources. Notably, it provides one-click access to the Astro documentation, GitHub repository, and Discord server.

This app also includes a “Copy debug info” button which will run the [`astro info`](/en/reference/cli-reference/#astro-info) command and copy the output to your clipboard. This can be useful when asking for help or reporting issues.


### Inspect


[Section titled Inspect](#inspect)

The Inspect app provides information about any [islands](/en/concepts/islands/) on the current page. This will show you the properties passed to each island, and the client directive that is being used to render them.


### Audit


[Section titled Audit](#audit)

The Audit app automatically runs a series of audits on the current page, checking for the most common performance and accessibility issues. When an issue is found, a red dot will appear in the toolbar. Clicking on the app will pop up a list of results from the audit and will highlight the related elements directly in the page.

Note

The basic performance and accessibility audits performed by the dev toolbar are not a replacement for dedicated tools like [Pa11y](https://pa11y.org/) or [Lighthouse](https://developers.google.com/web/tools/lighthouse), or even better, humans!

The dev toolbar aims to provide a quick and easy way to catch common issues during development, without needing to context-switch to a different tool.


### Settings


[Section titled Settings](#settings)

The Settings app allows you to configure options for the dev toolbar, such as verbose logging, disabling notifications, and adjusting its placement on your screen.


## Extending the dev toolbar


[Section titled Extending the dev toolbar](#extending-the-dev-toolbar)

Astro integrations can add new apps to the dev toolbar, allowing you to extend it with custom tools that are specific to your project. You can find [more dev tool apps to install in the integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=toolbar) or using the [Astro Menu](#astro-menu).

Install additional dev toolbar app integrations in your project just like any other [Astro integration](/en/guides/integrations-guide/) according to its own installation instructions.

**Related recipe:** [Create a dev toolbar app](/en/recipes/making-toolbar-apps/)


## Disabling the dev toolbar


[Section titled Disabling the dev toolbar](#disabling-the-dev-toolbar)

The dev toolbar is enabled by default for every site. You can choose to disable it for individual projects and/or users as needed.


### Per-project


[Section titled Per-project](#per-project)

To disable the dev toolbar for everyone working on a project, set `devToolbar: false` in the [Astro config file](/en/reference/configuration-reference/#devtoolbarenabled).

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({devToolbar: {enabled: false}});
```

To enable the dev toolbar again, remove these lines from your configuration, or set `enabled: true`.


### Per-user


[Section titled Per-user](#per-user)

To disable the dev toolbar for yourself on a specific project, run the [`astro preferences`](/en/reference/cli-reference/#astro-preferences) command.

Terminal window

```
astropreferencesdisabledevToolbar
```

To disable the dev toolbar in all Astro projects for a user on the current machine, add the `--global` flag when running `astro-preferences`:

Terminal window

```
astropreferencesdisable--globaldevToolbar
```

The dev toolbar can later be enabled with:

Terminal window

```
astropreferencesenabledevToolbar
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 89. `en/guides/ecommerce/.md`

```text
# E-commerce


---
url: https://docs.astro.build/en/guides/ecommerce/
description: An introduction to adding e-commerce options to your Astro site
---


# E-commerce


With Astro, you can build several e-commerce options, from checkout links to hosted payment pages to building an entire storefront using a payment service API.


## Payment processing overlays


[Section titled Payment processing overlays](#payment-processing-overlays)

Some payment processing services (e.g. [Lemon Squeezy](#lemon-squeezy), [Paddle](#paddle)) add a payment form to allow your customer to purchase from your site. These can be hosted overlays or embedded in a page on your site. These may offer some basic customization or site branding, and may be added to your Astro project as scripts, buttons, or external links.


### Lemon Squeezy


[Section titled Lemon Squeezy](#lemon-squeezy)

[Lemon Squeezy](https://www.lemonsqueezy.com/) is an all-in-one platform for payments and subscriptions with multi-currency support, global tax compliance, PayPal integration and more. It allows you to create and manage digital products and services through your account dashboard and provides product URLs for the checkout process.

The basic [Lemon.js JavaScript library](https://docs.lemonsqueezy.com/help/lemonjs/what-is-lemonjs) allows you to sell your Lemon Squeezy products with a checkout link.


#### Basic Usage


[Section titled Basic Usage](#basic-usage)

The following is an example of adding a Lemon Squeezy “Buy now” element to an Astro page. Clicking this link will open a checkout and allow the visitor to complete a single purchase.

1.  Add the following `<script>` tag to your page `head` or `body`:

    src/pages/my-product-page.astro

    ```
    <scriptsrc="https://app.lemonsqueezy.com/js/lemon.js"defer></script>
    ```

2.  Create an anchor tag on the page linking to your product URL. Include the class `lemonsqueezy-button` to open a checkout overlay when clicked.

    src/pages/my-product-page.astro

    ```
    <aclass="lemonsqueezy-button"href="https://demo.lemonsqueezy.com/checkout/...">Buy Now</a>
    ```



#### Lemon.js


[Section titled Lemon.js](#lemonjs)

Lemon.js also provides additional behavior such as [programmatically opening overlays](https://docs.lemonsqueezy.com/help/lemonjs/opening-overlays) and [handling overlay events](https://docs.lemonsqueezy.com/help/lemonjs/handling-events).

Read the [Lemon Squeezy developer getting started guide](https://docs.lemonsqueezy.com/guides/developer-guide) for more information.


### Paddle


[Section titled Paddle](#paddle)

[Paddle](https://www.paddle.com/) is a billing solution for digital products and services. It handles payments, taxes, and subscription management through an overlay or inline checkout.

[Paddle.js](https://developer.paddle.com/paddlejs/overview) is a lightweight JavaScript library that lets you build rich, integrated subscription billing experiences using Paddle.


#### Basic Usage


[Section titled Basic Usage](#basic-usage-1)

The following is an example of adding a Paddle “Buy Now” element to an Astro page. Clicking this link will open a checkout and allow the visitor to complete a single purchase.

After your default payment link domain (your own website) is approved by Paddle, you can turn any element on your page into a trigger for a checkout overlay using HTML data attributes.

1.  Add the following two `<script>` tags to your page `head` or `body`:

    src/pages/my-product-page.astro

    ```
    <scriptsrc="https://cdn.paddle.com/paddle/v2/paddle.js"></script><scripttype="text/javascript">Paddle.Setup({token: '7d279f61a3499fed520f7cd8c08'// replace with a client-side token});</script>
    ```

2.  Turn any element on your page into a Paddle Checkout button by adding the `paddle_button` class:

    src/pages/my-product-page.astro

    ```
    <ahref="#"class="paddle_button">Buy Now</a>
    ```

3.  Add a `data-items` attribute to specify your product’s Paddle `priceId` and `quantity`. You can also optionally pass additional [supported HTML data attributes](https://developer.paddle.com/paddlejs/html-data-attributes) to prefill data, handle checkout success, or style your button and checkout overlay:

    src/pages/my-product-page.astro

    ```
    <ahref="#"class="paddle_button"data-display-mode="overlay"data-theme="light"data-locale="en"data-success-url="https://example.com/thankyou"data-items='[{"priceId": "pri_01gs59hve0hrz6nyybj56z04eq","quantity": 1}]'>Buy now</a>
    ```



#### Paddle.js


[Section titled Paddle.js](#paddlejs)

Instead of passing HTML data attributes, you can send data to the checkout overlay using JavaScript for passing multiple attributes and even greater customization. You can also create upgrade workflows using an inline checkout.

Read more about [using Paddle.js to build an inline checkout](https://developer.paddle.com/build/checkout/build-branded-inline-checkout).


## Full-featured e-commerce solutions


[Section titled Full-featured e-commerce solutions](#full-featured-e-commerce-solutions)

For more customization over your site’s shopping cart and checkout process, you can connect a more fully-featured financial service provider (e.g. [Snipcart](#snipcart)) to your Astro project. These e-commerce platforms may also integrate with other third-party services for user account management, personalization, inventory and analytics.


### Snipcart


[Section titled Snipcart](#snipcart)

[Snipcart](https://snipcart.com/) is a powerful, developer-first HTML/JavaScript shopping cart platform.

Snipcart also allows you to integrate with third-party services such as shipping providers, enable webhooks for an advanced e-commerce integration between your shopping cart and other systems, choose from several payment gateways (e.g. Stripe, Paypal, and Square), customize email templates, and even provides live testing environments.

Tip

Want a pre-built Snipcart solution instead? Check out [`astro-snipcart`](https://astro-snipcart.vercel.app/), a fully functional Astro community template including an optional design system, ready for you to integrate with your existing Snipcart account.


#### Basic Usage


[Section titled Basic Usage](#basic-usage-2)

The following is an example of configuring a Snipcart checkout and adding button elements for “Add to cart” and “Check out now” to an Astro page. This will allow your visitors to add products to a cart without being immediately sent to a checkout page.

For complete instructions, including setting up your Snipcart store, please see [the Snipcart installation documentation](https://docs.snipcart.com/v3/setup/installation).

1.  Add the script [as shown in the Snipcart installation instructions](https://docs.snipcart.com/v3/setup/installation) on your page after the `<body>` element.

    src/pages/my-product-page.astro

    ```
    <body></body><script>window.SnipcartSettings= {publicApiKey: "YOUR_API_KEY",loadStrategy: "on-user-interaction",};(function()...); // available from the Snipcart documentation</script>
    ```

2.  Customize `window.SnipcartSettings` with any of the [available Snipcart settings](https://docs.snipcart.com/v3/setup/installation#settings) to control the behavior and appearance of your cart.

    src/pages/my-product-page.astro

    ```
    <script>window.SnipcartSettings= {publicApiKey: "YOUR_API_KEY",loadStrategy: "manual",version: "3.7.1",addProductBehavior: "none",modalStyle: "side",};(function()...); // available from the Snipcart documentation</script>
    ```

3.  Add `class="snipcart-add-item"` to any HTML element, such as a `<button>`, to add an item to the cart when clicked on. Also include any other data elements for [common Snipcart product attributes](https://docs.snipcart.com/v3/setup/products) such as price and description, and any optional fields.

    src/pages/my-product-page.astro

    ```
    <buttonclass="snipcart-add-item"data-item-id="astro-print"data-item-price="39.99"data-item-description="A framed print of the Astro logo."data-item-image="/assets/images/astro-print.jpg"data-item-name="Astro Print"data-item-custom1-name="Frame color"data-item-custom1-options="Brown|Silver[+10.00]|Gold[+20.00]"data-item-custom2-name="Delivery instructions"data-item-custom2-type="textarea">Add to cart</button>
    ```

4.  Add a Snipcart checkout button with the `snipcart-checkout` class to open the cart and allow guests to complete their purchase with a checkout modal.

    src/pages/my-product-page.astro

    ```
    <buttonclass="snipcart-checkout">Click here to checkout</button>
    ```



#### Snipcart JavaScript SDK


[Section titled Snipcart JavaScript SDK](#snipcart-javascript-sdk)

The [Snipcart JavaScript SDK](https://docs.snipcart.com/v3/sdk/basics) lets you configure, customize and manage your Snipcart cart programmatically.

This allows you to perform actions such as:

-   Retrieve relevant information about the current Snipcart session and apply certain operations to the cart.
-   Listen to incoming events and trigger callbacks dynamically.
-   Listen to state changes and receive a full snapshot of the state of the cart.

See the [Snipcart documentation](https://docs.snipcart.com/v3/) for more information about all the options to integrate Snipcart with your Astro Project.


#### `astro-snipcart`


[Section titled astro-snipcart](#astro-snipcart)

There are two `astro-snipcart` community packages that can simplify using Snipcart.

-   [`@lloydjatkinson/astro-snipcart` Astro template](https://astro-snipcart.vercel.app/): This Astro template includes an optional design system for a complete e-commerce solution out of the box. Learn more on its own extensive documentation site, including [the motivation behind building `astro-snipcart`](https://astro-snipcart.vercel.app/motivation) as providing a convenient, Astro-native way for you to interact with the Snipcart API.

-   [`@Adammatthiesen/astro-snipcart` integration](https://github.com/Adammatthiesen/astro-snipcart): This integration was heavily inspired by the `astro-snipcart` theme and provides Astro components (or Vue components) that you can add to your existing Astro project for creating products, controlling the cart, and more. See the [full tutorial](https://matthiesen.xyz/blog/getting-started-with-my-astro-snipcart-addon) for more information.



## Community Resources


[Section titled Community Resources](#community-resources)

-   [Hands-On Experience: eCommerce Store with Astro?](https://crystallize.com/blog/building-ecommerce-with-astro)
-   [Collecting Payments with Stripe using Astro](https://zellwk.com/blog/stripe-astro-recipe/)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 90. `en/guides/endpoints/.md`

```text
# Endpoints


---
url: https://docs.astro.build/en/guides/endpoints/
description: Learn how to create endpoints that serve any kind of data
---


# Endpoints


Astro lets you create custom endpoints to serve any kind of data. You can use this to generate images, expose an RSS document, or use them as API Routes to build a full API for your site.

In statically-generated sites, your custom endpoints are called at build time to produce static files. If you opt in to [SSR](/en/guides/on-demand-rendering/) mode, custom endpoints turn into live server endpoints that are called on request. Static and SSR endpoints are defined similarly, but SSR endpoints support additional features.


## Static File Endpoints


[Section titled Static File Endpoints](#static-file-endpoints)

To create a custom endpoint, add a `.js` or `.ts` file to the `/pages` directory. The `.js` or `.ts` extension will be removed during the build process, so the name of the file should include the extension of the data you want to create. For example, `src/pages/data.json.ts` will build a `/data.json` endpoint.

Endpoints export a `GET` function (optionally `async`) that receives a [context object](/en/reference/api-reference/) with properties similar to the `Astro` global. Here, it returns a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object with a `name` and `url`, and Astro will call this at build time and use the contents of the body to generate the file.

src/pages/builtwith.json.ts

```
// Outputs: /builtwith.jsonexportfunctionGET({ params,request }) {returnnewResponse(JSON.stringify({name: "Astro",url: "https://astro.build/",}),);}
```

Since Astro v3.0, the returned `Response` object doesn’t have to include the `encoding` property anymore. For example, to produce a binary `.png` image:

src/pages/astro-logo.png.ts

```
exportasyncfunctionGET({ params,request }) {const response = await fetch("https://docs.astro.build/assets/full-logo-light.png",);returnnewResponse(await response.arrayBuffer());}
```

You can also type your endpoint functions using the `APIRoute` type:

```
importtype { APIRoute } from"astro";export const GET:APIRoute = async ({ params, request }) => {...}
```


### `params` and Dynamic routing


[Section titled params and Dynamic routing](#params-and-dynamic-routing)

Endpoints support the same [dynamic routing](/en/guides/routing/#dynamic-routes) features that pages do. Name your file with a bracketed parameter name and export a [`getStaticPaths()` function](/en/reference/routing-reference/#getstaticpaths). Then, you can access the parameter using the `params` property passed to the endpoint function:

src/pages/api/\[id\].json.ts

```
importtype { APIRoute } from"astro";const usernames = ["Sarah", "Chris", "Yan", "Elian"];export const GET:APIRoute = ({ params, request }) => {const id = params.id;return newResponse(JSON.stringify({name: usernames[id],}),);};exportfunctiongetStaticPaths() {return [{ params: { id: "0" } },{ params: { id: "1" } },{ params: { id: "2" } },{ params: { id: "3" } },];}
```

This will generate four JSON endpoints at build time: `/api/0.json`, `/api/1.json`, `/api/2.json` and `/api/3.json`. Dynamic routing with endpoints works the same as it does with pages, but because the endpoint is a function and not a component, [props](/en/reference/routing-reference/#data-passing-with-props) aren’t supported.


### `request`


[Section titled request](#request)

All endpoints receive a `request` property, but in static mode, you only have access to `request.url`. This returns the full URL of the current endpoint and works the same as [Astro.request.url](/en/reference/api-reference/#request) does for pages.

src/pages/request-path.json.ts

```
importtype { APIRoute } from"astro";export const GET:APIRoute = ({ params, request }) => {return newResponse(JSON.stringify({path: newURL(request.url).pathname,}),);};
```


## Server Endpoints (API Routes)


[Section titled Server Endpoints (API Routes)](#server-endpoints-api-routes)

Everything described in the static file endpoints section can also be used in SSR mode: files can export a `GET` function which receives a [context object](/en/reference/api-reference/) with properties similar to the `Astro` global.

But, unlike in `static` mode, when you enable on-demand rendering for a route, the endpoint will be built when it is requested. This unlocks new features that are unavailable at build time, and allows you to build API routes that listen for requests and securely execute code on the server at runtime.

Your routes will be rendered on demand by default in `server` mode. In `static` mode, you must opt out of prerendering for each custom endpoint with `export const prerender = false`.

**Related recipe:** [Call endpoints from the server](/en/recipes/call-endpoints/)

Note

Be sure to [enable an on-demand rendering mode](/en/guides/on-demand-rendering/) before trying these examples, and opt out of prerendering in `static` mode.

Server endpoints can access `params` without exporting `getStaticPaths`, and they can return a `Response` object, allowing you to set status codes and headers:

src/pages/\[id\].json.js

```
import { getProduct } from"../db";exportasyncfunctionGET({ params }) {const id = params.id;const product = await getProduct(id);if (!product) {returnnewResponse(null, {status: 404,statusText: "Not found",});}returnnewResponse(JSON.stringify(product), {status: 200,headers: {"Content-Type": "application/json",},});}
```

This will respond to any request that matches the dynamic route. For example, if we navigate to `/helmet.json`, `params.id` will be set to `helmet`. If `helmet` exists in the mock product database, the endpoint will use a `Response` object to respond with JSON and return a successful [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/API/Response/status). If not, it will use a `Response` object to respond with a `404`.

In SSR mode, certain providers require the `Content-Type` header to return an image. In this case, use a `Response` object to specify a `headers` property. For example, to produce a binary `.png` image:

src/pages/astro-logo.png.ts

```
exportasyncfunctionGET({ params,request }) {const response = await fetch("https://docs.astro.build/assets/full-logo-light.png",);const buffer = Buffer.from(await response.arrayBuffer());returnnewResponse(buffer, {headers: { "Content-Type": "image/png" },});}
```


### HTTP methods


[Section titled HTTP methods](#http-methods)

In addition to the `GET` function, you can export a function with the name of any [HTTP method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). When a request comes in, Astro will check the method and call the corresponding function.

You can also export an `ALL` function to match any method that doesn’t have a corresponding exported function. If there is a request with no matching method, it will redirect to your site’s [404 page](/en/basics/astro-pages/#custom-404-error-page).

src/pages/methods.json.ts

```
export const GET:APIRoute = ({ params, request }) => {return newResponse(JSON.stringify({message: "This was a GET!",}),);};export const POST:APIRoute = ({ request }) => {return newResponse(JSON.stringify({message: "This was a POST!",}),);};export const DELETE:APIRoute = ({ request }) => {return newResponse(JSON.stringify({message: "This was a DELETE!",}),);};export const ALL:APIRoute = ({ request }) => {return newResponse(JSON.stringify({message: `This was a ${request.method}!`,}),);};
```

If you define a `GET` function but no `HEAD` function, Astro will automatically handle `HEAD` requests by calling the `GET` function and stripping the body from the response.

**Related recipes**

-   [Verify a Captcha](/en/recipes/captcha/)
-   [Build forms with API routes](/en/recipes/build-forms-api/)


### `request`


[Section titled request](#request-1)

In SSR mode, the `request` property returns a fully usable [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that refers to the current request. This allows you to accept data and check headers:

src/pages/test-post.json.ts

```
export const POST:APIRoute = async ({ request }) => {if (request.headers.get("Content-Type") === "application/json") {const body = await request.json();const name = body.name;return newResponse(JSON.stringify({message: "Your name was: " + name,}),{status: 200,},);}return newResponse(null, { status: 400 });};
```


### Redirects


[Section titled Redirects](#redirects)

The endpoint context exports a `redirect()` utility similar to `Astro.redirect`:

src/pages/links/\[id\].js

```
import { getLinkUrl } from"../db";exportasyncfunctionGET({ params,redirect }) {const { id } = params;const link = await getLinkUrl(id);if (!link) {returnnewResponse(null, {status: 404,statusText: "Not found",});}returnredirect(link,307);}
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 91. `en/guides/environment-variables/.md`

```text
# Using environment variables


---
url: https://docs.astro.build/en/guides/environment-variables/
description: Learn how to use environment variables in an Astro project.
---


# Using environment variables


Astro gives you access to [Vite’s built-in environment variables support](#vites-built-in-support) and includes some [default environment variables for your project](#default-environment-variables) that allow you to access configuration values for your current project (e.g. `site`, `base`), whether your project is running in development or production, and more.

Astro also provides a way to [use and organize your environment variables with type safety](#type-safe-environment-variables). It is available for use inside the Astro context (e.g. Astro components, routes and endpoints, UI framework components, middleware), and managed with [a schema in your Astro configuration](/en/reference/configuration-reference/#env).


## Vite’s built-in support


[Section titled Vite’s built-in support](#vites-built-in-support)

Astro uses Vite’s built-in support for environment variables, which are statically replaced at build time, and lets you [use any of its methods](https://vite.dev/guide/env-and-mode.html) to work with them.

Note that while *all* environment variables are available in server-side code, only environment variables prefixed with `PUBLIC_` are available in client-side code for security purposes.

.env

```
SECRET_PASSWORD=password123PUBLIC_ANYBODY=there
```

In this example, `PUBLIC_ANYBODY` (accessible via `import.meta.env.PUBLIC_ANYBODY`) will be available in server or client code, while `SECRET_PASSWORD` (accessible via `import.meta.env.SECRET_PASSWORD`) will be server-side only.

Caution

`.env` files are not loaded inside [configuration files](#in-the-astro-config-file).


### IntelliSense for TypeScript


[Section titled IntelliSense for TypeScript](#intellisense-for-typescript)

By default, Astro provides a type definition for `import.meta.env` in `astro/client.d.ts`.

While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with `PUBLIC_`.

To achieve this, you can create an `env.d.ts` in `src/` and configure `ImportMetaEnv` like this:

src/env.d.ts

```
interface ImportMetaEnv {readonly DB_PASSWORD:string;readonly PUBLIC_POKEAPI:string;// more env variables...}interface ImportMeta {readonly env:ImportMetaEnv;}
```


## Default environment variables


[Section titled Default environment variables](#default-environment-variables)

Astro includes a few environment variables out of the box:

-   `import.meta.env.MODE`: The mode your site is running in. This is `development` when running `astro dev` and `production` when running `astro build`.
-   `import.meta.env.PROD`: `true` if your site is running in production; `false` otherwise.
-   `import.meta.env.DEV`: `true` if your site is running in development; `false` otherwise. Always the opposite of `import.meta.env.PROD`.
-   `import.meta.env.BASE_URL`: The base URL your site is being served from. This is determined by the [`base` config option](/en/reference/configuration-reference/#base).
-   `import.meta.env.SITE`: This is set to [the `site` option](/en/reference/configuration-reference/#site) specified in your project’s `astro.config`.
-   `import.meta.env.ASSETS_PREFIX`: The prefix for Astro-generated asset links if the [`build.assetsPrefix` config option](/en/reference/configuration-reference/#buildassetsprefix) is set. This can be used to create asset links not handled by Astro.

Use them like any other environment variable.

```
const isProd = import.meta.env.PROD;const isDev = import.meta.env.DEV;
```


## Setting environment variables


[Section titled Setting environment variables](#setting-environment-variables)


### `.env` files


[Section titled .env files](#env-files)

Environment variables can be loaded from `.env` files in your project directory.

Just create a `.env` file in the project directory and add some variables to it.

.env

```

# This will only be available when run on the server!DB_PASSWORD="foobar"# This will be available everywhere!PUBLIC_POKEAPI="https://pokeapi.co/api/v2"

```

You can also add `.production`, `.development` or a custom mode name to the filename itself (e.g `.env.testing`, `.env.staging`). This allows you to use different sets of environment variables at different times.

The `astro dev` and `astro build` commands default to `"development"` and `"production"` modes, respectively. You can run these commands with the [`--mode` flag](/en/reference/cli-reference/#--mode-string) to pass a different value for `mode` and load the matching `.env` file.

This allows you to run the dev server or build your site connecting to different APIs:

-   [npm](#tab-panel-1792)
-   [pnpm](#tab-panel-1793)
-   [Yarn](#tab-panel-1794)

Terminal window

```

# Run the dev server connected to a "staging" APInpmrunastrodev----modestaging# Build a site that connects to a "production" API with additional debug informationnpmrunastrobuild----devOutput# Build a site that connects to a "testing" APInpmrunastrobuild----modetesting

```

Terminal window

```

# Run the dev server connected to a "staging" APIpnpmastrodev--modestaging# Build a site that connects to a "production" API with additional debug informationpnpmastrobuild--devOutput# Build a site that connects to a "testing" APIpnpmastrobuild--modetesting

```

Terminal window

```

# Run the dev server connected to a "staging" APIyarnastrodev--modestaging# Build a site that connects to a "production" API with additional debug informationyarnastrobuild--devOutput# Build a site that connects to a "testing" APIyarnastrobuild--modetesting

```

For more on `.env` files, [see the Vite documentation](https://vite.dev/guide/env-and-mode.html#env-files).


### In the Astro config file


[Section titled In the Astro config file](#in-the-astro-config-file)

Astro evaluates configuration files before it loads your other files. This means that you cannot use `import.meta.env` in `astro.config.mjs` to access environment variables that were set in `.env` files.

You can use `process.env` in a configuration file to access other environment variables, like those [set by the CLI](#using-the-cli).

You can also use [Vite’s `loadEnv` helper](https://main.vite.dev/config/#using-environment-variables-in-config) to manually load `.env` files.

astro.config.mjs

```
import { loadEnv } from"vite";const { SECRET_PASSWORD } = loadEnv(process.env.NODE_ENV, process.cwd(), "");
```

Note

`pnpm` does not allow you to import modules that are not directly installed in your project. If you are using `pnpm`, you will need to install `vite` to use the `loadEnv` helper.

Terminal window

```
pnpmadd-Dvite
```


### Using the CLI


[Section titled Using the CLI](#using-the-cli)

You can also add environment variables as you run your project:

-   [npm](#tab-panel-1795)
-   [pnpm](#tab-panel-1796)
-   [Yarn](#tab-panel-1797)

Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2npmrundev
```

Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2pnpmrundev
```

Terminal window

```
PUBLIC_POKEAPI=https://pokeapi.co/api/v2yarnrundev
```


## Getting environment variables


[Section titled Getting environment variables](#getting-environment-variables)

Environment variables in Astro are accessed with `import.meta.env`, using the [`import.meta` feature added in ES2020](https://tc39.es/ecma262/2020/#prod-ImportMeta), instead of `process.env`.

For example, use `import.meta.env.PUBLIC_POKEAPI` to get the `PUBLIC_POKEAPI` environment variable.

```
// When import.meta.env.SSR === trueconst data = await db(import.meta.env.DB_PASSWORD);// When import.meta.env.SSR === falseconst data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);
```

When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with `process.env`, but some adapters work differently. For the Deno adapter, you will use `Deno.env.get()`. See how to [access the Cloudflare runtime](/en/guides/integrations-guide/cloudflare/#cloudflare-runtime) to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don’t exist, Astro will look for them in `.env` files.


## Type safe environment variables


[Section titled Type safe environment variables](#type-safe-environment-variables)

The `astro:env` API lets you configure a type-safe schema for [environment variables you have set](#setting-environment-variables). This allows you to indicate whether they should be available on the server or the client, and define their data type and additional properties.

Developing an adapter? See how to [make an adapter compatible with `astro:env`](/en/reference/adapter-reference/#envgetsecret).


### Basic Usage


[Section titled Basic Usage](#basic-usage)


#### Define your schema


[Section titled Define your schema](#define-your-schema)

To configure a schema, add the `env.schema` option to your Astro config:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({env: {schema: {// ...}}})
```

You can then [register variables as a string, number, enum, or boolean](#data-types) using the `envField` helper. Define the [kind of environment variable](#variable-types) by providing a `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) for each variable, and pass any additional properties such as `optional` or `default` in an object:

astro.config.mjs

```
import { defineConfig, envField } from"astro/config";exportdefaultdefineConfig({env: {schema: {API_URL: envField.string({ context: "client", access: "public", optional: true }),PORT: envField.number({ context: "server", access: "public", default: 4321 }),API_SECRET: envField.string({ context: "server", access: "secret" }),}}})
```

Types will be generated for you when running `astro dev` or `astro build`, but you can run `astro sync` to generate types only.


#### Use variables from your schema


[Section titled Use variables from your schema](#use-variables-from-your-schema)

Import and use your defined variables from the appropriate `/client` or `/server` module:

```
---import { API_URL } from"astro:env/client";import { API_SECRET_TOKEN } from"astro:env/server";const data = await fetch(`${API_URL}/users`, {method: "GET",headers: {"Content-Type": "application/json","Authorization": `Bearer ${API_SECRET_TOKEN}`},})---<script>import { API_URL } from"astro:env/client";fetch(`${API_URL}/ping`)</script>
```


### Variable types


[Section titled Variable types](#variable-types)

There are three kinds of environment variables, determined by the combination of `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) settings defined in your schema:

-   **Public client variables**: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the `astro:env/client` module:

    ```
    import { API_URL } from"astro:env/client";
    ```

-   **Public server variables**: These variables end up in your final server bundle and can be accessed on the server through the `astro:env/server` module:

    ```
    import { PORT } from"astro:env/server";
    ```

-   **Secret server variables**: These variables are not part of your final bundle and can be accessed on the server through the `astro:env/server` module:

    ```
    import { API_SECRET } from"astro:env/server";
    ```

    By default, secrets are only validated at runtime. You can enable validating private variables on start by [configuring `validateSecrets: true`](/en/reference/configuration-reference/#envvalidatesecrets).


Note

**Secret client variables** are not supported because there is no safe way to send this data to the client. Therefore, it is not possible to configure both `context: "client"` and `access: "secret"` in your schema.


### Data types


[Section titled Data types](#data-types)

There are currently four data types supported: strings, numbers, enums, and booleans:

```
import { envField } from"astro/config";envField.string({// context & accessoptional: true,default: "foo",})envField.number({// context & accessoptional: true,default: 15,})envField.boolean({// context & accessoptional: true,default: true,})envField.enum({// context & accessvalues: ["foo", "bar", "baz"],optional: true,default: "baz",})
```

For a complete list of validation fields, see the [`envField` API reference](/en/reference/configuration-reference/#envschema).


### Retrieving secrets dynamically


[Section titled Retrieving secrets dynamically](#retrieving-secrets-dynamically)

Despite defining your schema, you may want to retrieve the raw value of a given secret or to retrieve secrets not defined in your schema. In this case, you can use `getSecret()` exported from `astro:env/server`:

```
import {FOO, // booleangetSecret} from"astro:env/server";getSecret("FOO"); // string | undefined
```

Learn more in [the API reference](/en/reference/modules/astro-env/#getsecret).


### Limitations


[Section titled Limitations](#limitations)

`astro:env` is a virtual module which means it can only be used inside the Astro context. For example, you can use it in:

-   Middlewares
-   Astro routes and endpoints
-   Astro components
-   Framework components
-   Modules

You cannot use it in the following and will have to resort to `process.env`:

-   `astro.config.mjs`
-   Scripts

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 92. `en/guides/fonts/.md`

```text
# Using custom fonts


---
url: https://docs.astro.build/en/guides/fonts/
description: Looking to add some custom typefaces to an Astro website? Use Google Fonts with Fontsource or add a font of your choice.
---


# Using custom fonts


This guide will show you how to add web fonts to your project and use them in your components.

Experimental Fonts API

Learn about Astro’s [experimental Fonts API](/en/reference/experimental-flags/fonts/) that allows you to use fonts from your filesystem and various font providers through a unified, fully customizable, and type-safe API.


## Using a local font file


[Section titled Using a local font file](#using-a-local-font-file)

This example will demonstrate adding a custom font using the font file `DistantGalaxy.woff`.

1.  Add your font file to `public/fonts/`.

2.  Add the following `@font-face` statement to your CSS. This could be in a global `.css` file you import, a `<style is:global>` block, or a `<style>` block in a specific layout or component where you want to use this font.

    ```
    /* Register your custom font family and tell the browser where to find it. */@font-face {font-family: 'DistantGalaxy';src: url('/fonts/DistantGalaxy.woff') format('woff');font-weight: normal;font-style: normal;font-display: swap;}
    ```

3.  Use the `font-family` value from the `@font-face` statement to style elements in your component or layout. In this example, the `<h1>` heading will have the custom font applied, while the paragraph `<p>` will not.

    src/pages/example.astro

    ```
    ------<h1>In a galaxy far, far away...</h1><p>Custom fonts make my headings much cooler!</p><style>h1 {font-family: 'DistantGalaxy', sans-serif;}</style>
    ```



## Using Fontsource


[Section titled Using Fontsource](#using-fontsource)

The [Fontsource](https://fontsource.org/) project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.

1.  Find the font you want to use in [Fontsource’s catalog](https://fontsource.org/). This example will use [Twinkle Star](https://fontsource.org/fonts/twinkle-star).

2.  Install the package for your chosen font.

    -   [npm](#tab-panel-1798)
    -   [pnpm](#tab-panel-1799)
    -   [Yarn](#tab-panel-1800)

    Terminal window

    ```
    npminstall@fontsource/twinkle-star
    ```

    Terminal window

    ```
    pnpmadd@fontsource/twinkle-star
    ```

    Terminal window

    ```
    yarnadd@fontsource/twinkle-star
    ```

    Tip

    You’ll find the correct package name in the “Quick Installation” section of each font page on Fontsource’s website. It will start with `@fontsource/` or `@fontsource-variable/` followed by the name of the font.

3.  Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.

    The import will automatically add the necessary `@font-face` rules needed to set up the font.

    src/layouts/BaseLayout.astro

    ```
    ---import'@fontsource/twinkle-star';---
    ```

4.  Use the font’s name as shown in the `body` example on its Fontsource page as the `font-family` value. This will work anywhere you can write CSS in your Astro project.

    ```
    h1 {font-family: "Twinkle Star", cursive;}
    ```


To optimize your website’s rendering times, you may want to preload fonts that are essential for the initial page display. See the [Fontsource guide to preloading fonts](https://fontsource.org/docs/getting-started/preload) for more information and usage.


## Register fonts in Tailwind


[Section titled Register fonts in Tailwind](#register-fonts-in-tailwind)

If you are using [Tailwind](/en/guides/styling/#tailwind), you can use either of the previous methods on this page to install your font, with some modifications. You can either add an [`@font-face` statement for a local font](#using-a-local-font-file) or use [Fontsource’s `import` strategy](#using-fontsource) to install your font.

To register your font in Tailwind:

1.  Follow either of the guides above, but skip the final step of adding `font-family` to your CSS.

2.  Add the typeface name to `src/styles/global.css`.

    This example adds `Inter` to the sans-serif font stack.

    src/styles/global.css

    ```
    @import'tailwindcss';@theme {--font-sans: 'Inter', 'sans-serif';}
    ```

    Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the `font-sans` class will also apply the Inter font.


See [Tailwind’s docs on adding custom font families](https://tailwindcss.com/docs/font-family#using-custom-values) for more information.


## More resources


[Section titled More resources](#more-resources)

-   Learn how web fonts work in [MDN’s web fonts guide](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Web_fonts).
-   Generate CSS for your font with [Font Squirrel’s Webfont Generator](https://www.fontsquirrel.com/tools/webfont-generator).

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 93. `en/guides/framework-components/.md`

```text
# Front-end frameworks


---
url: https://docs.astro.build/en/guides/framework-components/
description: Build your Astro website with React, Svelte, and more.
---


# Front-end frameworks


Build your Astro website without sacrificing your favorite component framework. Create Astro [islands](/en/concepts/islands/) with the UI frameworks of your choice.


## Official front-end framework integrations


[Section titled Official front-end framework integrations](#official-front-end-framework-integrations)

Astro supports a variety of popular frameworks including [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [SolidJS](https://www.solidjs.com/), and [AlpineJS](https://alpinejs.dev/) with official integrations.

Find even more [community-maintained framework integrations](https://astro.build/integrations/?search=&categories%5B%5D=frameworks) (e.g. Angular, Qwik, Elm) in our integrations directory.


### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



## Installing integrations


[Section titled Installing integrations](#installing-integrations)

One or several of these Astro integrations can be installed and configured in your project.

See the [Integrations Guide](/en/guides/integrations-guide/) for more details on installing and configuring Astro integrations.

Tip

Want to see an example for the framework of your choice? Visit [astro.new](https://astro.new/latest/frameworks) and select one of the framework templates.


## Using framework components


[Section titled Using framework components](#using-framework-components)

Use your JavaScript framework components in your Astro pages, layouts and components just like Astro components! All your components can live together in `/src/components`, or can be organized in any way you like.

To use a framework component, import it from its relative path in your Astro component script. Then, use the component alongside other components, HTML elements and JSX-like expressions in the component template.

src/pages/static-components.astro

```
---import MyReactComponent from'../components/MyReactComponent.jsx';---<html><body><h1>Use React components directly in Astro!</h1><MyReactComponent /></body></html>
```

By default, your framework components will only render on the server, as static HTML. This is useful for templating components that are not interactive and avoids sending any unnecessary JavaScript to the client.


## Hydrating interactive components


[Section titled Hydrating interactive components](#hydrating-interactive-components)

A framework component can be made interactive (hydrated) using a [`client:*` directive](/en/reference/directives-reference/#client-directives). These are component attributes that determine when your component’s JavaScript should be sent to the browser.

With all client directives except `client:only`, your component will first render on the server to generate static HTML. Component JavaScript will be sent to the browser according to the directive you chose. The component will then hydrate and become interactive.

src/pages/interactive-components.astro

```
---// Example: hydrating framework components in the browser.import InteractiveButton from'../components/InteractiveButton.jsx';import InteractiveCounter from'../components/InteractiveCounter.jsx';import InteractiveModal from'../components/InteractiveModal.svelte';---<!-- This component's JS will begin importing when the page loads --><InteractiveButtonclient:load /><!-- This component's JS will not be sent to the client untilthe user scrolls down and the component is visible on the page --><InteractiveCounterclient:visible /><!-- This component won't render on the server, but will render on the client when the page loads --><InteractiveModalclient:only="svelte" />
```

The JavaScript framework (React, Svelte, etc.) needed to render the component will be sent to the browser along with the component’s own JavaScript. If two or more components on a page use the same framework, the framework will only be sent once.

Accessibility

Most framework-specific accessibility patterns should work the same when these components are used in Astro. Be sure to choose a client directive that will ensure any accessibility-related JavaScript is properly loaded and executed at the appropriate time!


### Available hydration directives


[Section titled Available hydration directives](#available-hydration-directives)

There are several hydration directives available for UI framework components: `client:load`, `client:idle`, `client:visible`, `client:media={QUERY}` and `client:only={FRAMEWORK}`.

See our [directives reference](/en/reference/directives-reference/#client-directives) page for a full description of these hydration directives, and their usage.


## Mixing frameworks


[Section titled Mixing frameworks](#mixing-frameworks)

You can import and render components from multiple frameworks in the same Astro component.

src/pages/mixing-frameworks.astro

```
---// Example: Mixing multiple framework components on the same page.import MyReactComponent from'../components/MyReactComponent.jsx';import MySvelteComponent from'../components/MySvelteComponent.svelte';import MyVueComponent from'../components/MyVueComponent.vue';---<div><MySvelteComponent /><MyReactComponent /><MyVueComponent /></div>
```

Caution

Only **Astro** components (`.astro`) can contain components from multiple frameworks.


## Passing props to framework components


[Section titled Passing props to framework components](#passing-props-to-framework-components)

You can pass props from Astro components to framework components:

src/pages/frameworks-props.astro

```
---import TodoList from'../components/TodoList.jsx';import Counter from'../components/Counter.svelte';---<div><TodoListinitialTodos={["learn Astro", "review PRs"]} /><CounterstartingCount={1} /></div>
```

Passing functions as props

You can pass a function as a prop to a framework component, but it only works during server rendering. If you try to use the function in a hydrated component (for example, as an event handler), an error will occur.

This is because functions can’t be *serialized* (transferred from the server to the client) by Astro.


## Passing children to framework components


[Section titled Passing children to framework components](#passing-children-to-framework-components)

Inside of an Astro component, you **can** pass children to framework components. Each framework has its own patterns for how to reference these children: React, Preact, and Solid all use a special prop named `children`, while Svelte and Vue use the `<slot />` element.

src/pages/component-children.astro

```
---import MyReactSidebar from'../components/MyReactSidebar.jsx';---<MyReactSidebar><p>Here is a sidebar with some text and a button.</p></MyReactSidebar>
```

Additionally, you can use [Named Slots](/en/basics/astro-components/#named-slots) to group specific children together.

For React, Preact, and Solid, these slots will be converted to a top-level prop. Slot names using `kebab-case` will be converted to `camelCase`.

src/pages/named-slots.astro

```
---import MySidebar from'../components/MySidebar.jsx';---<MySidebar><h2slot="title">Menu</h2><p>Here is a sidebar with some text and a button.</p><ulslot="social-links"><li><ahref="https://twitter.com/astrodotbuild">Twitter</a></li><li><ahref="https://github.com/withastro">GitHub</a></li></ul></MySidebar>
```

src/components/MySidebar.jsx

```
exportdefaultfunctionMySidebar(props) {return (<aside><header>{props.title}</header><main>{props.children}</main><footer>{props.socialLinks}</footer></aside>)}
```

For Svelte and Vue these slots can be referenced using a `<slot>` element with the `name` attribute. Slot names using `kebab-case` will be preserved.

src/components/MySidebar.svelte

```
<aside><header><slotname="title" /></header><main><slot /></main><footer><slotname="social-links" /></footer></aside>
```


## Nesting framework components


[Section titled Nesting framework components](#nesting-framework-components)

Inside of an Astro file, framework component children can also be hydrated components. This means that you can recursively nest components from any of these frameworks.

src/pages/nested-components.astro

```
---import MyReactSidebar from'../components/MyReactSidebar.jsx';import MyReactButton from'../components/MyReactButton.jsx';import MySvelteButton from'../components/MySvelteButton.svelte';---<MyReactSidebar><p>Here is a sidebar with some text and a button.</p><divslot="actions"><MyReactButtonclient:idle /><MySvelteButtonclient:idle /></div></MyReactSidebar>
```

Caution

Remember: framework component files themselves (e.g. `.jsx`, `.svelte`) cannot mix multiple frameworks.

This allows you to build entire “apps” in your preferred JavaScript framework and render them, via a parent component, to an Astro page.

Note

Astro components are always rendered to static HTML, even when they include framework components that are hydrated. This means that you can only pass props that don’t do any HTML rendering. Passing React’s “render props” to framework components from an Astro component will not work, because Astro components can’t provide the client runtime behavior that this pattern requires. Instead, use named slots.


## Can I use Astro components inside my framework components?


[Section titled Can I use Astro components inside my framework components?](#can-i-use-astro-components-inside-my-framework-components)

Any UI framework component becomes an “island” of that framework. These components must be written entirely as valid code for that framework, using only its own imports and packages. You cannot import `.astro` components in a UI framework component (e.g. `.jsx` or `.svelte`).

You can, however, use [the Astro `<slot />` pattern](/en/basics/astro-components/#slots) to pass static content generated by Astro components as children to your framework components **inside an `.astro` component**.

src/pages/astro-children.astro

```
---import MyReactComponent from'../components/MyReactComponent.jsx';import MyAstroComponent from'../components/MyAstroComponent.astro';---<MyReactComponent><MyAstroComponentslot="name" /></MyReactComponent>
```


## Can I hydrate Astro components?


[Section titled Can I hydrate Astro components?](#can-i-hydrate-astro-components)

If you try to hydrate an Astro component with a `client:` modifier, you will get an error.

[Astro components](/en/basics/astro-components/) are HTML-only templating components with no client-side runtime. But, you can use a `<script>` tag in your Astro component template to send JavaScript to the browser that executes in the global scope.

Learn more about [client-side `<script>` tags in Astro components](/en/guides/client-side-scripts/)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 94. `en/guides/images/.md`

```text
# Images


---
url: https://docs.astro.build/en/guides/images/
description: Learn how to use images in Astro.
---


# Images


Astro provides several ways for you to use images on your site, whether they are stored locally inside your project, linked to from an external URL, or managed in a CMS or CDN.

Astro provides [image](#display-optimized-images-with-the-image--component) and [picture](#create-responsive-images-with-the-picture--component) components, [Markdown image syntax](#images-in-markdown-files) processing, [SVG components](#svg-components), and [an image generating function](#generating-images-with-getimage) to optimize and/or transform your images.

You can always choose to use images and SVG files using native HTML elements in `.astro` or Markdown files, or the standard way for your file type (e.g. `<img />` in MDX and JSX). However, Astro does not perform any processing or optimization of these images.

See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components.


## Where to store images


[Section titled Where to store images](#where-to-store-images)


### `src/` vs `public/`


[Section titled src/ vs public/](#src-vs-public)

We recommend that local images are kept in `src/` when possible so that Astro can transform, optimize and bundle them. Files in the `/public` directory are always served or copied into the build folder as-is, with no processing.

Your local images stored in `src/` can be used by all files in your project: `.astro`, `.md`, `.mdx`, `.mdoc`, and other UI frameworks. Images can be stored in any folder, including alongside your content.

Store your images in the `public/` folder if you want to avoid any processing or to have a direct public link to them.


### Remote images


[Section titled Remote images](#remote-images)

You can also choose to store your images remotely, in a [content management system (CMS)](/en/guides/cms/) or [digital asset management (DAM)](/en/guides/media/) platform. Astro can fetch your data remotely using APIs or display images from their full URL path.

For extra protection when dealing with external sources, Astro’s image components and helper function will only process (e.g. optimize, transform) images from [authorized image sources specified in your configuration](#authorizing-remote-images). Remote images from other sources will be displayed with no processing.


## Images in `.astro` files


[Section titled Images in .astro files](#images-in-astro-files)

In `.astro` files, a local image must be imported from its relative path. This import provides the `src` value for your image.

Remote and `public/` images do not require importing, and instead require a URL (full, or relative path on your site) for `src`.

Import and use Astro’s native [`<Image />`](#display-optimized-images-with-the-image--component) and [`<Picture />`](#create-responsive-images-with-the-picture--component) components for optimized images. Astro syntax also supports [writing an HTML `<img>` tag directly](#display-unprocessed-images-with-the-html-img-tag), which skips image processing.

src/pages/blog/my-images.astro

```
---import { Image } from'astro:assets';import localBirdImage from'../../images/subfolder/localBirdImage.png';---<Imagesrc={localBirdImage}alt="A bird sitting on a nest of eggs." /><Imagesrc="/images/bird-in-public-folder.jpg"alt="A bird."width="50"height="50" /><Imagesrc="https://example.com/remote-bird.jpg"alt="A bird."width="50"height="50" /><imgsrc={localBirdImage.src}alt="A bird sitting on a nest of eggs."><imgsrc="/images/bird-in-public-folder.jpg"alt="A bird."><imgsrc="https://example.com/remote-bird.jpg"alt="A bird.">
```

See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components.

**Related recipe:** [Dynamically import images](/en/recipes/dynamically-importing-images/)


### Display optimized images with the `<Image />` component


[Section titled Display optimized images with the &lt;Image /&gt; component](#display-optimized-images-with-the-image--component)

Use the built-in `<Image />` Astro component to display optimized versions of:

-   your local images located within the `src/` folder
-   [configured remote images](#authorizing-remote-images) from authorized sources

`<Image />` can transform a local or authorized remote image’s dimensions, file type, and quality for control over your displayed image. This transformation happens at build time for prerendered pages. When your page is rendered on demand, this transformation will occur on the fly when the page is viewed. The resulting `<img>` tag includes `alt`, `loading`, and `decoding` attributes and infers image dimensions to avoid Cumulative Layout Shift (CLS).

What is Cumulative Layout Shift?

[Cumulative Layout Shift (CLS)](https://web.dev/cls/) is a Core Web Vital metric for measuring how much content shifted on your page during loading. The `<Image />` component optimizes for CLS by automatically setting the correct `width` and `height` for your images.

src/components/MyComponent.astro

```
---// import the Image component and the imageimport { Image } from'astro:assets';import myImage from'../assets/my_image.png'; // Image is 1600x900---<!-- `alt` is mandatory on the Image component --><Imagesrc={myImage}alt="A description of my image." />
```

```
<!-- Prerendered output --><!-- Image is optimized, proper attributes are enforced --><imgsrc="/_astro/my_image.hash.webp"width="1600"height="900"decoding="async"loading="lazy"alt="A description of my image."/><!-- Output rendered on demand--><!-- src will use an endpoint generated on demand--><imgsrc="/_image?href=%2F_astro%2Fmy_image.hash.webp&amp;w=1600&amp;h=900&amp;f=webp"<!--...-->/>
```

The `<Image />` component accepts [several component properties](/en/reference/modules/astro-assets/#image-properties) as well as any attributes accepted by the HTML `<img>` tag.

The following example provides a `class` to the image component which will apply to the final `<img>` element.

src/pages/index.astro

```
---import { Image } from'astro:assets';import myImage from'../assets/my_image.png';---<!-- `alt` is mandatory on the Image component --><Imagesrc={myImage}alt=""class="my-class" />
```

```
<!-- Prerendered output --><imgsrc="/_astro/my_image.hash.webp"width="1600"height="900"decoding="async"loading="lazy"class="my-class"alt=""/>
```

Tip

You can also use the `<Image />` component for images in the `public/` folder, or remote images not specifically configured in your project, even though these images will not be optimized or processed. The resulting image will be the same as using the HTML `<img>`.

However, using the image component for all images provides a consistent authoring experience and prevents Cumulative Layout Shift (CLS) even for your unoptimized images.


### Create responsive images with the `<Picture />` component


[Section titled Create responsive images with the &lt;Picture /&gt; component](#create-responsive-images-with-the-picture--component)

**Added in:** `astro@3.3.0`

Use the built-in `<Picture />` Astro component to display a responsive image with multiple formats and/or sizes. Like the [`<Image />` component](#display-optimized-images-with-the-image--component), images will be processed at build time for prerendered pages. When your page is rendered on demand, processing will occur on the fly when the page is viewed.

src/pages/index.astro

```
---import { Picture } from'astro:assets';import myImage from'../assets/my_image.png'; // Image is 1600x900---<!-- `alt` is mandatory on the Picture component --><Picturesrc={myImage}formats={['avif', 'webp']}alt="A description of my image." />
```

```
<!-- Prerendered output --><picture><sourcesrcset="/_astro/my_image.hash.avif"type="image/avif" /><sourcesrcset="/_astro/my_image.hash.webp"type="image/webp" /><imgsrc="/_astro/my_image.hash.png"width="1600"height="900"decoding="async"loading="lazy"alt="A description of my image."/></picture>
```

See details about [the `<Picture />` component properties](/en/reference/modules/astro-assets/#picture-properties) in the `astro:assets` reference.


### Display unprocessed images with the HTML `<img>` tag


[Section titled Display unprocessed images with the HTML &lt;img&gt; tag](#display-unprocessed-images-with-the-html-img-tag)

The [Astro template syntax](/en/reference/astro-syntax/) also supports writing an `<img>` tag directly, with full control over its final output. These images will not be processed and optimized. It accepts all HTML `<img>` tag properties, and the only required property is `src`.

Local images must be imported from the relative path from the existing `.astro` file, or you can configure and use an [import alias](/en/guides/imports/#aliases). Then, you can access the image’s `src` and other properties to use in the `<img>` tag.

Imported image assets match the following signature:

```
interface ImageMetadata {src:string;width:number;height:number;format:string;}
```

The following example uses the image’s own `height` and `width` properties to avoid Cumulative Layout Shift (CLS) and improve Core Web Vitals:

src/pages/posts/post-1.astro

```
---// import local imagesimport myDog from'../../images/pets/local-dog.jpg';---// access the image properties<imgsrc={myDog.src}width={myDog.width}height={myDog.height}alt="A barking dog." />
```


#### Images in `public/`


[Section titled Images in public/](#images-in-public)

For images located within `public/` use the image’s file path relative to the public folder as the `src` value:

```
<imgsrc="/images/public-cat.jpg"alt="A sleeping cat." >
```


#### Remote images


[Section titled Remote images](#remote-images-1)

For remote images, use the image’s full URL as the `src` value:

```
<imgsrc="https://example.com/remote-cat.jpg"alt="A sleeping cat." >
```


### Choosing `<Image />` vs `<img>`


[Section titled Choosing &lt;Image /&gt; vs &lt;img&gt;](#choosing-image--vs-img)

The `<Image />` component optimizes your image and infers width and height (for images it can process) based on the original aspect ratio to avoid CLS. It is the preferred way to use images in `.astro` files whenever possible.

Use the HTML `<img>` element when you cannot use the `<Image />` component, for example:

-   for unsupported image formats
-   when you do not want your image optimized by Astro
-   to access and change the `src` attribute dynamically client-side


### Setting Default Values


[Section titled Setting Default Values](#setting-default-values)

Currently, there is no way to specify default values for all `<Image />` or `<Picture/>` components. Required attributes should be set on each individual component.

As an alternative, you can wrap these components in another Astro component for reuse. For example, you could create a component for your blog post images that receives attributes as props and applies consistent styles to each image:

src/components/BlogPostImage.astro

```
---import { Image } from'astro:assets';const { src, ...attrs } = Astro.props;---<Imagesrc={src} {...attrs} /><style>img {margin-block: 2.5rem;border-radius: 0.75rem;}</style>
```


### Authorizing remote images


[Section titled Authorizing remote images](#authorizing-remote-images)

You can configure lists of authorized image source URL domains and patterns for image optimization using [`image.domains`](/en/reference/configuration-reference/#imagedomains) and [`image.remotePatterns`](/en/reference/configuration-reference/#imageremotepatterns). This configuration is an extra layer of safety to protect your site when showing images from an external source.

Remote images from other sources will not be optimized, but using the `<Image />` component for these images will prevent Cumulative Layout Shift (CLS).

For example, the following configuration will only allow remote images from `astro.build` to be optimized:

astro.config.mjs

```
exportdefaultdefineConfig({image: {domains: ["astro.build"],}});
```

The following configuration will only allow remote images from HTTPS hosts:

astro.config.mjs

```
exportdefaultdefineConfig({image: {remotePatterns: [{ protocol: "https" }],}});
```


## SVG components


[Section titled SVG components](#svg-components)

**Added in:** `astro@5.7.0`

Astro allows you to import SVG files and use them as Astro components. Astro will inline the SVG content into your HTML output.

Reference the default import of any local `.svg` file. Since this import is treated as an Astro component, you must use the same conventions (e.g. capitalization) as when [using dynamic tags](/en/reference/astro-syntax/#dynamic-tags).

src/components/MyAstroComponent.astro

```
---import Logo from'./path/to/svg/file.svg';---<Logo />
```

Your SVG component, like `<Image />` or any other Astro component, is unavailable inside UI framework components, but can [be passed to a framework component](#images-in-ui-framework-components) inside a `.astro` component.


### SVG component attributes


[Section titled SVG component attributes](#svg-component-attributes)

You can pass props such as `width`, `height`, `fill`, `stroke`, and any other attribute accepted by the [native `<svg>` element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg). These attributes will automatically be applied to the underlying `<svg>` element. If a property is present in the original `.svg` file and is passed to the component, the value passed to the component will override the original value.

src/components/MyAstroComponent.astro

```
---import Logo from'../assets/logo.svg';---<Logowidth={64}height={64}fill="currentColor" />
```


## Using Images from a CMS or CDN


[Section titled Using Images from a CMS or CDN](#using-images-from-a-cms-or-cdn)

Image CDNs work with [all Astro image options](#images-in-astro-files). Use an image’s full URL as the `src` attribute in the `<Image />` component, an `<img>` tag, or in Markdown notation. For image optimization with remote images, also [configure your authorized domains or URL patterns](#authorizing-remote-images).

Alternatively, the CDN may provide its own SDKs to more easily integrate in an Astro project. For example, Cloudinary supports an [Astro SDK](https://astro.cloudinary.dev/) which allows you to easily drop in images with their `CldImage` component or a [Node.js SDK](https://cloudinary.com/documentation/node_integration) that can generate URLs to use with an `<img>` tag in a Node.js environment.

See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components.


## Images in Markdown files


[Section titled Images in Markdown files](#images-in-markdown-files)

Use standard Markdown `![alt](src)` syntax in your `.md` files. This syntax works with Astro’s [Image Service API](/en/reference/image-service-reference/) to optimize your local images stored in `src/` and remote images. Images stored in the `public/` folder are never optimized.

src/pages/post-1.md

```

# My Markdown Page<!-- Local image stored in src/assets/ --><!-- Use a relative file path or import alias -->![A starry night sky.](../assets/stars.png)<!-- Image stored in public/images/ --><!-- Use the file path relative to public/ -->![A starry night sky.](/images/stars.png)<!-- Remote image on another server --><!-- Use the full URL of the image -->![Astro](https://example.com/images/remote-image.png)

```

The HTML `<img>` tag can also be used to display images stored in `public/` or remote images without any image optimization or processing. However, `<img>` is not supported for your local images in `src`.

The `<Image />` and `<Picture />` components are unavailable in `.md` files. If you require more control over your image attributes, we recommend using [Astro’s MDX integration](/en/guides/integrations-guide/mdx/) to add support for `.mdx` file format. MDX allows additional [image options available in MDX](#images-in-mdx-files), including combining components with Markdown syntax.


## Images in MDX files


[Section titled Images in MDX files](#images-in-mdx-files)

You can use Astro’s `<Image />` and `<Picture />` components in your `.mdx` files by importing both the component and your image. Use them just as they are [used in `.astro` files](#images-in-astro-files). The JSX `<img />` tag is also supported for unprocessed images and [uses the same image import as the HTML `<img>` tag](#display-unprocessed-images-with-the-html-img-tag).

Additionally, there is support for [standard Markdown `![alt](src)` syntax](#images-in-markdown-files) with no import required.

src/pages/post-1.mdx

```
---title: My Page title---import { Image } from'astro:assets';import rocket from'../assets/rocket.png';# My MDX Page// Local image stored in the the same folder![Houston in the wild](houston.png)// Local image stored in src/assets/<Imagesrc={rocket}alt="A rocketship in space."/><imgsrc={rocket.src}alt="A rocketship in space."/>![A rocketship in space](../assets/rocket.png)// Image stored in public/images/<Imagesrc="/images/stars.png"alt="A starry night sky."/><imgsrc="/images/stars.png"alt="A starry night sky."/>![A starry night sky.](/images/stars.png)// Remote image on another server<Imagesrc="https://example.com/images/remote-image.png"/><imgsrc="https://example.com/images/remote-image.png"/>![Astro](https://example.com/images/remote-image.png)
```

See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components.


## Images in content collections


[Section titled Images in content collections](#images-in-content-collections)

Images in content collections will be processed the same way they are in [Markdown](#images-in-markdown-files) and [MDX](#images-in-mdx-files) depending on which file type you are using.

Additionally, you can declare an associated image for a content collections entry, such as a blog post’s cover image, in your frontmatter using its path relative to the current folder:

src/content/blog/my-post.md

```
---title: "My first blog post"cover: "./firstpostcover.jpeg"# will resolve to "src/content/blog/firstblogcover.jpeg"coverAlt: "A photograph of a sunset behind a mountain range."---This is a blog post
```

The `image` helper for the content collections schema lets you validate and import the image.

src/content.config.ts

```
import { defineCollection, z } from"astro:content";const blogCollection = defineCollection({schema: ({ image }) => z.object({title: z.string(),cover: image(),coverAlt: z.string(),}),});export const collections = {blog: blogCollection,};
```

The image will be imported and transformed into metadata, allowing you to pass it as a `src` to `<Image/>`, `<img>`, or `getImage()`.

The example below shows a blog index page that renders the cover photo and title of each blog post from the schema above:

src/pages/blog.astro

```
---import { Image } from"astro:assets";import { getCollection } from"astro:content";const allBlogPosts = await getCollection("blog");---{allBlogPosts.map((post)=> (<div><Imagesrc={post.data.cover}alt={post.data.coverAlt} /><h2><ahref={"/blog/"+post.slug}>{post.data.title}</a></h2></div>))}
```


## Images in UI framework components


[Section titled Images in UI framework components](#images-in-ui-framework-components)

The `<Image />` component, like any other Astro component, is unavailable inside UI framework components.

But, you can pass the static content generated by `<Image />` to a framework component inside a `.astro` file [as children](/en/guides/framework-components/#passing-children-to-framework-components) or using a [named `<slot/>`](/en/guides/framework-components/#can-i-use-astro-components-inside-my-framework-components):

src/components/ImageWrapper.astro

```
---import ReactComponent from'./ReactComponent.jsx';import { Image } from'astro:assets';import stars from'~/stars/docline.png';---<ReactComponent><Imagesrc={stars}alt="A starry night sky." /></ReactComponent>
```

You can also use the framework’s own image syntax to render an image (e.g. `<img />` in JSX, `<img>` in Svelte).

[Local images must first be imported](#display-unprocessed-images-with-the-html-img-tag) to access their image properties such as `src`.

src/components/ReactImage.jsx

```
import stars from"../assets/stars.png";exportdefaultfunctionReactImage() {return (<imgsrc={stars.src}alt="A starry night sky." />)}
```

src/components/SvelteImage.svelte

```
<script>import stars from'../assets/stars.png';</script><imgsrc={stars.src}alt="A starry night sky." />
```


## Generating images with `getImage()`


[Section titled Generating images with getImage()](#generating-images-with-getimage)

The `getImage()` function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an [API Route](/en/guides/endpoints/#server-endpoints-api-routes). When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create your own custom `<Image />` component.

See more in the [`getImage()` reference](/en/reference/modules/astro-assets/#getimage).

**Related recipe:** [Build a custom image component](/en/recipes/build-custom-img-component/)


## Alt Text


[Section titled Alt Text](#alt-text)

Not all users can see images in the same way, so accessibility is an especially important concern when using images. Use the `alt` attribute to provide [descriptive alt text](https://www.w3.org/WAI/tutorials/images/) for images.

This attribute is required for both the `<Image />` and `<Picture />` components. If no alt text is provided, a helpful error message will be provided reminding you to include the `alt` attribute.

If the image is merely decorative (i.e. doesn’t contribute to the understanding of the page), set `alt=""` so that screen readers know to ignore the image.


## Default image service


[Section titled Default image service](#default-image-service)

[Sharp](https://github.com/lovell/sharp) is the default image service used for `astro:assets`. You can further configure the image service using the [`image.service`](/en/reference/configuration-reference/#imageservice) option.

Note

When using a [strict package manager](https://pnpm.io/pnpm-vs-npm#npms-flat-tree) like `pnpm`, you may need to manually install Sharp into your project even though it is an Astro dependency:

Terminal window

```
pnpmaddsharp
```


### Configure no-op passthrough service


[Section titled Configure no-op passthrough service](#configure-no-op-passthrough-service)

If your [adapter](https://astro.build/integrations/?search=&categories%5B%5D=adapters) does not support Astro’s built-in Sharp image optimization (e.g. Deno, Cloudflare), you can configure a no-op image service to allow you to use the `<Image />` and `<Picture />` components. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using `astro:assets`, including no Cumulative Layout Shift (CLS), the enforced `alt` attribute, and a consistent authoring experience.

Configure the `passthroughImageService()` to avoid Sharp image processing:

astro.config.mjs

```
import { defineConfig, passthroughImageService } from'astro/config';exportdefaultdefineConfig({image: {service: passthroughImageService()}});
```


## Asset Caching


[Section titled Asset Caching](#asset-caching)

Astro stores processed image assets in a cache directory during site builds for both local and [remote images from authorized sources](#authorizing-remote-images). By preserving the cache directory between builds, processed assets are reused, improving build time and bandwidth usage.

The default cache directory is `./node_modules/.astro`, however this can be changed using the [`cacheDir`](/en/reference/configuration-reference/#cachedir) configuration setting.


### Remote Images


[Section titled Remote Images](#remote-images-2)

Remote images in the asset cache are managed based on [HTTP Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching), and respect the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) returned by the remote server. Images are cached if the Cache-Control header allows, and will be used until they are no longer [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age).


#### Revalidation


[Section titled Revalidation](#revalidation)

**Added in:** `astro@5.1.0`

[Revalidation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#validation) reduces bandwidth usage and build time by checking with the remote server whether an expired cached image is still up-to-date. If the server indicates that the image is still fresh, the cached version is reused, otherwise the image is redownloaded.

Revalidation requires that the remote server send [Last-Modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) and/or [Etag (entity tag)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) headers with its responses. This feature is available for remote servers that support the [If-Modified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since) and [If-None-Match](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) headers.


## Community Integrations


[Section titled Community Integrations](#community-integrations)

There are several third-party [community image integrations](https://astro.build/integrations?search=images) for optimizing and working with images in your Astro project.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 95. `en/guides/imports/.md`

```text
# Imports reference


---
url: https://docs.astro.build/en/guides/imports/
description: Learn how to import different file types into your Astro project.
---


# Imports reference


Astro supports most static assets with zero configuration required. You can use the `import` statement anywhere in your project JavaScript (including your Astro frontmatter) and Astro will include a built, optimized copy of that static asset in your final build. `@import` is also supported inside of CSS & `<style>` tags.


## Supported File Types


[Section titled Supported File Types](#supported-file-types)

The following file types are supported out-of-the-box by Astro:

-   Astro Components (`.astro`)
-   Markdown (`.md`, `.markdown`, etc.)
-   JavaScript (`.js`, `.mjs`)
-   TypeScript (`.ts`)
-   NPM Packages
-   JSON (`.json`)
-   CSS (`.css`)
-   CSS Modules (`.module.css`)
-   Images & Assets (`.svg`, `.jpg`, `.png`, etc.)

Additionally, you can extend Astro to add support for different [UI Frameworks](/en/guides/framework-components/) like React, Svelte and Vue components. You can also install the [Astro MDX integration](/en/guides/integrations-guide/mdx/) or the [Astro Markdoc integration](/en/guides/integrations-guide/markdoc/) to use `.mdx` or `.mdoc` files in your project.


### Files in `public/`


[Section titled Files in public/](#files-in-public)

You can place any static asset in the [`public/` directory](/en/basics/project-structure/#public) of your project, and Astro will copy it directly into your final build untouched. `public/` files are not built or bundled by Astro, which means that any type of file is supported.

You can reference a `public/` file by a URL path directly in your HTML templates.

```
// To link to /public/reports/annual/2024.pdfDownload the <ahref="/reports/annual/2024.pdf">2024 annual statement as a PDF</a>.// To display /public/assets/cats/ginger.jpg<imgsrc="/assets/cats/ginger.jpg"alt="An orange cat sleeping on a bed.">
```


## Import statements


[Section titled Import statements](#import-statements)

Astro uses ESM, the same [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#syntax) and [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) syntax supported in the browser.


### JavaScript


[Section titled JavaScript](#javascript)

```
import { getUser } from'./user.js';
```

JavaScript can be imported using normal ESM `import` & `export` syntax.

Importing JSX files

An appropriate [UI framework](/en/guides/framework-components/) ([React](/en/guides/integrations-guide/react/), [Preact](/en/guides/integrations-guide/preact/), or [Solid](/en/guides/integrations-guide/solid-js/)) is required to render JSX/TSX files. Use `.jsx`/`.tsx` extensions where appropriate, as Astro does not support JSX in `.js`/`.ts` files.


### TypeScript


[Section titled TypeScript](#typescript)

```
import { getUser } from'./user';importtype { UserType } from'./user';
```

Astro includes built-in support for [TypeScript](https://www.typescriptlang.org/). You can import `.ts` and `.tsx` files directly in your Astro project, and even write TypeScript code directly inside your [Astro component script](/en/basics/astro-components/#the-component-script) and any [script tags](/en/guides/client-side-scripts/).

**Astro doesn’t perform any type checking itself.** Type checking should be taken care of outside of Astro, either by your IDE or through a separate script. For type checking Astro files, the [`astro check` command](/en/reference/cli-reference/#astro-check) is provided.

TypeScript and file extensions

Per [TypeScript’s module resolution rules](https://www.typescriptlang.org/docs/handbook/module-resolution.html), `.ts` and `.tsx` file extensions should not be used when importing TypeScript files. Instead, either use `.js`/`.jsx` file extensions or completely omit the file extension.

```
import { getUser } from'./user.js'; // user.tsimport MyComponent from"./MyComponent"; // MyComponent.tsx
```

Read more about [TypeScript support in Astro](/en/guides/typescript/).


### NPM Packages


[Section titled NPM Packages](#npm-packages)

If you’ve installed an NPM package, you can import it in Astro.

```
---import { Icon } from'astro-icon';---
```

If a package was published using a legacy format, Astro will try to convert the package to ESM so that `import` statements work. In some cases, you may need to adjust your [`vite` config](/en/reference/configuration-reference/#vite) for it to work.

Caution

Some packages rely on a browser environment. Astro components runs on the server, so importing these packages in the frontmatter may [lead to errors](/en/guides/troubleshooting/#document-or-window-is-not-defined).


### JSON


[Section titled JSON](#json)

```
// Load the JSON object via the default exportimport json from'./data.json';
```

Astro supports importing JSON files directly into your application. Imported files return the full JSON object in the default import.


### CSS


[Section titled CSS](#css)

```
// Load and inject 'style.css' onto the pageimport'./style.css';
```

Astro supports importing CSS files directly into your application. Imported styles expose no exports, but importing one will automatically add those styles to the page. This works for all CSS files by default, and can support compile-to-CSS languages like Sass & Less via plugins.

Read more about advanced CSS import use cases such as a direct URL reference for a CSS file, or importing CSS as a string in the [Styling guide](/en/guides/styling/#advanced).


### CSS Modules


[Section titled CSS Modules](#css-modules)

```
// 1. Converts './style.module.css' classnames to unique, scoped values.// 2. Returns an object mapping the original classnames to their final, scoped value.import styles from'./style.module.css';// This example uses JSX, but you can use CSS Modules with any framework.return<divclassName={styles.error}>Your Error Message</div>;
```

Astro supports CSS Modules using the `[name].module.css` naming convention. Like any CSS file, importing one will automatically apply that CSS to the page. However, CSS Modules export a special default `styles` object that maps your original classnames to unique identifiers.

CSS Modules help you enforce component scoping & isolation on the frontend with uniquely-generated class names for your stylesheets.


### Other Assets


[Section titled Other Assets](#other-assets)

```
import imgReference from'./image.png'; // imgReference === '/src/image.png'import svgReference from'./image.svg'; // svgReference === '/src/image.svg'import txtReference from'./words.txt'; // txtReference === '/src/words.txt'// This example uses JSX, but you can use import references with any framework.<imgsrc={imgReference.src}alt="image description" />;
```

All other assets not explicitly mentioned above can be imported via ESM `import` and will return a URL reference to the final built asset. This can be useful for referencing non-JS assets by URL, like creating an image element with a `src` attribute pointing to that image.

It can also be useful to place images in the `public/` folder as explained on the [project-structure page](/en/basics/project-structure/#public).

Read more about appending Vite import parameters (e.g. `?url`, `?raw`) in [Vite’s static asset handling guide](https://vite.dev/guide/assets.html).

Note

Adding **alt text** to `<img>` tags is encouraged for accessibility! Don’t forget to add an `alt="a helpful description"` attribute to your image elements. You can just leave the attribute empty if the image is purely decorative.


## Aliases


[Section titled Aliases](#aliases)

An **alias** is a way to create shortcuts for your imports.

Aliases can help improve the development experience in codebases with many directories or relative imports.

src/pages/about/company.astro

```
---import Button from'../../components/controls/Button.astro';import logoUrl from'../../assets/logo.png?url';---
```

In this example, a developer would need to understand the tree relationship between `src/pages/about/company.astro`, `src/components/controls/Button.astro`, and `src/assets/logo.png`. And then, if the `company.astro` file were to be moved, these imports would also need to be updated.

You can add import aliases in `tsconfig.json`.

tsconfig.json

```
{"compilerOptions": {"baseUrl": ".","paths": {"@components/*": ["src/components/*"],"@assets/*": ["src/assets/*"]}}}
```

Note

Make sure `compilerOptions.baseUrl` is set so the aliased paths can be resolved.

The development server will automatically restart after this configuration change. You can now import using the aliases anywhere in your project:

src/pages/about/company.astro

```
---import Button from'@components/controls/Button.astro';import logoUrl from'@assets/logo.png?url';---
```

These aliases are also integrated automatically into [VS Code](https://code.visualstudio.com/docs/languages/jsconfig) and other editors.


## `import.meta.glob()`


[Section titled import.meta.glob()](#importmetaglob)

[Vite’s `import.meta.glob()`](https://vite.dev/guide/features.html#glob-import) is a way to import many files at once using glob patterns to find matching file paths.

`import.meta.glob()` takes a relative [glob pattern](#glob-patterns) matching the local files you’d like to import as a parameter. It returns an array of each matching file’s exports. To load all matched modules up front, pass `{ eager: true }` as the second argument:

src/components/my-component.astro

```
---// imports all files that end with `.md` in `./src/pages/post/`const matches = import.meta.glob('../pages/post/*.md', { eager: true });const posts = Object.values(matches);---<!-- Renders an <article> for the first 5 blog posts --><div>{posts.slice(0, 4).map((post)=> (<article><h2>{post.frontmatter.title}</h2><p>{post.frontmatter.description}</p><ahref={post.url}>Read more</a></article>))}</div>
```

Astro components imported using `import.meta.glob` are of type [`AstroInstance`](#astro-files). You can render each component instance using its `default` property:

src/pages/component-library.astro

```
---// imports all files that end with `.astro` in `./src/components/`const components = Object.values(import.meta.glob('../components/*.astro', { eager: true }));---<!-- Display all of our components -->{components.map((component)=> (<div><component.defaultsize={24} /></div>))}
```


### Supported Values


[Section titled Supported Values](#supported-values)

Vite’s `import.meta.glob()` function only supports static string literals. It does not support dynamic variables and string interpolation.

A common workaround is to instead import a larger set of files that includes all the files you need, then filter them:

src/components/featured.astro

```
---const { postSlug } = Astro.props;const pathToMyFeaturedPost = `src/pages/blog/${postSlug}.md`;const posts = Object.values(import.meta.glob("../pages/blog/*.md", { eager: true }));const myFeaturedPost = posts.find(post => post.file.includes(pathToMyFeaturedPost));---<p>Take a look at my favorite post, <ahref={myFeaturedPost.url}>{myFeaturedPost.frontmatter.title}</a>!</p>
```


### Import type utilities


[Section titled Import type utilities](#import-type-utilities)


#### Markdown files


[Section titled Markdown files](#markdown-files)

Markdown files loaded with `import.meta.glob()` return the following `MarkdownInstance` interface:

```
exportinterface MarkdownInstance<TextendsRecord<string, any>> {/* Any data specified in this file's YAML/TOML frontmatter */frontmatter:T;/* The absolute file path of this file */file:string;/* The rendered path of this file */url:string|undefined;/* Astro Component that renders the contents of this file */Content:AstroComponentFactory;/** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML/TOML frontmatter */rawContent():string;/** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */compiledContent():string;/* Function that returns an array of the h1...h6 elements in this file */getHeadings():Promise<{ depth:number; slug:string; text:string }[]>;default:AstroComponentFactory;}
```

You can optionally provide a type for the `frontmatter` variable using a TypeScript generic.

```
---importtype { MarkdownInstance } from'astro';interface Frontmatter {title:string;description?:string;}const posts = Object.values(import.meta.glob<MarkdownInstance<Frontmatter>>('./posts/**/*.md', { eager: true }));---<ul>{posts.map(post=><li>{post.frontmatter.title}</li>)}</ul>
```


#### Astro files


[Section titled Astro files](#astro-files)

Astro files have the following interface:

```
exportinterface AstroInstance {/* The file path of this file */file:string;/* The URL for this file (if it is in the pages directory) */url:string|undefined;default:AstroComponentFactory;}
```


#### Other files


[Section titled Other files](#other-files)

Other files may have various different interfaces, but `import.meta.glob()` accepts a TypeScript generic if you know exactly what an unrecognized file type contains.

```
---interface CustomDataFile {default:Record<string, any>;}const data = import.meta.glob<CustomDataFile>('../data/**/*.js');---
```


### Glob Patterns


[Section titled Glob Patterns](#glob-patterns)

A glob pattern is a file path that supports special wildcard characters. This is used to reference multiple files in your project at once.

For example, the glob pattern `./pages/**/*.{md,mdx}` starts within the pages subdirectory, looks through all of its subdirectories (`/**`), and matches any filename (`/*`) that ends in either `.md` or `.mdx` (`.{md,mdx}`).


#### Glob Patterns in Astro


[Section titled Glob Patterns in Astro](#glob-patterns-in-astro)

To use with `import.meta.glob()`, the glob pattern must be a string literal and cannot contain any variables.

Additionally, glob patterns must begin with one of the following:

-   `./` (to start in the current directory)
-   `../` (to start in the parent directory)
-   `/` (to start at the root of the project)

[Read more about the glob pattern syntax](https://github.com/micromatch/picomatch#globbing-features).


### `import.meta.glob()` vs `getCollection()`


[Section titled import.meta.glob() vs getCollection()](#importmetaglob-vs-getcollection)

[Content collections](/en/guides/content-collections/) provide a [`getCollection()` API](/en/reference/modules/astro-content/#getcollection) for loading multiple files instead of `import.meta.glob()`. If your content files (e.g. Markdown, MDX, Markdoc) are located in collections within the `src/content/` directory, use `getCollection()` to [query a collection](/en/guides/content-collections/#querying-collections) and return content entries.


## WASM


[Section titled WASM](#wasm)

```
// Loads and initializes the requested WASM fileconst wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm'));
```

Astro supports loading WASM files directly into your application using the browser’s [`WebAssembly`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly) API.


## Node Builtins


[Section titled Node Builtins](#node-builtins)

Astro supports Node.js built-ins, with some limitations, using Node’s newer `node:` prefix. There may be differences between development and production, and some features may be incompatible with on-demand rendering. Some [adapters](/en/guides/on-demand-rendering/) may also be incompatible with these built-ins modules or require configuration to support a subset (e.g., [Cloudflare Workers](/en/guides/integrations-guide/cloudflare/) or [Deno](https://github.com/denoland/deno-astro-adapter)).

The following example imports the `util` module from Node to parse a media type (MIME):

src/components/MyComponent.astro

```
---// Example: import the "util" built-in from Node.jsimport util from'node:util';exportinterface Props {mimeType:string,}const mime = newutil.MIMEType(Astro.props.mimeType)---<span>Type: {mime.type}</span><span>SubType: {mime.subtype}</span>
```


## Extending file type support


[Section titled Extending file type support](#extending-file-type-support)

With **Vite** and compatible **Rollup** plugins, you can import file types which aren’t natively supported by Astro. Learn where to find the plugins you need in the [Finding Plugins](https://vite.dev/guide/using-plugins.html#finding-plugins) section of the Vite Documentation.

Plugin configuration

Refer to your plugin’s documentation for configuration options, and how to correctly install it.

**Related recipe:** [Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 96. `en/guides/integrations-guide/.md`

```text
# Add Integrations


---
url: https://docs.astro.build/en/guides/integrations-guide/
description: Learn how to add integrations to your Astro project.
---


# Add Integrations


**Astro integrations** add new functionality and behaviors for your project with only a few lines of code. You can use an official integration, [integrations built by the community](#finding-more-integrations) or even [build a custom integration yourself](#building-your-own-integration).

Integrations can…

-   Unlock React, Vue, Svelte, Solid, and other popular UI frameworks with a [renderer](/en/guides/framework-components/).
-   Enable on-demand rendering with an [SSR adapter](/en/guides/on-demand-rendering/).
-   Integrate tools like MDX, and Partytown with a few lines of code.
-   Add new features to your project, like automatic sitemap generation.
-   Write custom code that hooks into the build process, dev server, and more.

Integrations directory

Browse or search the complete set of hundreds of official and community integrations in our [integrations directory](https://astro.build/integrations/). Find packages to add to your Astro project for authentication, analytics, performance, SEO, accessibility, UI, developer tools, and more.


## Official Integrations


[Section titled Official Integrations](#official-integrations)

The following integrations are maintained by Astro.


### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)



## Automatic Integration Setup


[Section titled Automatic Integration Setup](#automatic-integration-setup)

Astro includes an `astro add` command to automate the setup of official integrations. Several community plugins can also be added using this command. Please check each integration’s own documentation to see whether `astro add` is supported, or whether you must [install manually](#manual-installation).

Run the `astro add` command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies.

-   [npm](#tab-panel-3192)
-   [pnpm](#tab-panel-3193)
-   [Yarn](#tab-panel-3194)

Terminal window

```
npxastroaddreact
```

Terminal window

```
pnpmastroaddreact
```

Terminal window

```
yarnastroaddreact
```

It’s even possible to add multiple integrations at the same time!

-   [npm](#tab-panel-3195)
-   [pnpm](#tab-panel-3196)
-   [Yarn](#tab-panel-3197)

Terminal window

```
npxastroaddreactsitemappartytown
```

Terminal window

```
pnpmastroaddreactsitemappartytown
```

Terminal window

```
yarnastroaddreactsitemappartytown
```

Handling integration dependencies

If you see any warnings like `Cannot find package '[package-name]'` after adding an integration, your package manager may not have installed [peer dependencies](https://nodejs.org/en/blog/npm/peer-dependencies/) for you. To install these missing packages, run the following command:

-   [npm](#tab-panel-3198)
-   [pnpm](#tab-panel-3199)
-   [Yarn](#tab-panel-3200)

Terminal window

```
npminstall [package-name]
```

Terminal window

```
pnpmadd [package-name]
```

Terminal window

```
yarnadd [package-name]
```


### Manual Installation


[Section titled Manual Installation](#manual-installation)

Astro integrations are always added through the `integrations` property in your `astro.config.mjs` file.

There are three common ways to import an integration into your Astro project:

1.  [Install an npm package integration](#installing-an-npm-package).

2.  Import your own integration from a local file inside your project.

3.  Write your integration inline, directly in your config file.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import installedIntegration from'@astrojs/vue';import localIntegration from'./my-integration.js';exportdefaultdefineConfig({integrations: [// 1. Imported from an installed npm packageinstalledIntegration(),// 2. Imported from a local JS filelocalIntegration(),// 3. An inline object{name: 'namespace:id', hooks: { /* ... */ }},]});
    ```


Check out the [Integration API](/en/reference/integrations-reference/) reference to learn all of the different ways that you can write an integration.


#### Installing an NPM package


[Section titled Installing an NPM package](#installing-an-npm-package)

Install an NPM package integration using a package manager, and then update `astro.config.mjs` manually.

For example, to install the `@astrojs/sitemap` integration:

1.  Install the integration to your project dependencies using your preferred package manager:

    -   [npm](#tab-panel-3201)
    -   [pnpm](#tab-panel-3202)
    -   [Yarn](#tab-panel-3203)

    Terminal window

    ```
    npminstall@astrojs/sitemap
    ```

    Terminal window

    ```
    pnpmadd@astrojs/sitemap
    ```

    Terminal window

    ```
    yarnadd@astrojs/sitemap
    ```

2.  Import the integration to your `astro.config.mjs` file, and add it to your `integrations[]` array, along with any configuration options:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import sitemap from'@astrojs/sitemap';exportdefaultdefineConfig({// ...integrations: [sitemap()],// ...});
    ```

    Note that different integrations may have different configuration settings. Read each integration’s documentation, and apply any necessary config options to your chosen integration in `astro.config.mjs`.



### Custom Options


[Section titled Custom Options](#custom-options)

Integrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project.

```
integrations: [// Example: Customize your integration with function argumentssitemap({filter: true})]
```


### Toggle an Integration


[Section titled Toggle an Integration](#toggle-an-integration)

Falsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind `undefined` and boolean values.

```
integrations: [// Example: Skip building a sitemap on Windowsprocess.platform!=='win32'&&sitemap()]
```


## Upgrading Integrations


[Section titled Upgrading Integrations](#upgrading-integrations)

To upgrade all official integrations at once, run the `@astrojs/upgrade` command. This will upgrade both Astro and all official integrations to their latest versions.


### Automatic Upgrading


[Section titled Automatic Upgrading](#automatic-upgrading)

-   [npm](#tab-panel-3204)
-   [pnpm](#tab-panel-3205)
-   [Yarn](#tab-panel-3206)

Terminal window

```

# Upgrade Astro and official integrations together to latestnpx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations together to latestpnpmdlx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations together to latestyarndlx@astrojs/upgrade

```


### Manual Upgrading


[Section titled Manual Upgrading](#manual-upgrading)

To upgrade one or more integrations manually, use the appropriate command for your package manager.

-   [npm](#tab-panel-3207)
-   [pnpm](#tab-panel-3208)
-   [Yarn](#tab-panel-3209)

Terminal window

```

# Example: upgrade React and Partytown integrationsnpminstall@astrojs/react@latest@astrojs/partytown@latest

```

Terminal window

```

# Example: upgrade React and Partytown integrationspnpmadd@astrojs/react@latest@astrojs/partytown@latest

```

Terminal window

```

# Example: upgrade React and Partytown integrationsyarnadd@astrojs/react@latest@astrojs/partytown@latest

```


## Removing an Integration


[Section titled Removing an Integration](#removing-an-integration)

1.  To remove an integration, first uninstall the integration from your project.

    -   [npm](#tab-panel-3210)
    -   [pnpm](#tab-panel-3211)
    -   [Yarn](#tab-panel-3212)

    Terminal window

    ```
    npmuninstall@astrojs/react
    ```

    Terminal window

    ```
    pnpmremove@astrojs/react
    ```

    Terminal window

    ```
    yarnremove@astrojs/react
    ```

2.  Next, remove the integration from your `astro.config.*` file:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import react from'@astrojs/react';exportdefaultdefineConfig({integrations: [react()]});
    ```



## Finding More Integrations


[Section titled Finding More Integrations](#finding-more-integrations)

You can find many integrations developed by the community in the [Astro Integrations Directory](https://astro.build/integrations/). Follow links there for detailed usage and configuration instructions.


## Building Your Own Integration


[Section titled Building Your Own Integration](#building-your-own-integration)

Astro’s Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before.

Check out the [Integration API](/en/reference/integrations-reference/) reference to learn what integrations can do and how to write one yourself.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 97. `en/guides/integrations-guide/alpinejs/.md`

```text
# @astrojs/

					alpinejs

---
url: https://docs.astro.build/en/guides/integrations-guide/alpinejs/
description: Learn how to use the @astrojs/alpinejs framework integration to extend component support in your Astro project.
---


# @astrojs/ alpinejs


v0.4.8 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/alpinejs/) [npm](https://www.npmjs.com/package/@astrojs/alpinejs) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/alpinejs/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** adds [Alpine.js](https://alpinejs.dev/) to your project so that you can use Alpine.js anywhere on your page.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/alpinejs`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3177)
-   [pnpm](#tab-panel-3178)
-   [Yarn](#tab-panel-3179)

Terminal window

```
npxastroaddalpinejs
```

Terminal window

```
pnpmastroaddalpinejs
```

Terminal window

```
yarnastroaddalpinejs
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/alpinejs` package.

-   [npm](#tab-panel-3180)
-   [pnpm](#tab-panel-3181)
-   [Yarn](#tab-panel-3182)

Terminal window

```
npminstall@astrojs/alpinejs
```

Terminal window

```
pnpmadd@astrojs/alpinejs
```

Terminal window

```
yarnadd@astrojs/alpinejs
```

Most package managers will install associated peer dependencies as well. However, if you see a `Cannot find package 'alpinejs'` (or similar) warning when you start up Astro, you’ll need to manually install Alpine.js yourself:

-   [npm](#tab-panel-3183)
-   [pnpm](#tab-panel-3184)
-   [Yarn](#tab-panel-3185)

Terminal window

```
npminstallalpinejs@types/alpinejs
```

Terminal window

```
pnpmaddalpinejs@types/alpinejs
```

Terminal window

```
yarnaddalpinejs@types/alpinejs
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import alpinejs from'@astrojs/alpinejs';exportdefaultdefineConfig({// ...integrations: [alpinejs()],});
```


## Configuration Options


[Section titled Configuration Options](#configuration-options)


### `entrypoint`


[Section titled entrypoint](#entrypoint)

You can extend Alpine by setting the `entrypoint` option to a root-relative import specifier (e.g. `entrypoint: "/src/entrypoint"`).

The default export of this file should be a function that accepts an Alpine instance prior to starting. This allows the use of custom directives, plugins and other customizations for advanced use cases.

astro.config.mjs

```
import { defineConfig } from'astro/config';import alpine from'@astrojs/alpinejs';exportdefaultdefineConfig({// ...integrations: [alpine({ entrypoint: '/src/entrypoint' })],});
```

src/entrypoint.ts

```
importtype { Alpine } from'alpinejs'import intersect from'@alpinejs/intersect'exportdefault(Alpine:Alpine)=> {Alpine.plugin(intersect)}
```


## Usage


[Section titled Usage](#usage)

Once the integration is installed, you can use [Alpine.js](https://alpinejs.dev/) directives and syntax inside any Astro component. The Alpine.js script is automatically added and enabled on every page of your website so no client directives are needed. Add plugin scripts to the page `<head>`.

The following example adds [Alpine’s Collapse plugin](https://alpinejs.dev/plugins/collapse) to expand and collapse paragraph text:

src/pages/index.astro

```
------<html><head><!-- ... --><scriptdefersrc="https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script></head><body><!-- ... --><divx-data="{ expanded: false }"><button@click="expanded = ! expanded">Toggle Content</button><pid="foo"x-show="expanded"x-collapse>Lorem ipsum</p></div></body></html>
```


## Intellisense for TypeScript


[Section titled Intellisense for TypeScript](#intellisense-for-typescript)

The `@astrojs/alpine` integration adds `Alpine` to the global window object. For IDE autocompletion, add the following to your `src/env.d.ts`:

src/env.d.ts

```
interface Window {Alpine:import('alpinejs').Alpine;}
```


## Examples


[Section titled Examples](#examples)

-   The [Astro Alpine.js example](https://github.com/withastro/astro/tree/main/examples/framework-alpine) shows how to use Alpine.js in an Astro project.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 98. `en/guides/integrations-guide/cloudflare/.md`

```text
# @astrojs/

					cloudflare

---
url: https://docs.astro.build/en/guides/integrations-guide/cloudflare/
description: Learn how to use the @astrojs/cloudflare adapter to deploy your Astro project.
---


# @astrojs/ cloudflare


v12.5.3 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/cloudflare/) [npm](https://www.npmjs.com/package/@astrojs/cloudflare) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/cloudflare/CHANGELOG.md)

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Cloudflare](https://www.cloudflare.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/).

If you’re using Astro as a static site builder, you don’t need an adapter.

Learn how to deploy your Astro site in our [Cloudflare deployment guide](/en/guides/deploy/cloudflare/).


## Why Astro Cloudflare


[Section titled Why Astro Cloudflare](#why-astro-cloudflare)

Cloudflare’s [Developer Platform](https://developers.cloudflare.com/) lets you develop full-stack applications with access to resources such as storage and AI, all deployed to a global edge network. This adapter builds your Astro project for deployment through Cloudflare.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Add the Cloudflare adapter to enable server-rendering in your Astro project with the `astro add` command. This will install `@astrojs/cloudflare` and make the appropriate changes to your `astro.config.mjs` file in one step.

-   [npm](#tab-panel-3227)
-   [pnpm](#tab-panel-3228)
-   [Yarn](#tab-panel-3229)

Terminal window

```
npxastroaddcloudflare
```

Terminal window

```
pnpmastroaddcloudflare
```

Terminal window

```
yarnastroaddcloudflare
```

Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode).


### Manual Install


[Section titled Manual Install](#manual-install)

First, add the `@astrojs/cloudflare` adapter to your project’s dependencies using your preferred package manager.

-   [npm](#tab-panel-3230)
-   [pnpm](#tab-panel-3231)
-   [Yarn](#tab-panel-3232)

Terminal window

```
npminstall@astrojs/cloudflare
```

Terminal window

```
pnpmadd@astrojs/cloudflare
```

Terminal window

```
yarnadd@astrojs/cloudflare
```

Then, add the adapter to your `astro.config.mjs` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';import cloudflare from'@astrojs/cloudflare';exportdefaultdefineConfig({adapter: cloudflare(),});
```


## Options


[Section titled Options](#options)

The Cloudflare adapter accepts the following options:


### `cloudflareModules`


[Section titled cloudflareModules](#cloudflaremodules)

**Type:** `boolean` **Default:** `true`

Enables [imports of `.wasm`, `.bin`, and `.txt` modules](#cloudflare-module-imports).

This functionality is enabled by default. If you’d like to disable, set `cloudflareModules` to `false`.


### `imageService`


[Section titled imageService](#imageservice)

**Type:** `'passthrough' | 'cloudflare' | 'compile' | 'custom'` **Default:** `'compile'`

Determines which image service is used by the adapter. The adapter will default to `compile` mode when an incompatible image service is configured. Otherwise, it will use the globally configured image service:

-   **`cloudflare`:** Uses the [Cloudflare Image Resizing](https://developers.cloudflare.com/images/image-resizing/) service.
-   **`passthrough`:** Uses the existing [`noop`](/en/guides/images/#configure-no-op-passthrough-service) service.
-   **`compile`:** Uses Astro’s default service (sharp), but only on pre-rendered routes at build time. For pages rendered on-demand, all `astro:assets` features are disabled.
-   **`custom`:** Always uses the image service configured in [Image Options](/en/reference/configuration-reference/#image-options). **This option will not check to see whether the configured image service works in Cloudflare’s `workerd` runtime.**

astro.config.mjs

```
import { defineConfig } from"astro/config";import cloudflare from'@astrojs/cloudflare';exportdefaultdefineConfig({adapter: cloudflare({imageService: 'cloudflare'}),})
```


### `platformProxy`


[Section titled platformProxy](#platformproxy)

Determines whether and how the Cloudflare runtime is added to `astro dev`. It contains proxies to local `workerd` bindings and emulations of Cloudflare specific values, allowing the emulation of the runtime in the Node.js dev process. Read more about the [Cloudflare Runtime](#cloudflare-runtime).

Note

Proxies provided by this are a best effort emulation of the real production. Although they are designed to be as close as possible to the real thing, there might be a slight differences and inconsistencies between the two.


#### `platformProxy.enabled`


[Section titled platformProxy.enabled](#platformproxyenabled)

**Type:** `boolean` **Default:** `true`

Determines whether to enable the Cloudflare runtime in development mode.


#### `platformProxy.configPath`


[Section titled platformProxy.configPath](#platformproxyconfigpath)

**Type:** `string` **Default:** `undefined`

Defines the path to the Wrangler configuration file. If no value is set, it tracks `wrangler.toml`, `wrangler.json`, and `wrangler.jsonc` in the project root.


#### `platformProxy.environment`


[Section titled platformProxy.environment](#platformproxyenvironment)

**Type:** `string` **Default:** `undefined`

Sets the [Cloudflare environment](https://developers.cloudflare.com/workers/wrangler/environments/) to use. You must select an environment defined in the Wrangler configuration file, otherwise an error occurs.


#### `platformProxy.persist`


[Section titled platformProxy.persist](#platformproxypersist)

**Type:** `boolean | { path: string }` **Default:** `true`

Sets whether and where to save binding data locally to the file system.

-   If set to `true`, binding data is stored in `.wrangler/state/v3/`. It is the same as the default setting for wrangler.
-   If set to `false`, binding data is not stored in file system.
-   If set to `{ path: string }`, binding data is stored in the specified path.

Note

`wrangler`’s `--persist-to` option adds a sub directory called `v3` under the hood while the `@astrojs/cloudflare` `persist` property does not. For example, to reuse the same location as running `wrangler dev --persist-to ./my-directory`, you must specify: `persist: { path: "./my-directory/v3" }`.

The following configuration shows an example of enabling the Cloudflare runtime when running the development server, as well as using a `wrangler.json` config file. It also specifies a custom location for persisting data to the filesystem:

```
import cloudflare from'@astrojs/cloudflare';import { defineConfig } from'astro/config';exportdefaultdefineConfig({adapter: cloudflare({platformProxy: {enabled: true,configPath: 'wrangler.json',persist: {path: './.cache/wrangler/v3'},},}),});
```


### `routes.extend`


[Section titled routes.extend](#routesextend)

On Cloudflare Workers, this option is not applicable. Refer to [Routing on Cloudflare Workers](#routing-on-cloudflare-workers) for more information.

On Cloudflare Pages, this option allows you to add or exclude custom patterns (e.g. `/fonts/*`) to the generated `_routes.json` file that determines which routes are generated on-demand. This can be useful if you need to add route patterns which cannot be automatically generated, or exclude prerendered routes.

More information about the custom route patterns can be found in [Cloudflare’s routing docs](https://developers.cloudflare.com/pages/functions/routing/#functions-invocation-routes). Any routes specified are not automatically deduplicated and will be appended to the existing routes as is.


#### `routes.extend.include`


[Section titled routes.extend.include](#routesextendinclude)

**Type:** `{ pattern: string }[]` **Default:** `undefined`

Configures additional routes to be generated on demand by the Cloudflare adapter in the `routes.extend.include` array.


#### `routes.extend.exclude`


[Section titled routes.extend.exclude](#routesextendexclude)

**Type:** `{ pattern: string }[]` **Default:** `undefined`

Configures routes to be excluded from on-demand rendering in the `routes.extend.exclude` array. These routes will be prerendered and served statically instead, and will not invoke the server function. Additionally you can use this option to serve any static asset (e.g. images, fonts, css, js, html, txt, json, etc.) files directly without routing the request through the server function.

astro.config.mjs

```
exportdefaultdefineConfig({adapter: cloudflare({routes: {extend: {include: [{ pattern: '/static' }], // Route a prerended page to the server function for on-demand renderingexclude: [{ pattern: '/pagefind/*' }], // Use Starlight's pagefind search, which is generated statically at build time}},}),});
```


### `sessionKVBindingName`


[Section titled sessionKVBindingName](#sessionkvbindingname)

**Type:** `string` **Default:** `SESSION`

**Added in:** `astro@5.6.0`

The `sessionKVBindingName` option allows you to specify the name of the KV binding used for session storage. By default, this is set to `SESSION`, but you can change it to match your own KV binding name. See [Sessions](#sessions) for more information.

astro.config.mjs

```
exportdefaultdefineConfig({adapter: cloudflare({sessionKVBindingName: 'MY_SESSION_BINDING',}),});
```


## Cloudflare runtime


[Section titled Cloudflare runtime](#cloudflare-runtime)


### Usage


[Section titled Usage](#usage)

The Cloudflare runtime gives you access to environment variables and bindings to Cloudflare resources. The Cloudflare runtime uses bindings found in the `wrangler.toml`/`wrangler.json` configuration file.

You can access the bindings from `Astro.locals.runtime`:

src/pages/index.astro

```
---const { env } = Astro.locals.runtime;---
```

You can access the runtime from API endpoints through `context.locals`:

src/pages/api/someFile.js

```
exportfunctionGET(context) {const runtime = context.locals.runtime;returnnewResponse('Some body');}
```

See the [list of all supported bindings](https://developers.cloudflare.com/workers/wrangler/api/#supported-bindings) in the Cloudflare documentation.


### Environment variables and secrets


[Section titled Environment variables and secrets](#environment-variables-and-secrets)

The Cloudflare runtime treats environment variables as a type of binding.

For example, you can define an [environment variable](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-wrangler) in `wrangler.json` as follows:

wrangler.json

```
{"vars" : {"MY_VARIABLE": "test"}}
```

Secrets are a special type of environment variable that allow you to attach encrypted text values to your Worker. They need to be defined differently to ensure they are not visible after you set them.

To define `secrets`, add them through the [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/) rather than in your Wrangler config file.

Terminal window

```
npxwranglersecretput<KEY>
```

To set secrets for local development, you also need to add a `.dev.vars` file to the root of the Astro project:

.dev.vars

```
DB_PASSWORD=myPassword
```

You can then access environment variables, including secrets, from the `env` object available from `Astro.locals.runtime`:

src/pages/index.astro

```
---const { env } = Astro.locals.runtime;const myVariable = env.MY_VARIABLE;const secret = env.DB_PASSWORD;---
```

Cloudflare environment variables and secrets are compatible with the [`astro:env` API](/en/guides/environment-variables/#type-safe-environment-variables).


### Typing


[Section titled Typing](#typing)

`wrangler` provides a `types` command to generate TypeScript types for the bindings. This allows you to type locals without the need to manually type them. Refer to the [Cloudflare documentation](https://developers.cloudflare.com/workers/wrangler/commands/#types) for more information.

Every time you change your configuration files (e.g. `wrangler.toml`, `.dev.vars`) you need to run `wrangler types`.

Note

You can create a pnpm script to run `wrangler types` automatically before other commands.

package.json

```
{"scripts": {"dev": "wrangler types && astro dev","start": "wrangler types && astro dev","build": "wrangler types && astro check && astro build","preview": "wrangler types && astro preview","astro": "astro"}}
```

You can type the `runtime` object using `Runtime`:

src/env.d.ts

```
type Runtime =import('@astrojs/cloudflare').Runtime<Env>;declarenamespace App {interface Locals extendsRuntime {otherLocals: {test:string;};}}
```


## Cloudflare Platform


[Section titled Cloudflare Platform](#cloudflare-platform)


### Headers


[Section titled Headers](#headers)

You can attach [custom headers](https://developers.cloudflare.com/pages/platform/headers/) to your responses by adding a `_headers` file in your Astro project’s `public/` folder. This file will be copied to your build output directory.

This is available on Cloudflare Workers and Pages.


### Assets


[Section titled Assets](#assets)

Assets built by Astro are all named with a hash and therefore can be given long cache headers. By default, Astro on Cloudflare will add such a header for these files.


### Redirects


[Section titled Redirects](#redirects)

You can declare [custom redirects](https://developers.cloudflare.com/pages/platform/redirects/) to redirect requests to a different URL. To do so, add a `_redirects` file in your Astro project’s `public/` folder. This file will be copied to your build output directory.

This is available on Cloudflare Workers and Pages.


### Routes


[Section titled Routes](#routes)


#### Routing on Cloudflare Workers


[Section titled Routing on Cloudflare Workers](#routing-on-cloudflare-workers)

Routing for static assets is based on the file structure in the build directory (e.g. `./dist`). If no match is found, this will fall back to the Worker for on-demand rendering. Read more about [static asset routing with Cloudflare Workers](https://developers.cloudflare.com/workers/static-assets/routing/).

Unlike [Cloudflare Pages](#routing-on-cloudflare-pages), with Workers, you do not need a `_routes.json` file.

Currently, the Cloudflare adapter always generates this file. To work around this, create a `.assetsignore` file in your `public/` folder, and add the following lines to it:

public/.assetsignore

```
_worker.js_routes.json
```


#### Routing on Cloudflare Pages


[Section titled Routing on Cloudflare Pages](#routing-on-cloudflare-pages)

For Cloudflare Pages, [routing](https://developers.cloudflare.com/pages/platform/functions/routing/#functions-invocation-routes) uses a `_routes.json` file to determine which requests are routed to the server function and which are served as static assets. By default, a `_routes.json` file will be automatically generated for your project based on its files and configuration.

You can [specify additional routing patterns to follow](#routesextend) in your adapter config, or create your own custom `_routes.json` file to fully override the automatic generation.

Creating a custom `public/_routes.json` will override the automatic generation. See [Cloudflare’s documentation on creating a custom `_routes.json`](https://developers.cloudflare.com/pages/platform/functions/routing/#create-a-_routesjson-file) for more details.


## Sessions


[Section titled Sessions](#sessions)

The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices.

Astro automatically configures [Workers KV](https://developers.cloudflare.com/kv/) for session storage when using the Cloudflare adapter. Before using sessions, you need to create a KV namespace to store the data and configure a KV binding in your Wrangler config file. By default, Astro expects the KV binding to be named `SESSION`, but you can choose a different name if you prefer by setting the [`sessionKVBindingName`](#sessionkvbindingname) option in the adapter config.

1.  Create a KV namespace using the Wrangler CLI and make note of the ID of the new namespace:

    Terminal window

    ```
    npxwranglerkvnamespacecreate"SESSION"
    ```

2.  Declare the KV namespace in your Wrangler config, setting the namespace ID to the one returned by the previous command:

    -   [wrangler.json](#tab-panel-3225)
    -   [wrangler.toml](#tab-panel-3226)

    wrangler.json

    ```
    {"kv_namespaces": [{"binding": "SESSION","id": "<KV_NAMESPACE_ID>"}]}
    ```

    wrangler.toml

    ```
    kv_namespaces = [{ binding = "SESSION", id = "<KV_NAMESPACE_ID>" }]
    ```

3.  You can then use sessions in your server code:

    src/components/CartButton.astro

    ```
    ---export const prerender = false;const cart = await Astro.session?.get('cart');---<ahref="/checkout">🛒 {cart?.length??0} items</a>
    ```


Note

Writes to Cloudflare KV are [eventually consistent](https://developers.cloudflare.com/kv/concepts/how-kv-works/#consistency) between regions. This means that changes are available immediately within the same region but may take up to 60 seconds to propagate globally. This won’t affect most users as they are unlikely to switch regions between requests, but it may be a consideration for some use cases, such as VPN users.


## Cloudflare Module Imports


[Section titled Cloudflare Module Imports](#cloudflare-module-imports)

The Cloudflare `workerd` runtime supports imports of some [non-standard module types](https://developers.cloudflare.com/workers/wrangler/bundling/#including-non-javascript-modules). Most additional file types are also available in Astro:

-   `.wasm` or `.wasm?module`: exports a [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module) that can then be instantiated
-   `.bin`: exports an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) of the raw binary contents of the file
-   `.txt`: exports a string of the file contents

All module types export a single default value. Modules can be imported both from server-side rendered pages, or from prerendered pages for static site generation.

The following is an example of importing a Wasm module that then responds to requests by adding the request’s number parameters together.

pages/add/\[a\]/\[b\].js

```
// Import the WebAssembly moduleimport mod from'../util/add.wasm';// Instantiate first in order to use itconst addModule:any = newWebAssembly.Instance(mod);exportasyncfunctionGET(context) {const a = Number.parseInt(context.params.a);const b = Number.parseInt(context.params.b);returnnewResponse(`${addModule.exports.add(a,b)}`);}
```

While this example is trivial, Wasm can be used to accelerate computationally intensive operations which do not involve significant I/O such as embedding an image processing library, or embedding a small pre-indexed database for search over a read-only dataset.


## Node.js compatibility


[Section titled Node.js compatibility](#nodejs-compatibility)

Out of the box, Cloudflare does not support the Node.js runtime APIs. With some configuration, Cloudflare does support a subset of the Node.js runtime APIs. You can find supported Node.js runtime APIs in Cloudflare’s [documentation](https://developers.cloudflare.com/workers/runtime-apis/nodejs).

To use these APIs, your page or endpoint must be server-side rendered (not pre-rendered) and must use the `import {} from 'node:*'` import syntax.

pages/api/endpoint.js

```
export const prerender = false;import { Buffer } from'node:buffer';
```

You’ll also need to modify the `vite` configuration in your Astro config to allow for the `node:*` import syntax:

astro.config.mjs

```
import {defineConfig} from"astro/config";import cloudflare from'@astrojs/cloudflare';exportdefaultdefineConfig({adapter: cloudflare({}),vite: {ssr: {external: ['node:buffer'],},},})
```

Additionally, you’ll need to follow Cloudflare’s documentation on how to enable support. For detailed guidance, please refer to the [Cloudflare documentation on enabling Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/).

Package Compatibility Implications

If a project imports a package into the server that uses the Node.js runtime APIs, this can cause issues when deploying to Cloudflare. This issue arises with package that do not use the `node:*` import syntax. It is recommended that you contact the authors of the package to determine if the package supports the above import syntax. If the package does not support this, you may need to use a different package.


## Preview with Wrangler


[Section titled Preview with Wrangler](#preview-with-wrangler)

To use [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) to run your application locally, update the preview script.

For Workers:

package.json

```
"preview": "wrangler dev ./dist"
```

For Pages:

package.json

```
"preview": "wrangler pages dev ./dist"
```

Developing with [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) gives you access to [Cloudflare bindings](https://developers.cloudflare.com/pages/platform/functions/bindings), [environment variables](https://developers.cloudflare.com/pages/platform/functions/bindings/#environment-variables), and the [cf object](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties). Getting hot reloading of the Astro dev server to work with Wrangler might require custom setup. See [community examples](https://github.com/withastro/roadmap/discussions/590).


### Meaningful error messages


[Section titled Meaningful error messages](#meaningful-error-messages)

Currently, errors during running your application in Wrangler are not very useful, due to the minification of your code. For better debugging, you can add `vite.build.minify = false` setting to your `astro.config.mjs`.

astro.config.mjs

```
exportdefaultdefineConfig({adapter: cloudflare(),vite: {build: {minify: false,},},});
```


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 99. `en/guides/integrations-guide/db/.md`

```text
# @astrojs/

					db

---
url: https://docs.astro.build/en/guides/integrations-guide/db/
description: Learn how to use the @astrojs/db integration in your Astro project.
---


# @astrojs/ db


v0.15.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/db/) [npm](https://www.npmjs.com/package/@astrojs/db) [Changelog](https://github.com/withastro/astro/tree/main/packages/db/CHANGELOG.md)

Astro DB is a fully-managed SQL database designed for the Astro ecosystem: develop locally in Astro and deploy to any [libSQL-compatible database](/en/guides/astro-db/).

With Astro DB you have a powerful, local, type-safe tool to query and model content as a relational database.

See the [Astro DB guide](/en/guides/astro-db/) for full usage and examples.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-installation) instead.

Run one of the following commands in a new terminal window.

-   [npm](#tab-panel-3186)
-   [pnpm](#tab-panel-3187)
-   [Yarn](#tab-panel-3188)

Terminal window

```
npxastroadddb
```

Terminal window

```
pnpmastroadddb
```

Terminal window

```
yarnastroadddb
```


#### Manual Installation


[Section titled Manual Installation](#manual-installation)

If you prefer to set things up from scratch yourself, skip `astro add` and follow these instructions to install Astro DB yourself.


##### 1\. Install the integration from npm via a package manager


[Section titled 1. Install the integration from npm via a package manager](#1-install-the-integration-from-npm-via-a-package-manager)

-   [npm](#tab-panel-3189)
-   [pnpm](#tab-panel-3190)
-   [Yarn](#tab-panel-3191)

Terminal window

```
npminstall@astrojs/db
```

Terminal window

```
pnpmadd@astrojs/db
```

Terminal window

```
yarnadd@astrojs/db
```


##### 2\. Add the integration to `astro.config.mjs`


[Section titled 2. Add the integration to astro.config.mjs](#2-add-the-integration-to-astroconfigmjs)

astro.config.mjs

```
import { defineConfig } from'astro/config';import db from'@astrojs/db';exportdefaultdefineConfig({integrations: [db()]});
```


##### 3\. Configure your database


[Section titled 3. Configure your database](#3-configure-your-database)

Create a `db/config.ts` file at the root of your project. This is a special file that Astro will automatically load and use to configure your database tables.

db/config.ts

```
import { defineDb } from'astro:db';exportdefaultdefineDb({tables: {},})
```


## Table configuration reference


[Section titled Table configuration reference](#table-configuration-reference)


### `columns`


[Section titled columns](#columns)

Table columns are configured using the `columns` object:

```
import { defineTable, column, NOW } from'astro:db';const Comment = defineTable({columns: {id: column.number({ primaryKey: true }),author: column.text(),content: column.text({ optional: true }),published: column.date({ default: NOW }),},});
```

Columns are configured using the `column` utility. `column` supports the following types:

-   **`column.text(...)`** - store either plain or rich text content
-   **`column.number(...)`** - store integer and floating point values
-   **`column.boolean(...)`** - store true / false values
-   **`column.date(...)`** - store `Date` objects, parsed as ISO strings for data storage
-   **`column.json(...)`** - store arbitrary JSON blobs, parsed as stringified JSON for data storage

There are a few shared configuration values across all columns:

-   `primaryKey` - Set a `number` or `text` column as the unique identifier.
-   `optional` - Astro DB uses `NOT NULL` for all columns by default. Set `optional` to `true` to allow null values.
-   `default` - Set the default value for newly inserted entries. This accepts either a static value or a string of `sql` for generated values like timestamps.
-   `unique` - Mark a column as unique. This prevents duplicate values across entries in the table.
-   `references` - Reference a related table by column. This establishes a foreign key constraint, meaning each column value must have a matching value in the referenced table.


### `indexes`


[Section titled indexes](#indexes)

Table indexes are used to improve lookup speeds on a given column or combination of columns. The `indexes` property accepts an array of configuration objects specifying the columns to index:

db/config.ts

```
import { defineTable, column } from'astro:db';const Comment = defineTable({columns: {authorId: column.number(),published: column.date(),body: column.text(),},indexes: [{ on: ["authorId", "published"], unique: true },]});
```

This will generate a unique index on the `authorId` and `published` columns with the name `Comment_authorId_published_idx`.

The following configuration options are available for each index:

-   `on`: `string | string[]` - A single column or array of column names to index.
-   `unique`: `boolean` - Set to `true` to enforce unique values across the indexed columns.
-   `name`: `string` (optional) - A custom name for the unique index. This will override Astro’s generated name based on the table and column names being indexed (e.g. `Comment_authorId_published_idx`). Custom names are global, so ensure index names do not conflict between tables.


### `foreignKeys`


[Section titled foreignKeys](#foreignkeys)

Tip

`foreignKeys` is an advanced API for relating multiple table columns. If you only need to reference a single column, try using [the column `references` property.](#columns)

Foreign keys are used to establish a relationship between two tables. The `foreignKeys` property accepts an array of configuration objects that may relate one or more columns between tables:

db/config.ts

```
import { defineTable, column } from'astro:db';const Author = defineTable({columns: {firstName: column.text(),lastName: column.text(),},});const Comment = defineTable({columns: {authorFirstName: column.text(),authorLastName: column.text(),body: column.text(),},foreignKeys: [{columns: ["authorFirstName", "authorLastName"],references: ()=> [Author.columns.firstName, Author.columns.lastName],},],});
```

Each foreign key configuration object accepts the following properties:

-   `columns`: `string[]` - An array of column names to relate to the referenced table.
-   `references`: `() => Column[]` - A function that returns an array of columns from the referenced table.


## Astro DB CLI reference


[Section titled Astro DB CLI reference](#astro-db-cli-reference)

Astro DB includes a set of CLI commands to interact with your local and libSQL-compatible database.

These commands are called automatically when using a GitHub CI action, and can be called manually using the `astro db` CLI.


### `astro db push`


[Section titled astro db push](#astro-db-push)

**Flags:**

-   `--force-reset` Reset all production data if a breaking schema change is required.

Safely push database configuration changes to your project database. This will check for any risk of data loss and guide you on any recommended migration steps. If a breaking schema change must be made, use the `--force-reset` flag to reset all production data.


### `astro db verify`


[Section titled astro db verify](#astro-db-verify)

Check for any differences between your local and remote database configurations. This is automatically run by `astro db push`. `verify` will compare your local `db/config.ts` file with the remote database and warn if changes are detected.


### `astro db execute <file-path>`


[Section titled astro db execute &lt;file-path&gt;](#astro-db-execute-file-path)

**Flags:**

-   `--remote` Run against your libSQL-compatible database. Omit to run against your development server.

Execute a `.ts` or `.js` file to read or write to your database. This accepts a file path as an argument, and supports usage of the `astro:db` module to write type-safe queries. Use the `--remote` flag to run against your libSQL-compatible database, or omit the flag to run against your development server. See how to [seed development data](/en/guides/astro-db/#seed-your-database-for-development) for an example file.


### `astro db shell --query <sql-string>`


[Section titled astro db shell --query &lt;sql-string&gt;](#astro-db-shell---query-sql-string)

**Flags:**

-   `--query` Raw SQL query to execute.
-   `--remote` Run against your libSQL-compatible database. Omit to run against your development server.

Execute a raw SQL query against your database. Use the `--remote` flag to run against your libSQL-compatible database, or omit the flag to run against your development server.


## Astro DB utility reference


[Section titled Astro DB utility reference](#astro-db-utility-reference)


### `isDbError()`


[Section titled isDbError()](#isdberror)

The `isDbError()` function checks if an error is a libSQL database exception. This may include a foreign key constraint error when using references, or missing fields when inserting data. You can combine `isDbError()` with a try / catch block to handle database errors in your application:

src/pages/api/comment/\[id\].ts

```
import { db, Comment, isDbError } from'astro:db';importtype { APIRoute } from'astro';export const POST:APIRoute = (ctx) => {try {await db.insert(Comment).values({id: ctx.params.id,content: 'Hello, world!'});} catch (e) {if (isDbError(e)) {return newResponse(`Cannot insert comment with id ${id}\n\n${e.message}`, { status: 400 });}return newResponse('An unexpected error occurred', { status: 500 });}return newResponse(null, { status: 201 });};
```


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 100. `en/guides/integrations-guide/markdoc/.md`

```text
# @astrojs/

					markdoc

---
url: https://docs.astro.build/en/guides/integrations-guide/markdoc/
description: Learn how to use the @astrojs/markdoc integration in your Astro project.
---


# @astrojs/ markdoc


v0.15.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/markdoc/) [npm](https://www.npmjs.com/package/@astrojs/markdoc) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/markdoc/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables the usage of [Markdoc](https://markdoc.dev/) to create components, pages, and content collection entries.


## Why Markdoc?


[Section titled Why Markdoc?](#why-markdoc)

Markdoc allows you to enhance your Markdown with [Astro components](/en/basics/astro-components/). If you have existing content authored in Markdoc, this integration allows you to bring those files to your Astro project using content collections.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Run one of the following commands in a new terminal window.

-   [npm](#tab-panel-3213)
-   [pnpm](#tab-panel-3214)
-   [Yarn](#tab-panel-3215)

Terminal window

```
npxastroaddmarkdoc
```

Terminal window

```
pnpmastroaddmarkdoc
```

Terminal window

```
yarnastroaddmarkdoc
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/markdoc` package:

-   [npm](#tab-panel-3216)
-   [pnpm](#tab-panel-3217)
-   [Yarn](#tab-panel-3218)

Terminal window

```
npminstall@astrojs/markdoc
```

Terminal window

```
pnpmadd@astrojs/markdoc
```

Terminal window

```
yarnadd@astrojs/markdoc
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import markdoc from'@astrojs/markdoc';exportdefaultdefineConfig({// ...integrations: [markdoc()],});
```


### VS Code Editor Integration


[Section titled VS Code Editor Integration](#vs-code-editor-integration)

If you are using VS Code, there is an official [Markdoc language extension](https://marketplace.visualstudio.com/items?itemName=Stripe.markdoc-language-support) that includes syntax highlighting and autocomplete for configured tags. [See the language server on GitHub](https://github.com/markdoc/language-server.git) for more information.

To set up the extension, create a `markdoc.config.json` file in the project root with following content:

markdoc.config.json

```
[{"id": "my-site","path": "src/content","schema": {"path": "markdoc.config.mjs","type": "esm","property": "default","watch": true}}]
```

Set `markdoc.config.mjs` as your configuration file with the `schema` object, and define where your Markdoc files are stored using the `path` property. Since Markdoc is specific to content collections, you can use `src/content`.


## Usage


[Section titled Usage](#usage)

Markdoc files can only be used within content collections. Add entries to any content collection using the `.mdoc` extension:

-   Directorysrc/

    -   Directorycontent/

        -   Directorydocs/

            -   why-markdoc.mdoc
            -   quick-start.mdoc




Then, query your collection using the [Content Collection APIs](/en/guides/content-collections/#querying-collections):

src/pages/why-markdoc.astro

```
---import { getEntry, render } from'astro:content';const entry = await getEntry('docs', 'why-markdoc');const { Content } = await render(entry);---<!--Access frontmatter properties with `data`--><h1>{entry.data.title}</h1><!--Render Markdoc contents with the Content component--><Content />
```

See the [Astro Content Collection docs](/en/guides/content-collections/) for more information.


## Pass Markdoc variables


[Section titled Pass Markdoc variables](#pass-markdoc-variables)

You may need to pass [variables](https://markdoc.dev/docs/variables) to your content. This is useful when passing SSR parameters like A/B tests.

Variables can be passed as props via the `Content` component:

src/pages/why-markdoc.astro

```
---import { getEntry, render } from'astro:content';const entry = await getEntry('docs', 'why-markdoc');const { Content } = await render(entry);---<!--Pass the `abTest` param as a variable--><ContentabTestGroup={Astro.params.abTestGroup} />
```

Now, `abTestGroup` is available as a variable in `docs/why-markdoc.mdoc`:

src/content/docs/why-markdoc.mdoc

```
{% if $abTestGroup === 'image-optimization-lover' %}Let me tell you about image optimization...{% /if %}
```

To make a variable global to all Markdoc files, you can use the `variables` attribute from your `markdoc.config.mjs|ts`:

markdoc.config.mjs

```
import { defineMarkdocConfig } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({variables: {environment: process.env.IS_PROD?'prod':'dev',},});
```


### Access frontmatter from your Markdoc content


[Section titled Access frontmatter from your Markdoc content](#access-frontmatter-from-your-markdoc-content)

To access frontmatter, you can pass the entry `data` property as a variable where you render your content:

src/pages/why-markdoc.astro

```
---import { getEntry, render } from'astro:content';const entry = await getEntry('docs', 'why-markdoc');const { Content } = await render(entry);---<Contentfrontmatter={entry.data} />
```

This can now be accessed as `$frontmatter` in your Markdoc.


## Render components


[Section titled Render components](#render-components)

`@astrojs/markdoc` offers configuration options to use all of Markdoc’s features and connect UI components to your content.


### Use Astro components as Markdoc tags


[Section titled Use Astro components as Markdoc tags](#use-astro-components-as-markdoc-tags)

You can configure [Markdoc tags](https://markdoc.dev/docs/tags) that map to `.astro` components. You can add a new tag by creating a `markdoc.config.mjs|ts` file at the root of your project and configuring the `tag` attribute.

This example renders an `Aside` component, and allows a `type` prop to be passed as a string:

markdoc.config.mjs

```
import { defineMarkdocConfig, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({tags: {aside: {render: component('./src/components/Aside.astro'),attributes: {// Markdoc requires type defs for each attribute.// These should mirror the `Props` type of the component// you are rendering.// See Markdoc's documentation on defining attributes// https://markdoc.dev/docs/attributes#defining-attributestype: { type: String },},},},});
```

This component can now be used in your Markdoc files with the `{% aside %}` tag. Children will be passed to your component’s default slot:

```

# Welcome to Markdoc 👋{% aside type="tip" %}Use tags like this fancy "aside" to add some _flair_ to your docs.{% /aside %}

```


### Use client-side UI components


[Section titled Use client-side UI components](#use-client-side-ui-components)

Tags and nodes are restricted to `.astro` files. To embed client-side UI components in Markdoc, [use a wrapper `.astro` component that renders a framework component](/en/guides/framework-components/#nesting-framework-components) with your desired `client:` directive.

This example wraps a React `Aside.tsx` component with a `ClientAside.astro` component:

src/components/ClientAside.astro

```
---import Aside from'./Aside';---<Aside {...Astro.props} client:load />
```

This Astro component can now be passed to the `render` prop for any [tag](https://markdoc.dev/docs/tags) or [node](https://markdoc.dev/docs/nodes) in your config:

markdoc.config.mjs

```
import { defineMarkdocConfig, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({tags: {aside: {render: component('./src/components/ClientAside.astro'),attributes: {type: { type: String },},},},});
```


### Use Astro components from npm packages and TypeScript files


[Section titled Use Astro components from npm packages and TypeScript files](#use-astro-components-from-npm-packages-and-typescript-files)

You may need to use Astro components exposed as named exports from TypeScript or JavaScript files. This is common when using npm packages and design systems.

You can pass the import name as the second argument to the `component()` function:

markdoc.config.mjs

```
import { defineMarkdocConfig, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({tags: {tabs: {render: component('@astrojs/starlight/components', 'Tabs'),},},});
```

This generates the following import statement internally:

```
import { Tabs } from'@astrojs/starlight/components';
```


## Markdoc Partials


[Section titled Markdoc Partials](#markdoc-partials)

The `{% partial /%}` tag allows you to render other `.mdoc` files inside your Markdoc content.

This is useful for reusing content across multiple documents, and allows you to have `.mdoc` content files that do not follow your collection schema.

Tip

Use an underscore `_` prefix for partial files or directories. This excludes partials from content collection queries.

This example shows a Markdoc partial for a footer to be used inside blog collection entries:

src/content/blog/\_footer.mdoc

```
Social links:- [Twitter / X](https://twitter.com/astrodotbuild)- [Discord](https://astro.build/chat)- [GitHub](https://github.com/withastro/astro)
```

Use the `{% partial /%}` tag with to render the footer at the bottom of a blog post entry. Apply the `file` attribute with the path to the file, using either a relative path or an import alias:

src/content/blog/post.mdoc

```

# My Blog Post{% partial file="./_footer.mdoc" /%}

```


## Syntax highlighting


[Section titled Syntax highlighting](#syntax-highlighting)

`@astrojs/markdoc` provides [Shiki](https://shiki.style) and [Prism](https://github.com/PrismJS) extensions to highlight your code blocks.


### Shiki


[Section titled Shiki](#shiki)

Apply the `shiki()` extension to your Markdoc config using the `extends` property. You can optionally pass a shiki configuration object:

markdoc.config.mjs

```
import { defineMarkdocConfig } from'@astrojs/markdoc/config';import shiki from'@astrojs/markdoc/shiki';exportdefaultdefineMarkdocConfig({extends: [shiki({// Choose from Shiki's built-in themes (or add your own)// Default: 'github-dark'// https://shiki.style/themestheme: 'dracula',// Enable word wrap to prevent horizontal scrolling// Default: falsewrap: true,// Pass custom languages// Note: Shiki has countless langs built-in, including `.astro`!// https://shiki.style/languageslangs: [],}),],});
```


### Prism


[Section titled Prism](#prism)

Apply the `prism()` extension to your Markdoc config using the `extends` property.

markdoc.config.mjs

```
import { defineMarkdocConfig } from'@astrojs/markdoc/config';import prism from'@astrojs/markdoc/prism';exportdefaultdefineMarkdocConfig({extends: [prism()],});
```

To learn about configuring Prism stylesheets, [see our syntax highlighting guide](/en/guides/syntax-highlighting/#add-a-prism-stylesheet).


## Custom Markdoc nodes / elements


[Section titled Custom Markdoc nodes / elements](#custom-markdoc-nodes--elements)

You may want to render standard Markdown elements, such as paragraphs and bolded text, as Astro components. For this, you can configure a [Markdoc node](https://markdoc.dev/docs/nodes). If a given node receives attributes, they will be available as component props.

This example renders blockquotes with a custom `Quote.astro` component:

markdoc.config.mjs

```
import { defineMarkdocConfig, nodes, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({nodes: {blockquote: {...nodes.blockquote, // Apply Markdoc's defaults for other optionsrender: component('./src/components/Quote.astro'),},},});
```

See the [Markdoc nodes documentation](https://markdoc.dev/docs/nodes#built-in-nodes) to learn about all the built-in nodes and attributes.


### Custom headings


[Section titled Custom headings](#custom-headings)

`@astrojs/markdoc` automatically adds anchor links to your headings, and [generates a list of `headings` via the content collections API](/en/guides/content-collections/#rendering-body-content). To further customize how headings are rendered, you can apply an Astro component [as a Markdoc node](https://markdoc.dev/docs/nodes).

This example renders a `Heading.astro` component using the `render` property:

markdoc.config.mjs

```
import { defineMarkdocConfig, nodes, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({nodes: {heading: {...nodes.heading, // Preserve default anchor link generationrender: component('./src/components/Heading.astro'),},},});
```

All Markdown headings will render the `Heading.astro` component and pass the following `attributes` as component props:

-   `level: number` The heading level 1 - 6
-   `id: string` An `id` generated from the heading’s text contents. This corresponds to the `slug` generated by the [content `render()` function](/en/guides/content-collections/#rendering-body-content).

For example, the heading `### Level 3 heading!` will pass `level: 3` and `id: 'level-3-heading'` as component props.


### Custom image components


[Section titled Custom image components](#custom-image-components)

Astro’s `<Image />` component cannot be used directly in Markdoc. However, you can configure an Astro component to override the default image node every time the native `![]()` image syntax is used, or as a custom Markdoc tag to allow you to specify additional image attributes.


#### Override Markdoc’s default image node


[Section titled Override Markdoc’s default image node](#override-markdocs-default-image-node)

To override the default image node, you can configure an `.astro` component to be rendered in place of a standard `<img>`.

1.  Build a custom `MarkdocImage.astro` component to pass the required `src` and `alt` properties from your image to the `<Image />` component:

    src/components/MarkdocImage.astro

    ```
    ---import { Image } from"astro:assets";interface Props {src:ImageMetadata;alt:string;}const { src, alt } = Astro.props;---<Imagesrc={src}alt={alt} />
    ```

2.  The `<Image />` component requires a `width` and `height` for remote images which cannot be provided using the `![]()` syntax. To avoid errors when using remote images, update your component to render a standard HTML `<img>` tag when a remote URL `src` is found:

    src/components/MarkdocImage.astro

    ```
    ---import { Image } from"astro:assets";interface Props {src:ImageMetadata|string;alt:string;}const { src, alt } = Astro.props;---<Imagesrc={src}alt={alt} />{typeof src ==='string'?<imgsrc={src}alt={alt} />:<Imagesrc={src}alt={alt} />}
    ```

3.  Configure Markdoc to override the default image node and render `MarkdocImage.astro`:

    markdoc.config.mjs

    ```
    import { defineMarkdocConfig, nodes, component } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({nodes: {image: {...nodes.image, // Apply Markdoc's defaults for other optionsrender: component('./src/components/MarkdocImage.astro'),},},});
    ```

4.  The native image syntax in any `.mdoc` file will now use the `<Image />` component to optimize your local images. Remote images may still be used, but will not be rendered by Astro’s `<Image />` component.

    src/content/blog/post.mdoc

    ```
    <!-- Optimized by <Image /> -->![A picture of a cat](/cat.jpg)<!-- Unoptimized <img> -->![A picture of a dog](https://example.com/dog.jpg)
    ```



#### Create a custom Markdoc image tag


[Section titled Create a custom Markdoc image tag](#create-a-custom-markdoc-image-tag)

A Markdoc `image` tag allows you to set additional attributes on your image that are not possible with the `![]()` syntax. For example, custom image tags allow you to use Astro’s `<Image />` component for remote images that require a `width` and `height`.

The following steps will create a custom Markdoc image tag to display a `<figure>` element with a caption, using the Astro `<Image />` component to optimize the image.

1.  Create a `MarkdocFigure.astro` component to receive the necessary props and render an image with a caption:

    src/components/MarkdocFigure.astro

    ```
    ---// src/components/MarkdocFigure.astroimport { Image } from"astro:assets";interface Props {src:ImageMetadata|string;alt:string;width:number;height:number;caption:string;}const { src, alt, width, height, caption } = Astro.props;---<figure><Image {src} {alt} {width} {height}  />{caption &&<figcaption>{caption}</figcaption>}</figure>
    ```

2.  Configure your custom image tag to render your Astro component:

    markdoc.config.mjs

    ```
    import { component, defineMarkdocConfig, nodes } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({tags: {image: {attributes: {width: {type: String,},height: {type: String,},caption: {type: String,},...nodes.image.attributes},render: component('./src/components/MarkdocFigure.astro'),},},});
    ```

3.  Use the `image` tag in Markdoc files to display a figure with caption, providing all the necessary attributes for your component:

    ```
    {% image src="./astro-logo.png" alt="Astro Logo" width="100" height="100" caption="a caption!" /%}
    ```



## Advanced Markdoc configuration


[Section titled Advanced Markdoc configuration](#advanced-markdoc-configuration)

The `markdoc.config.mjs|ts` file accepts [all Markdoc configuration options](https://markdoc.dev/docs/config), including [tags](https://markdoc.dev/docs/tags) and [functions](https://markdoc.dev/docs/functions).

You can pass these options from the default export in your `markdoc.config.mjs|ts` file:

markdoc.config.mjs

```
import { defineMarkdocConfig } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({functions: {getCountryEmoji: {transform(parameters) {const [country] = Object.values(parameters);constcountryToEmojiMap = {japan: '🇯🇵',spain: '🇪🇸',france: '🇫🇷',};returncountryToEmojiMap[country] ??'🏳';},},},});
```

Now, you can call this function from any Markdoc content entry:

```
¡Hola {% getCountryEmoji("spain") %}!
```

[See the Markdoc documentation](https://markdoc.dev/docs/functions#creating-a-custom-function) for more on using variables or functions in your content.


### Set the root HTML element


[Section titled Set the root HTML element](#set-the-root-html-element)

Markdoc wraps documents with an `<article>` tag by default. This can be changed from the `document` Markdoc node. This accepts an HTML element name or `null` if you prefer to remove the wrapper element:

markdoc.config.mjs

```
import { defineMarkdocConfig, nodes } from'@astrojs/markdoc/config';exportdefaultdefineMarkdocConfig({nodes: {document: {...nodes.document, // Apply defaults for other optionsrender: null, // default 'article'},},});
```


## Integration config options


[Section titled Integration config options](#integration-config-options)

The Astro Markdoc integration handles configuring Markdoc options and capabilities that are not available through the `markdoc.config.js` file.


### `allowHTML`


[Section titled allowHTML](#allowhtml)

Enables writing HTML markup alongside Markdoc tags and nodes.

By default, Markdoc will not recognize HTML markup as semantic content.

To achieve a more Markdown-like experience, where HTML elements can be included alongside your content, set `allowHTML:true` as a `markdoc` integration option. This will enable HTML parsing in Markdoc markup.

astro.config.mjs

```
import { defineConfig } from'astro/config';import markdoc from'@astrojs/markdoc';exportdefaultdefineConfig({// ...integrations: [markdoc({ allowHTML: true })],});
```

Caution

When `allowHTML` is enabled, HTML markup inside Markdoc documents will be rendered as actual HTML elements (including `<script>`), making attack vectors like XSS possible. Ensure that any HTML markup comes from trusted sources.


### `ignoreIndentation`


[Section titled ignoreIndentation](#ignoreindentation)

By default, any content that is indented by four spaces is treated as a code block. Unfortunately, this behavior makes it difficult to use arbitrary levels of indentation to improve the readability of documents with complex structure.

When using nested tags in Markdoc, it can be helpful to indent the content inside of tags so that the level of depth is clear. To support arbitrary indentation, we have to disable the indent-based code blocks and modify several other markdown-it parsing rules that account for indent-based code blocks. These changes can be applied by enabling the ignoreIndentation option.

astro.config.mjs

```
import { defineConfig } from'astro/config';import markdoc from'@astrojs/markdoc';exportdefaultdefineConfig({// ...integrations: [markdoc({ ignoreIndentation: true })],});
```

```

# Welcome to Markdoc with indented tags 👋# Note: Can use either spaces or tabs for indentation{% custom-tag %}{% custom-tag %} ### Tags can be indented for better readability{% another-custom-tag %}This is easier to follow when there is a lot of nesting{% /another-custom-tag %}{% /custom-tag %}{% /custom-tag %}

```


## Examples


[Section titled Examples](#examples)

-   The [Astro Markdoc starter template](https://github.com/withastro/astro/tree/latest/examples/with-markdoc) shows how to use Markdoc files in your Astro project.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 101. `en/guides/integrations-guide/mdx/.md`

```text
# @astrojs/

					mdx

---
url: https://docs.astro.build/en/guides/integrations-guide/mdx/
description: Learn how to use the @astrojs/mdx integration in your Astro project.
---


# @astrojs/ mdx


v4.3.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/mdx/) [npm](https://www.npmjs.com/package/@astrojs/mdx) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/mdx/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables the usage of [MDX](https://mdxjs.com/) components and allows you to create pages as `.mdx` files.


## Why MDX?


[Section titled Why MDX?](#why-mdx)

MDX allows you to use variables, JSX expressions and components within Markdown content in Astro. If you have existing content authored in MDX, this integration allows you to bring those files to your Astro project.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Run one of the following commands in a new terminal window.

-   [npm](#tab-panel-3219)
-   [pnpm](#tab-panel-3220)
-   [Yarn](#tab-panel-3221)

Terminal window

```
npxastroaddmdx
```

Terminal window

```
pnpmastroaddmdx
```

Terminal window

```
yarnastroaddmdx
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/mdx` package:

-   [npm](#tab-panel-3222)
-   [pnpm](#tab-panel-3223)
-   [Yarn](#tab-panel-3224)

Terminal window

```
npminstall@astrojs/mdx
```

Terminal window

```
pnpmadd@astrojs/mdx
```

Terminal window

```
yarnadd@astrojs/mdx
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({// ...integrations: [mdx()],});
```


### Editor Integration


[Section titled Editor Integration](#editor-integration)

For editor support in [VS Code](https://code.visualstudio.com/), install the [official MDX extension](https://marketplace.visualstudio.com/items?itemName=unifiedjs.vscode-mdx).

For other editors, use the [MDX language server](https://github.com/mdx-js/mdx-analyzer/tree/main/packages/language-server).


## Usage


[Section titled Usage](#usage)

Visit the [MDX docs](https://mdxjs.com/docs/what-is-mdx/) to learn about using standard MDX features.


## MDX in Astro


[Section titled MDX in Astro](#mdx-in-astro)

Adding the MDX integration enhances your Markdown authoring with JSX variables, expressions and components.

It also adds extra features to standard MDX, including support for Markdown-style frontmatter in MDX. This allows you to use most of [Astro’s built-in Markdown features](/en/guides/markdown-content/).

`.mdx` files must be written in [MDX syntax](https://mdxjs.com/docs/what-is-mdx/#mdx-syntax) rather than Astro’s HTML-like syntax.


### Using MDX with content collections


[Section titled Using MDX with content collections](#using-mdx-with-content-collections)

To include MDX files in a content collection, make sure that your [collection loader](/en/guides/content-collections/#defining-the-collection-loader) is configured to load content from `.mdx` files:

src/content.config.ts

```
import { defineCollection, z } from'astro:content';import { glob } from'astro/loaders';const blog = defineCollection({loader: glob({ pattern: "**/*.{md,mdx}", base: "./src/blog" }),schema: z.object({title: z.string(),description: z.string(),pubDate: z.coerce.date(),})});export const collections = { blog };
```


### Using Exported Variables in MDX


[Section titled Using Exported Variables in MDX](#using-exported-variables-in-mdx)

MDX supports using `export` statements to add variables to your MDX content or to export data to a component that imports it.

For example, you can export a `title` field from an MDX page or component to use as a heading with `{JSX expressions}`:

/src/blog/posts/post-1.mdx

```
export const title = 'My first MDX post'# {title}
```

Or you can use that exported `title` in your page using `import` and `import.meta.glob()` statements:

src/pages/index.astro

```
---const matches = import.meta.glob('./posts/*.mdx', { eager: true });const posts = Object.values(matches);---{posts.map(post=><p>{post.title}</p>)}
```


#### Exported Properties


[Section titled Exported Properties](#exported-properties)

The following properties are available to a `.astro` component when using an `import` statement or `import.meta.glob()`:

-   **`file`** - The absolute file path (e.g. `/home/user/projects/.../file.mdx`).
-   **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`).
-   **`frontmatter`** - Contains any data specified in the file’s YAML/TOML frontmatter.
-   **`getHeadings()`** - An async function that returns an array of all headings (`<h1>` to `<h6>`) in the file with the type: `{ depth: number; slug: string; text: string }[]`. Each heading’s `slug` corresponds to the generated ID for a given heading and can be used for anchor links.
-   **`<Content />`** - A component that returns the full, rendered contents of the file.
-   **(any `export` value)** - MDX files can also export data with an `export` statement.


### Using Frontmatter Variables in MDX


[Section titled Using Frontmatter Variables in MDX](#using-frontmatter-variables-in-mdx)

The Astro MDX integration includes support for using frontmatter in MDX by default. Add frontmatter properties just as you would in Markdown files, and these variables are available to use in the template, and as named properties when importing the file somewhere else.

/src/blog/posts/post-1.mdx

```
---title: 'My first MDX post'author: 'Houston'---# {frontmatter.title}Written by: {frontmatter.author}
```


### Using Components in MDX


[Section titled Using Components in MDX](#using-components-in-mdx)

After installing the MDX integration, you can import and use both [Astro components](/en/basics/astro-components/) and [UI framework components](/en/guides/framework-components/#using-framework-components) in MDX (`.mdx`) files just as you would use them in any other Astro component.

Don’t forget to include a `client:directive` on your UI framework components, if necessary!

See more examples of using import and export statements in the [MDX docs](https://mdxjs.com/docs/what-is-mdx/#esm).

src/blog/post-1.mdx

```
---title: My first post---import ReactCounter from'../components/ReactCounter.jsx';I just started my new Astro blog!Here is my counter component, working in MDX:<ReactCounterclient:load/>
```


#### Custom components with imported MDX


[Section titled Custom components with imported MDX](#custom-components-with-imported-mdx)

When rendering imported MDX content, [custom components](#assigning-custom-components-to-html-elements) can be passed via the `components` prop.

src/pages/page.astro

```
---import { Content, components } from'../content.mdx';import Heading from'../Heading.astro';---<!-- Creates a custom <h1> for the # syntax, _and_ applies any custom components defined in `content.mdx` --><Contentcomponents={{...components, h1: Heading }} />
```

Note

Custom components defined and exported in an MDX file must be imported and then passed back to the `<Content />` component via the `components` property.


#### Assigning Custom Components to HTML elements


[Section titled Assigning Custom Components to HTML elements](#assigning-custom-components-to-html-elements)

With MDX, you can map Markdown syntax to custom components instead of their standard HTML elements. This allows you to write in standard Markdown syntax, but apply special component styling to selected elements.

Import your custom component into your `.mdx` file, then export a `components` object that maps the standard HTML element to your custom component:

src/blog/posts/post-1.mdx

```
import Blockquote from'../components/Blockquote.astro';export const components = {blockquote: Blockquote}> This quote will be a custom Blockquote
```

src/components/Blockquote.astro

```
---const props = Astro.props;---<blockquote {...props} class="bg-blue-50 p-4"><spanclass="text-4xl text-blue-600 mb-2">“</span><slot /><!-- Be sure to add a `<slot/>` for child content! --></blockquote>
```

Visit the [MDX website](https://mdxjs.com/table-of-components/) for a full list of HTML elements that can be overwritten as custom components.


## Configuration


[Section titled Configuration](#configuration)

Once the MDX integration is installed, no configuration is necessary to use `.mdx` files in your Astro project.

You can configure how your MDX is rendered with the following options:

-   [Options inherited from Markdown config](#options-inherited-from-markdown-config)
-   [`extendMarkdownConfig`](#extendmarkdownconfig)
-   [`recmaPlugins`](#recmaplugins)
-   [`optimize`](#optimize)


### Options inherited from Markdown config


[Section titled Options inherited from Markdown config](#options-inherited-from-markdown-config)

All [`markdown` configuration options](/en/reference/configuration-reference/#markdown-options) can be configured separately in the MDX integration. This includes remark and rehype plugins, syntax highlighting, and more. Options will default to those in your Markdown config ([see the `extendMarkdownConfig` option](#extendmarkdownconfig) to modify this).

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';import remarkToc from'remark-toc';import rehypePresetMinify from'rehype-preset-minify';exportdefaultdefineConfig({// ...integrations: [mdx({syntaxHighlight: 'shiki',shikiConfig: { theme: 'dracula' },remarkPlugins: [remarkToc],rehypePlugins: [rehypePresetMinify],remarkRehype: { footnoteLabel: 'Footnotes' },gfm: false,}),],});
```

Caution

MDX does not support passing remark and rehype plugins as a string. You should install, import, and apply the plugin function instead.

See the [Markdown Options reference](/en/reference/configuration-reference/#markdown-options) for a complete list of options.


### `extendMarkdownConfig`


[Section titled extendMarkdownConfig](#extendmarkdownconfig)

-   **Type:** `boolean`
-   **Default:** `true`

MDX will extend [your project’s existing Markdown configuration](/en/reference/configuration-reference/#markdown-options) by default. To override individual options, you can specify their equivalent in your MDX configuration.

For example, say you need to disable GitHub-Flavored Markdown and apply a different set of remark plugins for MDX files. You can apply these options like so, with `extendMarkdownConfig` enabled by default:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({// ...markdown: {syntaxHighlight: 'prism',remarkPlugins: [remarkPlugin1],gfm: true,},integrations: [mdx({// `syntaxHighlight` inherited from Markdown// Markdown `remarkPlugins` ignored,// only `remarkPlugin2` applied.remarkPlugins: [remarkPlugin2],// `gfm` overridden to `false`gfm: false,}),],});
```

You may also need to disable `markdown` config extension in MDX. For this, set `extendMarkdownConfig` to `false`:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({// ...markdown: {remarkPlugins: [remarkPlugin1],},integrations: [mdx({// Markdown config now ignoredextendMarkdownConfig: false,// No `remarkPlugins` applied}),],});
```


### `recmaPlugins`


[Section titled recmaPlugins](#recmaplugins)

These are plugins that modify the output [estree](https://github.com/estree/estree) directly. This is useful for modifying or injecting JavaScript variables in your MDX files.

We suggest [using AST Explorer](https://astexplorer.net/) to play with estree outputs, and trying [`estree-util-visit`](https://unifiedjs.com/explore/package/estree-util-visit/) for searching across JavaScript nodes.


### `optimize`


[Section titled optimize](#optimize)

-   **Type:** `boolean | { ignoreElementNames?: string[] }`

This is an optional configuration setting to optimize the MDX output for faster builds and rendering via an internal rehype plugin. This may be useful if you have many MDX files and notice slow builds. However, this option may generate some unescaped HTML, so make sure your site’s interactive parts still work correctly after enabling it.

This is disabled by default. To enable MDX optimization, add the following to your MDX integration configuration:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({// ...integrations: [mdx({optimize: true,}),],});
```


#### `ignoreElementNames`


[Section titled ignoreElementNames](#ignoreelementnames)

-   **Type:** `string[]`

**Added in:** `@astrojs/mdx@3.0.0`

Previously known as `customComponentNames`.

An optional property of `optimize` to prevent the MDX optimizer from handling certain element names, like [custom components passed to imported MDX content via the components prop](/en/guides/integrations-guide/mdx/#custom-components-with-imported-mdx).

You will need to exclude these components from optimization as the optimizer eagerly converts content into a static string, which will break custom components that needs to be dynamically rendered.

For example, the intended MDX output of the following is `<Heading>...</Heading>` in place of every `"<h1>...</h1>"`:

```
---import { Content, components } from'../content.mdx';import Heading from'../Heading.astro';---<Contentcomponents={{ ...components, h1: Heading }} />
```

To configure optimization for this using the `ignoreElementNames` property, specify an array of HTML element names that should be treated as custom components:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({// ...integrations: [mdx({optimize: {// Prevent the optimizer from handling `h1` elementsignoreElementNames: ['h1'],},}),],});
```

Note that if your MDX file [configures custom components using `export const components = { ... }`](/en/guides/integrations-guide/mdx/#assigning-custom-components-to-html-elements), then you do not need to manually configure this option. The optimizer will automatically detect them.


## Examples


[Section titled Examples](#examples)

-   The [Astro MDX starter template](https://github.com/withastro/astro/tree/latest/examples/with-mdx) shows how to use MDX files in your Astro project.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 102. `en/guides/integrations-guide/netlify/.md`

```text
# @astrojs/

					netlify

---
url: https://docs.astro.build/en/guides/integrations-guide/netlify/
description: Learn how to use the @astrojs/netlify adapter to deploy your Astro project.
---


# @astrojs/ netlify


v6.3.4 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/netlify/) [npm](https://www.npmjs.com/package/@astrojs/netlify) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/netlify/CHANGELOG.md)

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Netlify](https://www.netlify.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/).

If you’re using Astro as a static site builder, you only need this adapter if you are using additional Netlify services that require a server (e.g. [Netlify Image CDN](#netlify-image-cdn-support)). Otherwise, you do not need an adapter to deploy your static site.

Learn how to deploy your Astro site in our [Netlify deployment guide](/en/guides/deploy/netlify/).


## Why Astro Netlify


[Section titled Why Astro Netlify](#why-astro-netlify)

[Netlify](https://www.netlify.com/) is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Netlify.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Add the Netlify adapter to enable on-demand rendering in your Astro project with the `astro add` command. This will install `@astrojs/netlify` and make the appropriate changes to your `astro.config.mjs` file in one step.

-   [npm](#tab-panel-3239)
-   [pnpm](#tab-panel-3240)
-   [Yarn](#tab-panel-3241)

Terminal window

```
npxastroaddnetlify
```

Terminal window

```
pnpmastroaddnetlify
```

Terminal window

```
yarnastroaddnetlify
```

Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode).


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the Netlify adapter to your project’s dependencies using your preferred package manager:

-   [npm](#tab-panel-3242)
-   [pnpm](#tab-panel-3243)
-   [Yarn](#tab-panel-3244)

Terminal window

```
npminstall@astrojs/netlify
```

Terminal window

```
pnpmadd@astrojs/netlify
```

Terminal window

```
yarnadd@astrojs/netlify
```

Then, add the adapter to your `astro.config.*` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify(),});
```


## Usage


[Section titled Usage](#usage)

[Read the full deployment guide here.](/en/guides/deploy/netlify/)

Follow the instructions to [build your site locally](/en/guides/deploy/#building-your-site-locally). After building, you will have a `.netlify/` folder containing both [Netlify Functions](https://docs.netlify.com/functions/overview/) in the `.netlify/functions-internal/` folder and [Netlify Edge Functions](https://docs.netlify.com/edge-functions/overview/) in the`.netlify/edge-functions/` folder.

To deploy your site, install the [Netlify CLI](https://docs.netlify.com/cli/get-started/) and run:

Terminal window

```
netlifydeploy
```

The [Netlify Blog post on Astro](https://www.netlify.com/blog/how-to-deploy-astro/) and the [Netlify Docs](https://docs.netlify.com/integrations/frameworks/astro/) provide more information on how to use this integration to deploy to Netlify.


### Running Astro middleware on Netlify Edge Functions


[Section titled Running Astro middleware on Netlify Edge Functions](#running-astro-middleware-on-netlify-edge-functions)

Any Astro middleware is applied to pre-rendered pages at build-time, and to on-demand-rendered pages at runtime.

To implement redirects, access control, or custom response headers for pre-rendered pages, run your middleware on Netlify Edge Functions by enabling the [`edgeMiddleware` option](/en/reference/adapter-reference/#edgemiddleware):

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify({edgeMiddleware: true,}),});
```

When `edgeMiddleware` is enabled, an edge function will execute your middleware code for all requests including static assets, prerendered pages, and on-demand rendered pages.

For on-demand rendered pages, the `context.locals` object is serialized using JSON and sent in a header for the serverless function, which performs the rendering. As a security measure, the serverless function will refuse to serve requests with a `403 Forbidden` response unless they come from the generated edge function.


### Accessing edge context from your site


[Section titled Accessing edge context from your site](#accessing-edge-context-from-your-site)

Netlify Edge Functions provide a [context object](https://docs.netlify.com/edge-functions/api/#netlify-specific-context-object) that includes metadata about the request such as a user’s IP, geolocation data, and cookies.

This can be accessed through the `Astro.locals.netlify.context` object:

```
---const {geo: { city },} = Astro.locals.netlify.context;---<h1>Hello there, friendly visitor from {city}!</h1>
```

If you’re using TypeScript, you can get proper typings by updating `src/env.d.ts` to use `NetlifyLocals`:

src/env.d.ts

```
type NetlifyLocals =import('@astrojs/netlify').NetlifyLocalsdeclarenamespace App {interface Locals extendsNetlifyLocals {// ...}}
```

This is not available on prerendered pages.


### Netlify Image CDN support


[Section titled Netlify Image CDN support](#netlify-image-cdn-support)

This adapter by default uses the [Netlify Image CDN](https://docs.netlify.com/image-cdn/overview/) to transform images on-the-fly without impacting build times. It’s implemented using an [Astro Image Service](/en/reference/image-service-reference/) under the hood.

To opt out of Netlify’s Image CDN remote image optimization, use the `imageCDN` option:

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify({imageCDN: false,}),});
```

If you are using images hosted on another domain, you must authorize the domain or URL patterns using the [`image.domains`](/en/reference/configuration-reference/#imagedomains) or [`image.remotePatterns`](/en/reference/configuration-reference/#imageremotepatterns) configuration options:

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify(),image: {domains: ['example.com'],},});
```

For more information, see [the guide to authorizing remote images](/en/guides/images/#authorizing-remote-images). This is not required for images hosted on the same domain as your site.


### Static sites with the Netlify Adapter


[Section titled Static sites with the Netlify Adapter](#static-sites-with-the-netlify-adapter)

For static sites (`output: 'static'`) hosted on Netlify, you usually don’t need an adapter. However, some deployment features are only available through an adapter.

Static sites will need to install this adapter to use and configure Netlify’s [image service](#netlify-image-cdn-support).

If you use `redirects` configuration in your Astro config, the Netlify adapter can be used to translate this to the proper `_redirects` format.

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify(),redirects: {'/blog/old-post': '/blog/new-post',},});
```

Once you run `astro build` there will be a `dist/_redirects` file. Netlify will use that to properly route pages in production.

Note

You can still include a `public/_redirects` file for manual redirects. Any redirects you specify in the redirects config are appended to the end of your own.


### Sessions


[Section titled Sessions](#sessions)

The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices.

Astro automatically configures [Netlify Blobs](https://docs.netlify.com/blobs/overview/) for session storage when using the Netlify adapter. If you would prefer to use a different session storage driver, you can specify it in your Astro config. See [the `session` configuration reference](/en/reference/configuration-reference/#sessiondriver) for more details.


### Caching Pages


[Section titled Caching Pages](#caching-pages)

On-demand rendered pages without any dynamic content can be cached to improve performance and lower resource usage. Enabling the `cacheOnDemandPages` option in the adapter will cache all server-rendered pages for up to one year:

astro.config.mjs

```
exportdefaultdefineConfig({// ...adapter: netlify({cacheOnDemandPages: true,}),});
```

This can be changed on a per-page basis by adding caching headers to your response:

pages/index.astro

```
---import Layout from'../components/Layout.astro';Astro.response.headers.set('CDN-Cache-Control', 'public, max-age=45, must-revalidate');---<Layouttitle="Astro on Netlify">{newDate()}</Layout>
```

With [fine-grained cache control](https://www.netlify.com/blog/swr-and-fine-grained-cache-control/), Netlify supports standard caching headers like `CDN-Cache-Control` or `Vary`. Refer to the docs to learn about implementing e.g. time to live (TTL) or stale while revalidate (SWR) caching: [https://docs.netlify.com/platform/caching](https://docs.netlify.com/platform/caching)


### Including or excluding files from Netlify Functions


[Section titled Including or excluding files from Netlify Functions](#including-or-excluding-files-from-netlify-functions)

When deploying an Astro site with on-demand rendering to Netlify, the generated functions automatically trace and include server dependencies. However, you may need to customize which files are included in your Netlify Functions.


#### `includeFiles`


[Section titled includeFiles](#includefiles)

**Type:** `string[]` **Default:** `[]`

**Added in:** `astro@5.3.0`

The `includeFiles` property allows you to explicitly specify additional files that should be bundled with your function. This is useful for files that aren’t automatically detected as dependencies, such as:

-   Data files loaded using `fs` operations
-   Configuration files
-   Template files

Provide an array of additional files to include with file paths relative to your project’s [`root`](/en/reference/configuration-reference/#root). Absolute paths may not work as expected.

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify({includeFiles: ['./my-data.json'], // relative to `root`}),});
```


#### `excludeFiles`


[Section titled excludeFiles](#excludefiles)

**Type:** `string[]` **Default:** `[]`

**Added in:** `astro@5.3.0`

You can use the `excludeFiles` property to prevent specific files from being bundled that would otherwise be included. This is helpful for:

-   Reducing bundle size
-   Excluding large binaries
-   Preventing unwanted files from being deployed

Provide an array of specific files to exclude with file paths relative to your project’s [`root`](/en/reference/configuration-reference/#root). Absolute paths may not work as expected.

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({// ...adapter: netlify({excludeFiles: ['./src/some_big_file.jpg'], // relative to `root`}),});
```


#### Using glob patterns


[Section titled Using glob patterns](#using-glob-patterns)

Both `includeFiles` and `excludeFiles` support [glob patterns](/en/guides/imports/#glob-patterns) for matching multiple files:

astro.config.mjs

```
import { defineConfig } from'astro/config';import netlify from'@astrojs/netlify';exportdefaultdefineConfig({adapter: netlify({includeFiles: ['./data/**/*.json'],excludeFiles: ['./node_modules/package/**/*','./src/**/*.test.js']}),});
```


## Examples


[Section titled Examples](#examples)

-   The [Astro Netlify Edge Starter](https://github.com/sarahetter/astro-netlify-edge-starter) provides an example and a guide in the README.

-   [Browse Astro Netlify projects on GitHub](https://github.com/search?q=path%3A**%2Fastro.config.mjs+%40astrojs%2Fnetlify&type=code) for more examples!



## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 103. `en/guides/integrations-guide/node/.md`

```text
# @astrojs/

					node

---
url: https://docs.astro.build/en/guides/integrations-guide/node/
description: Learn how to use the @astrojs/node adapter to deploy your Astro project.
---


# @astrojs/ node


v9.2.2 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/node/) [npm](https://www.npmjs.com/package/@astrojs/node) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/node/CHANGELOG.md)

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to Node targets, including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/).

If you’re using Astro as a static site builder, you don’t need an adapter.


## Why Astro Node.js


[Section titled Why Astro Node.js](#why-astro-nodejs)

[Node.js](https://nodejs.org/en/) is a JavaScript runtime for server-side code. @astrojs/node can be used either in standalone mode or as middleware for other http servers, such as [Express](https://expressjs.com/).


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Add the Node adapter to enable on-demand rendering in your Astro project with the `astro add` command. This will install `@astrojs/node` and make the appropriate changes to your `astro.config.*` file in one step.

-   [npm](#tab-panel-3245)
-   [pnpm](#tab-panel-3246)
-   [Yarn](#tab-panel-3247)

Terminal window

```
npxastroaddnode
```

Terminal window

```
pnpmastroaddnode
```

Terminal window

```
yarnastroaddnode
```

Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode).


### Manual Install


[Section titled Manual Install](#manual-install)

First, add the Node adapter to your project’s dependencies using your preferred package manager.

-   [npm](#tab-panel-3248)
-   [pnpm](#tab-panel-3249)
-   [Yarn](#tab-panel-3250)

Terminal window

```
npminstall@astrojs/node
```

Terminal window

```
pnpmadd@astrojs/node
```

Terminal window

```
yarnadd@astrojs/node
```

Then, add the adapter to your `astro.config.*` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';import node from'@astrojs/node';exportdefaultdefineConfig({adapter: node({mode: 'standalone',}),});
```


## Configuration


[Section titled Configuration](#configuration)

@astrojs/node can be configured by passing options into the adapter function. The following options are available:


### `mode`


[Section titled mode](#mode)

**Type:** `'middleware' | 'standalone'`

Controls whether the adapter builds to `middleware` or `standalone` mode.

-   `middleware` mode allows the built output to be used as middleware for another Node.js server, like Express.js or Fastify.
-   `standalone` mode builds a server that automatically starts when the entry module is run. This allows you to more easily deploy your build to a host without needing additional code.

astro.config.mjs

```
import { defineConfig } from'astro/config';import node from'@astrojs/node';exportdefaultdefineConfig({adapter: node({mode: 'middleware',}),});
```


## Usage


[Section titled Usage](#usage)

First, [performing a build](/en/guides/deploy/#building-your-site-locally). Depending on which `mode` selected (see above) follow the appropriate steps below:


### Middleware


[Section titled Middleware](#middleware)

The server entrypoint is built to `./dist/server/entry.mjs` by default. This module exports a `handler` function that can be used with any framework that supports the Node `request` and `response` objects.

For example, with Express:

run-server.mjs

```
import express from'express';import { handleras ssrHandler } from'./dist/server/entry.mjs';const app = express();// Change this based on your astro.config.mjs, `base` option.// They should match. The default value is "/".const base = '/';app.use(base, express.static('dist/client/'));app.use(ssrHandler);app.listen(8080);
```

Or, with Fastify (>4):

run-server.mjs

```
import Fastify from'fastify';import fastifyMiddie from'@fastify/middie';import fastifyStatic from'@fastify/static';import { fileURLToPath } from'node:url';import { handleras ssrHandler } from'./dist/server/entry.mjs';const app = Fastify({ logger: true });awaitapp.register(fastifyStatic, {root: fileURLToPath(newURL('./dist/client', import.meta.url)),}).register(fastifyMiddie);app.use(ssrHandler);app.listen({ port: 8080 });
```

Additionally, you can also pass in an object to be accessed with `Astro.locals` or in Astro middleware:

run-server.mjs

```
import express from'express';import { handleras ssrHandler } from'./dist/server/entry.mjs';const app = express();app.use(express.static('dist/client/'));app.use((req, res, next)=> {const locals = {title: 'New title',};ssrHandler(req, res, next, locals);});app.listen(8080);
```

Note that middleware mode does not do file serving. You’ll need to configure your HTTP framework to do that for you. By default the client assets are written to `./dist/client/`.


### Standalone


[Section titled Standalone](#standalone)

In standalone mode a server starts when the server entrypoint is run. By default it is built to `./dist/server/entry.mjs`. You can run it with:

Terminal window

```
node./dist/server/entry.mjs
```

For standalone mode the server handles file serving in addition to the page and API routes.


#### Custom host and port


[Section titled Custom host and port](#custom-host-and-port)

You can override the host and port the standalone server runs on by passing them as environment variables at runtime:

Terminal window

```
HOST=0.0.0.0PORT=4321node./dist/server/entry.mjs
```


#### HTTPS


[Section titled HTTPS](#https)

By default the standalone server uses HTTP. This works well if you have a proxy server in front of it that does HTTPS. If you need the standalone server to run HTTPS itself you need to provide your SSL key and certificate.

You can pass the path to your key and certification via the environment variables `SERVER_CERT_PATH` and `SERVER_KEY_PATH`. This is how you might pass them in bash:

Terminal window

```
SERVER_KEY_PATH=./private/key.pemSERVER_CERT_PATH=./private/cert.pemnode./dist/server/entry.mjs
```


#### Runtime environment variables


[Section titled Runtime environment variables](#runtime-environment-variables)

If an `.env` file containing environment variables is present when the build process is run, these values will be hard-coded in the output, just as when generating a static website.

During the build, the runtime variables must be absent from the `.env` file, and you must provide Astro with every environment variable to expect at run-time: `VARIABLE_1=placeholder astro build`. This signals to Astro that the actual value will be available when the built application is run. The placeholder value will be ignored by the build process, and Astro will use the value provided at run-time.

In the case of multiple run-time variables, store them in a separate file (e.g. `.env.runtime`) from `.env`. Start the build with the following command:

Terminal window

```
export $(cat.env.runtime) && astrobuild
```


#### Assets


[Section titled Assets](#assets)

In standalone mode, assets in your `dist/client/` folder are served via the standalone server. You might be deploying these assets to a CDN, in which case the server will never actually be serving them. But in some cases, such as intranet sites, it’s fine to serve static assets directly from the application server.

Assets in the `dist/client/_astro/` folder are the ones that Astro has built. These assets are all named with a hash and therefore can be given long cache headers. Internally the adapter adds this header for these assets:

```
Cache-Control: public, max-age=31536000, immutable
```


## Sessions


[Section titled Sessions](#sessions)

The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices.

Astro uses the local filesystem for session storage when using the Node adapter. If you would prefer to use a different session storage driver, you can specify it in your Astro config. See [the `session` configuration reference](/en/reference/configuration-reference/#sessiondriver) for more details.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 104. `en/guides/integrations-guide/partytown/.md`

```text
# @astrojs/

					partytown

---
url: https://docs.astro.build/en/guides/integrations-guide/partytown/
description: Learn how to use the @astrojs/partytown integration in your Astro project.
---


# @astrojs/ partytown


v2.1.4 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/partytown/) [npm](https://www.npmjs.com/package/@astrojs/partytown) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/partytown/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables [Partytown](https://partytown.builder.io/) in your Astro project.


## Why Astro Partytown


[Section titled Why Astro Partytown](#why-astro-partytown)

Partytown is a lazy-loaded library to help relocate resource intensive scripts into a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), and off of the [main thread](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread).

If you’re using third-party scripts for things like analytics or ads, Partytown is a great way to make sure that they don’t slow down your site.

The Astro Partytown integration installs Partytown for you and makes sure it’s enabled on all of your pages.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Run one of the following commands in a new terminal window.

-   [npm](#tab-panel-3251)
-   [pnpm](#tab-panel-3252)
-   [Yarn](#tab-panel-3253)

Terminal window

```
npxastroaddpartytown
```

Terminal window

```
pnpmastroaddpartytown
```

Terminal window

```
yarnastroaddpartytown
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/partytown` package:

-   [npm](#tab-panel-3254)
-   [pnpm](#tab-panel-3255)
-   [Yarn](#tab-panel-3256)

Terminal window

```
npminstall@astrojs/partytown
```

Terminal window

```
pnpmadd@astrojs/partytown
```

Terminal window

```
yarnadd@astrojs/partytown
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import partytown from'@astrojs/partytown';exportdefaultdefineConfig({// ...integrations: [partytown()],});
```


## Usage


[Section titled Usage](#usage)

Partytown should be ready to go with zero config. If you have an existing 3rd party script on your site, try adding the `type="text/partytown"` attribute:

```
<scripttype="text/partytown"src="fancy-analytics.js"></script>
```

If you open the “Network” tab from [your browser’s dev tools](https://developer.chrome.com/docs/devtools/open/), you should see the `partytown` proxy intercepting this request.


## Configuration


[Section titled Configuration](#configuration)

To configure this integration, pass a ‘config’ object to the `partytown()` function call in `astro.config.mjs`.

astro.config.mjs

```
exportdefaultdefineConfig({// ...integrations: [partytown({config: {// options go here},}),],});
```

This mirrors the [Partytown config object](https://partytown.builder.io/configuration).


### config.debug


[Section titled config.debug](#configdebug)

Partytown ships with a `debug` mode; enable or disable it by passing `true` or `false` to `config.debug`. If [`debug` mode](https://partytown.builder.io/debugging) is enabled, it will output detailed logs to the browser console.

If this option isn’t set, `debug` mode will be on by default in [dev](/en/reference/cli-reference/#astro-dev) or [preview](/en/reference/cli-reference/#astro-preview) mode.

astro.config.mjs

```
exportdefaultdefineConfig({// ...integrations: [partytown({// Example: Disable debug mode.config: { debug: false },}),],});
```


### config.forward


[Section titled config.forward](#configforward)

Third-party scripts typically add variables to the `window` object so that you can communicate with them throughout your site. But when a script is loaded in a web-worker, it doesn’t have access to that global `window` object.

To solve this, Partytown can “patch” variables to the global window object and forward them to the appropriate script.

You can specify which variables to forward with the `config.forward` option. [Read more in Partytown’s documentation.](https://partytown.builder.io/forwarding-events)

astro.config.mjs

```
exportdefaultdefineConfig({// ...integrations: [partytown({// Example: Add dataLayer.push as a forwarding-event.config: {forward: ['dataLayer.push'],},}),],});
```


## Examples


[Section titled Examples](#examples)

-   [Browse projects with Astro Partytown on GitHub](https://github.com/search?q=%22%40astrojs%2Fpartytown%22+path%3A**%2Fpackage.json&type=code) for more examples!


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 105. `en/guides/integrations-guide/preact/.md`

```text
# @astrojs/

					preact

---
url: https://docs.astro.build/en/guides/integrations-guide/preact/
description: Learn how to use the @astrojs/preact framework integration to extend component support in your Astro project.
---


# @astrojs/ preact


v4.1.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/preact/) [npm](https://www.npmjs.com/package/@astrojs/preact) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/preact/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Preact](https://preactjs.com/) components.


## Why Preact?


[Section titled Why Preact?](#why-preact)

Preact is a library that lets you build interactive UI components for the web. If you want to build interactive features on your site using JavaScript, you may prefer using its component format instead of using browser APIs directly.

Preact is also a great choice if you have previously used React. Preact provides the same API as React, but in a much smaller 3kB package. It even supports rendering many React components using the `compat` configuration option (see below).

**Want to learn more about Preact before using this integration?** Check out [“Learn Preact”](https://preactjs.com/tutorial), an interactive tutorial on their website.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/preact`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3257)
-   [pnpm](#tab-panel-3258)
-   [Yarn](#tab-panel-3259)

Terminal window

```
npxastroaddpreact
```

Terminal window

```
pnpmastroaddpreact
```

Terminal window

```
yarnastroaddpreact
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/preact` package:

-   [npm](#tab-panel-3260)
-   [pnpm](#tab-panel-3261)
-   [Yarn](#tab-panel-3262)

Terminal window

```
npminstall@astrojs/preact
```

Terminal window

```
pnpmadd@astrojs/preact
```

Terminal window

```
yarnadd@astrojs/preact
```

Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'preact'` (or similar) warning when you start up Astro, you’ll need to install Preact:

-   [npm](#tab-panel-3263)
-   [pnpm](#tab-panel-3264)
-   [Yarn](#tab-panel-3265)

Terminal window

```
npminstallpreact
```

Terminal window

```
pnpmaddpreact
```

Terminal window

```
yarnaddpreact
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';exportdefaultdefineConfig({// ...integrations: [preact()],});
```

And add the following code to the `tsconfig.json` file.

tsconfig.json

```
{"extends": "astro/tsconfigs/strict","include": [".astro/types.d.ts", "**/*"],"exclude": ["dist"],"compilerOptions": {"jsx": "react-jsx","jsxImportSource": "preact"}}
```


## Usage


[Section titled Usage](#usage)

To use your first Preact component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You’ll explore:

-   📦 how framework components are loaded,
-   💧 client-side hydration options, and
-   🤝 opportunities to mix and nest frameworks together

Also check our [Astro Integration Documentation](/en/guides/integrations-guide/) for more on integrations.


## Configuration


[Section titled Configuration](#configuration)

The Astro Preact integration handles how Preact components are rendered and it has its own options. Change these in the `astro.config.mjs` file which is where your project’s integration settings live.

For basic usage, you do not need to configure the Preact integration.


### compat


[Section titled compat](#compat)

You can enable `preact/compat`, Preact’s compatibility layer for rendering React components without needing to install or ship React’s larger libraries to your users’ web browsers.

To do so, pass an object to the Preact integration and set `compat: true`.

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';exportdefaultdefineConfig({integrations: [preact({ compat: true })],});
```

With the `compat` option enabled, the Preact integration will render React components as well as Preact components in your project and also allow you to import React components inside Preact components. Read more in [“Switching to Preact (from React)”](https://preactjs.com/guide/v10/switching-to-preact) on the Preact website.

When importing React component libraries, in order to swap out the `react` and `react-dom` dependencies as `preact/compat`, you can use [`overrides`](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides) to do so.

package.json

```
{"overrides": {"react": "npm:@preact/compat@latest","react-dom": "npm:@preact/compat@latest"}}
```

Check out the [`pnpm` overrides](https://pnpm.io/package_json#pnpmoverrides) and [`yarn` resolutions](https://yarnpkg.com/configuration/manifest#resolutions) docs for their respective overrides features.

Note

Currently, the `compat` option only works for React libraries that export code as ESM. If an error happens during build-time, try adding the library to `vite.ssr.noExternal: ['the-react-library']` in your `astro.config.mjs` file.


### devtools


[Section titled devtools](#devtools)

**Added in:** `@astrojs/preact@3.3.0`

You can enable [Preact devtools](https://preactjs.github.io/preact-devtools/) in development by passing an object with `devtools: true` to your `preact()` integration config:

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';exportdefaultdefineConfig({// ...integrations: [preact({ devtools: true })],});
```


## Options


[Section titled Options](#options)


### Combining multiple JSX frameworks


[Section titled Combining multiple JSX frameworks](#combining-multiple-jsx-frameworks)

When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.

Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths.

We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required:

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';import react from'@astrojs/react';import svelte from'@astrojs/svelte';import vue from'@astrojs/vue';import solid from'@astrojs/solid-js';exportdefaultdefineConfig({// Enable many frameworks to support all different kinds of components.// No `include` is needed if you are only using a single JSX framework!integrations: [preact({include: ['**/preact/*'],}),react({include: ['**/react/*'],}),solid({include: ['**/solid/*'],}),],});
```


## Examples


[Section titled Examples](#examples)

-   The [Astro Preact example](https://github.com/withastro/astro/tree/latest/examples/framework-preact) shows how to use an interactive Preact component in an Astro project.
-   The [Astro Nanostores example](https://github.com/withastro/astro/tree/latest/examples/with-nanostores) shows how to share state between different components — and even different frameworks! — in an Astro project.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 106. `en/guides/integrations-guide/react/.md`

```text
# @astrojs/

					react

---
url: https://docs.astro.build/en/guides/integrations-guide/react/
description: Learn how to use the @astrojs/react framework integration to extend component support in your Astro project.
---


# @astrojs/ react


v4.3.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/react/) [npm](https://www.npmjs.com/package/@astrojs/react) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/react/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [React](https://react.dev/) components.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/react`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3266)
-   [pnpm](#tab-panel-3267)
-   [Yarn](#tab-panel-3268)

Terminal window

```
npxastroaddreact
```

Terminal window

```
pnpmastroaddreact
```

Terminal window

```
yarnastroaddreact
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/react` package:

-   [npm](#tab-panel-3269)
-   [pnpm](#tab-panel-3270)
-   [Yarn](#tab-panel-3271)

Terminal window

```
npminstall@astrojs/react
```

Terminal window

```
pnpmadd@astrojs/react
```

Terminal window

```
yarnadd@astrojs/react
```

Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'react'` (or similar) warning when you start up Astro, you’ll need to install `react` and `react-dom` with its type definitions:

-   [npm](#tab-panel-3272)
-   [pnpm](#tab-panel-3273)
-   [Yarn](#tab-panel-3274)

Terminal window

```
npminstallreactreact-dom@types/react@types/react-dom
```

Terminal window

```
pnpmaddreactreact-dom@types/react@types/react-dom
```

Terminal window

```
yarnaddreactreact-dom@types/react@types/react-dom
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import react from'@astrojs/react';exportdefaultdefineConfig({// ...integrations: [react()],});
```

And add the following code to the `tsconfig.json` file.

tsconfig.json

```
{"extends": "astro/tsconfigs/strict","include": [".astro/types.d.ts", "**/*"],"exclude": ["dist"],"compilerOptions": {"jsx": "react-jsx","jsxImportSource": "react"}}
```


## Getting started


[Section titled Getting started](#getting-started)

To use your first React component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You’ll explore:

-   📦 how framework components are loaded,
-   💧 client-side hydration options, and
-   🤝 opportunities to mix and nest frameworks together


## Options


[Section titled Options](#options)


### Combining multiple JSX frameworks


[Section titled Combining multiple JSX frameworks](#combining-multiple-jsx-frameworks)

When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.

Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths.

We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required:

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';import react from'@astrojs/react';import svelte from'@astrojs/svelte';import vue from'@astrojs/vue';import solid from'@astrojs/solid-js';exportdefaultdefineConfig({// Enable many frameworks to support all different kinds of components.// No `include` is needed if you are only using a single JSX framework!integrations: [preact({include: ['**/preact/*'],}),react({include: ['**/react/*'],}),solid({include: ['**/solid/*'],}),],});
```


### Children parsing


[Section titled Children parsing](#children-parsing)

Children passed into a React component from an Astro component are parsed as plain strings, not React nodes.

For example, the `<ReactComponent />` below will only receive a single child element:

```
---import ReactComponent from'./ReactComponent';---<ReactComponent><div>one</div><div>two</div></ReactComponent>
```

If you are using a library that *expects* more than one child element to be passed, for example so that it can slot certain elements in different places, you might find this to be a blocker.

You can set the experimental flag `experimentalReactChildren` to tell Astro to always pass children to React as React virtual DOM nodes. There is some runtime cost to this, but it can help with compatibility.

You can enable this option in the configuration for the React integration:

astro.config.mjs

```
import { defineConfig } from'astro/config';import react from'@astrojs/react';exportdefaultdefineConfig({// ...integrations: [react({experimentalReactChildren: true,}),],});
```


### Disable streaming (experimental)


[Section titled Disable streaming (experimental)](#disable-streaming-experimental)

Astro streams the output of React components by default. However, you can disable this behavior by enabling the `experimentalDisableStreaming` option. This is particularly helpful for supporting libraries that don’t work well with streaming, like some CSS-in-JS solutions.

To disable streaming for all React components in your project, configure `@astrojs/react` with `experimentalDisableStreaming: true`:

astro.config.mjs

```
import { defineConfig } from'astro/config';import react from'@astrojs/react';exportdefaultdefineConfig({// ...integrations: [react({experimentalDisableStreaming: true,}),],});
```


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 107. `en/guides/integrations-guide/solid-js/.md`

```text
# @astrojs/

					solid-js

---
url: https://docs.astro.build/en/guides/integrations-guide/solid-js/
description: Learn how to use the @astrojs/solid-js framework integration to extend component support in your Astro project.
---


# @astrojs/ solid-js


v5.1.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/solid/) [npm](https://www.npmjs.com/package/@astrojs/solid-js) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/solid/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [SolidJS](https://www.solidjs.com/) components.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/solid-js`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3281)
-   [pnpm](#tab-panel-3282)
-   [Yarn](#tab-panel-3283)

Terminal window

```
npxastroaddsolid
```

Terminal window

```
pnpmastroaddsolid
```

Terminal window

```
yarnastroaddsolid
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/solid-js` package:

-   [npm](#tab-panel-3284)
-   [pnpm](#tab-panel-3285)
-   [Yarn](#tab-panel-3286)

Terminal window

```
npminstall@astrojs/solid-js
```

Terminal window

```
pnpmadd@astrojs/solid-js
```

Terminal window

```
yarnadd@astrojs/solid-js
```

Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'solid-js'` (or similar) warning when you start up Astro, you’ll need to install SolidJS:

-   [npm](#tab-panel-3287)
-   [pnpm](#tab-panel-3288)
-   [Yarn](#tab-panel-3289)

Terminal window

```
npminstallsolid-js
```

Terminal window

```
pnpmaddsolid-js
```

Terminal window

```
yarnaddsolid-js
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import solidJs from'@astrojs/solid-js';exportdefaultdefineConfig({// ...integrations: [solidJs()],});
```

And add the following code to the `tsconfig.json` file.

tsconfig.json

```
{"extends": "astro/tsconfigs/strict","include": [".astro/types.d.ts", "**/*"],"exclude": ["dist"],"compilerOptions": {"jsx": "preserve","jsxImportSource": "solid-js"}}
```


## Getting started


[Section titled Getting started](#getting-started)

To use your first SolidJS component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You’ll explore:

-   📦 how framework components are loaded,
-   💧 client-side hydration options, and
-   🤝 opportunities to mix and nest frameworks together


## Configuration


[Section titled Configuration](#configuration)


### devtools


[Section titled devtools](#devtools)

**Added in:** `@astrojs/solid-js@4.2.0`

You can enable [Solid DevTools](https://github.com/thetarnav/solid-devtools) in development by passing an object with `devtools: true` to your `solid()` integration config and adding `solid-devtools` to your project dependencies:

-   [npm](#tab-panel-3290)
-   [pnpm](#tab-panel-3291)
-   [Yarn](#tab-panel-3292)

Terminal window

```
npminstallsolid-devtools
```

Terminal window

```
pnpmaddsolid-devtools
```

Terminal window

```
yarnaddsolid-devtools
```

astro.config.mjs

```
import { defineConfig } from'astro/config';import solid from'@astrojs/solid-js';exportdefaultdefineConfig({// ...integrations: [solid({ devtools: true })],});
```


## Options


[Section titled Options](#options)


### Combining multiple JSX frameworks


[Section titled Combining multiple JSX frameworks](#combining-multiple-jsx-frameworks)

When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.

Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths.

We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required:

astro.config.mjs

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';import react from'@astrojs/react';import svelte from'@astrojs/svelte';import vue from'@astrojs/vue';import solid from'@astrojs/solid-js';exportdefaultdefineConfig({// Enable many frameworks to support all different kinds of components.// No `include` is needed if you are only using a single JSX framework!integrations: [preact({include: ['**/preact/*'],}),react({include: ['**/react/*'],}),solid({include: ['**/solid/*', '**/node_modules/@suid/material/**'],}),],});
```


## Usage


[Section titled Usage](#usage)

Use a SolidJS component as you would any [UI framework component](/en/guides/framework-components/).


### Suspense Boundaries


[Section titled Suspense Boundaries](#suspense-boundaries)

In order to support Solid Resources and Lazy Components without excessive configuration, server-only and hydrating components are automatically wrapped in top-level Suspense boundaries and rendered on the server using the [`renderToStringAsync`](https://www.solidjs.com/docs/latest/api#rendertostringasync) function. Therefore, you do not need to add a top-level Suspense boundary around async components.

For example, you can use Solid’s [`createResource`](https://www.solidjs.com/docs/latest/api#createresource) to fetch async remote data on the server. The remote data will be included in the initial server-rendered HTML from Astro:

CharacterName.tsx

```
functionCharacterName() {const [name] = createResource(() =>fetch('https://swapi.dev/api/people/1').then((result) => result.json()).then((data) => data.name));return (<><h2>Name:</h2>{/* Luke Skywalker */}<div>{name()}</div></>);}
```

Similarly, Solid’s [Lazy Components](https://www.solidjs.com/docs/latest/api#lazy) will also be resolved and their HTML will be included in the initial server-rendered page.

Non-hydrating [`client:only` components](/en/reference/directives-reference/#clientonly) are not automatically wrapped in Suspense boundaries.

Feel free to add additional Suspense boundaries according to your preference.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 108. `en/guides/integrations-guide/svelte/.md`

```text
# @astrojs/

					svelte

---
url: https://docs.astro.build/en/guides/integrations-guide/svelte/
description: Learn how to use the @astrojs/svelte framework integration to extend component support in your Astro project.
---


# @astrojs/ svelte


v7.1.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/svelte/) [npm](https://www.npmjs.com/package/@astrojs/svelte) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/svelte/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Svelte](https://svelte.dev/) 5 components. For Svelte 3 and 4 support, install `@astrojs/svelte@5` instead.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/svelte`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3293)
-   [pnpm](#tab-panel-3294)
-   [Yarn](#tab-panel-3295)

Terminal window

```
npxastroaddsvelte
```

Terminal window

```
pnpmastroaddsvelte
```

Terminal window

```
yarnastroaddsvelte
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/svelte` package:

-   [npm](#tab-panel-3296)
-   [pnpm](#tab-panel-3297)
-   [Yarn](#tab-panel-3298)

Terminal window

```
npminstall@astrojs/svelte
```

Terminal window

```
pnpmadd@astrojs/svelte
```

Terminal window

```
yarnadd@astrojs/svelte
```

Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'svelte'` (or similar) warning when you start up Astro, you’ll need to install Svelte and TypeScript:

-   [npm](#tab-panel-3299)
-   [pnpm](#tab-panel-3300)
-   [Yarn](#tab-panel-3301)

Terminal window

```
npminstallsveltetypescript
```

Terminal window

```
pnpmaddsveltetypescript
```

Terminal window

```
yarnaddsveltetypescript
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import svelte from'@astrojs/svelte';exportdefaultdefineConfig({// ...integrations: [svelte()],});
```

And create a new file called `svelte.config.js` in your project root directory and add the following code:

svelte.config.js

```
import { vitePreprocess } from'@astrojs/svelte';exportdefault {preprocess: vitePreprocess(),}
```


## Getting started


[Section titled Getting started](#getting-started)

To use your first Svelte component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You’ll explore:

-   📦 how framework components are loaded,
-   💧 client-side hydration options, and
-   🤝 opportunities to mix and nest frameworks together


## Options


[Section titled Options](#options)

This integration is powered by `@sveltejs/vite-plugin-svelte`. To customize the Svelte compiler, options can be provided to the integration. See the [`@sveltejs/vite-plugin-svelte` docs](https://github.com/sveltejs/vite-plugin-svelte/blob/HEAD/docs/config.md) for more details.

You can set options either by passing them to the `svelte` integration in `astro.config.mjs` or in `svelte.config.js`. The options in `astro.config.mjs` will take precedence over the options in `svelte.config.js` if both are present:

astro.config.mjs

```
import { defineConfig } from'astro/config';import svelte from'@astrojs/svelte';exportdefaultdefineConfig({integrations: [svelte({ extensions: ['.svelte'] })],});
```

svelte.config.js

```
exportdefault {extensions: ['.svelte'],};
```


## Preprocessors


[Section titled Preprocessors](#preprocessors)

**Added in:** `@astrojs/svelte@2.0.0`

If you’re using SCSS or Stylus in your Svelte files, you can create a `svelte.config.js` file so that they are preprocessed by Svelte, and the Svelte IDE extension can correctly parse the Svelte files.

svelte.config.js

```
import { vitePreprocess } from'@astrojs/svelte';exportdefault {preprocess: vitePreprocess(),};
```

This config file will be automatically added for you when you run `astro add svelte`. See the [`@sveltejs/vite-plugin-svelte` docs](https://github.com/sveltejs/vite-plugin-svelte/blob/HEAD/docs/preprocess.md) for more details about `vitePreprocess`.


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 109. `en/guides/integrations-guide/vercel/.md`

```text
# @astrojs/

					vercel

---
url: https://docs.astro.build/en/guides/integrations-guide/vercel/
description: Learn how to use the @astrojs/vercel adapter to deploy your Astro project.
---


# @astrojs/ vercel


v8.1.4 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/vercel/) [npm](https://www.npmjs.com/package/@astrojs/vercel) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/vercel/CHANGELOG.md)

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Vercel](https://www.vercel.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/).

If you’re using Astro as a static site builder, you only need this adapter if you are using additional Vercel services (e.g. [Vercel Web Analytics](https://vercel.com/docs/analytics), [Vercel Image Optimization](https://vercel.com/docs/image-optimization)). Otherwise, you do not need an adapter to deploy your static site.

Learn how to deploy your Astro site in our [Vercel deployment guide](/en/guides/deploy/vercel/).


## Why Astro Vercel?


[Section titled Why Astro Vercel?](#why-astro-vercel)

[Vercel](https://www.vercel.com/) is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Vercel.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

Add the Vercel adapter to enable on-demand rendering in your Astro project with the following `astro add` command. This will install `@astrojs/vercel` and make the appropriate changes to your `astro.config.mjs` file in one step.

-   [npm](#tab-panel-3302)
-   [pnpm](#tab-panel-3303)
-   [Yarn](#tab-panel-3304)

Terminal window

```
npxastroaddvercel
```

Terminal window

```
pnpmastroaddvercel
```

Terminal window

```
yarnastroaddvercel
```

Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode).


### Manual Install


[Section titled Manual Install](#manual-install)

First, add the `@astrojs/vercel` adapter to your project’s dependencies using your preferred package manager:

-   [npm](#tab-panel-3305)
-   [pnpm](#tab-panel-3306)
-   [Yarn](#tab-panel-3307)

Terminal window

```
npminstall@astrojs/vercel
```

Terminal window

```
pnpmadd@astrojs/vercel
```

Terminal window

```
yarnadd@astrojs/vercel
```

Then, add the adapter to your `astro.config.*` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel(),});
```


## Usage


[Section titled Usage](#usage)

Find out more about [deploying your project to Vercel](/en/guides/deploy/vercel/).

You can deploy by CLI (`vercel deploy`) or by connecting your new repo in the [Vercel Dashboard](https://vercel.com/). Alternatively, you can create a production build locally:

Terminal window

```
astrobuildverceldeploy--prebuilt
```


## Configuration


[Section titled Configuration](#configuration)

To configure this adapter, pass an object to the `vercel()` function call in `astro.config.mjs`:


### `webAnalytics`


[Section titled webAnalytics](#webanalytics)

**Type:** `VercelWebAnalyticsConfig` **Available for:** Serverless, Static

**Added in:** `@astrojs/vercel@3.8.0`

With `@vercel/analytics@1.3.x` or earlier, you can set `webAnalytics: { enabled: true }` in your Astro config to inject Vercel’s tracking scripts into all of your pages.

For `@vercel/analytics@1.4.0` and later, use Vercel’s Analytics component to enable [Vercel Web Analytics](https://vercel.com/docs/concepts/analytics) instead.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({webAnalytics: {enabled: true,},}),});
```


### `imagesConfig`


[Section titled imagesConfig](#imagesconfig)

**Type:** `VercelImageConfig` **Available for:** Serverless, Static

**Added in:** `@astrojs/vercel@3.3.0`

Configuration options for [Vercel’s Image Optimization API](https://vercel.com/docs/concepts/image-optimization). See [Vercel’s image configuration documentation](https://vercel.com/docs/build-output-api/v3/configuration#images) for a complete list of supported parameters.

The `domains` and `remotePatterns` properties will automatically be filled using [the Astro corresponding `image` settings](/en/reference/configuration-reference/#image-options).

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...output: 'static',adapter: vercel({imagesConfig: {sizes: [320, 640, 1280],},}),});
```


### `imageService`


[Section titled imageService](#imageservice)

**Type:** `boolean` **Available for:** Serverless, Static

**Added in:** `@astrojs/vercel@3.3.0`

When enabled, an [Image Service](/en/reference/image-service-reference/) powered by the Vercel Image Optimization API will be automatically configured and used in production. In development, the image service specified by [`devImageService`](#devimageservice) will be used instead.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...output: 'static',adapter: vercel({imageService: true,}),});
```

src/pages/index.astro

```
---import { Image } from'astro:assets';import astroLogo from'../assets/logo.png';---<!-- This component --><Imagesrc={astroLogo}alt="My super logo!" /><!-- will become the following HTML --><imgsrc="/_vercel/image?url=_astro/logo.hash.png&w=...&q=..."alt="My super logo!"loading="lazy"decoding="async"width="..."height="..."/>
```


### `devImageService`


[Section titled devImageService](#devimageservice)

**Type:** `'sharp' | string` **Available for:** Serverless, Static

**Added in:** `@astrojs/vercel@3.8.0`

**Default**: `sharp`

Allows you to configure which image service to use in development when [imageService](#imageservice) is enabled. This can be useful if you cannot install Sharp’s dependencies on your development machine, but using another image service like Squoosh would allow you to preview images in your dev environment. Build is unaffected and will always use Vercel’s Image Optimization.

It can also be set to any arbitrary value in order to use a custom image service instead of Astro’s built-in ones.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({imageService: true,devImageService: 'sharp',}),});
```


### `isr`


[Section titled isr](#isr)

**Type:** `boolean | VercelISRConfig` **Available for:** Serverless

**Added in:** `@astrojs/vercel@7.2.0`

**Default**: `false`

Allows your project to be deployed as an [ISR (Incremental Static Regeneration)](https://vercel.com/docs/incremental-static-regeneration) function, which caches your on-demand rendered pages in the same way as prerendered pages after first request.

To enable this feature, set `isr` to true in your Vercel adapter configuration in `astro.config.mjs`:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({isr: true,}),});
```

Note that ISR function requests do not include search params, similar to [requests](/en/reference/api-reference/#request) in static mode.


#### ISR cache invalidation


[Section titled ISR cache invalidation](#isr-cache-invalidation)

By default, an ISR function caches for the duration of your deployment. You can further control caching by setting an expiration time, or by excluding particular routes from caching entirely.


##### Time-based invalidation


[Section titled Time-based invalidation](#time-based-invalidation)

You can change the length of time to cache routes this by configuring an `expiration` value in seconds:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({isr: {// caches all pages on first request and saves for 1 dayexpiration: 60*60*24,},}),});
```


##### Excluding paths from caching


[Section titled Excluding paths from caching](#excluding-paths-from-caching)

To implement Vercel’s [Draft mode](https://vercel.com/docs/build-output-api/v3/features#draft-mode), or [On-Demand Incremental Static Regeneration (ISR)](https://vercel.com/docs/build-output-api/v3/features#on-demand-incremental-static-regeneration-isr), you can create a bypass token and provide it to the `isr` config along with any routes to exclude from caching:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({adapter: vercel({isr: {// A secret random string that you create.bypassToken: "005556d774a8",// Paths that will always be served fresh.exclude: ['/preview','/auth/[page]',/^\/api\/.+/// Regular expressions supported since @astrojs/vercel@v8.1.0]}})})
```


### `includeFiles`


[Section titled includeFiles](#includefiles)

**Type:** `string[]` **Available for:** Serverless

Use this property to force files to be bundled with your function. This is helpful when you notice missing files.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({includeFiles: ['./my-data.json'],}),});
```


### `excludeFiles`


[Section titled excludeFiles](#excludefiles)

**Type:** `string[]` **Available for:** Serverless

Use this property to exclude any files from the bundling process that would otherwise be included.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({excludeFiles: ['./src/some_big_file.jpg'],}),});
```


### `maxDuration`


[Section titled maxDuration](#maxduration)

**Type:** `number` **Available for:** Serverless

Use this property to extend or limit the maximum duration (in seconds) that Serverless Functions can run before timing out. See the [Vercel documentation](https://vercel.com/docs/functions/serverless-functions/runtimes#maxduration) for the default and maximum limit for your account plan.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({maxDuration: 60}),});
```


### `skewProtection`


[Section titled skewProtection](#skewprotection)

**Type:** `boolean` **Available for:** Serverless

**Added in:** `@astrojs/vercel@7.6.0`

Use this property to enable [Vercel Skew protection](https://vercel.com/docs/deployments/skew-protection) (available with Vercel Pro and Enterprise accounts).

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({skewProtection: true}),});
```


### Running Astro middleware on Vercel Edge Functions


[Section titled Running Astro middleware on Vercel Edge Functions](#running-astro-middleware-on-vercel-edge-functions)

The `@astrojs/vercel` adapter can create an [edge function](https://vercel.com/docs/functions/edge-functions) from an Astro middleware in your code base. When `edgeMiddleware` is enabled, an edge function will execute your middleware code for all requests including static assets, prerendered pages, and on-demand rendered pages.

For on-demand rendered pages, the `context.locals` object is serialized using JSON and sent in a header for the serverless function, which performs the rendering. As a security measure, the serverless function will refuse to serve requests with a `403 Forbidden` response unless they come from the generated edge function.

This is an opt-in feature. To enable it, set `edgeMiddleware` to `true`:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({// ...adapter: vercel({edgeMiddleware: true,}),});
```

The edge middleware has access to Vercel’s [`RequestContext`](https://vercel.com/docs/functions/edge-middleware/middleware-api#requestcontext) as `ctx.locals.vercel.edge`. If you’re using TypeScript, you can get proper typings by updating `src/env.d.ts` to use `EdgeLocals`:

```
type EdgeLocals =import('@astrojs/vercel').EdgeLocalsdeclarenamespace App {interface Locals extendsEdgeLocals {// ...}}
```


### Node.js Version Support


[Section titled Node.js Version Support](#nodejs-version-support)

The `@astrojs/vercel` adapter supports specific Node.js versions for deploying your Astro project on Vercel. To view the supported Node.js versions on Vercel, click on the settings tab for a project and scroll down to “Node.js Version” section.

Check out the [Vercel documentation](https://vercel.com/docs/functions/serverless-functions/runtimes/node-js#default-and-available-versions) to learn more.


### Sessions


[Section titled Sessions](#sessions)

The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices.

When using sessions on Vercel, you need to [configure a driver](/en/reference/configuration-reference/#sessiondriver) for session storage. You can install a storage provider from [the Vercel marketplace](https://vercel.com/marketplace?category=storage).

For example, if you have installed [a Redis integration](https://vercel.com/marketplace?category=storage&search=redis) and linked a database to your site:

1.  Install the `ioredis` package:

    -   [npm](#tab-panel-3308)
    -   [pnpm](#tab-panel-3309)
    -   [Yarn](#tab-panel-3310)

    Terminal window

    ```
    npminstallioredis
    ```

    Terminal window

    ```
    pnpminstallioredis
    ```

    Terminal window

    ```
    yarnaddioredis
    ```

2.  Use [the Vercel CLI](https://vercel.com/docs/cli) to load your environment variables:

    Terminal window

    ```
    vercelenvpull.env.local
    ```

    This will create a `.env.local` file in your project root with the environment variables needed to connect to your Redis database when developing locally.

3.  Configure the session driver:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import vercel from'@astrojs/vercel';exportdefaultdefineConfig({adapter: vercel(),session: {driver: 'redis',options: {url: process.env.REDIS_URL,},},});
    ```



## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 110. `en/guides/integrations-guide/vue/.md`

```text
# @astrojs/

					vue

---
url: https://docs.astro.build/en/guides/integrations-guide/vue/
description: Learn how to use the @astrojs/vue framework integration to extend component support in your Astro project.
---


# @astrojs/ vue


v5.1.0 [GitHub](https://github.com/withastro/astro/tree/main/packages/integrations/vue/) [npm](https://www.npmjs.com/package/@astrojs/vue) [Changelog](https://github.com/withastro/astro/tree/main/packages/integrations/vue/CHANGELOG.md)

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Vue 3](https://vuejs.org/) components.


## Installation


[Section titled Installation](#installation)

Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead.

To install `@astrojs/vue`, run the following from your project directory and follow the prompts:

-   [npm](#tab-panel-3311)
-   [pnpm](#tab-panel-3312)
-   [Yarn](#tab-panel-3313)

Terminal window

```
npxastroaddvue
```

Terminal window

```
pnpmastroaddvue
```

Terminal window

```
yarnastroaddvue
```

If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below.


### Manual Install


[Section titled Manual Install](#manual-install)

First, install the `@astrojs/vue` package:

-   [npm](#tab-panel-3314)
-   [pnpm](#tab-panel-3315)
-   [Yarn](#tab-panel-3316)

Terminal window

```
npminstall@astrojs/vue
```

Terminal window

```
pnpmadd@astrojs/vue
```

Terminal window

```
yarnadd@astrojs/vue
```

Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'vue'` (or similar) warning when you start up Astro, you’ll need to install Vue:

-   [npm](#tab-panel-3317)
-   [pnpm](#tab-panel-3318)
-   [Yarn](#tab-panel-3319)

Terminal window

```
npminstallvue
```

Terminal window

```
pnpmaddvue
```

Terminal window

```
yarnaddvue
```

Then, apply the integration to your `astro.config.*` file using the `integrations` property:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue()],});
```


## Getting started


[Section titled Getting started](#getting-started)

To use your first Vue component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You’ll explore:

-   📦 how framework components are loaded,
-   💧 client-side hydration options, and
-   🤝 opportunities to mix and nest frameworks together


## Troubleshooting


[Section titled Troubleshooting](#troubleshooting)

For help, check out the `#support` channel on [Discord](https://astro.build/chat). Our friendly Support Squad members are here to help!

You can also check our [Astro Integration Documentation](/en/guides/integrations-guide/) for more on integrations.


## Contributing


[Section titled Contributing](#contributing)

This package is maintained by Astro’s Core team. You’re welcome to submit an issue or PR!


## Options


[Section titled Options](#options)

This integration is powered by `@vitejs/plugin-vue`. To customize the Vue compiler, options can be provided to the integration. See the `@vitejs/plugin-vue` [docs](https://www.npmjs.com/package/@vitejs/plugin-vue) for more details.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue({template: {compilerOptions: {// treat any tag that starts with ion- as custom elementsisCustomElement: (tag)=>tag.startsWith('ion-'),},},// ...}),],});
```


### appEntrypoint


[Section titled appEntrypoint](#appentrypoint)

You can extend the Vue `app` instance setting the `appEntrypoint` option to a root-relative import specifier (for example, `appEntrypoint: "/src/pages/_app"`).

The default export of this file should be a function that accepts a Vue `App` instance prior to rendering, allowing the use of [custom Vue plugins](https://vuejs.org/guide/reusability/plugins.html), `app.use`, and other customizations for advanced use cases.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue({ appEntrypoint: '/src/pages/_app' })],});
```

src/pages/\_app.ts

```
importtype { App } from'vue';import i18nPlugin from'my-vue-i18n-plugin';exportdefault(app:App)=> {app.use(i18nPlugin);};
```


### jsx


[Section titled jsx](#jsx)

You can use Vue JSX by setting `jsx: true`.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue({ jsx: true })],});
```

This will enable rendering for both Vue and Vue JSX components. To customize the Vue JSX compiler, pass an options object instead of a boolean. See the `@vitejs/plugin-vue-jsx` [docs](https://www.npmjs.com/package/@vitejs/plugin-vue-jsx) for more details.

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue({jsx: {// treat any tag that starts with ion- as custom elementsisCustomElement: (tag)=>tag.startsWith('ion-'),},}),],});
```


### devtools


[Section titled devtools](#devtools)

**Added in:** `@astrojs/vue@4.2.0`

You can enable [Vue DevTools](https://devtools-next.vuejs.org/) in development by passing an object with `devtools: true` to your `vue()` integration config:

astro.config.mjs

```
import { defineConfig } from'astro/config';import vue from'@astrojs/vue';exportdefaultdefineConfig({// ...integrations: [vue({ devtools: true })],});
```


#### Customizing Vue DevTools


[Section titled Customizing Vue DevTools](#customizing-vue-devtools)

**Added in:** `@astrojs/vue@4.3.0`

For more customization, you can instead pass options that the [Vue DevTools Vite Plugin](https://devtools-next.vuejs.org/guide/vite-plugin#options) supports. (Note: `appendTo` is not supported.)

For example, you can set `launchEditor` to your preferred editor if you are not using Visual Studio Code:

astro.config.mjs

```
import { defineConfig } from"astro/config";import vue from"@astrojs/vue";exportdefaultdefineConfig({// ...integrations: [vue({devtools: { launchEditor: "webstorm" },}),],});
```


## More integrations



### Front-end frameworks


-   ### [@astrojs/alpinejs](/en/guides/integrations-guide/alpinejs/)

-   ### [@astrojs/preact](/en/guides/integrations-guide/preact/)

-   ### [@astrojs/react](/en/guides/integrations-guide/react/)

-   ### [@astrojs/solid⁠-⁠js](/en/guides/integrations-guide/solid-js/)

-   ### [@astrojs/svelte](/en/guides/integrations-guide/svelte/)

-   ### [@astrojs/vue](/en/guides/integrations-guide/vue/)



### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)



### Other integrations


-   ### [@astrojs/db](/en/guides/integrations-guide/db/)

-   ### [@astrojs/markdoc](/en/guides/integrations-guide/markdoc/)

-   ### [@astrojs/mdx](/en/guides/integrations-guide/mdx/)

-   ### [@astrojs/partytown](/en/guides/integrations-guide/partytown/)

-   ### [@astrojs/sitemap](/en/guides/integrations-guide/sitemap/)


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 111. `en/guides/internationalization/.md`

```text
# Internationalization (i18n) Routing


---
url: https://docs.astro.build/en/guides/internationalization/
description: Learn how to use Astro’s i18n routing features to localize your site’s pages.
---


# Internationalization (i18n) Routing


Astro’s internationalization (i18n) features allow you to adapt your project for an international audience. This routing API helps you generate, use, and verify the URLs that your multi-language site produces.

Astro’s i18n routing allows you to bring your multilingual content with support for configuring a default language, computing relative page URLs, and accepting preferred languages provided by your visitor’s browser. You can also specify fallback languages on a per-language basis so that your visitors can always be directed to existing content on your site.


## Routing Logic


[Section titled Routing Logic](#routing-logic)

Astro uses a [middleware](/en/guides/middleware/) to implement its routing logic. This middleware function is placed in the [first position](/en/guides/middleware/#chaining-middleware) where it awaits every `Response` coming from any additional middleware and each page route before finally executing its own logic.

This means that operations (e.g. redirects) from your own middleware and your page logic are run first, your routes are rendered, and then the i18n middleware performs its own actions such as verifying that a localized URL corresponds to a valid route.

You can also choose to [add your own i18n logic in addition to or instead of Astro’s i18n middleware](#manual), giving you even more control over your routes while still having access to the `astro:i18n` helper functions.


## Configure i18n routing


[Section titled Configure i18n routing](#configure-i18n-routing)

Both a list of all supported languages ([`locales`](/en/reference/configuration-reference/#i18nlocales)) and a default language ([`defaultLocale`](/en/reference/configuration-reference/#i18ndefaultlocale)), which must be one of the languages listed in `locales`, need to be specified in an `i18n` configuration object. Additionally, you can configure more specific routing and fallback behavior to match your desired URLs.

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "pt-br"],defaultLocale: "en",}})
```


### Create localized folders


[Section titled Create localized folders](#create-localized-folders)

Organize your content folders with localized content by language. Create individual `/[locale]/` folders anywhere within `src/pages/` and Astro’s [file-based routing](/en/guides/routing/) will create your pages at corresponding URL paths.

Your folder names must match the items in `locales` exactly. Include a localized folder for your `defaultLocale` only if you configure `prefixDefaultLocale: true` to show a localized URL path for your default language (e.g. `/en/about/`).

-   Directorysrc

    -   Directorypages

        -   about.astro
        -   index.astro
        -   Directoryes

            -   about.astro
            -   index.astro

        -   Directorypt-br

            -   about.astro
            -   index.astro




Note

The localized folders do not need to be at the root of the `/pages/` folder.


### Create links


[Section titled Create links](#create-links)

With i18n routing configured, you can now compute links to pages within your site using the helper functions such as [`getRelativeLocaleUrl()`](/en/reference/modules/astro-i18n/#getrelativelocaleurl) available from the [`astro:i18n` module](/en/reference/modules/astro-i18n/). These generated links will always provide the correct, localized route and can help you correctly use, or check, URLs on your site.

You can also still write the links manually.

src/pages/es/index.astro

```
---import { getRelativeLocaleUrl } from'astro:i18n';// defaultLocale is "es"const aboutURL = getRelativeLocaleUrl("es", "about");---<ahref="/get-started/">¡Vamos!</a><ahref={getRelativeLocaleUrl('es', 'blog')}>Blog</a><ahref={aboutURL}>Acerca</a>
```


## `routing`


[Section titled routing](#routing)

Astro’s built-in file-based routing automatically creates URL routes for you based on your file structure within `src/pages/`.

When you configure i18n routing, information about this file structure (and the corresponding URL paths generated) is available to the i18n helper functions so they can generate, use, and verify the routes in your project. Many of these options can be used together for even more customization and per-language flexibility.

You can even choose to [implement your own routing logic manually](#manual) for even greater control.


### `prefixDefaultLocale`


[Section titled prefixDefaultLocale](#prefixdefaultlocale)

**Added in:** `astro@3.5.0`

This routing option defines whether or not your default language’s URLs should use a language prefix (e.g. `/en/about/`).

All non-default supported languages **will** use a localized prefix (e.g. `/fr/` or `/french/`) and content files must be located in appropriate folders. This configuration option allows you to specify whether your default language should also follow a localized URL structure.

This setting also determines where the page files for your default language must exist (e.g. `src/pages/about/` or `src/pages/en/about`) as the file structure and URL structure must match for all languages.

-   `"prefixDefaultLocale: false"` (default): URLs in your default language will **not** have a `/[locale]/` prefix. All other locales will.

-   `"prefixDefaultLocale: true"`: All URLs, including your default language, will have a `/[locale]/` prefix.



#### `prefixDefaultLocale: false`


[Section titled prefixDefaultLocale: false](#prefixdefaultlocale-false)

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "fr"],defaultLocale: "en",routing: {prefixDefaultLocale: false}}})
```

This is the **default** value. Set this option when URLs in your default language will **not** have a `/[locale]/` prefix and files in your default language exist at the root of `src/pages/`:

-   Directorysrc

    -   Directorypages

        -   about.astro
        -   index.astro
        -   Directoryes

            -   about.astro
            -   index.astro

        -   Directoryfr

            -   about.astro
            -   index.astro




-   `src/pages/about.astro` will produce the route `example.com/about/`
-   `src/pages/fr/about.astro` will produce the route `example.com/fr/about/`


#### `prefixDefaultLocale: true`


[Section titled prefixDefaultLocale: true](#prefixdefaultlocale-true)

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "fr"],defaultLocale: "en",routing: {prefixDefaultLocale: true}}})
```

Set this option when all routes will have their `/locale/` prefix in their URL and when all page content files, including those for your `defaultLocale`, exist in a localized folder:

-   Directorysrc

    -   Directorypages

        -   **index.astro** // Note: this file is always required
        -   Directoryen

            -   index.astro
            -   about.astro

        -   Directoryes

            -   about.astro
            -   index.astro

        -   Directorypt-br

            -   about.astro
            -   index.astro




-   URLs without a locale prefix, (e.g. `example.com/about/`) will return a 404 (not found) status code unless you specify a [fallback strategy](#fallback).


### `redirectToDefaultLocale`


[Section titled redirectToDefaultLocale](#redirecttodefaultlocale)

**Added in:** `astro@4.2.0`

Configures whether or not the home URL (`/`) generated by `src/pages/index.astro` will redirect to `/<defaultLocale>`.

Setting `prefixDefaultLocale: true` will also automatically set `redirectToDefaultLocale: true` in your `routing` config object. By default, the required `src/pages/index.astro` file will automatically redirect to the index page of your default locale.

You can opt out of this behavior by [setting `redirectToDefaultLocale: false`](/en/reference/configuration-reference/#i18nroutingredirecttodefaultlocale). This allows you to have a site home page that exists outside of your configured locale folder structure.


### `manual`


[Section titled manual](#manual)

**Added in:** `astro@4.6.0`

When this option is enabled, Astro will **disable** its i18n middleware so that you can implement your own custom logic. No other `routing` options (e.g. `prefixDefaultLocale`) may be configured with `routing: "manual"`.

You will be responsible for writing your own routing logic, or [executing Astro’s i18n middleware manually](#middleware-function) alongside your own.

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "fr"],defaultLocale: "en",routing: "manual"}})
```

Astro provides helper functions for your middleware so you can control your own default routing, exceptions, fallback behavior, error catching, etc: [`redirectToDefaultLocale()`](/en/reference/modules/astro-i18n/#redirecttodefaultlocale), [`notFound()`](/en/reference/modules/astro-i18n/#notfound), and [`redirectToFallback()`](/en/reference/modules/astro-i18n/#redirecttofallback):

src/middleware.js

```
import { defineMiddleware } from"astro:middleware";import { redirectToDefaultLocale } from"astro:i18n"; // function available with `manual` routingexport const onRequest = defineMiddleware(async (ctx, next) => {if (ctx.url.startsWith("/about")) {return next();} else {return redirectToDefaultLocale(302);}})
```


#### middleware function


[Section titled middleware function](#middleware-function)

The [`middleware`](#middleware-function) function manually creates Astro’s i18n middleware. This allows you to extend Astro’s i18n routing instead of completely replacing it.

You can run `middleware` with [routing options](#routing) in combination with your own middleware, using the [`sequence`](/en/reference/modules/astro-middleware/#sequence) utility to determine the order:

src/middleware.js

```
import {defineMiddleware, sequence} from"astro:middleware";import { middleware } from"astro:i18n"; // Astro's own i18n routing configexport const userMiddleware = defineMiddleware(async (ctx, next) => {// this response might come from Astro's i18n middleware, and it might return a 404const response = await next();// the /about page is an exception and we want to render itif (ctx.url.startsWith("/about")) {return newResponse("About page", {status: 200});} else {return response;}});export const onRequest = sequence(userMiddleware,middleware({redirectToDefaultLocale: false,prefixDefaultLocale: true}))
```


## `domains`


[Section titled domains](#domains)

**Added in:** `astro@4.9.0`

This routing option allows you to customize your domains on a per-language basis for `server` rendered projects using the [`@astrojs/node`](/en/guides/integrations-guide/node/) or [`@astrojs/vercel`](/en/guides/integrations-guide/vercel/) adapter with a `site` configured.

Add `i18n.domains` to map any of your supported `locales` to custom URLs:

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({site: "https://example.com",output: "server", // required, with no prerendered pagesadapter: node({mode: 'standalone',}),i18n: {locales: ["es", "en", "fr", "ja"],defaultLocale: "en",routing: {prefixDefaultLocale: false},domains: {fr: "https://fr.example.com",es: "https://example.es"}}})
```

All non-mapped `locales` will follow your `prefixDefaultLocales` configuration. However, even if this value is `false`, page files for your `defaultLocale` must also exist within a localized folder. For the configuration above, an `/en/` folder is required.

With the above configuration:

-   The file `/fr/about.astro` will create the URL `https://fr.example.com/about`.
-   The file `/es/about.astro` will create the URL `https://example.es/about`.
-   The file `/ja/about.astro` will create the URL `https://example.com/ja/about`.
-   The file `/en/about.astro` will create the URL `https://example.com/about`.

The above URLs will also be returned by the `getAbsoluteLocaleUrl()` and `getAbsoluteLocaleUrlList()` functions.


## Fallback


[Section titled Fallback](#fallback)

When a page in one language doesn’t exist (e.g. a page that is not yet translated), instead of displaying a 404 page, you can choose to display fallback content from another `locale` on a per-language basis. This is useful when you do not yet have a page for every route, but you want to still provide some content to your visitors.

Your fallback strategy consists of two parts: choosing which languages should fallback to which other languages ([`i18n.fallback`](/en/reference/configuration-reference/#i18nfallback)) and choosing whether to perform a [redirect](/en/guides/routing/#redirects) or a [rewrite](/en/guides/routing/#rewrites) to show the fallback content ([`i18n.routing.fallbackType`](/en/reference/configuration-reference/#i18nroutingfallbacktype) added in Astro v4.15.0).

For example, when you configure `i18n.fallback: { fr: "es" }`, Astro will ensure that a page is built in `src/pages/fr/` for every page that exists in `src/pages/es/`.

If any page does not already exist, then a page will be created depending on your `fallbackType`:

-   With a redirect to the corresponding `es` route (default behavior).
-   With the content of the `/es/` page (`i18n.routing.fallbackType: "rewrite"`).

For example, the configuration below sets `es` as the fallback locale for any missing `fr` routes. This means that a user visiting `example.com/fr/my-page/` will be shown the content for `example.com/es/my-page/` (without being redirected) instead of being taken to a 404 page when `src/pages/fr/my-page.astro` does not exist.

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "fr"],defaultLocale: "en",fallback: {fr: "es"},routing: {fallbackType: "rewrite"}}})
```


## Custom locale paths


[Section titled Custom locale paths](#custom-locale-paths)

In addition to defining your site’s supported `locales` as strings (e.g. “en”, “pt-br”), Astro also allows you to map an arbitrary number of [browser-recognized language `codes`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax) to a custom URL `path`. While locales can be strings of any format as long as they correspond to your project folder structure, `codes` must follow the browser’s accepted syntax.

Pass an object to the `locales` array with a `path` key to define a custom URL prefix, and `codes` to indicate the languages mapped to this URL. In this case, your `/[locale]/` folder name must match exactly the value of the `path` and your URLs will be generated using the `path` value.

This is useful if you support multiple variations of a language (e.g. `"fr"`, `"fr-BR"`, and `"fr-CA"`) and you want to have all these variations mapped under the same URL `/fr/`, or even customize it entirely (e.g. `/french/`):

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({i18n: {locales: ["es", "en", "fr"],locales: ["es", "en", {path: "french", // no slashes includedcodes: ["fr", "fr-BR", "fr-CA"]}],defaultLocale: "en",routing: {prefixDefaultLocale: true}}})
```

When using functions from the [`astro:i18n` virtual module](/en/reference/modules/astro-i18n/) to compute valid URL paths based on your configuration (e.g. `getRelativeLocaleUrl()`), [use the `path` as the value for `locale`](/en/reference/modules/astro-i18n/#getlocalebypath).


#### Limitations


[Section titled Limitations](#limitations)

This feature has some restrictions:

-   The `site` option is mandatory.
-   The `output` option must be set to `"server"`.
-   There cannot be any individual prerendered pages.

Astro relies on the following headers in order to support the feature:

-   [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) and [`Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host). Astro will use the former, and if not present, will try the latter.
-   [`X-Forwarded-Proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`URL#protocol`](https://developer.mozilla.org/en-US/docs/Web/API/URL/protocol) of the server request.

Make sure that your server proxy/hosting platform is able to provide this information. Failing to retrieve these headers will result in a 404 (status code) page.


## Browser language detection


[Section titled Browser language detection](#browser-language-detection)

Astro’s i18n routing allows you to access two properties for browser language detection in pages rendered on demand: `Astro.preferredLocale` and `Astro.preferredLocaleList`. All pages, including static prerendered pages, have access to `Astro.currentLocale`.

These combine the browser’s `Accept-Language` header, and your `locales` (strings or `codes`) to automatically respect your visitor’s preferred languages.

-   [`Astro.preferredLocale`](/en/reference/api-reference/#preferredlocale): Astro can compute a **preferred locale** for your visitor if their browser’s preferred locale is included in your `locales` array. This value is undefined if no such match exists.

-   [`Astro.preferredLocaleList`](/en/reference/api-reference/#preferredlocalelist): An array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. The value is `[]` if none of the browser’s requested languages are found in your `locales` array. If the browser does not specify any preferred languages, then this value will be [`i18n.locales`](/en/reference/configuration-reference/#i18nlocales).

-   [`Astro.currentLocale`](/en/reference/api-reference/#currentlocale): The locale computed from the current URL, using the syntax specified in your `locales` configuration. If the URL does not contain a `/[locale]/` prefix, then the value will default to [`i18n.defaultLocale`](/en/reference/configuration-reference/#i18ndefaultlocale).


In order to successfully match your visitors’ preferences, provide your `codes` using the same pattern [used by the browser](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax).

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 112. `en/guides/markdown-content/.md`

```text
# Markdown in Astro


---
url: https://docs.astro.build/en/guides/markdown-content/
description: Learn about Astro's built-in support for Markdown.
---


# Markdown in Astro


[Markdown](https://daringfireball.net/projects/markdown/) is commonly used to author text-heavy content like blog posts and documentation. Astro includes built-in support for Markdown files that can also include [frontmatter YAML](https://dev.to/paulasantamaria/introduction-to-yaml-125f) (or [TOML](https://toml.io)) to define custom properties such as a title, description, and tags.

In Astro, you can author content in [GitHub Flavored Markdown](https://github.github.com/gfm/), then render it in `.astro` components. This combines a familiar writing format designed for content with the flexibility of Astro’s component syntax and architecture.

Tip

For additional functionality, such as including components and JSX expressions in Markdown, add the [`@astrojs/mdx` integration](/en/guides/integrations-guide/mdx/) to write your Markdown content using [MDX](https://mdxjs.com/).


## Organizing Markdown files


[Section titled Organizing Markdown files](#organizing-markdown-files)

Your local Markdown files can be kept anywhere within your `src/` directory. Markdown files located within `src/pages/` will automatically generate [Markdown pages on your site](#individual-markdown-pages).

Your Markdown content and frontmatter properties are available to use in components through [local file imports](#importing-markdown) or when [queried and rendered from data fetched by a content collections helper function](#markdown-from-content-collections-queries).


### File imports vs content collections queries


[Section titled File imports vs content collections queries](#file-imports-vs-content-collections-queries)

Local Markdown can be imported into `.astro` components using an `import` statement for a single file and [Vite’s `import.meta.glob()`](/en/guides/imports/#importmetaglob) to query multiple files at once. The [exported data from these Markdown files](#importing-markdown) can then be used in the `.astro` component.

If you have groups of related Markdown files, consider [defining them as collections](/en/guides/content-collections/). This gives you several advantages, including the ability to store Markdown files anywhere on your filesystem or remotely.

Collections use content-specific, optimized APIs for [querying and rendering your Markdown content](#markdown-from-content-collections-queries) instead of file imports. Collections are intended for sets of data that share the same structure, such as blog posts or product items. When you define that shape in a schema, you additionally get validation, type safety, and Intellisense in your editor.

See more about [when to use content collections](/en/guides/content-collections/#when-to-create-a-collection) instead of file imports.


## Dynamic JSX-like expressions


[Section titled Dynamic JSX-like expressions](#dynamic-jsx-like-expressions)

After importing or querying Markdown files, you can write dynamic HTML templates in your `.astro` components that include frontmatter data and body content.

src/pages/posts/great-post.md

```
---title: 'The greatest post of all time'author: 'Ben'---Here is my _great_ post!
```

src/pages/my-posts.astro

```
---import*as greatPost from'./posts/great-post.md';const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));---<p>{greatPost.frontmatter.title}</p><p>Written by: {greatPost.frontmatter.author}</p><p>Post Archive:</p><ul>{posts.map(post=><li><ahref={post.url}>{post.frontmatter.title}</a></li>)}</ul>
```


### Available Properties


[Section titled Available Properties](#available-properties)


#### Markdown from content collections queries


[Section titled Markdown from content collections queries](#markdown-from-content-collections-queries)

When fetching data from your collections with the helper functions `getCollection()` or `getEntry()`, your Markdown’s frontmatter properties are available on a `data` object (e.g. `post.data.title`). Additionally, `body` contains the raw, uncompiled body content as a string.

The [`render()`](/en/reference/modules/astro-content/#render) function returns your Markdown body content, a generated list of headings, as well as a modified frontmatter object after any remark or rehype plugins have been applied.

Read more about [using content returned by a collections query](/en/guides/content-collections/#using-content-in-astro-templates).


#### Importing Markdown


[Section titled Importing Markdown](#importing-markdown)

The following exported properties are available in your `.astro` component when importing Markdown using `import` or `import.meta.glob()`:

-   **`file`** - The absolute file path (e.g. `/home/user/projects/.../file.md`).
-   **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`).
-   **`frontmatter`** - Contains any data specified in the file’s YAML (or TOML) frontmatter.
-   **`<Content />`** - A component that returns the full, rendered contents of the file.
-   **`rawContent()`** - A function that returns the raw Markdown document as a string.
-   **`compiledContent()`** - An async function that returns the Markdown document compiled to an HTML string.
-   **`getHeadings()`** - An async function that returns an array of all headings (`<h1>` to `<h6>`) in the file with the type: `{ depth: number; slug: string; text: string }[]`. Each heading’s `slug` corresponds to the generated ID for a given heading and can be used for anchor links.

An example Markdown blog post may pass the following `Astro.props` object:

```
Astro.props= {file: "/home/user/projects/.../file.md",url: "/en/guides/markdown-content/",frontmatter: {/** Frontmatter from a blog post */title: "Astro 0.18 Release",date: "Tuesday, July 27 2021",author: "Matthew Phillips",description: "Astro 0.18 is our biggest release since Astro launch.",},getHeadings: ()=> [{"depth": 1, "text": "Astro 0.18 Release", "slug": "astro-018-release"},{"depth": 2, "text": "Responsive partial hydration", "slug": "responsive-partial-hydration"}/* ... */],rawContent: ()=>"# Astro 0.18 Release\nA little over a month ago, the first public beta [...]",compiledContent: ()=>"<h1>Astro 0.18 Release</h1>\n<p>A little over a month ago, the first public beta [...]</p>",}
```


## The `<Content />` Component


[Section titled The &lt;Content /&gt; Component](#the-content--component)

The `<Content />` component is available by importing `Content` from a Markdown file. This component returns the file’s full body content, rendered to HTML. You can optionally rename `Content` to any component name you prefer.

You can similarly [render the HTML content of a Markdown collection entry](/en/guides/content-collections/#rendering-body-content) by rendering a `<Content />` component.

src/pages/content.astro

```
---// Import statementimport {Contentas PromoBanner} from'../components/promoBanner.md';// Collections queryimport { getEntry, render } from'astro:content';const product = await getEntry('products', 'shirt');const { Content } = await render(product);---<h2>Today's promo</h2><PromoBanner /><p>Sale Ends: {product.data.saleEndDate.toDateString()}</p><Content />
```


## Heading IDs


[Section titled Heading IDs](#heading-ids)

Writing headings in Markdown will automatically give you anchor links so you can link directly to certain sections of your page.

src/pages/page-1.md

```
---title: My page of content---## IntroductionI can link internally to [my conclusion](#conclusion) on the same page when writing Markdown.## ConclusionI can visit `https://example.com/page-1/#introduction` in a browser to navigate directly to my Introduction.
```

Astro generates heading `id`s based on `github-slugger`. You can find more examples in [the github-slugger documentation](https://github.com/Flet/github-slugger#usage).


### Heading IDs and plugins


[Section titled Heading IDs and plugins](#heading-ids-and-plugins)

Astro injects an `id` attribute into all heading elements (`<h1>` to `<h6>`) in Markdown and MDX files. You can retrieve this data from the `getHeadings()` utility available as a [Markdown exported property](#available-properties) from an imported file, or from the `render()` function when [using Markdown returned from a content collections query](#markdown-from-content-collections-queries).

You can customize these heading IDs by adding a rehype plugin that injects `id` attributes (e.g. `rehype-slug`). Your custom IDs, instead of Astro’s defaults, will be reflected in the HTML output and the items returned by `getHeadings()`.

By default, Astro injects `id` attributes after your rehype plugins have run. If one of your custom rehype plugins needs to access the IDs injected by Astro, you can import and use Astro’s `rehypeHeadingIds` plugin directly. Be sure to add `rehypeHeadingIds` before any plugins that rely on it:

astro.config.mjs

```
import { defineConfig } from'astro/config';import { rehypeHeadingIds } from'@astrojs/markdown-remark';import { otherPluginThatReliesOnHeadingIDs } from'some/plugin/source';exportdefaultdefineConfig({markdown: {rehypePlugins: [rehypeHeadingIds,otherPluginThatReliesOnHeadingIDs,],},});
```


## Markdown Plugins


[Section titled Markdown Plugins](#markdown-plugins)

Markdown support in Astro is powered by [remark](https://remark.js.org/), a powerful parsing and processing tool with an active ecosystem. Other Markdown parsers like Pandoc and markdown-it are not currently supported.

Astro applies the [GitHub-flavored Markdown](https://github.com/remarkjs/remark-gfm) and [SmartyPants](https://github.com/silvenon/remark-smartypants) plugins by default. This brings some niceties like generating clickable links from text, and formatting for [quotations and em-dashes](https://daringfireball.net/projects/smartypants/).

You can customize how remark parses your Markdown in `astro.config.mjs`. See the full list of [Markdown configuration options](/en/reference/configuration-reference/#markdown-options).


### Adding remark and rehype plugins


[Section titled Adding remark and rehype plugins](#adding-remark-and-rehype-plugins)

Astro supports adding third-party [remark](https://github.com/remarkjs/remark) and [rehype](https://github.com/rehypejs/rehype) plugins for Markdown. These plugins allow you to extend your Markdown with new capabilities, like [auto-generating a table of contents](https://github.com/remarkjs/remark-toc), [applying accessible emoji labels](https://github.com/florianeckerstorfer/remark-a11y-emoji), and [styling your Markdown](/en/guides/styling/#markdown-styling).

We encourage you to browse [awesome-remark](https://github.com/remarkjs/awesome-remark) and [awesome-rehype](https://github.com/rehypejs/awesome-rehype) for popular plugins! See each plugin’s own README for specific installation instructions.

This example applies [`remark-toc`](https://github.com/remarkjs/remark-toc) and [`rehype-accessible-emojis`](https://www.npmjs.com/package/rehype-accessible-emojis) to Markdown files:

astro.config.mjs

```
import { defineConfig } from'astro/config';import remarkToc from'remark-toc';import { rehypeAccessibleEmojis } from'rehype-accessible-emojis';exportdefaultdefineConfig({markdown: {remarkPlugins: [ [remarkToc, { heading: 'toc', maxDepth: 3 } ] ],rehypePlugins: [rehypeAccessibleEmojis],},});
```


### Customizing a plugin


[Section titled Customizing a plugin](#customizing-a-plugin)

In order to customize a plugin, provide an options object after it in a nested array.

The example below adds the [heading option to the `remarkToc` plugin](https://github.com/remarkjs/remark-toc#options) to change where the table of contents is placed, and the [`behavior` option to the `rehype-autolink-headings` plugin](https://github.com/rehypejs/rehype-autolink-headings#options) in order to add the anchor tag after the headline text.

astro.config.mjs

```
import remarkToc from'remark-toc';import rehypeSlug from'rehype-slug';import rehypeAutolinkHeadings from'rehype-autolink-headings';exportdefault {markdown: {remarkPlugins: [ [remarkToc, { heading: "contents"} ] ],rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append' }]],},}
```


### Modifying frontmatter programmatically


[Section titled Modifying frontmatter programmatically](#modifying-frontmatter-programmatically)

You can add frontmatter properties to all of your Markdown and MDX files by using a [remark or rehype plugin](#markdown-plugins).

1.  Append a `customProperty` to the `data.astro.frontmatter` property from your plugin’s `file` argument:

    example-remark-plugin.mjs

    ```
    exportfunctionexampleRemarkPlugin() {// All remark and rehype plugins return a separate functionreturnfunction(tree, file) {file.data.astro.frontmatter.customProperty='Generated property';}}
    ```

    Tip

    **Added in:** `astro@2.0.0`

    `data.astro.frontmatter` contains all properties from a given Markdown or MDX document. This allows you to modify existing frontmatter properties, or compute new properties from this existing frontmatter.

2.  Apply this plugin to your `markdown` or `mdx` integration config:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import { exampleRemarkPlugin } from'./example-remark-plugin.mjs';exportdefaultdefineConfig({markdown: {remarkPlugins: [exampleRemarkPlugin]},});
    ```

    or

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import { exampleRemarkPlugin } from'./example-remark-plugin.mjs';exportdefaultdefineConfig({integrations: [mdx({remarkPlugins: [exampleRemarkPlugin],}),],});
    ```


Now, every Markdown or MDX file will have `customProperty` in its frontmatter, making it available when [importing your markdown](#importing-markdown) and from [the `Astro.props.frontmatter` property in your layouts](#frontmatter-layout-property).

**Related recipe:** [Add reading time](/en/recipes/reading-time/)


### Extending Markdown config from MDX


[Section titled Extending Markdown config from MDX](#extending-markdown-config-from-mdx)

Astro’s MDX integration will extend [your project’s existing Markdown configuration](/en/reference/configuration-reference/#markdown-options) by default. To override individual options, you can specify their equivalent in your MDX configuration.

The following example disables GitHub-Flavored Markdown and applies a different set of remark plugins for MDX files:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({markdown: {syntaxHighlight: 'prism',remarkPlugins: [remarkPlugin1],gfm: true,},integrations: [mdx({// `syntaxHighlight` inherited from Markdown// Markdown `remarkPlugins` ignored,// only `remarkPlugin2` applied.remarkPlugins: [remarkPlugin2],// `gfm` overridden to `false`gfm: false,})]});
```

To avoid extending your Markdown config from MDX, set [the `extendMarkdownConfig` option](/en/guides/integrations-guide/mdx/#extendmarkdownconfig) (enabled by default) to `false`:

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({markdown: {remarkPlugins: [remarkPlugin],},integrations: [mdx({// Markdown config now ignoredextendMarkdownConfig: false,// No `remarkPlugins` applied})]});
```


## Individual Markdown pages


[Section titled Individual Markdown pages](#individual-markdown-pages)

Tip

[Content collections](/en/guides/content-collections/) and [importing Markdown into `.astro` components](#dynamic-jsx-like-expressions) provide more features for rendering your Markdown and are the recommended way to handle most of your content. However, there may be times when you want the convenience of just adding a file to `src/pages/` and having a simple page automatically created for you.

Astro treats [any supported file inside of the `/src/pages/` directory](/en/basics/astro-pages/#supported-page-files) as a page, including `.md` and other Markdown file types.

Placing a file in this directory, or any sub-directory, will automatically build a page route using the pathname of the file and display the Markdown content rendered to HTML. Astro will automatically add a `<meta charset="utf-8">` tag to your page to allow easier authoring of non-ASCII content.

src/pages/page-1.md

```
---title: Hello, World---# Hi there!This Markdown file creates a page at `your-domain.com/page-1/`It probably isn't styled much, but Markdown does support:-**bold** and _italics._- lists- [links](https://astro.build)-<p>HTML elements</p>- and more!
```


### Frontmatter `layout` property


[Section titled Frontmatter layout property](#frontmatter-layout-property)

To help with the limited functionality of individual Markdown pages, Astro provides a special frontmatter `layout` property which is a relative path to an Astro [Markdown layout component](/en/basics/layouts/#markdown-layouts). `layout` is not a special property when using [content collections](/en/guides/content-collections/) to query and render your Markdown content, and is not guaranteed to be supported outside of its intended use case.

If your Markdown file is located within `src/pages/`, create a layout component and add it in this layout property to provide a page shell around your Markdown content.

src/pages/posts/post-1.md

```
---layout: ../../layouts/BlogPostLayout.astrotitle: Astro in briefauthor: Himanshudescription: Find out what makes Astro awesome!---This is a post written in Markdown.
```

This layout component is a regular Astro component with [specific properties automatically available](/en/basics/layouts/#markdown-layout-props) through `Astro.props` for your Astro template. For example, you can access your Markdown file’s frontmatter properties through `Astro.props.frontmatter`:

src/layouts/BlogPostLayout.astro

```
---const {frontmatter} = Astro.props;---<html><head><!-- ... --><metacharset="utf-8"> // no longer added by default</head><!-- ... --><h1>{frontmatter.title}</h1><h2>Post author: {frontmatter.author}</h2><p>{frontmatter.description}</p><slot /><!-- Markdown content is injected here --><!-- ... --></html>
```

When using the frontmatter `layout` property, you must include the `<meta charset="utf-8">` tag in your layout as Astro will no longer add it automatically. You can now also [style your Markdown](/en/guides/styling/#markdown-styling) in your layout component.

Learn more about [Markdown Layouts](/en/basics/layouts/#markdown-layouts).


## Fetching Remote Markdown


[Section titled Fetching Remote Markdown](#fetching-remote-markdown)

Astro does not include built-in support for remote Markdown outside of [content collections](/en/guides/content-collections/).

To fetch remote Markdown directly and render it to HTML, you will need to install and configure your own Markdown parser from NPM. This will not inherit from any of Astro’s built-in Markdown settings that you have configured.

Be sure that you understand these limitations before implementing this in your project, and consider fetching your remote Markdown using a content collections loader instead.

src/pages/remote-example.astro

```
---// Example: Fetch Markdown from a remote API// and render it to HTML, at runtime.// Using "marked" (https://github.com/markedjs/marked)import { marked } from'marked';const response = await fetch('https://raw.githubusercontent.com/wiki/adam-p/markdown-here/Markdown-Cheatsheet.md');const markdown = await response.text();const content = marked.parse(markdown);---<articleset:html={content} />
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 113. `en/guides/media/.md`

```text
# Use a DAM with Astro


---
url: https://docs.astro.build/en/guides/media/
description: How to use a Digital Asset Manager (DAM) to add images and videos to Astro
---


# Use a DAM with Astro


**Ready to connect a headless Digital Asset Manager (DAM) to your Astro project?** Follow one of our guides to integrate a hosted media system.

Tip

Find [community-maintained integrations](https://astro.build/integrations/) for connecting a DAM or hosted media system to your project in our integrations directory.


## Hosted Media Guides


[Section titled Hosted Media Guides](#hosted-media-guides)

Note that many of these pages are **stubs**: they’re collections of resources waiting for your contribution!

-   ### [Cloudinary](/en/guides/media/cloudinary/)



## Why use a DAM or hosted media?


[Section titled Why use a DAM or hosted media?](#why-use-a-dam-or-hosted-media)

Using a DAM, or Digital Asset Manager, helps individuals, teams, and organizations manage their image and video assets from a central location much like a [CMS](/en/guides/cms/).

The difference is the type of content being managed: a DAM would primarily manage images, videos, other media assets like 3D models, and any metadata associated with those assets.

This can be useful particularly when using a single source of truth for your assets between multiple web or mobile properties. This is important if you’re part of an organization that requires multiple teams to use the same assets, or are integrating into other content systems like a PIM (Product Information Manager) to connect your assets to products.


## Which hosted media systems or DAMs work well with Astro?


[Section titled Which hosted media systems or DAMs work well with Astro?](#which-hosted-media-systems-or-dams-work-well-with-astro)

Much like when using a CMS, as Astro handles the *presentation* of your content, you’ll want to use a headless DAM that allows you to fetch and interact with your assets via an API or SDK.

Some headless DAMs, like Cloudinary, provide an Astro [integration](/en/guides/integrations-guide/) that allows you to easily fetch your assets as well as display them on your website or app.


## Can I use Astro without a hosted media system or DAM?


[Section titled Can I use Astro without a hosted media system or DAM?](#can-i-use-astro-without-a-hosted-media-system-or-dam)

Yes! Astro provides built-in ways to [store images](/en/guides/images/#where-to-store-images), including support for referencing remote images.

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 114. `en/guides/media/cloudinary/.md`

```text
# Cloudinary & Astro


---
url: https://docs.astro.build/en/guides/media/cloudinary/
description: Add images and videos to your Astro project using Cloudinary
---


# Cloudinary & Astro


[Cloudinary](https://cloudinary.com) is an image and video platform and headless Digital Asset Manager (DAM) that lets you host assets and deliver them from their content delivery network (CDN).

When delivering from Cloudinary, you additionally get access to their Transformation API, giving you the ability to edit your assets with tools like background removal, dynamic cropping and resizing, and generative AI.


## Using Cloudinary in Astro


[Section titled Using Cloudinary in Astro](#using-cloudinary-in-astro)

Cloudinary supports a wide variety of SDKs that can be used depending on your Astro environment.

The [Cloudinary Astro SDK](https://astro.cloudinary.dev/) provides native Astro components, including image, video, and upload components, as well as a content loader that can be used with Astro content collections.

Alternatively, both the Cloudinary [Node.js SDK](https://cloudinary.com/documentation/node_integration) and [JavaScript SDK](https://cloudinary.com/documentation/javascript_integration) can be used to generate URLs for your images. The Node.js SDK can additionally make requests to the Cloudinary API including uploading assets, requesting resources, and running content analysis.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   An existing Astro project
-   A Cloudinary account


## Installing Astro Cloudinary


[Section titled Installing Astro Cloudinary](#installing-astro-cloudinary)

Install the Cloudinary Astro SDK by running the appropriate command for your package manager:

-   [npm](#tab-panel-3320)
-   [pnpm](#tab-panel-3321)
-   [Yarn](#tab-panel-3322)

Terminal window

```
npminstallastro-cloudinary
```

Terminal window

```
pnpmaddastro-cloudinary
```

Terminal window

```
yarnaddastro-cloudinary
```


## Configuring your account


[Section titled Configuring your account](#configuring-your-account)

Create a new `.env` file in the root of your project and add your Cloudinary credentials:

.env

```
PUBLIC_CLOUDINARY_CLOUD_NAME="<Your Cloud Name>"//OnlyneededifusingCldUploadWidgetorcldAssetsLoaderPUBLIC_CLOUDINARY_API_KEY="<Your API Key>"CLOUDINARY_API_SECRET="<Your API Secret>"
```


## Using Cloudinary images


[Section titled Using Cloudinary images](#using-cloudinary-images)

Add images in `.astro` components by passing image data (e.g. `src`, `width`, `alt`) to the `<CldImage>` component. This will automatically optimize your image and give you access to the Transformations API.

Component.astro

```
---import { CldImage } from'astro-cloudinary';---<CldImagesrc="<Public ID>"width="<Width>"height="<Height>"alt="<Description>"/>
```

See [Cloudinary’s `<CldImage>` documentation](https://astro.cloudinary.dev/cldimage/basic-usage) for more information.


## Using Cloudinary videos


[Section titled Using Cloudinary videos](#using-cloudinary-videos)

To add video to your `.astro` components, add the `<CldVideoPlayer>` and pass the appropriate properties. This component will automatically optimize and embed your video using the [Cloudinary Video Player](https://cloudinary.com/documentation/cloudinary_video_player).

Component.astro

```
---import { CldVideoPlayer } from'astro-cloudinary';---<CldVideoPlayersrc="<Public ID>"width="<Width>"height="<Height>"/>
```

See [Cloudinary’s `<CldVideoPlayer>` documentation](https://astro.cloudinary.dev/cldvideoplayer/basic-usage) for more information.


## Enabling Cloudinary uploads


[Section titled Enabling Cloudinary uploads](#enabling-cloudinary-uploads)

To enable file uploading in your website or app’s UI, add the `<CldUploadWidget>` which will embed the [Cloudinary Upload Widget](https://cloudinary.com/documentation/upload_widget).

The following example creates a widget to allow unsigned uploads by passing an unsigned [Upload Preset](https://cloudinary.com/documentation/upload_presets):

Component.astro

```
---import { CldUploadWidget } from'astro-cloudinary';---<CldUploadWidgetuploadPreset="<Upload Preset>"><button>Upload</button></CldUploadWidget>
```

For signed uploads, you can find [a guide and example](https://astro.cloudinary.dev/clduploadwidget/signed-uploads) on the Astro Cloudinary docs.

See [Cloudinary’s `<CldUploadWidget>` documentation](https://astro.cloudinary.dev/clduploadwidget/basic-usage) for more information.


## Cloudinary content loader


[Section titled Cloudinary content loader](#cloudinary-content-loader)

The Cloudinary Astro SDK provides the `cldAssetsLoader` content loader to load Cloudinary assets for content collections.

To load a collection of images or videos, set `loader: cldAssetsLoader ({})` with a `folder`, if required:

config.ts

```
import { defineCollection } from'astro:content';import { cldAssetsLoader } from'astro-cloudinary/loaders';export const collections = {assets: defineCollection({loader: cldAssetsLoader({folder: '<Folder>'// Optional, without loads root directory})}),}
```

You can then use the [`getCollection()` or `getEntry()` query functions](/en/guides/content-collections/#querying-collections) to select one or many images or videos from your collection.

See [Cloudinary’s `cldAssetsLoader` documentation](https://astro.cloudinary.dev/cldassetsloader/basic-usage) for more information.


## Generating Cloudinary image URLs


[Section titled Generating Cloudinary image URLs](#generating-cloudinary-image-urls)

The Astro Cloudinary SDK provides a `getCldOgImageUrl()` helper for generating and using URLs for your images. Use this when you need a URL instead of a component to display your image.

One common use for a URL is for an Open Graph image in `<meta>` tags for social media cards. This helper, like the components, provides you access to Cloudinary transformations to create dynamic, unique social cards for any of your pages.

The following example shows the necessary `<meta>` tags for a social media card, using `getCldOgImageUrl()` to generate an Open Graph image:

Layout.astro

```
---import { getCldOgImageUrl } from'astro-cloudinary/helpers';const ogImageUrl = getCldOgImageUrl({ src: '<Public ID>' });---<metaproperty="og:image"content={ogImageUrl} /><metaproperty="og:image:secure_url"content={ogImageUrl} /><metaproperty="og:image:width"content="1200" /><metaproperty="og:image:height"content="630" /><metaproperty="twitter:title"content="<Twitter Title>" /><metaproperty="twitter:card"content="summary_large_image" /><metaproperty="twitter:image"content={ogImageUrl} />
```

Find [Cloudinary Social Media Card templates](https://astro.cloudinary.dev/templates/social-media-cards) on the Cloudinary docs.

See [Cloudinary’s `getCldOgImageUrl()` documentation](https://astro.cloudinary.dev/getcldogimageurl/basic-usage) for more information.


## Using Cloudinary in Node.js


[Section titled Using Cloudinary in Node.js](#using-cloudinary-in-nodejs)

For more complex asset management, uploading, or analysis, you can use the Cloudinary Node.js SDK when working in an Astro Node.js environment.

Install the Cloudinary Node.js SDK by running the appropriate command for your package manager:

-   [npm](#tab-panel-3323)
-   [pnpm](#tab-panel-3324)
-   [Yarn](#tab-panel-3325)

Terminal window

```
npminstallcloudinary
```

Terminal window

```
pnpmaddcloudinary
```

Terminal window

```
yarnaddcloudinary
```

Add the following environment variables in your `.env` file:

.env

```
PUBLIC_CLOUDINARY_CLOUD_NAME="<Your Cloud Name>"PUBLIC_CLOUDINARY_API_KEY="<Your API Key>"CLOUDINARY_API_SECRET="<Your API Secret>"
```

Configure your account with a new Cloudinary instance by adding the following code between the fences of your Astro component:

Component.astro

```
---import { v2as cloudinary } from"cloudinary";cloudinary.config({cloud_name: import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME,api_key: import.meta.env.PUBLIC_CLOUDINARY_API_KEY,api_secret: import.meta.env.CLOUDINARY_API_SECRET,});---
```

This will give you access to all of the Cloudinary APIs to allow you to interact with your images, videos, and other supported files.

Component.astro

```
awaitcloudinary.uploader.upload('./path/to/file');
```

Learn how to [upload files using the Cloudinary Node.js SDK with Astro Forms](https://www.youtube.com/watch?v=DQUYMyT2MTM).


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Cloudinary Astro SDK](https://astro.cloudinary.dev/)
-   [Cloudinary Node.js SDK](https://cloudinary.com/documentation/node_integration)
-   [Using Cloudinary with Astro (YouTube)](https://www.youtube.com/playlist?list=PL8dVGjLA2oMqnpf2tShn1exf5GkSWuu5-)
-   [Code Examples Using Cloudinary Astro SDK (GitHub)](https://github.com/cloudinary-community/cloudinary-examples/tree/main/examples/astro-cloudinary)


## More DAM guides


-   ### [Cloudinary](/en/guides/media/cloudinary/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 115. `en/guides/middleware/.md`

```text
# Middleware


---
url: https://docs.astro.build/en/guides/middleware/
description: Learn how to use middleware in Astro.
---


# Middleware


**Middleware** allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. This rendering occurs at build time for all prerendered pages, but occurs when the route is requested for pages rendered on demand, making [additional SSR features like cookies and headers](/en/guides/on-demand-rendering/#on-demand-rendering-features) available.

Middleware also allows you to set and share request-specific information across endpoints and pages by mutating a `locals` object that is available in all Astro components and API endpoints. This object is available even when this middleware runs at build time.


## Basic Usage


[Section titled Basic Usage](#basic-usage)

1.  Create `src/middleware.js|ts` (Alternatively, you can create `src/middleware/index.js|ts`.)

2.  Inside this file, export an [`onRequest()`](/en/reference/modules/astro-middleware/#onrequest) function that can be passed a [`context` object](#the-context-object) and `next()` function. This must not be a default export.

    src/middleware.js

    ```
    exportfunctiononRequest(context, next) {// intercept data from a request// optionally, modify the properties in `locals`context.locals.title="New title";// return a Response or the result of calling `next()`returnnext();};
    ```

3.  Inside any `.astro` file, access response data using `Astro.locals`.

    src/components/Component.astro

    ```
    ---const data = Astro.locals;---<h1>{data.title}</h1><p>This {data.property} is from middleware.</p>
    ```



### The `context` object


[Section titled The context object](#the-context-object)

The [`context`](/en/reference/api-reference/) object includes information to be made available to other middleware, API routes and `.astro` routes during the rendering process.

This is an optional argument passed to `onRequest()` that may contain the `locals` object as well as any additional properties to be shared during rendering. For example, the `context` object may include cookies used in authentication.


### Storing data in `context.locals`


[Section titled Storing data in context.locals](#storing-data-in-contextlocals)

`context.locals` is an object that can be manipulated inside the middleware.

This `locals` object is forwarded across the request handling process and is available as a property to [`APIContext`](/en/reference/api-reference/#locals) and [`AstroGlobal`](/en/reference/api-reference/#locals). This allows data to be shared between middlewares, API routes, and `.astro` pages. This is useful for storing request-specific data, such as user data, across the rendering step.

Integration properties

[Integrations](/en/guides/integrations-guide/) may set properties and provide functionality through the `locals` object. If you are using an integration, check its documentation to ensure you are not overriding any of its properties or doing unnecessary work.

You can store any type of data inside `locals`: strings, numbers, and even complex data types such as functions and maps.

src/middleware.js

```
exportfunctiononRequest(context, next) {// intercept data from a request// optionally, modify the properties in `locals`context.locals.user.name="John Wick";context.locals.welcomeTitle=()=> {return"Welcome back "+locals.user.name;};// return a Response or the result of calling `next()`returnnext();};
```

Then you can use this information inside any `.astro` file with `Astro.locals`.

src/pages/orders.astro

```
---const title = Astro.locals.welcomeTitle();const orders = Array.from(Astro.locals.orders.entries());const data = Astro.locals;---<h1>{title}</h1><p>This {data.property} is from middleware.</p><ul>{orders.map(order=> {return<li>{/* do something with each order */}</li>;})}</ul>
```

`locals` is an object that lives and dies within a single Astro route; when your route page is rendered, `locals` won’t exist anymore and a new one will be created. Information that needs to persist across multiple page requests must be stored elsewhere.

Note

The value of `locals` cannot be overridden at run time. Doing so would risk wiping out all the information stored by the user. Astro performs checks and will throw an error if `locals` are overridden.


## Example: redacting sensitive information


[Section titled Example: redacting sensitive information](#example-redacting-sensitive-information)

The example below uses middleware to replace “PRIVATE INFO” with the word “REDACTED” to allow you to render modified HTML on your page:

src/middleware.js

```
export const onRequest = async (context, next) => {const response = await next();const html = await response.text();const redactedHtml = html.replaceAll("PRIVATE INFO", "REDACTED");return newResponse(redactedHtml, {status: 200,headers: response.headers});};
```


## Middleware types


[Section titled Middleware types](#middleware-types)

You can import and use the utility function `defineMiddleware()` to take advantage of type safety:

src/middleware.ts

```
import { defineMiddleware } from"astro:middleware";// `context` and `next` are automatically typedexport const onRequest = defineMiddleware((context, next) => {});
```

Instead, if you’re using JsDoc to take advantage of type safety, you can use `MiddlewareHandler`:

src/middleware.js

```
/*** @type{import("astro").MiddlewareHandler}*/// `context` and `next` are automatically typedexport const onRequest = (context, next) => {};
```

To type the information inside `Astro.locals`, which gives you autocompletion inside `.astro` files and middleware code, declare a global namespace in the `env.d.ts` file:

src/env.d.ts

```
type User = {id:number;name:string;};declarenamespace App {interface Locals {user:User;welcomeTitle:()=>string;orders:Map<string, object>;session:import("./lib/server/session").Session|null;}}
```

Then, inside the middleware file, you can take advantage of autocompletion and type safety.


## Chaining middleware


[Section titled Chaining middleware](#chaining-middleware)

Multiple middlewares can be joined in a specified order using [`sequence()`](/en/reference/modules/astro-middleware/#sequence):

src/middleware.js

```
import { sequence } from"astro:middleware";asyncfunctionvalidation(_, next) {console.log("validation request");const response = await next();console.log("validation response");returnresponse;}asyncfunctionauth(_, next) {console.log("auth request");const response = await next();console.log("auth response");returnresponse;}asyncfunctiongreeting(_, next) {console.log("greeting request");const response = await next();console.log("greeting response");returnresponse;}export const onRequest = sequence(validation, auth, greeting);
```

This will result in the following console order:

Terminal window

```
validationrequestauthrequestgreetingrequestgreetingresponseauthresponsevalidationresponse
```


## Rewriting


[Section titled Rewriting](#rewriting)

**Added in:** `astro@4.13.0`

The `APIContext` exposes a method called `rewrite()` which works the same way as [Astro.rewrite](/en/guides/routing/#rewrites).

Use `context.rewrite()` inside middleware to display a different page’s content without [redirecting](/en/guides/routing/#dynamic-redirects) your visitor to a new page. This will trigger a new rendering phase, causing any middleware to be re-executed.

src/middleware.js

```
import { isLoggedIn } from"~/auth.js"exportfunctiononRequest(context, next) {if (!isLoggedIn(context)) {// If the user is not logged in, update the Request to render the `/login` route and// add header to indicate where the user should be sent after a successful login.// Re-execute middleware.returncontext.rewrite(newRequest("/login", {headers: {"x-redirect-to": context.url.pathname}}));}returnnext();};
```

You can also pass the `next()` function an optional URL path parameter to rewrite the current `Request` without retriggering a new rendering phase. The location of the rewrite path can be provided as a string, URL, or `Request`:

src/middleware.js

```
import { isLoggedIn } from"~/auth.js"exportfunctiononRequest(context, next) {if (!isLoggedIn(context)) {// If the user is not logged in, update the Request to render the `/login` route and// add header to indicate where the user should be sent after a successful login.// Return a new `context` to any following middlewares.returnnext(newRequest("/login", {headers: {"x-redirect-to": context.url.pathname}}));}returnnext();};
```

The `next()` function accepts the same payload of [the `Astro.rewrite()` function](/en/reference/api-reference/#rewrite). The location of the rewrite path can be provided as a string, URL, or `Request`.

When you have multiple middleware functions chained via [sequence()](#chaining-middleware), submitting a path to `next()` will rewrite the `Request` in place and the middleware will not execute again. The next middleware function in the chain will receive the new `Request` with its updated `context`:

Calling `next()` with this signature will create a new `Request` object using the old `ctx.request`. This means that trying to consume `Request.body`, either before or after this rewrite, will throw a runtime error. This error is often raised with [Astro Actions that use HTML forms](/en/guides/actions/#call-actions-from-an-html-form-action). In these cases, we recommend handling rewrites from your Astro templates using `Astro.rewrite()` instead of using middleware.

src/middleware.js

```
// Current URL is https://example.com/blog// First middleware functionasyncfunctionfirst(_, next) {console.log(context.url.pathname) // this will log "/blog"// Rewrite to a new route, the homepage// Return updated `context` which is passed to next functionreturnnext("/")}// Current URL is still https://example.com/blog// Second middleware functionasyncfunctionsecond(context, next) {// Receives updated `context`console.log(context.url.pathname) // this will log  "/"returnnext()}export const onRequest = sequence(first, second);
```


## Error pages


[Section titled Error pages](#error-pages)

Middleware will attempt to run for all on-demand rendered pages, even when a matching route cannot be found. This includes Astro’s default (blank) 404 page and any custom 404 pages. However, it is up to the [adapter](/en/guides/on-demand-rendering/) to decide whether that code runs. Some adapters may serve a platform-specific error page instead.

Middleware will also attempt to run before serving a 500 error page, including a custom 500 page, unless the server error occurred in the execution of the middleware itself. If your middleware does not run successfully, then you will not have access to `Astro.locals` to render your 500 page.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 116. `en/guides/migrate-to-astro/.md`

```text
# Migrate an existing project to Astro


---
url: https://docs.astro.build/en/guides/migrate-to-astro/
description: Some tips and tricks for converting your site to Astro.
---


# Migrate an existing project to Astro


**Ready to convert your site to Astro?** See one of our guides for migration tips.


## Migration Guides


[Section titled Migration Guides](#migration-guides)

-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Note that many of these pages are **stubs**: they’re collections of resources waiting for your contribution!


## Why migrate your site to Astro?


[Section titled Why migrate your site to Astro?](#why-migrate-your-site-to-astro)

Astro provides many benefits: performance, simplicity, and many of the features you want built right into the framework. When you do need to extend your site, Astro provides several [official and 3rd-party community integrations](https://astro.build/integrations).

Migrating may be less work than you think!

Depending on your existing project, you may be able to use your existing:

-   [UI framework components](/en/guides/framework-components/) directly in Astro.

-   [CSS stylesheets or libraries](/en/guides/styling/) including Tailwind.

-   [Markdown/MDX files](/en/guides/markdown-content/), configured using your existing [remark and rehype plugins](/en/guides/markdown-content/#markdown-plugins).

-   [Content from a CMS](/en/guides/cms/) through an integration or API.



## Which projects can I convert to Astro?


[Section titled Which projects can I convert to Astro?](#which-projects-can-i-convert-to-astro)

[Many existing sites can be built with Astro](/en/concepts/why-astro/). Astro is ideally suited for your existing content-based sites like blogs, landing pages, marketing sites and portfolios. Astro integrates with several popular headless CMSes, and allows you to connect eCommerce shop carts.

Astro allows you have a fully statically-generated website, a dynamic app with routes rendered on demand, or a combination of both with [complete control over your project rendering](/en/guides/on-demand-rendering/), making it a great replacement for SSGs or for sites that need to fetch some page data on the fly.


## How will my project design change?


[Section titled How will my project design change?](#how-will-my-project-design-change)

Depending on your existing project, you may need to think differently about:

-   Designing in [Astro Islands](/en/concepts/islands/#what-is-an-island) to avoid sending unnecessary JavaScript to the browser.

-   Providing client-side interactivity with [client-side `<script>` tags](/en/guides/client-side-scripts/) or [UI framework components](/en/guides/framework-components/).

-   Managing [shared state](/en/recipes/sharing-state-islands/) with Nano Stores or local storage instead of app-wide hooks or wrappers.


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 117. `en/guides/migrate-to-astro/from-create-react-app/.md`

```text
# Migrating from Create React App (CRA)


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-create-react-app/
description: Tips for migrating an existing Create React App project to Astro
---


# Migrating from Create React App (CRA)


Astro’s [React integration](/en/guides/integrations-guide/react/) provides support for [using React components inside Astro components](/en/guides/framework-components/), including entire React apps like Create React App (CRA)!

src/pages/index.astro

```
---// Import your root App componentimport App from'../cra-project/App.jsx';---<!-- Use a client directive to load your app --><Appclient:load />
```

See how to [Build a Single Page Application (SPA) with Astro](https://logsnag.com/blog/react-spa-with-astro) External using React Router.

Many apps will “just work” as full React apps when you add them directly to your Astro project with the React integration installed. This is a great way to get your project up and running immediately and keep your app functional while you migrate to Astro.

Over time, you can convert your structure piece-by-piece to a combination of `.astro` and `.jsx` components. You will probably discover you need fewer React components than you think!

Here are some key concepts and migration strategies to help you get started. Use the rest of our docs and our [Discord community](https://astro.build/chat) to keep going!


## Key Similarities between CRA and Astro


[Section titled Key Similarities between CRA and Astro](#key-similarities-between-cra-and-astro)

-   The [syntax of `.astro` files is similar to JSX](/en/reference/astro-syntax/#differences-between-astro-and-jsx). Writing Astro should feel familiar.

-   Astro uses file-based routing, and [allows specially named pages to create dynamic routes](/en/guides/routing/#dynamic-routes).

-   Astro is [component-based](/en/basics/astro-components/), and your markup structure will be similar before and after your migration.

-   Astro has [official integrations for React, Preact, and Solid](/en/guides/integrations-guide/react/) so you can use your existing JSX components. Note that in Astro, these files **must** have a `.jsx` or `.tsx` extension.

-   Astro has support for [installing NPM packages](/en/guides/imports/#npm-packages), including React libraries. Many of your existing dependencies will work in Astro.



## Key Differences between CRA and Astro


[Section titled Key Differences between CRA and Astro](#key-differences-between-cra-and-astro)

When you rebuild your CRA site in Astro, you will notice some important differences:

-   CRA is a single-page application that uses `index.js` as your project’s root. Astro is a multi-page site, and `index.astro` is your home page.

-   [`.astro` components](/en/basics/astro-components/) are not written as exported functions that return page templating. Instead, you’ll split your code into a “code fence” for your JavaScript and a body exclusively for the HTML you generate.

-   [content-driven](/en/concepts/why-astro/#content-driven): Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing CRA app might be built for high client-side interactivity and may require advanced Astro techniques to include items that are more challenging to replicate using `.astro` components, such as dashboards.



## Add your CRA to Astro


[Section titled Add your CRA to Astro](#add-your-cra-to-astro)

Your existing app can be rendered directly inside a new Astro project, often with no changes to your app’s code.


### Create a new Astro project


[Section titled Create a new Astro project](#create-a-new-astro-project)

Use the `create astro` command for your package manager to launch Astro’s CLI wizard and select a new “empty” Astro project.

-   [npm](#tab-panel-3334)
-   [pnpm](#tab-panel-3335)
-   [Yarn](#tab-panel-3336)

Terminal window

```
npmcreateastro@latest
```

Terminal window

```
pnpmcreateastro@latest
```

Terminal window

```
yarncreateastro@latest
```


### Add integrations and dependencies


[Section titled Add integrations and dependencies](#add-integrations-and-dependencies)

Add the React integration using the `astro add` command for your package manager. If your app uses other packages supported by the `astro add` command, like Tailwind and MDX, you can add them all with one command:

-   [npm](#tab-panel-3337)
-   [pnpm](#tab-panel-3338)
-   [Yarn](#tab-panel-3339)

Terminal window

```
npxastroaddreactnpxastroaddreacttailwindmdx
```

Terminal window

```
pnpmastroaddreactpnpmastroaddreacttailwindmdx
```

Terminal window

```
yarnastroaddreactyarnastroaddreacttailwindmdx
```

If your CRA requires any dependencies (e.g. NPM packages), then install them individually using the command line or by adding them to your new Astro project’s `package.json` manually and then running an install command. Note that many, but not all, React dependencies will work in Astro.


### Add your existing app files


[Section titled Add your existing app files](#add-your-existing-app-files)

Copy your existing Create React App (CRA) project source files and folders (e.g. `components`, `hooks`, `styles`, etc.) into a new folder inside `src/`, keeping its file structure so your app will continue to work. Note that all `.js` file extensions must be renamed to `.jsx` or `.tsx`.

Do not include any configuration files. You will use Astro’s own `astro.config.mjs`, `package.json`, and `tsconfig.json`.

Move the contents of your app’s `public/` folder (e.g. static assets) into Astro’s `public/` folder.

-   Directorypublic/

    -   logo.png
    -   favicon.ico
    -   …

-   Directorysrc/

    -   Directorycra-project/

        -   App.jsx
        -   …

    -   Directorypages/

        -   index.astro


-   astro.config.mjs
-   package.json
-   tsconfig.json


### Render your app


[Section titled Render your app](#render-your-app)

Import your app’s root component in the frontmatter section of `index.astro`, then render the `<App />` component in your page template:

src/pages/index.astro

```
---import App from'../cra-project/App.jsx';---<Appclient:load />
```

Client directives

Your app needs a [client directive](/en/reference/directives-reference/#client-directives) for interactivity. Astro will render your React app as static HTML until you opt-in to client-side JavaScript.

Use `client:load` to ensure your app loads immediately from the server, or `client:only="react"` to skip rendering on the server and run your app entirely client-side.


## Convert your CRA to Astro


[Section titled Convert your CRA to Astro](#convert-your-cra-to-astro)

After [adding your existing app to Astro](#add-your-cra-to-astro), you will probably want to convert your app itself to Astro!

You will replicate a similar component-based design [using Astro HTML templating components for your basic structure](/en/basics/astro-components/) while importing and including individual React components (which may themselves be entire apps!) for islands of interactivity.

Every migration will look different and can be done incrementally without disrupting your working app. Convert individual pieces at your own pace so that more and more of your app is powered by Astro components over time.

As you convert your React app, you will decide which React components you will [rewrite as Astro components](#converting-jsx-files-to-astro-files). Your only restriction is that Astro components can import React components, but React components must only import other React components:

src/pages/static-components.astro

```
---import MyReactComponent from'../components/MyReactComponent.jsx';---<html><body><h1>Use React components directly in Astro!</h1><MyReactComponent /></body></html>
```

Instead of importing Astro components into React components, you can nest React components inside a single Astro component:

src/pages/nested-components.astro

```
---import MyReactSidebar from'../components/MyReactSidebar.jsx';import MyReactButton from'../components/MyReactButton.jsx';---<MyReactSidebar><p>Here is a sidebar with some text and a button.</p><divslot="actions"><MyReactButtonclient:idle /></div></MyReactSidebar>
```

You may find it helpful to learn about [Astro islands](/en/concepts/islands/) and [Astro components](/en/basics/astro-components/) before restructuring your CRA as an Astro project.


### Compare: JSX vs Astro


[Section titled Compare: JSX vs Astro](#compare-jsx-vs-astro)

Compare the following CRA component and a corresponding Astro component:

-   [JSX](#tab-panel-3332)
-   [Astro](#tab-panel-3333)

StarCount.jsx

```
import React, { useState, useEffect } from'react';import Header from'./Header';import Footer from'./Footer';const Component = () => {const [stars, setStars] = useState(0);const [message, setMessage] = useState('');useEffect(() => {const fetchData = async () => {const res = await fetch('https://api.github.com/repos/withastro/astro');const json = await res.json();setStars(json.stargazers_count | 0);setMessage(json.message);};fetchData();}, []);return (<><Header /><pstyle={{backgroundColor: `#f4f4f4`,padding: `1em 1.5em`,textAlign: `center`,marginBottom: `1em`}}>Astro has {stars} 🧑‍🚀</p><Footer /></>)};exportdefaultComponent;
```

StarCount.astro

```
---import Header from'./Header.astro';import Footer from'./Footer.astro';import'./layout.css';const res = await fetch('https://api.github.com/repos/withastro/astro')const json = await res.json();const message = json.message;const stars = json.stargazers_count | 0;---<Header /><pclass="banner">Astro has {stars} 🧑‍🚀</p><Footer /><style>.banner {background-color: #f4f4f4;padding: 1em1.5em;text-align: center;margin-bottom: 1em;}</style>
```


### Converting JSX files to `.astro` files


[Section titled Converting JSX files to .astro files](#converting-jsx-files-to-astro-files)

Here are some tips for converting a CRA `.js` component into a `.astro` component:

1.  Use the returned JSX of the existing CRA component function as the basis for your HTML template.

2.  Change any [CRA or JSX syntax to Astro](#reference-convert-cra-syntax-to-astro) or to HTML web standards. This includes `{children}` and `className`, for example.

3.  Move any necessary JavaScript, including import statements, into a [“code fence” (`---`)](/en/basics/astro-components/#the-component-script). Note: JavaScript to [conditionally render content](/en/reference/astro-syntax/#dynamic-html) is often written inside the HTML template directly in Astro.

4.  Use [`Astro.props`](/en/reference/api-reference/#props) to access any additional props that were previously passed to your CRA function.

5.  Decide whether any imported components also need to be converted to Astro. You can keep them as React components for now, or forever. But, you may eventually want to convert them to `.astro` components, especially if they do not need to be interactive!

6.  Replace `useEffect()` with import statements or [`import.meta.glob()`](/en/guides/imports/#importmetaglob) to query your local files. Use `fetch()` to fetch external data.



### Migrating Tests


[Section titled Migrating Tests](#migrating-tests)

As Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of your CRA site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.

See Astro’s [testing guide](/en/guides/testing/) for more.


## Reference: Convert CRA Syntax to Astro


[Section titled Reference: Convert CRA Syntax to Astro](#reference-convert-cra-syntax-to-astro)


### CRA Imports to Astro


[Section titled CRA Imports to Astro](#cra-imports-to-astro)

Update any [file imports](/en/guides/imports/) to reference relative file paths exactly. This can be done using [import aliases](/en/guides/typescript/#import-aliases), or by writing out a relative path in full.

Note that `.astro` and several other file types must be imported with their full file extension.

src/pages/authors/Fred.astro

```
---import Card from'../../components/Card.astro';---<Card />
```


### CRA Children Props to Astro


[Section titled CRA Children Props to Astro](#cra-children-props-to-astro)

Convert any instances of `{children}` to an Astro `<slot />`. Astro does not need to receive `{children}` as a function prop and will automatically render child content in a `<slot />`.

src/components/MyComponent.astro

```
------export default function MyComponent(props) {return (<div>{props.children}</div>);}<div><slot /></div>
```

React components that pass multiple sets of children can be migrated to an Astro component using [named slots](/en/basics/astro-components/#named-slots).

See more about [specific `<slot />` usage in Astro](/en/basics/astro-components/#slots).


### CRA Data Fetching to Astro


[Section titled CRA Data Fetching to Astro](#cra-data-fetching-to-astro)

Fetching data in a Create React App component is similar to Astro, with some slight differences.

You will need to remove any instances of a side effect hook (`useEffect`) for either `import.meta.glob()` or `getCollection()`/`getEntry()` to access data from other files in your project source.

To [fetch remote data](/en/guides/data-fetching/), use `fetch()`.

These data requests are made in the frontmatter of the Astro component and use top-level await.

src/pages/index.astro

```
---import { getCollection } from'astro:content';// Get all `src/content/blog/` entriesconst allBlogPosts = await getCollection('blog');// Get all `src/pages/posts/` entriesconst allPosts = Object.values(import.meta.glob('../pages/post/*.md', { eager: true }));// Fetch remote dataconst response = await fetch('https://randomuser.me/api/');const data = await response.json();const randomUser = data.results[0];---
```

See more about local files imports with [`import.meta.glob()`](/en/guides/imports/#importmetaglob), [querying using the Collections API](/en/guides/content-collections/#querying-collections) or [fetching remote data](/en/guides/data-fetching/).


### CRA Styling to Astro


[Section titled CRA Styling to Astro](#cra-styling-to-astro)

You may need to replace any [CSS-in-JS libraries](https://github.com/withastro/astro/issues/4432) (e.g. styled-components) with other available CSS options in Astro.

If necessary, convert any inline style objects (`style={{ fontWeight: "bold" }}`) to inline HTML style attributes (`style="font-weight:bold;"`). Or, use an [Astro `<style>` tag](/en/guides/styling/#styling-in-astro) for scoped CSS styles.

src/components/Card.astro

```
<divstyle={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div><divstyle="background-color: #f4f4f4; padding: 1em;">{message}</div>
```

Tailwind is supported after installing the [Tailwind Vite plugin](/en/guides/styling/#tailwind). No changes to your existing Tailwind code are required!

See more about [Styling in Astro](/en/guides/styling/).


## Troubleshooting


[Section titled Troubleshooting](#troubleshooting)

Your CRA might “just work” in Astro! But, you may likely need to make minor adjustments to duplicate your existing app’s functionality and/or styles.

If you cannot find your answers within these docs, please visit the [Astro Discord](https://astro.build/chat) and ask questions in our support forum!


## Community Resources


[Section titled Community Resources](#community-resources)

[Code Fix: The SIBA Website's Move from Create-React-App to Astro](https://brittanisavery.com/post/move-siba-to-astro)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Create React App to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-create-react-app.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 118. `en/guides/migrate-to-astro/from-docusaurus/.md`

```text
# Migrating from Docusaurus


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-docusaurus/
description: Tips for migrating an existing Docusaurus project to Astro
---


# Migrating from Docusaurus


[Docusaurus](https://Docusaurus.io) is a popular documentation website builder built on React.


## Key Similarities between Docusaurus and Astro


[Section titled Key Similarities between Docusaurus and Astro](#key-similarities-between-docusaurus-and-astro)

Docusaurus and Astro share some similarities that will help you migrate your project:

-   Both Astro and Docusaurus are modern, JavaScript-based (Jamstack) site builders intended for [content-driven websites](/en/concepts/why-astro/#content-driven), like documentation sites.

-   Both Astro and Docusaurus support [MDX pages](/en/guides/markdown-content/). You should be able to use your existing `.mdx` files to Astro.

-   Both Astro and Docusaurus use [file-based routing](/en/guides/routing/) to generate page routes automatically for any MDX file located in `src/pages`. Using Astro’s file structure for your existing content and when adding new pages should feel familiar.

-   Astro has an [official integration for using React components](/en/guides/integrations-guide/react/). Note that in Astro, React files **must** have a `.jsx` or `.tsx` extension.

-   Astro supports [installing NPM packages](/en/guides/imports/#npm-packages), including several for React. You may be able to keep some or all of your existing React components and dependencies.

-   [Astro’s JSX-like syntax](/en/basics/astro-components/#the-component-template) should feel familiar if you are used to writing React.



## Key Differences between Docusaurus and Astro


[Section titled Key Differences between Docusaurus and Astro](#key-differences-between-docusaurus-and-astro)

When you rebuild your Docusaurus site in Astro, you will notice some important differences:

-   Docusaurus is a React-based single-page application (SPA). Astro sites are multi-page apps built using [`.astro` components](/en/basics/astro-components/), but can also support [React, Preact, Vue.js, Svelte, SolidJS, AlpineJS](/en/guides/framework-components/) and raw HTML templating.

-   Docusaurus was designed to build documentation websites and has some built-in, documentation-specific website features that you would have to build yourself in Astro. Instead, Astro offers some of these features through [Starlight: an official docs theme](https://starlight.astro.build). This website was the inspiration for Starlight, and now runs on it! You can also find more [community docs themes](https://astro.build/themes?search=&categories%5B%5D=docs) with built-in features in our Themes Showcase.

-   Docusaurus sites use MDX pages for content. Astro’s docs theme uses Markdown (`.md`) files by default and does not require you to use MDX. You can optionally [install Astro’s MDX integration](/en/guides/integrations-guide/mdx/) (included in our Starlight theme by default) and use `.mdx` files in addition to standard Markdown files.



## Switch from Docusaurus to Astro


[Section titled Switch from Docusaurus to Astro](#switch-from-docusaurus-to-astro)

To convert a Docusaurus documentation site to Astro, start with our official [Starlight docs theme starter template](https://starlight.astro.build), or explore more community docs themes in our [theme showcase](https://astro.build/themes?search=&categories%5B%5D=docs).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3326)
-   [pnpm](#tab-panel-3327)
-   [Yarn](#tab-panel-3328)

Terminal window

```
npmcreateastro@latest----templatestarlight
```

Terminal window

```
pnpmcreateastro@latest--templatestarlight
```

Terminal window

```
yarncreateastro--templatestarlight
```

Astro’s MDX integration is included by default, so you can [bring your existing content files to Starlight](https://starlight.astro.build/getting-started/#add-content) right away.

You can find Astro’s docs starter, and other official templates, on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[Speeding up documentation by 10 times (Russian)](https://habr.com/ru/articles/880220/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Docusaurus site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-docusaurus.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 119. `en/guides/migrate-to-astro/from-eleventy/.md`

```text
# Migrating from Eleventy


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-eleventy/
description: Tips for migrating an existing Eleventy project to Astro
---


# Migrating from Eleventy


[Eleventy](https://11ty.dev) is an open-source static site generator that works with multiple template languages.


## Key Similarities between Eleventy (11ty) and Astro


[Section titled Key Similarities between Eleventy (11ty) and Astro](#key-similarities-between-eleventy-11ty-and-astro)

Eleventy (11ty) and Astro share some similarities that will help you migrate your project:

-   Both Astro and Eleventy are modern, JavaScript-based (Jamstack) site builders.

-   Astro and Eleventy both allow you to use a [headless CMS, APIs or Markdown files for data](/en/guides/data-fetching/). You can continue to use your preferred content authoring system, and will be able to keep your existing content.



## Key Differences between Eleventy (11ty) and Astro


[Section titled Key Differences between Eleventy (11ty) and Astro](#key-differences-between-eleventy-11ty-and-astro)

When you rebuild your Eleventy (11ty) site in Astro, you will notice some important differences:

-   Eleventy supports a variety of templating languages. Astro supports [including components from several popular JS Frameworks (e.g. React, Svelte, Vue, Solid)](/en/guides/framework-components/), but uses [Astro layouts, pages and components](/en/basics/astro-components/) for most page templating.

-   Astro uses a [`src/` directory](/en/basics/project-structure/#src) for all files, including site metadata, that are available for querying and processing during site build. Within this is a [special `src/pages/` folder for file-based routing](/en/basics/astro-pages/).

-   Astro uses a [`public/` folder for static assets](/en/basics/project-structure/#public) that do not need to be processed nor transformed during the build.

-   In Eleventy, bundling CSS, JavaScript, and other assets needs to be configured manually. [Astro handles this for you out-of-the-box](/en/concepts/why-astro/#easy-to-use).



## Switch from Eleventy to Astro


[Section titled Switch from Eleventy to Astro](#switch-from-eleventy-to-astro)

To convert an Eleventy blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3329)
-   [pnpm](#tab-panel-3330)
-   [Yarn](#tab-panel-3331)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

Bring your existing Markdown (or MDX, with our optional integration) files as content to [create Markdown or MDX pages](/en/guides/markdown-content/).

Your Eleventy project allowed you to use a variety of templating languages to build your site. In an Astro project, your page templating will mostly be achieved with Astro components, which can be used as UI elements, layouts and even full pages. You may want to explore [Astro’s component syntax](/en/basics/astro-components/) to see how to template in Astro using components.

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[This Site Is Now Built with Astro](https://aqandrew.com/blog/now-built-with-astro/) Why I switched from Eleventy.

[Website Rewrite: 2025](https://www.welchcanavan.com/posts/site-rewrite-2025/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting an Eleventy site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-eleventy.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 120. `en/guides/migrate-to-astro/from-gatsby/.md`

```text
# Migrating from Gatsby


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-gatsby/
description: Tips for migrating an existing Gatsby project to Astro
---


# Migrating from Gatsby


Here are some key concepts and migration strategies to help you get started. Use the rest of our docs and our [Discord community](https://astro.build/chat) to keep going!


## Key Similarities between Gatsby and Astro


[Section titled Key Similarities between Gatsby and Astro](#key-similarities-between-gatsby-and-astro)

Gatsby and Astro share some similarities that will help you migrate your project:

-   The [syntax of `.astro` files is similar to JSX](/en/reference/astro-syntax/#jsx-like-expressions). Writing Astro should feel familiar.

-   Astro has built-in support for [Markdown](/en/guides/markdown-content/) and an integration for using MDX files. Also, you can configure and continue to use many of your existing Markdown plugins.

-   Astro also has an [official integration for using React components](/en/guides/integrations-guide/react/). Note that in Astro, React files **must** have a `.jsx` or `.tsx` extension.

-   Astro has support for [installing NPM packages](/en/guides/imports/#npm-packages), including React libraries. Many of your existing dependencies will work in Astro.

-   Like Gatsby, Astro projects can be SSG or [SSR with page-level prerendering](/en/guides/on-demand-rendering/).



## Key Differences between Gatsby and Astro


[Section titled Key Differences between Gatsby and Astro](#key-differences-between-gatsby-and-astro)

When you rebuild your Gatsby site in Astro, you will notice some important differences:

-   Gatsby projects are React single-page apps and use `index.js` as your project’s root. Astro projects are multi-page sites, and `index.astro` is your home page.

-   [Astro components](/en/basics/astro-components/) are not written as exported functions that return page templating. Instead, you’ll split your code into a “code fence” for your JavaScript and a body exclusively for the HTML you generate.

-   [Local file data](/en/guides/imports/): Gatsby uses GraphQL to retrieve data from your project files. Astro uses ESM imports and top-level await functions (e.g. [`import.meta.glob()`](/en/guides/imports/#importmetaglob), [`getCollection()`](/en/guides/content-collections/#querying-collections)) to import data from your project files. You can manually add GraphQL to your Astro project but it is not included by default.



## Convert your Gatsby Project


[Section titled Convert your Gatsby Project](#convert-your-gatsby-project)

Each project migration will look different, but there are some common actions you will perform when converting from Gatsby to Astro.


### Create a new Astro project


[Section titled Create a new Astro project](#create-a-new-astro-project)

Use the `create astro` command for your package manager to launch Astro’s CLI wizard or choose a community theme from the [Astro Theme Showcase](https://astro.build/themes).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters (e.g. `docs`, `blog`, `portfolio`). Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3342)
-   [pnpm](#tab-panel-3343)
-   [Yarn](#tab-panel-3344)

Terminal window

```

# launch the Astro CLI Wizardnpmcreateastro@latest# create a new project with an official examplenpmcreateastro@latest----template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardpnpmcreateastro@latest# create a new project with an official examplepnpmcreateastro@latest--template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardyarncreateastro@latest# create a new project with an official exampleyarncreateastro@latest--template<example-name>

```

Then, copy your existing Gatsby project files over to your new Astro project into a separate folder outside of `src`.

Tip

Visit [https://astro.new](https://astro.new) for the full list of official starter templates, and links for opening a new project in IDX, StackBlitz, CodeSandbox, or Gitpod.


### Install integrations (optional)


[Section titled Install integrations (optional)](#install-integrations-optional)

You may find it useful to install some of [Astro’s optional integrations](/en/guides/integrations-guide/) to use while converting your Gatsby project to Astro:

-   **@astrojs/react**: to reuse some existing React UI components in your new Astro site or keep writing with React components.

-   **@astrojs/mdx**: to bring existing MDX files from your Gatsby project, or to use MDX in your new Astro site.



### Put your code in `src`


[Section titled Put your code in src](#put-your-code-in-src)

Following [Astro’s project structure](/en/basics/project-structure/):

1.  **Delete** Gatsby’s `public/` folder.

    Gatsby uses the `public/` directory for its build output, so you can safely discard this folder. You will no longer need a built version of your Gatsby site. (Astro uses `dist/` by default for the build output.)

2.  **Rename** Gatsby’s `static/` folder to `public/`, and use it as Astro’s `public/` folder.

    Astro uses a folder called `public/` for static assets. You can alternatively copy the contents of `static/` into your existing Astro `public/` folder.

3.  **Copy or Move** Gatsby’s other files and folders (e.g. `components`, `pages`, etc.) as needed into your Astro `src/` folder as you rebuild your site, following [Astro’s project structure](/en/basics/project-structure/).

    Astro’s `src/pages/` folder is a special folder used for file-based routing to create your site’s pages and posts from `.astro`, `.md` and `.mdx` files. You will not have to configure any routing behavior for your Astro, Markdown, and MDX files.

    All other folders are optional, and you can organize the contents of your `src/` folder any way you like. Other common folders in Astro projects include `src/layouts/`, `src/components`, `src/styles`, and `src/scripts`.



### Tips: Convert JSX files to `.astro` files


[Section titled Tips: Convert JSX files to .astro files](#tips-convert-jsx-files-to-astro-files)

Here are some tips for converting a Gatsby `.js` component into a `.astro` component:

1.  Use only the `return()` of the existing Gatsby component function as your HTML template.

2.  Change any [Gatsby or JSX syntax to Astro syntax](#reference-convert-to-astro-syntax) or to HTML web standards. This includes `<Link to="">`, `{children}`, and `className`, for example.

3.  Move any necessary JavaScript, including import statements, into a [“code fence” (`---`)](/en/basics/astro-components/#the-component-script). Note: JavaScript to [conditionally render content](/en/reference/astro-syntax/#dynamic-html) is often written inside the HTML template directly in Astro.

4.  Use [`Astro.props`](/en/reference/api-reference/#props) to access any additional props that were previously passed to your Gatsby function.

5.  Decide whether any imported components also need to be converted to Astro. With the official React integration installed, you can [use existing React components in your Astro files](/en/guides/framework-components/). But, you may want to convert them to `.astro` components, especially if they do not need to be interactive!

6.  Remove any GraphQL queries. Instead, use import and [`import.meta.glob()`](/en/guides/imports/#importmetaglob) statements to query your local files.


See [an example from Gatsby’s Blog starter template converted step-by-step](#guided-example-gatsby-layout-to-astro)


#### Compare: `.jsx` vs `.astro`


[Section titled Compare: .jsx vs .astro](#compare-jsx-vs-astro)

Compare the following Gatsby component and a corresponding Astro component:

-   [JSX](#tab-panel-3340)
-   [Astro](#tab-panel-3341)

component.jsx

```
import*as React from"react"import { useStaticQuery, graphql } from"gatsby"import Header from"./header"import Footer from"./footer"import"./layout.css"const Component = ({ message, children }) => {const data = useStaticQuery(graphql`query SiteTitleQuery {site {siteMetadata {title}}}`)return (<><HeadersiteTitle={data.site.siteMetadata.title} /><divstyle={{ margin: `0`, maxWidth: `960`}}>{message}</div><main>{children}</main><FootersiteTitle={data.site.siteMetadata} /></>)}exportdefaultComponent
```

component.astro

```
---import Header from"./Header.astro"import Footer from"./Footer.astro"import"../styles/stylesheet.css"import { site } from"../data/siteMetaData.js"const { message } = Astro.props---<HeadersiteTitle={site.title} /><divstyle="margin: 0; max-width: 960;">{message}</div><main><slot /></main><FootersiteTitle={site.title} />
```


### Migrating Layout Files


[Section titled Migrating Layout Files](#migrating-layout-files)

You may find it helpful to start by converting your Gatsby layouts and templates into [Astro layout components](/en/basics/layouts/).

Each Astro page explicitly requires `<html>`, `<head>`, and `<body>` tags to be present, so it is common to reuse a layout file across pages. Astro uses a [`<slot />`](/en/basics/astro-components/#slots) instead of React’s `{children}` prop for page content, with no import statement required. Your Gatsby `layout.js` and templates will not include these.

Note the standard HTML templating, and direct access to `<head>`:

src/layouts/Layout.astro

```
<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><!-- Wrap the slot element with your existing layout templating --><slot /></body></html>
```

You may also wish to reuse code from Gatsby’s `src/components/seo.js` to include additional site metadata. Notice that Astro uses neither `<Helmet>` nor `<Header>` but instead creates `<head>` directly. You may import and use components, even within `<head>`, to separate and organize your page content.


### Migrating Pages and Posts


[Section titled Migrating Pages and Posts](#migrating-pages-and-posts)

In Gatsby, your [pages and posts](/en/basics/astro-pages/) may exist in `src/pages/` or outside of `src` in another folder, like `content`. In Astro, all your page content must live within `src/` unless you are using [content collections](/en/guides/content-collections/).


#### React Pages


[Section titled React Pages](#react-pages)

Your existing Gatsby JSX (`.js`) pages will need to be [converted from JSX files to `.astro` pages](#tips-convert-jsx-files-to-astro-files). You cannot use an existing JSX page file in Astro.

These [`.astro` pages](/en/basics/astro-pages/) must be located within `src/pages/` and will have page routes generated automatically based on their file path.


#### Markdown and MDX pages


[Section titled Markdown and MDX pages](#markdown-and-mdx-pages)

Astro has built-in support for Markdown and an optional integration for MDX files. Your existing [Markdown and MDX files](/en/guides/markdown-content/) can be reused but may require some adjustments to their frontmatter, such as adding [Astro’s special `layout` frontmatter property](/en/basics/layouts/#markdown-layouts). They can also be placed within `src/pages/` to take advantage of automatic file-based routing.

Alternatively, you can use [content collections](/en/guides/content-collections/) in Astro to store and manage your content. You will retrieve the content yourself and [generate those pages dynamically](/en/guides/content-collections/#generating-routes-from-content).


### Migrating Tests


[Section titled Migrating Tests](#migrating-tests)

As Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of the older Gatsby site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.

See Astro’s [testing guide](/en/guides/testing/) for more.


### Repurpose config files


[Section titled Repurpose config files](#repurpose-config-files)

Gatsby has several top-level configuration files that also include site and page metadata and are used for routing. You will not use any of these `gatsby-*.js` files in your Astro project, but there may be some content that you can reuse as you build your Astro project:

-   `gatsby-config.js`: Move your `siteMetadata: {}` into `src/data/siteMetadata.js` (or `siteMetadata.json`) to import data about your site (title, description, social accounts, etc.) into page layouts.

-   `gatsby-browser.js`: Consider adding anything used here directly into your [main layout](#migrating-layout-files)’s `<head>` tag.

-   `gatsby-node.js`: You will not need to create your own nodes in Astro, but viewing the schema in this file may help you with defining types in your Astro project.

-   `gatsby-ssr.js`: If you choose to use SSR in Astro, you will [add and configure the SSR adapter](/en/guides/on-demand-rendering/) of your choice directly in `astro.config.mjs`.



## Reference: Convert to Astro Syntax


[Section titled Reference: Convert to Astro Syntax](#reference-convert-to-astro-syntax)

The following are some examples of Gatsby-specific syntax that you will need to convert to Astro. See more [differences between Astro and JSX](/en/reference/astro-syntax/#differences-between-astro-and-jsx) in the guide to writing Astro components.


### Gatsby Links to Astro


[Section titled Gatsby Links to Astro](#gatsby-links-to-astro)

Convert any Gatsby `<Link to="">`, `<NavLink>` etc. components to HTML `<a href="">` tags.

```
<Linkto="/blog">Blog</Link><ahref="/blog">Blog</a>
```

Astro does not use any special component for links, although you are welcome to build your own `<Link>` component. You can then import and use this `<Link>` just as you would any other component.

src/components/Link.astro

```
---const { to } = Astro.props---<ahref={to}><slot /></a>
```


### Gatsby Imports to Astro


[Section titled Gatsby Imports to Astro](#gatsby-imports-to-astro)

If necessary, update any [file imports](/en/guides/imports/) to reference relative file paths exactly. This can be done using [import aliases](/en/guides/typescript/#import-aliases), or by writing out a relative path in full.

Note that `.astro` and several other file types must be imported with their full file extension.

src/pages/authors/Fred.astro

```
---import Card from`../../components/Card.astro`;---<Card />
```


### Gatsby Children Props to Astro


[Section titled Gatsby Children Props to Astro](#gatsby-children-props-to-astro)

Convert any instances of `{children}` to an Astro `<slot />`. Astro does not need to receive `{children}` as a function prop and will automatically render child content in a `<slot />`.

src/components/MyComponent

```
------export default function MyComponent(props) {return (<div>{props.children}</div>);}<div><slot /></div>
```

React components that pass multiple sets of children can be migrated to an Astro component using [named slots](/en/basics/astro-components/#named-slots).

See more about [specific `<slot />` usage in Astro](/en/basics/astro-components/#slots).


### Gatsby Styling to Astro


[Section titled Gatsby Styling to Astro](#gatsby-styling-to-astro)

You may need to replace any [CSS-in-JS libraries](https://github.com/withastro/astro/issues/4432) (e.g. styled-components) with other available CSS options in Astro.

If necessary, convert any inline style objects (`style={{ fontWeight: "bold" }}`) to inline HTML style attributes (`style="font-weight:bold;"`). Or, use an [Astro `<style>` tag](/en/guides/styling/#styling-in-astro) for scoped CSS styles.

src/components/Card.astro

```
<divstyle={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div><divstyle="background-color: #f4f4f4; padding: 1em;">{message}</div>
```

Tailwind is supported after installing the [Tailwind Vite plugin](/en/guides/styling/#tailwind). No changes to your existing Tailwind code are required!

Global styling is achieved in Gatsby using CSS imports in `gatsby-browser.js`. In Astro, you will import `.css` files directly into a main layout component to achieve global styles.

See more about [Styling in Astro](/en/guides/styling/).


### Gatsby Image Plugin to Astro


[Section titled Gatsby Image Plugin to Astro](#gatsby-image-plugin-to-astro)

Convert Gatsby’s `<StaticImage />` and `<GatsbyImage />` components to [Astro’s own image integration components](/en/guides/images/), or to a [standard HTML `<img>` / JSX `<img />`](/en/guides/images/#images-in-ui-framework-components) tag as appropriate in your React components.

src/pages/index.astro

```
---import { Image } from'astro:assets';import rocket from'../assets/rocket.png';---<Imagesrc={rocket}alt="A rocketship in space." /><imgsrc={rocket.src}alt="A rocketship in space.">
```

Astro’s `<Image />` component works in `.astro` and `.mdx` files only. See a [full list of its component attributes](/en/reference/modules/astro-assets/#image-properties) and note that several will differ from Gatsby’s attributes.

To continue using [images in Markdown (`.md`) files](/en/guides/images/#images-in-markdown-files) using standard Markdown syntax (`![]()`), you may need to update the link. Using the HTML `<img>` tag directly is not supported in `.md` files for local images, and must be converted to Markdown syntax.

src/pages/post-1.md

```

# My Markdown Page<!-- Local image stored at src/assets/stars.png -->![A starry night sky.](../assets/stars.png)

```

In React (`.jsx`) components, use standard JSX image syntax (`<img />`). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.

You can learn more about [using images in Astro](/en/guides/images/) in the Images Guide.


### Gatsby GraphQL to Astro


[Section titled Gatsby GraphQL to Astro](#gatsby-graphql-to-astro)

Remove all references to GraphQL queries, and instead use [`import.meta.glob()`](/en/guides/imports/#importmetaglob) to access data from your local files.

Or, if using content collections, query your Markdown and MDX files using [`getEntry()` and `getCollection()`](/en/guides/content-collections/#generating-routes-from-content).

These data requests are made in the frontmatter of the Astro component using the data.

src/pages/index.astro

```
---import { graphql } from"gatsby"import { getCollection } from'astro:content';// Get all `src/content/blog/` entriesconst allBlogPosts = await getCollection('blog');// Get all `src/pages/posts/` entriesconst allPosts = Object.values(import.meta.glob('../pages/post/*.md', { eager: true }));---export const pageQuery = graphql`{allMarkdownRemark(sort: { frontmatter: { date: DESC } }) {nodes {excerptfields {slug}frontmatter {date(formatString: "MMMM DD, YYYY")titledescription}}}}`
```


## Guided example: Gatsby layout to Astro


[Section titled Guided example: Gatsby layout to Astro](#guided-example-gatsby-layout-to-astro)

This example converts the main project layout (`layout.js`) from Gatsby’s blog starter to `src/layouts/Layout.astro`.

This page layout shows one header when visiting the home page, and a different header with a link back to Home for all other pages.

1.  Identify the `return()` JSX.

    layout.js

    ```
    import*as React from"react"import { Link } from"gatsby"const Layout = ({ location, title, children }) => {const rootPath = `${__PATH_PREFIX__}/`const isRootPath = location.pathname === rootPathlet headerif (isRootPath) {header = (<h1className="main-heading"><Linkto="/">{title}</Link></h1>)} else {header = (<LinkclassName="header-link-home"to="/">Home</Link>)}return (<divclassName="global-wrapper"data-is-root-path={isRootPath}><headerclassName="global-header">{header}</header><main>{children}</main><footer>© {newDate().getFullYear()}, Built with{``}<ahref="https://www.gatsbyjs.com">Gatsby</a></footer></div>)}exportdefaultLayout
    ```

2.  Create `Layout.astro` and add this `return` value, [converted to Astro syntax](#reference-convert-to-astro-syntax).

    Note that:

    -   `{new Date().getFullYear()}` just works 🎉
    -   `{children}` becomes `<slot />` 🦥
    -   `className` becomes `class` 📛
    -   `Gatsby` becomes `Astro` 🚀

    src/layouts/Layout.astro

    ```
    ------<divclass="global-wrapper"data-is-root-path={isRootPath}><headerclass="global-header">{header}</header><main><slot /></main><footer>© {newDate().getFullYear()}, Built with{``}<ahref="https://www.astro.build">Astro</a></footer></div>
    ```

3.  Add a page shell so that your layout provides each page with the necessary parts of an HTML document:

    src/layouts/Layout.astro

    ```
    ------<html><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><divclass="global-wrapper"data-is-root-path={isRootPath}><headerclass="global-header">{header}</header><main><slot /></main><footer>&#169;{newDate().getFullYear()}, Built with{``}<ahref="https://www.astro.build">Astro</a></footer></div></body></html>
    ```

4.  Add any needed imports, props, and JavaScript

    To conditionally render a header based on the page route and title in Astro:

    -   Provide the props via `Astro.props`. (Remember: your Astro templating accesses props from its frontmatter, not passed into a function.)
    -   Use a ternary operator to show one heading if this is the home page, and a different heading otherwise.
    -   Remove variables for `{header}` and `{isRootPath}` as they are no longer needed.
    -   Replace Gatsby’s `<Link/>` tags with `<a>` anchor tags.
    -   Use `class` instead of `className`.
    -   Import a local stylesheet from your project for the class names to take effect.

    src/layouts/Layout.astro

    ```
    ---import'../styles/style.css';const { title, pathname } = Astro.props---<html><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><divclass="global-wrapper"><headerclass="global-header">{ pathname ==="/"?<h1class="main-heading"><ahref="/">{title}</a></h1>:<h1class="main-heading"><aclass="header-link-home"href="/">Home</a></h1>}</header><main><slot /></main><footer>&#169;{newDate().getFullYear()}, Built with{``}<ahref="https://www.astro.build">Astro</a></footer></div></body></html>
    ```

5.  Update `index.astro` to use this new layout and pass it the necessary `title` and `pathname` props:

    src/pages/index.astro

    ```
    ---import Layout from'../layouts/Layout.astro';const pagePathname = Astro.url.pathname---<Layouttitle="Home Page"pathname={pagePathname}><p>Astro</p></Layout>
    ```

    Tip

    You can [get the current page’s path using `Astro.url`](/en/reference/api-reference/#url).

6.  To test the conditional header, create a second page, `about.astro` using the same pattern:

    src/pages/about.astro

    ```
    ---import Layout from'../layouts/Layout.astro';const pagePathname = Astro.url.pathname---<Layouttitle="About"pathname={pagePathname}><p>About</p></Layout>
    ```

    You should see a link to “Home” only when visiting the About page.



## Community Resources


[Section titled Community Resources](#community-resources)

[Migrating from Gatsby to Astro](https://loige.co/migrating-from-gatsby-to-astro/) How and why I migrated this blog from Gatsby to Astro and what I learned in the process.

[Migrating to Astro was EZ](https://joelhooks.com/migrating-to-astro-was-ez) This is about the process of migrating from Gatsby to Astro, and why I chose Astro.

[My Switch from Gatsby to Astro](https://www.joshfinnie.com/blog/my-switch-from-gatsby-to-astro/) The switch to Astro is definitely worth a blog post! It’s revolutionizing the static web development scene for the better.

[Why I moved to Astro from Gatsby](https://dev.to/askrodney/why-i-moved-to-astro-from-gatsby-3fck) Taking a quick look at what made me want to switch and why Astro was a good fit.

[Another Migration: From Gatsby to Astro](https://logarithmicspirals.com/blog/migrating-from-gatsby-to-astro/) Learn about how I transitioned my personal website from Gatsby to Astro as I share insights and experiences from the migration process.

[From Gatsby gridlock to Astro bliss: my personal site redesign](https://jwn.gr/posts/migrating-from-gatsby-to-astro/) Gatsby has shown its age and I found myself seeking a modern alternative. Enter Astro — a framework that has breathed some new life into this site.

[Why and how I moved my blog away from Gatsby and React to Astro Js and Preact](https://www.helmerdavila.com/blog/en/why-and-how-i-moved-my-blog-away-from-gatsby-and-react-to-astro-js-and-preact) All is about simplicity and power at the same time.

[How I rewrote my HUGE Gatsby site in Astro and learned to love it in the process](https://dunedinsound.com/blog/how_i_rewrote_my_huge_gatsby_site_in_astro_and_learned_to_love_it_in_the_process/) Everything is faster. Happier. More productive.

[How I switched from Gatsby to Astro (While Keeping Drupal in the Mix)](https://albert.skibinski.nl/en/blog/how-i-switched-gatsby-astro-while-keeping-drupal-mix/) I came across the relatively new Astro, which ticked all the boxes.

[Migrating my website from Gatsby to Astro](https://dev.to/flashblaze/migrating-my-website-from-gatsby-to-astro-2ej5) Astro has entered the chat.

[Gatsby to Astro](https://alvin.codes/writing/gatsby-to-astro) Why and how I migrated this website from Gatsby to Astro.

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Gatsby site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-gatsby.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 121. `en/guides/migrate-to-astro/from-gitbook/.md`

```text
# Migrating from GitBook


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-gitbook/
description: Tips for migrating an existing GitBook project to Astro
---


# Migrating from GitBook


[GitBook](https://gitbook.com) is a web-based platform for creating and publishing documentation and books in a collaborative manner, with version control integration and customizable features.


## Key Similarities between GitBook and Astro


[Section titled Key Similarities between GitBook and Astro](#key-similarities-between-gitbook-and-astro)

GitBook and Astro share some similarities that will help you migrate your project:

-   Both Astro and GitBook support [Markdown](/en/guides/markdown-content/). You can migrate all your existing documentation utilizing GitBook’s Git Sync feature.

-   Both Astro and GitBook use some form of [file-based routing](/en/guides/routing/). Using Astro’s file structure for your existing content and when adding new pages should feel familiar.



## Key Differences between GitBook and Astro


[Section titled Key Differences between GitBook and Astro](#key-differences-between-gitbook-and-astro)

When you migrate your GitBook docs to Astro, you will notice some important differences:

-   A GitBook site is edited using an online dashboard. In Astro, you will use a [code editor](/en/editor-setup/) and development environment to maintain your site. You can develop locally on your machine, or choose a cloud editor/development environment like IDX, StackBlitz, CodeSandbox, or Gitpod.

-   GitBook stores your content in a database. In Astro, you will have individual files (typically Markdown or MDX) in your [project directory](/en/basics/project-structure/) for each page’s content. Or, you can choose to use a [CMS for your content](/en/guides/cms/) and use Astro to fetch and present the data.

-   GitBook uses a custom syntax on top of Markdown for content. Astro supports Markdoc via the optional [Markdoc integration](/en/guides/integrations-guide/markdoc/), which features a similar syntax to the one you would use in GitBook.



## Switch from GitBook to Astro


[Section titled Switch from GitBook to Astro](#switch-from-gitbook-to-astro)

To convert a GitBook documentation site to Astro, start with our official [Starlight docs theme starter template](https://starlight.astro.build), or explore more community docs themes in our [theme showcase](https://astro.build/themes?search=&categories%5B%5D=docs).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3345)
-   [pnpm](#tab-panel-3346)
-   [Yarn](#tab-panel-3347)

Terminal window

```
npmcreateastro@latest----templatestarlight
```

Terminal window

```
pnpmcreateastro@latest--templatestarlight
```

Terminal window

```
yarncreateastro--templatestarlight
```

Once you have a new Astro project, you can sync your existing GitBook content to your new Astro project. GitBook has a [Git Sync feature](https://docs.gitbook.com/product-tour/git-sync) that will automatically sync your GitBook content to a GitHub/GitLab repository.

To sync directly to the docs template’s content collection, specify `src/content/docs/en` or `src/content/docs` as the project directory.

Caution

When enabling Git Sync be sure to specify “**GitBook to GitHub**” as the priority. This will ensure that your GitBook content is synced to your GitHub repository. Otherwise, you will overwrite your existing GitBook content.

After syncing the content, you will now have a copy of your GitBook content in your Astro repository. Disable git sync to prevent future syncing with GitBook.

Note that although you now have your content migrated to your Astro project, it will not be immediately usable. To use this content in your Astro site, you will need to spend some time manually changing GitBook’s syntax into a format compatible with Astro. In particular:

-   Astro’s [Markdoc integration](/en/guides/integrations-guide/markdoc/) requires that the file extension be `.mdoc`. This is to avoid conflicts with other Markdown extensions like `.mdx` and `.md`.
-   GitBook syntax differs from Markdoc where the `/` prefix denoting a closing tag is replaced with `end` for GitBook files. You will need to update this notation throughout your files.
-   Some features of GitBook rely on custom components. These components will not exist in Astro and must be created and added to your project through [Markdoc’s config `tags` attribute](/en/guides/integrations-guide/markdoc/#use-astro-components-as-markdoc-tags) or removed from your files.


## Community Resources


[Section titled Community Resources](#community-resources)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a GitBook site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-gitbook.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 122. `en/guides/migrate-to-astro/from-gridsome/.md`

```text
# Migrating from Gridsome


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-gridsome/
description: Tips for migrating an existing Gridsome project to Astro
---


# Migrating from Gridsome


[Gridsome](https://gridsome.org) is an open-source static site generator built on Vue and GraphQL.


## Key Similarities between Gridsome and Astro


[Section titled Key Similarities between Gridsome and Astro](#key-similarities-between-gridsome-and-astro)

Gridsome and Astro share some similarities that will help you migrate your project:

-   Both Gridsome and Astro are modern JavaScript static-site generators with similar [project file structures](/en/basics/project-structure/#directories-and-files).

-   Both Gridsome and Astro use a `src/` folder for your project files and a [special `src/pages/` folder for file-based routing](/en/basics/astro-pages/). Creating and managing pages for your site should feel familiar.

-   Astro has [an official integration for using Vue components](/en/guides/integrations-guide/vue/) and supports [installing NPM packages](/en/guides/imports/#npm-packages), including several for Vue. You will be able to write Vue UI components, and may be able to keep some or all of your existing Gridsome Vue components and dependencies.

-   Astro and Gridsome both allow you to use a [headless CMS, APIs or Markdown files for data](/en/guides/data-fetching/). You can continue to use your preferred content authoring system, and will be able to keep your existing content.



## Key Differences between Gridsome and Astro


[Section titled Key Differences between Gridsome and Astro](#key-differences-between-gridsome-and-astro)

When you rebuild your Gridsome site in Astro, you will notice some important differences:

-   Gridsome is a Vue-based single-page application (SPA). Astro sites are multi-page apps built using [`.astro` components](/en/basics/astro-components/), but can also support [React, Preact, Vue.js, Svelte, SolidJS, AlpineJS](/en/guides/framework-components/) and raw HTML templating.

-   As an SPA, Gridsome uses `vue-router` for SPA routing, and `vue-meta` for managing `<head>`. In Astro, you will create separate HTML pages and control your page `<head>` directly, or in a [layout component](/en/basics/layouts/).

-   [Local file data](/en/guides/imports/): Gridsome uses GraphQL to retrieve data from your project files. Astro uses ESM imports and [`import.meta.glob()`](/en/guides/imports/#importmetaglob) to import data from local project files. Remote resources can be loaded using the standard `fetch()` API. GraphQL may be optionally added to your project, but is not included by default.



## Switch from Gridsome to Astro


[Section titled Switch from Gridsome to Astro](#switch-from-gridsome-to-astro)

To convert a Gridsome blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3348)
-   [pnpm](#tab-panel-3349)
-   [Yarn](#tab-panel-3350)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

Bring your existing Markdown (or MDX, with our optional integration) files as content to [create Markdown or MDX pages](/en/guides/markdown-content/).

Since Gridsome’s project structure is similar to Astro’s, you may be able to copy several existing files from your project into the same location in your new Astro project. However, the two project structures are not identical. You may want to examine [Astro’s project structure](/en/basics/project-structure/) to see what the differences are.

Since Astro queries and imports your local files differently than Gridsome, you may want to read about how to load files using [`import.meta.glob()`](/en/guides/imports/#importmetaglob) to understand how to work with your local files.

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[Migration from Gridsome to Astro](https://fyodor.io/migration-from-gridsome-to-astro/)

[Hello Astro!](https://thamas.hu/astro-hello)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Gridsome site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-gridsome.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 123. `en/guides/migrate-to-astro/from-hugo/.md`

```text
# Migrating from Hugo


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-hugo/
description: Tips for migrating an existing Hugo project to Astro
---


# Migrating from Hugo


[Hugo](https://gohugo.io) is an open-source static site generator built on Go.


## Key Similarities between Hugo and Astro


[Section titled Key Similarities between Hugo and Astro](#key-similarities-between-hugo-and-astro)

Hugo and Astro share some similarities that will help you migrate your project:

-   Hugo and Astro are both modern static-site generators, ideally suited to [content-driven websites](/en/concepts/why-astro/#content-driven) like blogs.

-   Hugo and Astro both allow you to [author your content in Markdown](/en/guides/markdown-content/). However, Hugo includes several special frontmatter properties and allows you to write frontmatter in YAML, TOML or JSON. Even though many of your existing Hugo frontmatter properties will not be “special” in Astro, you can continue to use your existing Markdown files and YAML (or TOML) frontmatter values.

-   Hugo and Astro both allow you to enhance your site with a variety of [integrations and external packages](https://astro.build/integrations/).



## Key Differences between Hugo and Astro


[Section titled Key Differences between Hugo and Astro](#key-differences-between-hugo-and-astro)

When you rebuild your Hugo site in Astro, you will notice some important differences:

-   Hugo uses Go Templating for page templating. [Astro syntax](/en/basics/astro-components/) is a JSX-like superset of HTML.

-   Astro does not use shortcodes for dynamic content in standard Markdown files, but [Astro’s MDX integration](/en/guides/integrations-guide/mdx/) does allow you to use JSX and import components in MDX files.

-   While Hugo can use “partials” for reusable layout elements, [Astro is entirely component-based](/en/basics/astro-components/). Any `.astro` file can be a component, a layout or an entire page, and can import and render any other Astro components. Astro components can also include [other UI framework components (e.g. React, Svelte, Vue, Solid)](/en/guides/framework-components/) as well as content or metadata from [other files in your project](/en/guides/imports/), such as Markdown or MDX.



## Switch from Hugo to Astro


[Section titled Switch from Hugo to Astro](#switch-from-hugo-to-astro)

To convert a Hugo blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3351)
-   [pnpm](#tab-panel-3352)
-   [Yarn](#tab-panel-3353)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

Bring your existing Markdown (or MDX, with our optional integration) files as content to [create Markdown or MDX pages](/en/guides/markdown-content/). Astro allows YAML or TOML frontmatter in these files, so if you are using JSON frontmatter, you will need to convert it.

To continue to use dynamic content such as variables, expressions or UI components within your Markdown content, add Astro’s optional MDX integration and convert your existing Markdown files to [MDX pages](/en/guides/markdown-content/). MDX supports YAML and TOML frontmatter, so you can keep your existing frontmatter properties. But, you must replace any shortcode syntax with [MDX’s own syntax](https://mdxjs.com/docs/what-is-mdx/#mdx-syntax), which allows JSX expressions and/or component imports.

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[Elio Struyf's migration story from Hugo to Astro](https://www.eliostruyf.com/migration-story-hugo-astro/)

[Hugo Vs Astro - Which Static Site Generator To Choose In 2023](https://onebite.dev/hugo-vs-astro-which-static-site-generator-to-choose-in-2023/)

[Lessons from an AI-assisted migration to Astro](https://bennet.org/blog/lessons-from-ai-assisted-migration-to-astro/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Hugo site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-hugo.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 124. `en/guides/migrate-to-astro/from-jekyll/.md`

```text
# Migrating from Jekyll


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-jekyll/
description: Tips for migrating an existing Jekyll project to Astro
---


# Migrating from Jekyll


[Jekyll](https://jekyllrb.com) is a static site generator built on Ruby.


## Key Similarities between Jekyll and Astro


[Section titled Key Similarities between Jekyll and Astro](#key-similarities-between-jekyll-and-astro)

Jekyll and Astro share some similarities that will help you migrate your project:

-   Both Jekyll and Astro are static-site generators, commonly used to create blogs.

-   Both Jekyll and Astro allow you to write your content in Markdown and HTML. Jekyll and Astro both provide some special frontmatter YAML properties for page layout and unpublished draft posts. You can continue to use your existing Markdown files in Astro.

-   Both Jekyll and Astro use [file-based routing](/en/guides/routing/) for creating pages from your blog posts. Astro provides a [special `src/pages/` directory for all pages and posts](/en/basics/project-structure/#srcpages). Jekyll uses a similar special folder called `_posts/` for your Markdown blog posts, however your site pages can exist elsewhere. Creating new blog posts should feel familiar.



## Key Differences between Jekyll and Astro


[Section titled Key Differences between Jekyll and Astro](#key-differences-between-jekyll-and-astro)

When you rebuild your Jekyll site in Astro, you will notice some important differences:

-   As Jekyll is primarily a blogging platform, several blog features are built-in that you may have to build yourself in Astro. Or, choose a [blog starter template theme](https://astro.build/themes?search=&categories%5B%5D=blog) that includes these features. For example, Jekyll has built-in support for tags and categories which you will find in several Astro blog themes, but is not included in a minimal Astro project.

-   Jekyll uses Liquid templates for reusable layout elements and templating. Astro uses JSX-like [`.astro` files for templating and components](/en/basics/astro-components/). Any `.astro` file can be a component, a layout or an entire page, and can import and render any other Astro components. You can also build using [other UI framework components (e.g. React, Svelte, Vue, Solid)](/en/guides/framework-components/) as well as content or metadata from [other files in your project](/en/guides/imports/), such as Markdown or MDX.



## Switch from Jekyll to Astro


[Section titled Switch from Jekyll to Astro](#switch-from-jekyll-to-astro)

To convert a Jekyll blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3354)
-   [pnpm](#tab-panel-3355)
-   [Yarn](#tab-panel-3356)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

Bring your existing Markdown files as content to [create Markdown pages](/en/guides/markdown-content/), using an [Astro Markdown layout](/en/basics/layouts/#markdown-layouts) instead of a Liquid template.

Much of your existing HTML page content can be converted into [Astro pages](/en/basics/astro-pages/), and you will additionally be able to [use variables, JSX-like expressions and component imports directly in your HTML templating](/en/reference/astro-syntax/#jsx-like-expressions).

Astro does not have a `permalink` property that accepts placeholders. You may need to read more about [Astro’s page routing](/en/guides/routing/) if you want to keep your existing URL structure. Or, consider [setting redirects at a host like Netlify](https://docs.netlify.com/routing/redirects/).

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[From Jekyll to Astro](https://jackcarey.co.uk/posts/astro-rewrite/)

[Goodbye Jekyll, Hello Astro](https://kiranrao.in/blog/bye-jekyll-hello-astro/)

[Back to the Future: Our Tech Blog's Transition from Jekyll to Astro](https://alasco.tech/2023/09/06/migrating-to-astro)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Jekyll site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-jekyll.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 125. `en/guides/migrate-to-astro/from-nextjs/.md`

```text
# Migrating from Next.js


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-nextjs/
description: Tips for migrating an existing Next.js project to Astro
---


# Migrating from Next.js


Here are some key concepts and migration strategies to help you get started. Use the rest of our docs and our [Discord community](https://astro.build/chat) to keep going!


## Key Similarities between Next.js and Astro


[Section titled Key Similarities between Next.js and Astro](#key-similarities-between-nextjs-and-astro)

Next.js and Astro share some similarities that will help you migrate your project:

-   The [syntax of `.astro` files is similar to JSX](/en/reference/astro-syntax/#differences-between-astro-and-jsx). Writing Astro should feel familiar.
-   Astro projects can also be SSG or [SSR with page-level prerendering](/en/guides/on-demand-rendering/).
-   Astro uses file-based routing, and [allows specially named pages to create dynamic routes](/en/guides/routing/#dynamic-routes).
-   Astro is [component-based](/en/basics/astro-components/), and your markup structure will be similar before and after your migration.
-   Astro has [official integrations for React, Preact, and Solid](/en/guides/integrations-guide/react/) so you can use your existing JSX components. Note that in Astro, these files **must** have a `.jsx` or `.tsx` extension.
-   Astro has support for [installing NPM packages](/en/guides/imports/#npm-packages), including React libraries. Many of your existing dependencies will work in Astro.


## Key Differences between Next.js and Astro


[Section titled Key Differences between Next.js and Astro](#key-differences-between-nextjs-and-astro)

When you rebuild your Next.js site in Astro, you will notice some important differences:

-   Next.js is a React single-page app, and uses `index.js` as your project’s root. Astro is a multi-page site, and `index.astro` is your home page.

-   [`.astro` components](/en/basics/astro-components/) are not written as exported functions that return page templating. Instead, you’ll split your code into a “code fence” for your JavaScript and a body exclusively for the HTML you generate.

-   [content-driven](/en/concepts/why-astro/#content-driven): Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing Next.js app might be built for high client-side interactivity and may require advanced Astro techniques to include items that are more challenging to replicate using `.astro` components, such as dashboards.



## Convert your Next.js Project


[Section titled Convert your Next.js Project](#convert-your-nextjs-project)

Each project migration will look different, but there are some common actions you will perform when converting from Next.js to Astro.


### Create a new Astro project


[Section titled Create a new Astro project](#create-a-new-astro-project)

Use the `create astro` command for your package manager to launch Astro’s CLI wizard or choose a community theme from the [Astro Theme Showcase](https://astro.build/themes).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters (e.g. `docs`, `blog`, `portfolio`). Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3364)
-   [pnpm](#tab-panel-3365)
-   [Yarn](#tab-panel-3366)

Terminal window

```

# launch the Astro CLI Wizardnpmcreateastro@latest# create a new project with an official examplenpmcreateastro@latest----template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardpnpmcreateastro@latest# create a new project with an official examplepnpmcreateastro@latest--template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardyarncreateastro@latest# create a new project with an official exampleyarncreateastro@latest--template<example-name>

```

Then, copy your existing Next project files over to your new Astro project in a separate folder outside of `src`.

Tip

Visit [https://astro.new](https://astro.new) for the full list of official starter templates, and links for opening a new project in IDX, StackBlitz, CodeSandbox, or Gitpod.


### Install integrations (optional)


[Section titled Install integrations (optional)](#install-integrations-optional)

You may find it useful to install some of [Astro’s optional integrations](/en/guides/integrations-guide/) to use while converting your Next project to Astro:

-   **@astrojs/react**: to reuse some existing React UI components in your new Astro site, or keep writing with React components.

-   **@astrojs/mdx**: to bring existing MDX files from your Next project, or to use MDX in your new Astro site.



### Put your source code in `src`


[Section titled Put your source code in src](#put-your-source-code-in-src)

Following [Astro’s project structure](/en/basics/project-structure/):

1.  **Keep** Next’s `public/` folder untouched.

    Astro uses the `public/` directory for static assets, just like Next. There is no change needed to this folder, nor its contents.

2.  **Copy or Move** Next’s other files and folders (e.g. `pages`, `styles` etc.) into Astro’s `src/` folder as you rebuild your site, following [Astro’s project structure](/en/basics/project-structure/).

    Like Next, Astro’s `src/pages/` folder is a special folder used for file-based routing. All other folders are optional, and you can organize the contents of your `src/` folder any way you like. Other common folders in Astro projects include `src/layouts/`, `src/components`, `src/styles`, `src/scripts`.



### The Astro config file


[Section titled The Astro config file](#the-astro-config-file)

Astro has a configuration file at the root of your project called [`astro.config.mjs`](/en/guides/configuring-astro/). This is used only for configuring your Astro project and any installed integrations, including [SSR adapters](/en/guides/deploy/).


### Tips: Convert JSX files to `.astro` files


[Section titled Tips: Convert JSX files to .astro files](#tips-convert-jsx-files-to-astro-files)

Here are some tips for converting a Next `.js` component into a `.astro` component:

1.  Use the returned JSX of the existing Next.js component function as the basis for your HTML template.

2.  Change any [Next or JSX syntax to Astro](#reference-convert-nextjs-syntax-to-astro) or to HTML web standards. This includes `<Link>`, `<Script>`, `{children}`, and `className`, for example.

3.  Move any necessary JavaScript, including import statements, into a [“code fence” (`---`)](/en/basics/astro-components/#the-component-script). Note: JavaScript to [conditionally render content](/en/reference/astro-syntax/#dynamic-html) is often written inside the HTML template directly in Astro.

4.  Use [`Astro.props`](/en/reference/api-reference/#props) to access any additional props that were previously passed to your Next function.

5.  Decide whether any imported components also need to be converted to Astro. With the official integration installed, you can [use existing React components in your Astro file](/en/guides/framework-components/). But, you may want to convert them to `.astro` components, especially if they do not need to be interactive!

6.  Replace `getStaticProps()` with import statements or [`import.meta.glob()`](/en/guides/imports/#importmetaglob) to query your local files. Use `fetch()` to fetch external data.


See [an example of a Next `.js` file converted step-by-step](#guided-example-next-data-fetching-to-astro).


#### Compare: JSX vs Astro


[Section titled Compare: JSX vs Astro](#compare-jsx-vs-astro)

Compare the following Next component and a corresponding Astro component:

-   [JSX](#tab-panel-3362)
-   [Astro](#tab-panel-3363)

StarCount.jsx

```
import Header from"./header";import Footer from"./footer";import"./layout.css";exportasyncfunctiongetStaticProps() {const res = await fetch("https://api.github.com/repos/withastro/astro");const json = await res.json();return {props: { message: json.message, stars: json.stargazers_count|0 },}}const Component = ({ stars, message }) => {return (<><Header /><pstyle={{backgroundColor: `#f4f4f4`,padding: `1em 1.5em`,textAlign: `center`,marginBottom: `1em`}}>Astro has {stars} 🧑‍🚀</p><Footer /></>)}exportdefaultComponent;
```

StarCount.astro

```
---import Header from"./header";import Footer from"./footer";import"./layout.css";const res = await fetch("https://api.github.com/repos/withastro/astro");const json = await res.json();const message = json.message;const stars = json.stargazers_count | 0;---<Header /><pclass="banner">Astro has {stars} 🧑‍🚀</p><Footer /><style>.banner {background-color: #f4f4f4;padding: 1em1.5em;text-align: center;margin-bottom: 1em;}<style>
```


### Migrating Layout Files


[Section titled Migrating Layout Files](#migrating-layout-files)

You may find it helpful to start by converting your Next.js layouts and templates into [Astro layout components](/en/basics/layouts/).

Next has two different methods for creating layout files, each of which handles layouts differently than Astro:

-   The `pages` directory

-   [The `/app` directory](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts)


Each Astro page explicitly requires `<html>`, `<head>`, and `<body>` tags to be present, so it is common to reuse a layout file across pages. Astro uses a [`<slot />`](/en/basics/astro-components/#slots) for page content, with no import statement required. Note the standard HTML templating, and direct access to `<head>`:

src/layouts/Layout.astro

```
------<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><metaname="generator"content={Astro.generator} /><title>Astro</title></head><body><!-- Wrap the slot element with your existing layout templating --><slot /></body></html>
```


#### Migrating from Next.js’ `pages` directory


[Section titled Migrating from Next.js’ pages directory](#migrating-from-nextjs-pages-directory)

Your Next project may have a `pages/_document.jsx` file that imports React components to customize your app’s `<head>`:

pages/\_document.jsx

```
import Document, { Html, Head, Main, NextScript } from"next/document";exportdefaultclassMyDocumentextendsDocument {render() {return (<Htmllang="en"><Head><linkrel="icon"href="/favicon.ico" /></Head><body><Main /><NextScript /></body></Html>);}}
```

1.  Make a new Astro layout file using only the returned JSX.

2.  Replace any React components with `<html>`, `<head>`, `<slot>`, and other HTML standard tags.

    src/layouts/Document.astro

    ```
    <htmllang="en"><head><linkrel="icon"href="/favicon.ico" /></head><body><slot/></body></html>
    ```



#### Migrating from Next.js’ `/app` directory


[Section titled Migrating from Next.js’ /app directory](#migrating-from-nextjs-app-directory)

Next.js’ `app/` directory layout files are created with two files: a `layout.jsx` file to customize the `<html>` and `<body>` contents, and a `head.jsx` file to customize the `<head>` element contents.

app/layout.jsx

```
exportdefaultfunctionLayout({ children }) {return (<htmllang="en"><body>{children}</body></html>);}
```

app/head.jsx

```
exportdefaultfunctionHead() {return (<><title>My Page</title></>);}
```

1.  Make a new Astro layout file using only the returned JSX.

2.  Replace both these files with a single Astro layout file that contains a page shell (`<html>`, `<head>`, and `<body>` tags) and a `<slot/>` instead of React’s `{children}` prop:

    src/layouts/Layout.astro

    ```
    <htmllang="en"><head><title>My Page</title></head><body><slot/></body></html>
    ```



### Migrating Pages and Posts


[Section titled Migrating Pages and Posts](#migrating-pages-and-posts)

In Next.js, your posts either live in `/pages` or `/app/routeName/page.jsx`.

In Astro, all your page content must live within `src/` unless you are using [content collections](/en/guides/content-collections/).


#### React pages


[Section titled React pages](#react-pages)

Your existing Next JSX (`.js`) pages will need to be [converted from JSX files to `.astro` pages](#tips-convert-jsx-files-to-astro-files). You cannot use an existing JSX page file in Astro.

These [`.astro` pages](/en/basics/astro-pages/) must be located within `src/pages/` and will have page routes generated automatically based on their file path.


#### Markdown and MDX pages


[Section titled Markdown and MDX pages](#markdown-and-mdx-pages)

Astro has built-in support for Markdown and an optional integration for MDX files. You can reuse any existing [Markdown and MDX files](/en/guides/markdown-content/), but they may require some adjustments to their frontmatter, such as adding [Astro’s special `layout` frontmatter property](/en/basics/layouts/#markdown-layouts). You will no longer need to manually create pages for each Markdown-generated route. These files can be placed within `src/pages/` to take advantage of automatic file-based routing.

Alternatively, you can use [content collections](/en/guides/content-collections/) in Astro to store and manage your content. You will retrieve the content yourself and [generate those pages dynamically](/en/guides/content-collections/#generating-routes-from-content).


### Migrating Tests


[Section titled Migrating Tests](#migrating-tests)

As Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of your Next site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.

See Astro’s [testing guide](/en/guides/testing/) for more.


## Reference: Convert Next.js Syntax to Astro


[Section titled Reference: Convert Next.js Syntax to Astro](#reference-convert-nextjs-syntax-to-astro)


### Next Links to Astro


[Section titled Next Links to Astro](#next-links-to-astro)

Convert any Next `<Link to="">`, `<NavLink>` etc. components to HTML `<a href="">` tags.

```
<Linkto="/blog">Blog</Link><ahref="/blog">Blog</a>
```

Astro does not use any special component for links, although you are welcome to build your own `<Link>` component. You can then import and use this `<Link>` just as you would any other component.

src/components/Link.astro

```
---const { to } = Astro.props;---<ahref={to}><slot /></a>
```


### Next Imports to Astro


[Section titled Next Imports to Astro](#next-imports-to-astro)

Update any [file imports](/en/guides/imports/) to reference relative file paths exactly. This can be done using [import aliases](/en/guides/typescript/#import-aliases), or by writing out a relative path in full.

Note that `.astro` and several other file types must be imported with their full file extension.

src/pages/authors/Fred.astro

```
---import Card from"../../components/Card.astro";---<Card />
```


### Next Children Props to Astro


[Section titled Next Children Props to Astro](#next-children-props-to-astro)

Convert any instances of `{children}` to an Astro `<slot />`. Astro does not need to receive `{children}` as a function prop and will automatically render child content in a `<slot />`.

src/components/MyComponent.astro

```
------export default function MyComponent(props) {return (<div>{props.children}</div>);}<div><slot /></div>
```

React components that pass multiple sets of children can be migrated to an Astro component using [named slots](/en/basics/astro-components/#named-slots).

See more about [specific `<slot />` usage in Astro](/en/basics/astro-components/#slots).


### Next Data Fetching to Astro


[Section titled Next Data Fetching to Astro](#next-data-fetching-to-astro)

Convert any instances of `getStaticProps()` to either `import.meta.glob()` or `getCollection()`/`getEntry()` in order to access data from other files in your project source. To [fetch remote data](/en/guides/data-fetching/), use `fetch()`.

These data requests are made in the frontmatter of the Astro component and use top-level await.

src/pages/index.astro

```
---import { getCollection } from'astro:content';// Get all `src/content/blog/` entriesconst allBlogPosts = await getCollection('blog');// Get all `src/pages/posts/` entriesconst allPosts = Object.values(import.meta.glob('../pages/posts/*.md', { eager: true }));const response = await fetch('https://randomuser.me/api/');const data = await response.json();const randomUser = data.results[0];---
```

See more about local files imports with [`import.meta.glob()`](/en/guides/imports/#importmetaglob), [querying using the Collections API](/en/guides/content-collections/#querying-collections) or [fetching remote data](/en/guides/data-fetching/).


### Next Styling to Astro


[Section titled Next Styling to Astro](#next-styling-to-astro)

You may need to replace any [CSS-in-JS libraries](https://github.com/withastro/astro/issues/4432) (e.g. styled-components) with other available CSS options in Astro.

If necessary, convert any inline style objects (`style={{ fontWeight: "bold" }}`) to inline HTML style attributes (`style="font-weight:bold;"`). Or, use an [Astro `<style>` tag](/en/guides/styling/#styling-in-astro) for scoped CSS styles.

src/components/Card.astro

```
<divstyle={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div><divstyle="background-color: #f4f4f4; padding: 1em;">{message}</div>
```

Tailwind is supported after installing the [Tailwind Vite plugin](/en/guides/styling/#tailwind). No changes to your existing Tailwind code are required!

See more about [Styling in Astro](/en/guides/styling/).


### Next Image Plugin to Astro


[Section titled Next Image Plugin to Astro](#next-image-plugin-to-astro)

Convert any Next `<Image />` components to [Astro’s own image component](/en/guides/images/) in `.astro` or `.mdx` files, or to a [standard HTML `<img>` / JSX `<img />`](/en/guides/images/#images-in-ui-framework-components) tag as appropriate in your React components.

Astro’s `<Image />` component works in `.astro` and `.mdx` files only. See a [full list of its component attributes](/en/reference/modules/astro-assets/#image-properties) and note that several will differ from Next’s attributes.

src/pages/index.astro

```
---import { Image } from'astro:assets';import rocket from'../assets/rocket.png';---<Imagesrc={rocket}alt="A rocketship in space." /><imgsrc={rocket.src}alt="A rocketship in space.">
```

In React (`.jsx`) components, use standard JSX image syntax (`<img />`). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.

You can learn more about [using images in Astro](/en/guides/images/) in the Images Guide.


## Guided example: Next data fetching to Astro


[Section titled Guided example: Next data fetching to Astro](#guided-example-next-data-fetching-to-astro)

Here is an example of Next.js Pokédex data fetch converted to Astro.

`pages/index.js` fetches and displays a list of the first 151 Pokémon using [the REST PokéAPI](https://pokeapi.co/).

Here’s how to recreate that in `src/pages/index.astro`, replacing `getStaticProps()` with `fetch()`.

1.  Identify the return() JSX.

    pages/index.js

    ```
    import Link from'next/link'import styles from'../styles/poke-list.module.css';exportdefaultfunctionHome({ pokemons }) {return (<><ulclassName={`plain-list ${styles.pokeList}`}>{pokemons.map((pokemon)=> (<liclassName={styles.pokemonListItem}key={pokemon.name}><LinkclassName={styles.pokemonContainer}as={`/pokemon/${pokemon.name}`}href="/pokemon/[name]"><pclassName={styles.pokemonId}>No. {pokemon.id}</p><imgclassName={styles.pokemonImage}src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`}alt={`${pokemon.name} picture`}></img><h2className={styles.pokemonName}>{pokemon.name}</h2></Link></li>))}</ul></>)}export const getStaticProps = async () => {const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151")const resJson = await res.json();const pokemons = resJson.results.map(pokemon => {const name = pokemon.name;// https://pokeapi.co/api/v2/pokemon/1/const url = pokemon.url;const id = url.split("/")[url.split("/").length-2];return {name,url,id}});return {props: {pokemons,},}}
    ```

2.  Create `src/pages/index.astro`

    Use the return value of the Next function. Convert any Next or React syntax to Astro, including changing the case of any [HTML global attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes).

    Note that:

    -   `.map` just works!

    -   `className` becomes `class`.

    -   `<Link>` becomes `<a>`.

    -   The `<> </>` fragment is not required in Astro templating.

    -   `key` is a React attribute, and is not an attribute of `li` in Astro.


    src/pages/index.astro

    ```
    ------<ulclass="plain-list pokeList">{pokemons.map((pokemon)=> (<liclass="pokemonListItem"><aclass="pokemonContainer"href={`/pokemon/${pokemon.name}`}><pclass="pokemonId">No. {pokemon.id}</p><imgclass="pokemonImage"src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`}alt={`${pokemon.name} picture`}/><h2class="pokemonName">{pokemon.name}</h2></a></li>))}</ul>
    ```

3.  Add any needed imports, props, and JavaScript

    Note that:

    -   the `getStaticProps` function is no longer needed. Data from the API is fetched directly in the code fence.
    -   A `<Layout>` component is imported and wraps the page templating.

    src/pages/index.astro

    ```
    ---import Layout from'../layouts/layout.astro';const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151");const resJson = await res.json();const pokemons = resJson.results.map(pokemon => {const name = pokemon.name;// https://pokeapi.co/api/v2/pokemon/1/const url = pokemon.url;const id = url.split("/")[url.split("/").length-2];return {name,url,id}});---<Layout><ulclass="plain-list pokeList">{pokemons.map((pokemon)=> (<liclass="pokemonListItem"key={pokemon.name}><aclass="pokemonContainer"href={`/pokemon/${pokemon.name}`}><pclass="pokemonId">No. {pokemon.id}</p><imgclass="pokemonImage"src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`}alt={`${pokemon.name} picture`}/><h2class="pokemonName">{pokemon.name}</h2></a></li>))}</ul></Layout>
    ```



## Community Resources


[Section titled Community Resources](#community-resources)

[Why we switched to Astro (and why it might interest you)](https://www.datocms.com/blog/why-we-switched-to-astro)

[Migrating from Next.js to Astro](https://johnzanussi.com/posts/nextjs-to-astro-migration)

[From NextJS to Astro](https://vanntile.com/blog/next-to-astro)

[Converting Next.js to Astro](https://ericclemmons.com/blog/converting-nextjs-to-astro)

[Migrating to Astro (from Next.js)](https://www.raygesualdo.com/posts/migrating-to-astro-the-beginning/)

[Astro.js as an alternative to Next.js](https://www.railyard.works/blog/astro-as-alternative-to-next)

[Why I Switched My Website from Next.js to Astro](https://praveenjuge.com/blog/why-i-switched-my-website-from-nextjs-to-astro/)

[NextJS to Astro: more control = faster sites](https://www.youtube.com/watch?v=PSzCtdM20Fc)

[How Astro made my site 100x faster](https://www.youtube.com/watch?v=cOxA3kMYtkM)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Next.js site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-nextjs.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 126. `en/guides/migrate-to-astro/from-nuxtjs/.md`

```text
# Migrating from NuxtJS


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-nuxtjs/
description: Tips for migrating an existing NuxtJS project to Astro
---


# Migrating from NuxtJS


Here are some key concepts and migration strategies to help you get started. Use the rest of our docs and our [Discord community](https://astro.build/chat) to keep going!

> This guide is referring to [Nuxt 2](https://nuxtjs.org/), not the newer Nuxt 3. While some of the concepts are similar, Nuxt 3 is a newer version of the framework and may require different strategies for parts of your migration.


## Key Similarities between Nuxt and Astro


[Section titled Key Similarities between Nuxt and Astro](#key-similarities-between-nuxt-and-astro)

Nuxt and Astro share some similarities that will help you migrate your project:

-   Astro projects can also be SSG or [SSR with page level prerendering](/en/guides/on-demand-rendering/).
-   Astro uses file-based routing, and [allows specially named pages to create dynamic routes](/en/guides/routing/#dynamic-routes).
-   Astro is [component-based](/en/basics/astro-components/), and your markup structure will be similar before and after your migration.
-   Astro has [an official integration for using Vue components](/en/guides/integrations-guide/vue/).
-   Astro has support for [installing NPM packages](/en/guides/imports/#npm-packages), including Vue libraries. You may be able to keep some or all of your existing Vue components and dependencies.


## Key Differences between Nuxt and Astro


[Section titled Key Differences between Nuxt and Astro](#key-differences-between-nuxt-and-astro)

When you rebuild your Nuxt site in Astro, you will notice some important differences:

-   Nuxt is a Vue-based SPA (single-page application). Astro sites are multi-page apps built using `.astro` components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, and raw HTML templating.

-   [Page Routing](/en/basics/astro-pages/#file-based-routing): Nuxt uses `vue-router` for SPA routing, and `vue-meta` for managing `<head>`. In Astro, you will create separate HTML page routes and control your page `<head>` directly, or in a layout component.

-   [content-driven](/en/concepts/why-astro/#content-driven): Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing Nuxt app may be built for high client-side interactivity. Astro has built-in capabilities for working with your content, such as page generation, but may require advanced Astro techniques to include items that are more challenging to replicate using `.astro` components, such as dashboards.



## Convert your NuxtJS Project


[Section titled Convert your NuxtJS Project](#convert-your-nuxtjs-project)

Each project migration will look different, but there are some common actions you will perform when converting from Nuxt to Astro.


### Create a new Astro project


[Section titled Create a new Astro project](#create-a-new-astro-project)

Use the `create astro` command for your package manager to launch Astro’s CLI wizard or choose a community theme from the [Astro Theme Showcase](https://astro.build/themes).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters (e.g. `docs`, `blog`, `portfolio`). Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3359)
-   [pnpm](#tab-panel-3360)
-   [Yarn](#tab-panel-3361)

Terminal window

```

# launch the Astro CLI Wizardnpmcreateastro@latest# create a new project with an official examplenpmcreateastro@latest----template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardpnpmcreateastro@latest# create a new project with an official examplepnpmcreateastro@latest--template<example-name>

```

Terminal window

```

# launch the Astro CLI Wizardyarncreateastro@latest# create a new project with an official exampleyarncreateastro@latest--template<example-name>

```

Then, copy your existing Nuxt project files over to your new Astro project in a separate folder outside of `src`.

Tip

Visit [https://astro.new](https://astro.new) for the full list of official starter templates, and links for opening a new project in IDX, StackBlitz, CodeSandbox, or Gitpod.


### Install integrations (optional)


[Section titled Install integrations (optional)](#install-integrations-optional)

You may find it useful to install some of [Astro’s optional integrations](/en/guides/integrations-guide/) to use while converting your Nuxt project to Astro:

-   **@astrojs/vue**: to reuse some existing Vue UI components in your new Astro site, or keep writing with Vue components.

-   **@astrojs/mdx**: to bring existing MDX files from your Nuxt project, or to use MDX in your new Astro site.



### Put your source code in `src`


[Section titled Put your source code in src](#put-your-source-code-in-src)

1.  **Move** the contents of Nuxt’s `static/` folder into `public/`.

    Astro uses the `public/` directory for static assets, similar to Nuxt’s `static/` folder.

2.  **Copy or Move** Nuxt’s other files and folders (e.g. `pages`, `layouts` etc.) into Astro’s `src/` folder.

    Like Nuxt, Astro’s `src/pages/` folder is a special folder used for file-based routing. All other folders are optional, and you can organize the contents of your `src/` folder any way you like. Other common folders in Astro projects include `src/layouts/`, `src/components`, `src/styles`, `src/scripts`.



### Convert Vue SFC pages to `.astro` files


[Section titled Convert Vue SFC pages to .astro files](#convert-vue-sfc-pages-to-astro-files)

Here are some tips for converting a Nuxt `.vue` component into a `.astro` component:

1.  Use the `<template>` of the existing NuxtJS component function as the basis for your HTML template.

2.  Change any [Nuxt or Vue syntax to Astro](#reference-convert-nuxtjs-syntax-to-astro) or to HTML web standards. This includes `<NuxtLink>`, `:class`, `{{variable}}`, and `v-if`, for example.

3.  Move `<script>` JavaScript, into a “code fence” (`---`). Convert your component’s data-fetching properties to server-side JavaScript - see [Nuxt data fetching to Astro](#nuxt-data-fetching-to-astro).

4.  Use `Astro.props` to access any additional props that were previously passed to your Vue component.

5.  Decide whether any imported components also need to be converted to Astro. With the official integration installed, you can [use existing Vue components in your Astro file](/en/guides/integrations-guide/vue/). But, you may want to convert them to Astro, especially if they do not need to be interactive!


See [an example from a Nuxt app converted step-by-step](#guided-example-see-the-steps).


#### Compare: Vue vs Astro


[Section titled Compare: Vue vs Astro](#compare-vue-vs-astro)

Compare the following Nuxt component and a corresponding Astro component:

-   [Vue](#tab-panel-3357)
-   [Astro](#tab-panel-3358)

Page.vue

```
<template><div><pv-if="message==='Not found'">The repository you're looking up doesn't exist</p><divv-else><Header/><pclass="banner">Astro has {{stars}} 🧑‍🚀</p><Footer/></div></div></template><script>import Vue from'vue'exportdefaultVue.extend({name: 'IndexPage',asyncasyncData() {constres = await fetch('https://api.github.com/repos/withastro/astro')constjson = await res.json();return {message: json.message,stars: json.stargazers_count|0,};}});</script><stylescoped>.banner {background-color: #f4f4f4;padding: 1em1.5em;text-align: center;margin-bottom: 1em;}<style>
```

Page.astro

```
---import Header from"./header";import Footer from'./footer';import"./layout.css";const res = await fetch('https://api.github.com/repos/withastro/astro')const json = await res.json()const message = json.message;const stars = json.stargazers_count | 0;---{message ==="Not Found"?<p>The repository you're looking up doesn't exist</p>:<><Header /><pclass="banner">Astro has {stars} 🧑‍🚀</p><Footer /></>}<style>.banner {background-color: #f4f4f4;padding: 1em1.5em;text-align: center;margin-bottom: 1em;}<style>
```


### Migrating Layout Files


[Section titled Migrating Layout Files](#migrating-layout-files)

You may find it helpful to start by converting your Nuxt layouts and templates into [Astro layout components](/en/basics/layouts/).

Each Astro page explicitly requires `<html>`, `<head>`, and `<body>` tags to be present. Your Nuxt `layout.vue` and templates will not include these.

Note the standard HTML templating, and direct access to `<head>`:

src/layouts/Layout.astro

```
<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><!-- Wrap the slot element with your existing layout templating --><slot /></body></html>
```

You may also wish to reuse code from [your Nuxt’s page’s `head` property](https://nuxtjs.org/docs/configuration-glossary/configuration-head/#the-head-property) to include additional site metadata. Notice that Astro uses neither `vue-meta` nor a component’s `head` property but instead creates `<head>` directly. You may import and use components, even within `<head>`, to separate and organize your page content.


### Migrating Pages and Posts


[Section titled Migrating Pages and Posts](#migrating-pages-and-posts)

In NuxtJS, your [pages](/en/basics/astro-pages/) live in `/pages`. In Astro, all your page content must live within `src/` unless you are using [content collections](/en/guides/content-collections/).


#### Vue Pages


[Section titled Vue Pages](#vue-pages)

Your existing Nuxt Vue (`.vue`) pages will need to be [converted from Vue files to `.astro` pages](#convert-vue-sfc-pages-to-astro-files). You cannot use an existing Vue page file in Astro.

These [`.astro` pages](/en/basics/astro-pages/) must be located within `src/pages/` and will have page routes generated automatically based on their file path.


##### Dynamic File Path Naming


[Section titled Dynamic File Path Naming](#dynamic-file-path-naming)

In Nuxt, your dynamic pages use an underscore to represent a dynamic page property that’s then passed to the page generation:

-   Directorypages/

    -   Directorypokemon/

        -   \_name.vue

    -   index.vue

-   nuxt.config.js

To convert to Astro, change this underscored dynamic path property (e.g. `_name.vue`) to be wrapped in a pair of square brackets (e.g. `[name].astro`):

-   Directorysrc/

    -   Directorypages/

        -   Directorypokemon/

            -   \[name\].astro

        -   index.astro


-   astro.config.mjs


#### Markdown and MDX pages


[Section titled Markdown and MDX pages](#markdown-and-mdx-pages)

Astro has built-in support for Markdown and an optional integration for MDX files. You can reuse any existing Markdown and MDX pages, but they may require some adjustments to their frontmatter, such as adding [Astro’s special `layout` frontmatter property](/en/basics/layouts/#markdown-layouts).

You will no longer need to manually create pages for each Markdown-generated route or use an external package like `@nuxt/content`. These files can be placed within `src/pages/` to take advantage of automatic file-based routing.

When part of a [content collection](/en/guides/content-collections/), you will [generate pages dynamically](/en/guides/content-collections/#generating-routes-from-content) from your content entries.


### Migrating Tests


[Section titled Migrating Tests](#migrating-tests)

As Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box, if you have been able to match the markup of your Nuxt site. Testing libraries such as Jest and Vue Testing Library can be imported and used in Astro to test your Vue components.

See Astro’s [testing guide](/en/guides/testing/) for more.


## Reference: Convert NuxtJS Syntax to Astro


[Section titled Reference: Convert NuxtJS Syntax to Astro](#reference-convert-nuxtjs-syntax-to-astro)


### Nuxt Local Variables to Astro


[Section titled Nuxt Local Variables to Astro](#nuxt-local-variables-to-astro)

To use local variables in an Astro component’s HTML, change the set of two curly braces to one set of curly braces:

src/components/Component.astro

```
---const message = "Hello!"---<p>{{message}}</p><p>{message}</p>
```


### Nuxt Property Passing to Astro


[Section titled Nuxt Property Passing to Astro](#nuxt-property-passing-to-astro)

To bind an attribute or component property in an Astro component, change this syntax to the following:

src/components/Component.astro

```
------<pv-bind:aria-label="message">...</p><!-- Or --><p :aria-label="message">...</p><!-- Also support component props --><Headertitle="Page"/><paria-label={message}>...</p><!-- Also support component props --><Headertitle={"Page"}/>
```


### Nuxt Links to Astro


[Section titled Nuxt Links to Astro](#nuxt-links-to-astro)

Convert any Nuxt `<NuxtLink to="">` components to HTML `<a href="">` tags.

```
<NuxtLinkto="/blog">Blog</Link><ahref="/blog">Blog</a>
```

Astro does not use any special component for links, although you are welcome to build custom link components. You can then import and use this `<Link>` just as you would any other component.

src/components/Link.astro

```
---const { to } = Astro.props---<ahref={to}><slot /></a>
```


### Nuxt Imports to Astro


[Section titled Nuxt Imports to Astro](#nuxt-imports-to-astro)

If necessary, update any [file imports](/en/guides/imports/) to reference relative file paths exactly. This can be done using [import aliases](/en/guides/typescript/#import-aliases), or by writing out a relative path in full.

Note that `.astro` and several other file types must be imported with their full file extension.

src/pages/authors/Fred.astro

```
---import Card from`../../components/Card.astro`;---<Card />
```


### Nuxt Dynamic Page Generation to Astro


[Section titled Nuxt Dynamic Page Generation to Astro](#nuxt-dynamic-page-generation-to-astro)

In Nuxt, to generate a dynamic page you either must:

-   Use SSR.
-   [Use the `generate` function in `nuxt.config.js`](https://nuxtjs.org/docs/configuration-glossary/configuration-generate/) to define all possible static routes.

In Astro, you similarly have two choices:

-   [Use SSR](/en/guides/on-demand-rendering/).
-   Export a `getStaticPaths()` function in the frontmatter of an Astro page to tell the framework which [static routes to generate dynamically](/en/guides/routing/#dynamic-routes).


#### Convert a `generate` function in Nuxt to a `getStaticPaths` function in Astro.


[Section titled Convert a generate function in Nuxt to a getStaticPaths function in Astro.](#convert-a-generate-function-in-nuxt-to-a-getstaticpaths-function-in-astro)

To generate multiple pages, replace the function to create routes in your `nuxt.config.js` with `getStaticPaths()` directly inside a dynamic routing page itself:

nuxt.config.js

```
{// ...generate: {asyncroutes() {// Axios is required here unless you're using Node 18const res = await axios.get("https://pokeapi.co/api/v2/pokemon?limit=151")const pokemons = res.data.results;returnpokemons.map(pokemon=> {return'/pokemon/'+pokemon.name})}}}
```

src/pages/pokemon/\[name\].astro

```
---export const getStaticPaths = async () => {const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151")const resJson = await res.json();const pokemons = resJson.results;return pokemons.map(({ name }) => ({params: { name },}))}// ...---<!-- Your template here -->
```


### Nuxt Data Fetching to Astro


[Section titled Nuxt Data Fetching to Astro](#nuxt-data-fetching-to-astro)

Nuxt has two methods of fetching server-side data:

-   [`asyncData` options API](https://nuxtjs.org/docs/features/data-fetching/#async-data)
-   [`fetch` hook](https://nuxtjs.org/docs/features/data-fetching/#the-fetch-hook)

In Astro, fetch data inside of your page’s code fence.

Migrate the following:

pages/index.vue

```
{// ...async asyncData() {const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151")const resJson = await res.json();const pokemons = resJson.results;return {pokemons,}},}
```

To a code fence without a wrapper function:

src/pages/index.astro

```
---const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151")const resJson = await res.json();const pokemons = resJson.results;---<!-- Your template here -->
```


### Nuxt Styling to Astro


[Section titled Nuxt Styling to Astro](#nuxt-styling-to-astro)

Nuxt utilizes Vue’s component styling to generate a page’s style.

pages/index.vue

```
<template><!-- Your template here --></template><script>// Your server logic here</script><stylescoped>.class {color: red;}</style>
```

Similarly, in Astro you can drop in a `<style>` element in your page’s template to provide scoped styles to the component.

src/pages/index.vue

```
---// Your server logic here---<style>.class {color: red;}</style>
```


#### Global Styling


[Section titled Global Styling](#global-styling)

`<style>` tags are `scoped` by default in Astro. To make a `<style>` tag global, mark it with the `is:global` attribute:

src/pages/index.vue

```
<styleis:global>p {color: red;}</style>
```


#### Pre-processor support


[Section titled Pre-processor support](#pre-processor-support)

[Astro supports the most popular CSS preprocessors](/en/guides/styling/#css-preprocessors) by installing them as a dev dependency. For example, to use SCSS:

Terminal window

```
npminstall-Dsass
```

After doing so, you’re then able to use `.scss` or `.sass` styled without modification from your Vue components.

src/layouts/Layout.astro

```
<p>Hello, world</p><stylelang="scss">p {color: black;&:hover {color: red;}}</style>
```

See more about [Styling in Astro](/en/guides/styling/).


### Nuxt Image Plugin to Astro


[Section titled Nuxt Image Plugin to Astro](#nuxt-image-plugin-to-astro)

Convert any [Nuxt `<nuxt-img/>` or `<nuxt-picture/>` components](https://image.nuxtjs.org/components/nuxt-img) to [Astro’s own image component](/en/guides/images/) in `.astro` or `.mdx` files, or to a [standard HTML `<img>`](/en/guides/images/#images-in-ui-framework-components) or `<picture>` tag as appropriate in your Vue components.

Astro’s `<Image />` component works in `.astro` and `.mdx` files only. See a [full list of its component attributes](/en/reference/modules/astro-assets/#image-properties) and note that several will differ from Nuxt’s attributes.

src/pages/index.astro

```
---import { Image } from'astro:assets';import rocket from'../assets/rocket.png';---<Imagesrc={rocket}alt="A rocketship in space." /><imgsrc={rocket.src}alt="A rocketship in space.">
```

In Vue (`.vue`) components within your Astro app, use standard JSX image syntax (`<img />`). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.

You can learn more about [using images in Astro](/en/guides/images/) in the Images Guide.


## Guided example: See the steps!


[Section titled Guided example: See the steps!](#guided-example-see-the-steps)

Here is an example of Nuxt Pokédex data fetch converted to Astro.

`pages/index.vue` fetches and displays a list of the first 151 Pokémon using [the REST PokéAPI](https://pokeapi.co/).

Here’s how to recreate that in `src/pages/index.astro`, replacing `asyncData()` with `fetch()`.

1.  Identify the `<template>` and `<style>` in the Vue SFC.

    pages/index.vue

    ```
    <template><ulclass="plain-list pokeList"><liv-for="pokemon of pokemons"class="pokemonListItem":key="pokemon.name"><NuxtLinkclass="pokemonContainer":to="`/pokemon/${pokemon.name}`"><pclass="pokemonId">No. {{pokemon.id}}</p><imgclass="pokemonImage":src="`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`":alt="`${pokemon.name}picture`"/><h2class="pokemonName">{{pokemon.name}}</h2></NuxtLink></li></ul></template><script>import Vue from 'vue'export default Vue.extend({name: 'IndexPage',layout: 'default',asyncasyncData() {const res=awaitfetch("https://pokeapi.co/api/v2/pokemon?limit=151")const resJson=awaitres.json();const pokemons=resJson.results.map(pokemon=> {const name = pokemon.name;// https://pokeapi.co/api/v2/pokemon/1/const url = pokemon.url;const id = url.split("/")[url.split("/").length-2];return {name,url,id}});return {pokemons,}},head() {return {title: "Pokedex: Generation 1"}}});</script><stylescoped>.pokeList {display: grid;grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );gap: 1rem;}/* ... */</style>
    ```

2.  Create `src/pages/index.astro`

    Use the `<template>` and `<style>` tags of the Nuxt SFC. Convert any Nuxt or Vue syntax to Astro.

    Note that:

    -   `<template>` is removed

    -   `<style>` has its `scoped` attribute removed

    -   `v-for` becomes `.map`.

    -   `:attr="val"` becomes `attr={val}`

    -   `<NuxtLink>` becomes `<a>`.

    -   The `<> </>` fragment is not required in Astro templating.


    src/pages/index.astro

    ```
    ------<ulclass="plain-list pokeList">{pokemons.map((pokemon)=> (<liclass="pokemonListItem"key={pokemon.name}><aclass="pokemonContainer"href={`/pokemon/${pokemon.name}`}><pclass="pokemonId">No.{pokemon.id}</p><imgclass="pokemonImage"src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`}alt={`${pokemon.name} picture`}/><h2class="pokemonName">{pokemon.name}</h2></a></li>))}</ul><style>.pokeList {display: grid;grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );gap: 1rem;}/* ... */</style>
    ```

3.  Add any needed imports, props and JavaScript

    Note that:

    -   The `asyncData` function is no longer needed. Data from the API is fetched directly in the code fence.
    -   A `<Layout>` component is imported, and wraps the page templating.
        -   Our `head()` Nuxt method is passed to the `<Layout>` component, which is passed to the `<title>` element as a property.

    src/pages/index.astro

    ```
    ---import Layout from'../layouts/layout.astro';const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151");const resJson = await res.json();const pokemons = resJson.results.map(pokemon => {const name = pokemon.name;// https://pokeapi.co/api/v2/pokemon/1/const url = pokemon.url;const id = url.split("/")[url.split("/").length-2];return {name,url,id}});---<Layouttitle="Pokedex: Generation 1"><ulclass="plain-list pokeList">{pokemons.map((pokemon)=> (<liclass="pokemonListItem"key={pokemon.name}><aclass="pokemonContainer"href={`/pokemon/${pokemon.name}`}><pclass="pokemonId">No. {pokemon.id}</p><imgclass="pokemonImage"src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`}alt={`${pokemon.name} picture`}/><h2class="pokemonName">{pokemon.name}</h2></a></li>))}</ul></Layout><style>.pokeList {display: grid;grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );gap: 1rem;}/* ... */</style>
    ```



## Community Resources


[Section titled Community Resources](#community-resources)

[From Nuxt to Astro - rebuilding with Astro](https://dev.to/lindsaykwardell/from-nuxt-to-astro-rebuilding-with-astro-5ann)

[Nuxt 2 to Astro 3 Replatforming – from Setup to Production](https://stevenwoodson.com/blog/replatforming-from-nuxtjs-2-to-astro/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Nuxt site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-nuxtjs.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 127. `en/guides/migrate-to-astro/from-pelican/.md`

```text
# Migrating from Pelican


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-pelican/
description: Tips for migrating an existing Pelican project to Astro
---


# Migrating from Pelican


[Pelican](https://getpelican.com) is an open-source static site generator built on Python.


## Key Similarities between Pelican and Astro


[Section titled Key Similarities between Pelican and Astro](#key-similarities-between-pelican-and-astro)

Pelican and Astro share some similarities that will help you migrate your project:

-   Pelican and Astro are both static-site generators, ideally suited to [content-driven websites](/en/concepts/why-astro/#content-driven) like blogs.

-   Pelican and Astro both have built-in support for [writing in Markdown](/en/guides/markdown-content/), including frontmatter YAML properties for page metadata. However, Astro has very few reserved frontmatter properties compared to Pelican. Even though many of your existing Pelican frontmatter properties will not be “special” in Astro, you can continue to use your existing Markdown files and frontmatter values.



## Key Differences between Pelican and Astro


[Section titled Key Differences between Pelican and Astro](#key-differences-between-pelican-and-astro)

When you rebuild your Pelican site in Astro, you will notice some important differences:

-   Pelican supports writing content in Markdown and reStructured Text (`.rst`). Astro supports [creating pages from Markdown and MDX](/en/guides/markdown-content/) files, but does not support reStructured Text.

-   Pelican uses HTML files and Jinja syntax for templating. [Astro syntax](/en/basics/astro-components/) is a JSX-like superset of HTML. All valid HTML is valid `.astro` syntax.

-   Pelican was designed to build content-rich websites like blogs and has some built-in, blog features that you would have to build yourself in Astro. Instead, Astro offers some of these features included in an [official blog theme](https://github.com/withastro/astro/tree/latest/examples/blog).



## Switch from Pelican to Astro


[Section titled Switch from Pelican to Astro](#switch-from-pelican-to-astro)

To convert a Pelican documentation site to Astro, start with our official [Starlight docs theme starter template](https://starlight.astro.build), or explore more community themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3367)
-   [pnpm](#tab-panel-3368)
-   [Yarn](#tab-panel-3369)

Terminal window

```
npmcreateastro@latest----templatestarlight
```

Terminal window

```
pnpmcreateastro@latest--templatestarlight
```

Terminal window

```
yarncreateastro--templatestarlight
```

Bring your existing Markdown content files to [create Markdown pages](/en/guides/markdown-content/). You can still take advantage of [file-based routing](/en/guides/routing/) by copying these documents from Pelican’s `content/` folder into `src/pages/` in Astro. You may wish to read about [Astro’s project structure](/en/basics/project-structure/) to learn where files should be located.

Pelican may have handled much of your site layout and metadata for you. You may wish to read about [building Astro Layouts as Markdown page wrappers](/en/basics/layouts/#markdown-layouts) to see how to manage templating yourself in Astro, including your page `<head>`.

Like Pelican, Astro has many plugins that extend its functionality. Explore the [official list of integrations](/en/guides/integrations-guide/) for adding features such as MDX support, and find hundreds more of community-maintained integrations in the [Astro Integrations Directory](https://astro.build/integrations/). You can even use the [Astro Integration API](/en/reference/integrations-reference/) to build your own custom integration to extend your project’s features.

To convert other types of sites, such as a portfolio or a blog, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a Pelican site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-pelican.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 128. `en/guides/migrate-to-astro/from-sveltekit/.md`

```text
# Migrating from SvelteKit


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-sveltekit/
description: Tips for migrating an existing SvelteKit project to Astro
---


# Migrating from SvelteKit


[SvelteKit](https://kit.svelte.dev) is a framework for building web applications on top of Svelte.


## Key Similarities between SvelteKit and Astro


[Section titled Key Similarities between SvelteKit and Astro](#key-similarities-between-sveltekit-and-astro)

SvelteKit and Astro share some similarities that will help you migrate your project:

-   Both SvelteKit and Astro are modern JavaScript static-site generators and server-side rendering frameworks.

-   Both SvelteKit and Astro use a [`src/` folder for your project files](/en/basics/project-structure/#src) and a [special folder for file-based routing](/en/basics/astro-pages/). Creating and managing pages for your site should feel familiar.

-   Astro has [an official integration for using Svelte components](/en/guides/integrations-guide/svelte/) and supports [installing NPM packages](/en/guides/imports/#npm-packages), including several for Svelte. You will be able to write Svelte UI components, and may be able to keep some or all of your existing components and dependencies.

-   Astro and SvelteKit both allow you to use a [headless CMS, APIs or Markdown files for data](/en/guides/data-fetching/). You can continue to use your preferred content authoring system, and will be able to keep your existing content.



## Key Differences between SvelteKit and Astro


[Section titled Key Differences between SvelteKit and Astro](#key-differences-between-sveltekit-and-astro)

When you rebuild your SvelteKit site in Astro, you will notice some important differences:

-   Astro sites are multi-page apps, whereas SvelteKit defaults to SPAs (single-page applications) with server-side rendering, but can also create MPAs, traditional SPAs, or you can mix and match these techniques within an app.

-   [Components](/en/basics/astro-components/): SvelteKit uses [Svelte](https://svelte.dev). Astro pages are built using [`.astro` components](/en/basics/astro-components/), but can also support [React, Preact, Vue.js, Svelte, SolidJS, AlpineJS](/en/guides/framework-components/) and raw HTML templating.

-   [content-driven](/en/concepts/why-astro/#content-driven): Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing SvelteKit app might be built for high client-side interactivity. Astro has built-in capabilities for working with your content, such as page generation, but may require advanced Astro techniques to include items that are more challenging to replicate using `.astro` components, such as dashboards.

-   [Markdown-ready](/en/guides/markdown-content/): Astro includes built-in Markdown support, and includes a [special frontmatter YAML `layout` property](/en/basics/layouts/#markdown-layouts) used per-file for page templating. If you are converting a SvelteKit Markdown-based blog, you will not have to install a separate Markdown integration and you will not set a layout via a configuration file. You can bring your existing Markdown files, but you may need to reorganize as Astro’s file-based routing does not require a folder for each page route.



## Switch from SvelteKit to Astro


[Section titled Switch from SvelteKit to Astro](#switch-from-sveltekit-to-astro)

To convert a SvelteKit blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes/).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3370)
-   [pnpm](#tab-panel-3371)
-   [Yarn](#tab-panel-3372)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

Bring your existing Markdown (or MDX, with our optional integration) files as content to [create Markdown or MDX pages](/en/guides/markdown-content/).

While file-based routing and layout components are similar in Astro, you may wish to read about [Astro’s project structure](/en/basics/project-structure/) to learn where files should be located.

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[Rewriting my blog from SvelteKit to Astro](https://kharann.com/blog/rewriting-my-blog/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a SvelteKit site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-sveltekit.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 129. `en/guides/migrate-to-astro/from-vuepress/.md`

```text
# Migrating from VuePress


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-vuepress/
description: Tips for migrating an existing VuePress project to Astro
---


# Migrating from VuePress


[VuePress](https://vuePress.vuejs.org) is an open-source static site generator built on Vue.


## Key Similarities between VuePress and Astro


[Section titled Key Similarities between VuePress and Astro](#key-similarities-between-vuepress-and-astro)

VuePress and Astro share some similarities that will help you migrate your project:

-   Both VuePress and Astro are modern JavaScript static-site generators with similar project file structures. Both use a [special `src/pages/` folder for file-based routing](/en/basics/astro-pages/). Creating and managing pages for your site should feel familiar.

-   Astro and VuePress are both designed for [content-driven websites](/en/concepts/why-astro/#content-driven), with excellent built-in support for Markdown files. Writing in Markdown will feel familiar, and you will be able to keep your existing content.

-   Astro has [an official integration for using Vue components](/en/guides/integrations-guide/vue/) and supports [installing NPM packages](/en/guides/imports/#npm-packages), including several for Vue. You will be able to write Vue UI components, and may be able to keep some or all of your existing Vue components and dependencies.



## Key Differences between VuePress and Astro


[Section titled Key Differences between VuePress and Astro](#key-differences-between-vuepress-and-astro)

When you rebuild your VuePress site in Astro, you will notice some important differences.

-   VuePress is a Vue-based single-page application (SPA). Astro sites are multi-page apps built using [`.astro` components](/en/basics/astro-components/), but can also support [React, Preact, Vue.js, Svelte, SolidJS, AlpineJS](/en/guides/framework-components/) and raw HTML templating.

-   [Layout templates](/en/basics/layouts/): VuePress sites are created using Markdown (`.md`) files for page content and HTML (`.html`) templates for layout. Astro is component-based, and uses Astro components, which include HTML templating for pages, layouts and individual UI elements. Astro can also create [pages from `.md` and `.mdx` files](/en/guides/markdown-content/), using an Astro layout component for wrapping Markdown content in a page template.

-   VuePress was designed to build content-heavy, Markdown-centric sites and has some built-in, documentation-specific website features that you would have to build yourself in Astro. Instead, Astro offers some documentation-specific features through an [official docs theme](https://starlight.astro.build). This website was the inspiration for that template! You can also find more [community docs themes](https://astro.build/themes?search=&categories%5B%5D=docs) with built-in features in our Themes Showcase.



## Switch from VuePress to Astro


[Section titled Switch from VuePress to Astro](#switch-from-vuepress-to-astro)

To convert a VuePress documentation site to Astro, start with our official [Starlight docs theme starter template](https://starlight.astro.build), or explore more community docs themes in our [theme showcase](https://astro.build/themes?search=&categories%5B%5D=docs).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3373)
-   [pnpm](#tab-panel-3374)
-   [Yarn](#tab-panel-3375)

Terminal window

```
npmcreateastro@latest----templatestarlight
```

Terminal window

```
pnpmcreateastro@latest--templatestarlight
```

Terminal window

```
yarncreateastro--templatestarlight
```

Bring your existing Markdown content files to [create Markdown pages](/en/guides/markdown-content/). You can still take advantage of [file-based routing](/en/guides/routing/) by moving these documents from `docs` in VuePress to `src/pages/` in Astro. Create folders with names that correspond to your existing VuePress project, and you should be able to keep your existing URLs.

VuePress, or any theme you installed, probably handled much of your site layout and metadata for you. You may wish to read about [building Astro Layouts as Markdown page wrappers](/en/basics/layouts/#markdown-layouts) to see how to manage templating yourself in Astro, including your page `<head>`.

You can find Astro’s docs starter, and other templates, on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a VuePress site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-vuepress.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 130. `en/guides/migrate-to-astro/from-wordpress/.md`

```text
# Migrating from WordPress


---
url: https://docs.astro.build/en/guides/migrate-to-astro/from-wordpress/
description: Tips for migrating an existing WordPress project to Astro
---


# Migrating from WordPress


[WordPress](https://wordpress.org) is an open-source, personal publishing system built on PHP and MySQL.

Tip

You can [use WordPress as a headless CMS for your Astro project](/en/guides/cms/wordpress/). Follow our guide to use your existing WordPress content in a new Astro project.


## Key Similarities between WordPress and Astro


[Section titled Key Similarities between WordPress and Astro](#key-similarities-between-wordpress-and-astro)

WordPress and Astro share some similarities that will help you migrate your project:

-   Both WordPress and Astro are ideal for [content-driven websites](/en/concepts/why-astro/#content-driven) like blogs and support writing your content in Markdown (requires a plugin in WordPress). Although the process for adding new content is different, [writing in Markdown files](/en/guides/markdown-content/) for your Astro blog should feel familiar if you have used Markdown syntax in your WordPress editor.

-   Both WordPress and Astro encourage you to [think about the design of your site in “blocks”](/en/concepts/islands/) (components). In Astro you will probably [write more of your own code to create these blocks](/en/basics/astro-components/) rather than rely on pre-built plugins. But thinking about the individual pieces of your site and how they are presented on the page should feel familiar.



## Key Differences between WordPress and Astro


[Section titled Key Differences between WordPress and Astro](#key-differences-between-wordpress-and-astro)

When you rebuild your WordPress site in Astro, you will notice some important differences:

-   A WordPress site is edited using an online dashboard. In Astro, you will use a [code editor](/en/editor-setup/) and development environment to maintain your site. You can develop locally on your machine, or choose a cloud editor/development environment like IDX, StackBlitz, CodeSandbox or Gitpod.

-   WordPress has an extensive plugin and theme market. In Astro, you will find some themes and [integrations](https://astro.build/integrations/) available, but you may now have to build many of your existing features yourself instead of looking for third-party solutions. Or, you can choose to start with an [Astro theme](https://astro.build/themes) with built-in features!

-   WordPress stores your content in a database. In Astro, you will have individual files (typically Markdown or MDX) in your [project directory](/en/basics/project-structure/) for each page’s content. Or, you can choose to use a [CMS for your content](/en/guides/cms/), even your existing WordPress site, and use Astro to fetch and present the data.



## Switch from WordPress to Astro


[Section titled Switch from WordPress to Astro](#switch-from-wordpress-to-astro)

To convert a WordPress blog to Astro, start with our blog theme starter template, or explore more community blog themes in our [theme showcase](https://astro.build/themes).

You can pass a `--template` argument to the `create astro` command to start a new Astro project with one of our official starters. Or, you can [start a new project from any existing Astro repository on GitHub](/en/install-and-setup/#install-from-the-cli-wizard).

-   [npm](#tab-panel-3376)
-   [pnpm](#tab-panel-3377)
-   [Yarn](#tab-panel-3378)

Terminal window

```
npmcreateastro@latest----templateblog
```

Terminal window

```
pnpmcreateastro@latest--templateblog
```

Terminal window

```
yarncreateastro--templateblog
```

You can continue to [use your existing WordPress blog as your CMS for Astro](/en/guides/cms/wordpress/), which means you will keep using your WordPress dashboard for writing your posts. Your content will be managed at WordPress, but all other aspects of your Astro site will be built in your code editing environment, and you will [deploy your Astro site](/en/guides/deploy/) separately from your WordPress site. (Be sure to update your domain at your host to keep the same website URL!)

You may wish to take [Astro’s Build a Blog Tutorial](/en/tutorial/0-introduction/) if you are new to working in a code editor and using GitHub to store and deploy your site. It will walk you through all the accounts and setup you need! You will also learn how to [build Astro components yourself](/en/tutorial/3-components/), and it will show you how to [add blog posts directly in Astro](/en/tutorial/2-pages/2/) if you choose not to use WordPress to write your content.

If you want to move all of your existing post content to Astro, you may find this [tool for exporting Markdown from WordPress helpful](https://github.com/lonekorean/wordpress-export-to-markdown). You may need to make some adjustments to the result if you have to [convert a large or complicated WordPress site to Markdown](https://swizec.com/blog/how-to-export-a-large-wordpress-site-to-markdown/).

To convert other types of sites, such as a portfolio or documentation site, see more official starter templates on [astro.new](https://astro.new). You’ll find a link to each project’s GitHub repository, as well as one-click links to open a working project in IDX, StackBlitz, CodeSandbox and Gitpod online development environments.


## Community Resources


[Section titled Community Resources](#community-resources)

[Goodbye Wordpress, hello Astro!](https://trib.tv/posts/2025/wordpress-to-astro/)

[How I Migrated from Wordpress to Astro](https://itsthatlady.dev/blog/migrate-from-wordpress-to-astro/)

[How and Why I Moved My Blog from WordPress to Astro and Markdown](https://levelup.gitconnected.com/how-and-why-i-moved-my-blog-from-wordpress-to-astro-and-markdown-3549672d5a86)

[How I Migrated From Wordpress to Astro: Boosted Pagespeed Scores to 100% and Cut 100% Hosting cost](https://devaradise.com/wordpress-to-static-website-astro/)

[WordPress to Astro site conversion](https://share.transistor.fm/s/d86496cd)

[How to Convert a Wordpress blog to an Astro Static Site](https://blog.okturtles.org/2024/10/convert-wordpress-to-static-site/)

[Why I switched from WordPress to Astro](https://dev.to/fratzinger/why-i-switched-from-wordpress-to-astro-5ge)

[Why I ditched WordPress for Astro](https://vbartalis.xyz/en/blog/why-i-ditched-wordpress-for-astro-js/)

[DeWP: utility to use your WordPress data in Astro projects](https://delucis.github.io/dewp/)

[Astro vs. WordPress: Rendering Patterns of the Modern Web](https://andrewkepson.com/blog/headless-wordpress/astro-vs-wordpress-rendering-patterns/)

Have a resource to share?

If you found (or made!) a helpful video or blog post about converting a WordPress site to Astro, [add it to this list](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/migrate-to-astro/from-wordpress.mdx)!


## More migration guides


-   ### [Create React App](/en/guides/migrate-to-astro/from-create-react-app/)

-   ### [Docusaurus](/en/guides/migrate-to-astro/from-docusaurus/)

-   ### [Eleventy](/en/guides/migrate-to-astro/from-eleventy/)

-   ### [Gatsby](/en/guides/migrate-to-astro/from-gatsby/)

-   ### [GitBook](/en/guides/migrate-to-astro/from-gitbook/)

-   ### [Gridsome](/en/guides/migrate-to-astro/from-gridsome/)

-   ### [Hugo](/en/guides/migrate-to-astro/from-hugo/)

-   ### [Jekyll](/en/guides/migrate-to-astro/from-jekyll/)

-   ### [Next.js](/en/guides/migrate-to-astro/from-nextjs/)

-   ### [NuxtJS](/en/guides/migrate-to-astro/from-nuxtjs/)

-   ### [Pelican](/en/guides/migrate-to-astro/from-pelican/)

-   ### [SvelteKit](/en/guides/migrate-to-astro/from-sveltekit/)

-   ### [VuePress](/en/guides/migrate-to-astro/from-vuepress/)

-   ### [WordPress](/en/guides/migrate-to-astro/from-wordpress/)


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 131. `en/guides/on-demand-rendering/.md`

```text
# On-demand rendering


---
url: https://docs.astro.build/en/guides/on-demand-rendering/
description: Generate server-rendered pages and routes on demand with an adapter.
---


# On-demand rendering


Your Astro project code must be **rendered** to HTML in order to be displayed on the web.

By default, Astro pages, routes, and API endpoints will be pre-rendered at build time as static pages. However, you can choose to render some or all of your routes on demand by a server when a route is requested.

On-demand rendered pages and routes are generated per visit, and can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild.

On-demand rendering on the server at request time is also known as **server-side rendering (SSR)**.


## Server adapters


[Section titled Server adapters](#server-adapters)

To render any page on demand, you need to add an **adapter**. Each adapter allows Astro to output a script that runs your project on a specific **runtime**: the environment that runs code on the server to generate pages when they are requested (e.g. Netlify, Cloudflare).

You may also wish to add an adapter even if your site is entirely static and you are not rendering any pages on demand. For example, the [Netlify adapter](/en/guides/integrations-guide/netlify/) enables Netlify’s Image CDN, and [server islands](/en/guides/server-islands/) require an adapter installed to use `server:defer` on a component.


### Adapters


-   ### [@astrojs/cloudflare](/en/guides/integrations-guide/cloudflare/)

-   ### [@astrojs/netlify](/en/guides/integrations-guide/netlify/)

-   ### [@astrojs/node](/en/guides/integrations-guide/node/)

-   ### [@astrojs/vercel](/en/guides/integrations-guide/vercel/)


Astro maintains official adapters for [Node.js](https://nodejs.org/), [Netlify](https://www.netlify.com/), [Vercel](https://vercel.com/), and [Cloudflare](https://www.cloudflare.com/). You can find both [official and community adapters in our integrations directory](https://astro.build/integrations/?search=&categories%5B%5D=adapters). Choose the one that corresponds to your [deployment environment](/en/guides/deploy/).


### Add an Adapter


[Section titled Add an Adapter](#add-an-adapter)

You can add any of the [official adapter integrations maintained by Astro](/en/guides/integrations-guide/#official-integrations) with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step.

For example, to install the Netlify adapter, run:

-   [npm](#tab-panel-1801)
-   [pnpm](#tab-panel-1802)
-   [Yarn](#tab-panel-1803)

Terminal window

```
npxastroaddnetlify
```

Terminal window

```
pnpmastroaddnetlify
```

Terminal window

```
yarnastroaddnetlify
```

You can also [add an adapter manually by installing the NPM package](/en/guides/integrations-guide/#installing-an-npm-package) (e.g. `@astrojs/netlify`) and updating `astro.config.mjs` yourself.

Note that different adapters may have different configuration settings. Read each adapter’s documentation, and apply any necessary config options to your chosen adapter in `astro.config.mjs`


## Enabling on-demand rendering


[Section titled Enabling on-demand rendering](#enabling-on-demand-rendering)

**By default, your entire Astro site will be prerendered**, and static HTML pages will be sent to the browser. However, you may opt out of prerendering on any routes that require server rendering, for example, a page that checks for cookies and displays personalized content.

First, [add an adapter integration](#add-an-adapter) for your server runtime to enable on-demand server rendering in your Astro project.

Then, add `export const prerender = false` at the top of the individual page or endpoint you want to render on demand. The rest of your site will remain a static site:

src/pages/page-rendered-on-demand.astro

```
---export const prerender = false---<html><!--This content will be server-rendered on demand!Just add an adapter integration for a server runtime!All other pages are statically-generated at build time!--><html>
```

The following example shows opting out of prerendering in order to display a random number each time the endpoint is hit:

src/pages/randomnumber.js

```
export const prerender = false;exportasyncfunctionGET() {let number = Math.random();returnnewResponse(JSON.stringify({number,message: `Here's a random number: ${number}`,}),);}
```


### `'server'` mode


[Section titled &#39;server&#39; mode](#server-mode)

For a **highly dynamic app**, after adding an adapter, you can [set your build output configuration to `output: 'server'`](/en/reference/configuration-reference/#output) to **server-render all your pages by default**. This is the equivalent of opting out of prerendering on every page.

Then, if needed, you can choose to prerender any individual pages that do not require a server to execute, such as a privacy policy or about page.

src/pages/about-my-app.astro

```
---export const prerender = true---<html><!--`output: 'server'` is configured, but this page is static!The rest of my site is rendered on demand!--><html>
```

Add `export const prerender = true` to any page or route to prerender a static page or endpoint:

src/pages/myendpoint.js

```
export const prerender = true;exportasyncfunctionGET() {returnnewResponse(JSON.stringify({message: `This is my static endpoint`,}),);}
```

Tip

Start with the default `'static'` mode until you are sure that **most or all** of your pages will be rendered on demand! This ensures that your site is as performant as possible, not relying on a server function to render static content.

The `'server'` output mode does not bring any additional functionality. It only switches the default rendering behavior.

See more about the [`output` setting](/en/reference/configuration-reference/#output) in the configuration reference.


## On-demand rendering features


[Section titled On-demand rendering features](#on-demand-rendering-features)


### HTML streaming


[Section titled HTML streaming](#html-streaming)

With HTML streaming, a document is broken up into chunks, sent over the network in order, and rendered on the page in that order. Astro uses HTML streaming in on-demand rendering to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, although network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering.

**Related recipe:** [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/)

Caution

Features that modify the [Response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header) are only available at the **page level**. (You can’t use them inside of components, including layout components.) By the time Astro runs your component code, it has already sent the Response headers and they cannot be modified.


### Cookies


[Section titled Cookies](#cookies)

A page or API endpoint rendered on demand can check, set, get, and delete cookies.

The example below updates the value of a cookie for a page view counter:

src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' modelet counter = 0if (Astro.cookies.has('counter')) {const cookie = Astro.cookies.get('counter')const value = cookie?.number()if (value !==undefined&&!isNaN(value)) counter = value +1}Astro.cookies.set('counter', String(counter))---<html><h1>Counter = {counter}</h1></html>
```

See more details about [`Astro.cookies` and the `AstroCookie` type](/en/reference/api-reference/#cookies) in the API reference.


### `Response`


[Section titled Response](#response)

[`Astro.response`](/en/reference/api-reference/#response) is a standard [`ResponseInit`](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#options) object. It can be used to set the response status and headers.

The example below sets a response status and status text for a product page when the product does not exist:

src/pages/product/\[id\].astro

```
---export const prerender = false; // Not needed in 'server' modeimport { getProduct } from'../api';const product = await getProduct(Astro.params.id);// No product foundif (!product) {Astro.response.status=404;Astro.response.statusText='Not found';}---<html><!-- Page here... --></html>
```


#### `Astro.response.headers`


[Section titled Astro.response.headers](#astroresponseheaders)

You can set headers using the `Astro.response.headers` object:

src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' modeAstro.response.headers.set('Cache-Control', 'public, max-age=3600');---<html><!-- Page here... --></html>
```


#### Return a `Response` object


[Section titled Return a Response object](#return-a-response-object)

You can also return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object directly from any page using on-demand rendering either manually or with [`Astro.redirect`](/en/reference/api-reference/#redirect).

The example below looks up an ID in the database on a dynamic page and either it returns a 404 if the product does not exist, or it redirects the user to another page if the product is no longer available, or it displays the product:

src/pages/product/\[id\].astro

```
---export const prerender = false; // Not needed in 'server' modeimport { getProduct } from'../api';const product = await getProduct(Astro.params.id);// No product foundif (!product) {returnnewResponse(null, {status: 404,statusText: 'Not found'});}// The product is no longer availableif (!product.isAvailable) {return Astro.redirect("/products", 301);}---<html><!-- Page here... --></html>
```


### `Request`


[Section titled Request](#request)

`Astro.request` is a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object. It can be used to get the `url`, `headers`, `method`, and even the body of the request.

You can access additional information from this object for pages that are not statically generated.


#### `Astro.request.headers`


[Section titled Astro.request.headers](#astrorequestheaders)

The headers for the request are available on `Astro.request.headers`. This works like the browser’s [`Request.headers`](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers). It is a [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object where you can retrieve headers such as the cookie.

src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' modeconst cookie = Astro.request.headers.get('cookie');// ...---<html><!-- Page here... --></html>
```


#### `Astro.request.method`


[Section titled Astro.request.method](#astrorequestmethod)

The HTTP method used in the request is available as `Astro.request.method`. This works like the browser’s [`Request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method). It returns the string representation of the HTTP method used in the request.

src/pages/index.astro

```
---export const prerender = false; // Not needed in 'server' modeconsole.log(Astro.request.method) // GET (when navigated to in the browser)---
```

See more details about [`Astro.request`](/en/reference/api-reference/#request) in the API reference.


### Server Endpoints


[Section titled Server Endpoints](#server-endpoints)

A server endpoint, also known as an **API route**, is a special function exported from a `.js` or `.ts` file within the `src/pages/` folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server.

The function takes an [endpoint context](/en/reference/api-reference/) and returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).

To learn more, see our [Endpoints Guide](/en/guides/endpoints/#server-endpoints-api-routes).

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 132. `en/guides/prefetch/.md`

```text
# Prefetch


---
url: https://docs.astro.build/en/guides/prefetch/
description: Prefetch links for snappier navigation between pages.
---


# Prefetch


Page load times play a big role in the usability and overall enjoyment of a site. Astro’s **opt-in prefetching** brings the benefits of near-instant page navigations to your multi-page application (MPA) as your visitors interact with the site.


## Enable prefetching


[Section titled Enable prefetching](#enable-prefetching)

You can enable prefetching with the `prefetch` config:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({prefetch: true});
```

A prefetch script will be added to all pages of your site. You can then add the `data-astro-prefetch` attribute to any `<a />` links on your site to opt-in to prefetching. When you hover over the link, the script will fetch the page in the background.

```
<ahref="/about"data-astro-prefetch>
```

Note that prefetching only works for links within your site, and not external links.


## Prefetch configuration


[Section titled Prefetch configuration](#prefetch-configuration)

The `prefetch` config also accepts an option object to further customize prefetching.


### Prefetch strategies


[Section titled Prefetch strategies](#prefetch-strategies)

Astro supports 4 prefetch strategies for various use cases:

-   `hover` (default): Prefetch when you hover over or focus on the link.
-   `tap`: Prefetch just before you click on the link.
-   `viewport`: Prefetch as the links enter the viewport.
-   `load`: Prefetch all links on the page after the page is loaded.

You can specify a strategy for an individual link by passing it to the `data-astro-prefetch` attribute:

```
<ahref="/about"data-astro-prefetch="tap">About</a>
```

Each strategy is fine-tuned to only prefetch when needed and save your users’ bandwidth. For example:

-   If a visitor is using [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) or has a [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType), prefetch will fallback to the `tap` strategy.
-   Quickly hovering or scrolling over links will not prefetch them.


### Default prefetch strategy


[Section titled Default prefetch strategy](#default-prefetch-strategy)

The default prefetch strategy when adding the `data-astro-prefetch` attribute is `hover`. To change it, you can configure [`prefetch.defaultStrategy`](/en/reference/configuration-reference/#prefetchdefaultstrategy) in your `astro.config.mjs` file:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({prefetch: {defaultStrategy: 'viewport'}});
```


### Prefetch all links by default


[Section titled Prefetch all links by default](#prefetch-all-links-by-default)

If you want to prefetch all links, including those without the `data-astro-prefetch` attribute, you can set [`prefetch.prefetchAll`](/en/reference/configuration-reference/#prefetchprefetchall) to `true`:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({prefetch: {prefetchAll: true}});
```

You can then opt-out of prefetching for individual links by setting `data-astro-prefetch="false"`:

```
<ahref="/about"data-astro-prefetch="false">About</a>
```

The default prefetch strategy for all links can be changed with `prefetch.defaultStrategy` as shown in the [Default prefetch strategy section](#default-prefetch-strategy).


## Prefetch programmatically


[Section titled Prefetch programmatically](#prefetch-programmatically)

As some navigation might not always appear as `<a />` links, you can also prefetch programmatically with the `prefetch()` API from the `astro:prefetch` module:

```
<buttonid="btn">Click me</button><script>import { prefetch } from'astro:prefetch';const btn = document.getElementById('btn');btn.addEventListener('click', ()=> {prefetch('/about');});</script>
```

The `prefetch()` API includes the same [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) and [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType) detection so that it only prefetches when needed.

To ignore slow connection detection, you can use the `ignoreSlowConnection` option:

```
// Prefetch even on data saver mode or slow connectionprefetch('/about', { ignoreSlowConnection: true });
```


### `eagerness`


[Section titled eagerness](#eagerness)

**Type:** `'immediate' | 'eager' | 'moderate' | 'conservative'` **Default:** `'immediate'`

**Added in:** `astro@5.6.0`

With the experimental [`clientPrerender`](/en/reference/experimental-flags/client-prerender/) flag enabled, you can use the `eagerness` option on `prefetch()` to suggest to the browser how eagerly it should prefetch/prerender link targets.

This follows the same API described in the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/speculationrules#eagerness) and defaults to `immediate` (the most eager option). In decreasing order of eagerness, the other options are `eager`, `moderate`, and `conservative`.

The `eagerness` option allows you to balance the benefit of reduced wait times against bandwidth, memory, and CPU costs for your site visitors. Some browsers, such as Chrome, have [limits in place to guard against over-speculating](https://developer.chrome.com/blog/speculation-rules-improvements#chrome-limits) (prerendering/prefetching too many links).

```
------<script>// Control prefetching eagerness with `experimental.clientPrerender`import { prefetch } from'astro:prefetch';// This page is resource-intensiveprefetch('/data-heavy-dashboard', { eagerness: 'conservative' });// This page is critical to the visitor's journeyprefetch('/getting-started'); // defaults to `{ eagerness: 'immediate' }`// This page may not be visitedprefetch('/terms-of-service', { eagerness: 'moderate' });</script>
```

To use `prefetch()` programmatically with large sets of links, you can set `eagerness: 'moderate'` to take advantage of [First In, First Out (FIFO)](https://en.wikipedia.org/wiki/FIFO_\(computing_and_electronics\)) strategies and browser heuristics to let the browser decide when to prerender/prefetch them and in what order:

```
<aclass="link-moderate"href="/nice-link-1">A Nice Link 1</a><aclass="link-moderate"href="/nice-link-2">A Nice Link 2</a><aclass="link-moderate"href="/nice-link-3">A Nice Link 3</a><aclass="link-moderate"href="/nice-link-4">A Nice Link 4</a>...<aclass="link-moderate"href="/nice-link-20">A Nice Link 20</a><script>import { prefetch } from'astro:prefetch';const linkModerate = document.getElementsByClassName('link-moderate');linkModerate.forEach((link)=>prefetch(link.getAttribute('href'), {eagerness: 'moderate'}));</script>
```

Make sure to only import `prefetch()` in client-side scripts as it relies on browser APIs.


## Using with View Transitions


[Section titled Using with View Transitions](#using-with-view-transitions)

When you use [View Transitions](/en/guides/view-transitions/) on a page, prefetching will also be enabled by default. It sets a default configuration of `{ prefetchAll: true }` which enables [prefetching for all links](#prefetch-all-links-by-default) on the page.

You can customize the prefetch configuration in `astro.config.mjs` to override the default. For example:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({// Disable prefetch completelyprefetch: false});
```

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({// Keep prefetch, but only prefetch for links with `data-astro-prefetch`prefetch: {prefetchAll: false}});
```


## Browser support


[Section titled Browser support](#browser-support)

Astro’s prefetching uses [`<link rel="prefetch">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/prefetch) if supported by the browser, and falls back to the [`fetch()` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) otherwise.

The most common browsers support Astro’s prefetching with subtle differences:


### Chrome


[Section titled Chrome](#chrome)

Chrome supports `<link rel="prefetch">`. Prefetching works as intended.

It also fully supports `<script type="speculationrules">` from the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API), which can be used to further describe [prefetching strategies and rules](#eagerness), enhancing user experience for your Chrome users. You’ll need to enable [`clientPrerender`](/en/reference/experimental-flags/client-prerender/) experiment to utilize this functionality with `prefetch()`


### Firefox


[Section titled Firefox](#firefox)

Firefox supports `<link rel="prefetch">` but may display errors or fail entirely:

-   Without an explicit cache header (e.g. [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) or [`Expires`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires)), prefetching will error with `NS_BINDING_ABORTED`.
-   Even in the event of an error, if the response has a proper [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header, it will be re-used on navigation.
-   Otherwise, if it errors with no other cache headers, the prefetch will not work.


### Safari


[Section titled Safari](#safari)

Safari does not support `<link rel="prefetch">` and will fall back to the `fetch()` API which requires cache headers (e.g. [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control), [`Expires`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires), and [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)) to be set. Otherwise, the prefetch will not work.

**Edge case:** `ETag` headers do not work in private windows.


### Recommendations


[Section titled Recommendations](#recommendations)

To best support all browsers, make sure your pages have the proper cache headers.

For static or prerendered pages, the `ETag` header is often automatically set by the deployment platform and is expected to work out of the box.

For dynamic and server-side rendered pages, set the appropriate cache headers yourself based on the page content. Visit the [MDN documentation on HTTP caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) for more information.


## Migrating from `@astrojs/prefetch`


[Section titled Migrating from @astrojs/prefetch](#migrating-from-astrojsprefetch)

The `@astrojs/prefetch` integration was deprecated in v3.5.0 and will eventually be removed entirely. Use the following instructions to migrate to Astro’s built-in prefetching which replaces this integration.

1.  Remove the `@astrojs/prefetch` integration and enable the `prefetch` config in `astro.config.mjs`:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import prefetch from'@astrojs/prefetch';exportdefaultdefineConfig({integrations: [prefetch()],prefetch: true});
    ```

2.  Convert from `@astrojs/prefetch`’s configuration options:

    -   The deprecated integration used the `selector` config option to specify which links should be prefetched upon entering the viewport.

        Add `data-astro-prefetch="viewport"` to these individual links instead.

        ```
        <ahref="/about"data-astro-prefetch="viewport">
        ```

    -   The deprecated integration used the `intentSelector` config option to specify which links should be prefetched when they were hovered over or focused.

        Add `data-astro-prefetch` or `data-astro-prefetch="hover"` to these individual links instead:

        ```
        <!-- You can omit the value if `defaultStrategy` is set to `hover` (default) --><ahref="/about"data-astro-prefetch><!-- Otherwise, you can explicitly define the prefetch strategy --><ahref="/about"data-astro-prefetch="hover">
        ```

    -   The `throttles` option from `@astrojs/prefetch` is no longer needed as the new prefetch feature will automatically schedule and prefetch optimally.


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 133. `en/guides/routing/.md`

```text
# Routing


---
url: https://docs.astro.build/en/guides/routing/
description: An intro to routing with Astro.
---


# Routing


Astro uses **file-based routing** to generate your build URLs based on the file layout of your project `src/pages/` directory.


## Navigating between pages


[Section titled Navigating between pages](#navigating-between-pages)

Astro uses standard HTML [`<a>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) to navigate between routes. There is no framework-specific `<Link>` component provided.

src/pages/index.astro

```
<p>Read more <ahref="/about/">about</a> Astro!</p><!-- With `base: "/docs"` configured --><p>Learn more in our <ahref="/docs/reference/">reference</a> section!</p>
```


## Static routes


[Section titled Static routes](#static-routes)

`.astro` [page components](/en/basics/astro-pages/) as well as Markdown and MDX Files (`.md`, `.mdx`) within the `src/pages/` directory **automatically become pages on your website**. Each page’s route corresponds to its path and filename within the `src/pages/` directory.

```

# Example: Static routessrc/pages/index.astro        -> mysite.com/src/pages/about.astro        -> mysite.com/aboutsrc/pages/about/index.astro  -> mysite.com/aboutsrc/pages/about/me.astro     -> mysite.com/about/mesrc/pages/posts/1.md         -> mysite.com/posts/1

```

Tip

There is no separate “routing config” to maintain in an Astro project! When you add a file to the `src/pages/` directory, a new route is automatically created for you. In static builds, you can customize the file output format using the [`build.format`](/en/reference/configuration-reference/#buildformat) configuration option.


## Dynamic routes


[Section titled Dynamic routes](#dynamic-routes)

An Astro page file can specify dynamic route parameters in its filename to generate multiple, matching pages. For example, `src/pages/authors/[author].astro` generates a bio page for every author on your blog. `author` becomes a *parameter* that you can access from inside the page.

In Astro’s default static output mode, these pages are generated at build time, and so you must predetermine the list of `author`s that get a corresponding file. In SSR mode, a page will be generated on request for any route that matches.


### Static (SSG) Mode


[Section titled Static (SSG) Mode](#static-ssg-mode)

Because all routes must be determined at build time, a dynamic route must export a `getStaticPaths()` that returns an array of objects with a `params` property. Each of these objects will generate a corresponding route.

`[dog].astro` defines the dynamic `dog` parameter in its filename, so the objects returned by `getStaticPaths()` must include `dog` in their `params`. The page can then access this parameter using `Astro.params`.

src/pages/dogs/\[dog\].astro

```
---exportfunctiongetStaticPaths() {return [{ params: { dog: "clifford" }},{ params: { dog: "rover" }},{ params: { dog: "spot" }},];}const { dog } = Astro.params;---<div>Good dog, {dog}!</div>
```

This will generate three pages: `/dogs/clifford`, `/dogs/rover`, and `/dogs/spot`, each displaying the corresponding dog name.

The filename can include multiple parameters, which must all be included in the `params` objects in `getStaticPaths()`:

src/pages/\[lang\]-\[version\]/info.astro

```
---exportfunctiongetStaticPaths() {return [{ params: { lang: "en", version: "v1" }},{ params: { lang: "fr", version: "v2" }},];}const { lang, version } = Astro.params;---
```

This will generate `/en-v1/info` and `/fr-v2/info`.

Parameters can be included in separate parts of the path. For example, the file `src/pages/[lang]/[version]/info.astro` with the same `getStaticPaths()` above will generate the routes `/en/v1/info` and `/fr/v2/info`.


#### Decoding `params`


[Section titled Decoding params](#decoding-params)

The `params` provided to the function `getStaticPaths()` function are not decoded. Use the function [`decodeURI`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) when you need to decode parameter values.

src/pages/\[slug\].astro

```
---exportfunctiongetStaticPaths() {return [{ params: { slug: decodeURI("%5Bpage%5D") }},// decodes to "[page]"]}---
```

Learn more about [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths).

**Related recipe:** [Add i18n features](/en/recipes/i18n/)


#### Rest parameters


[Section titled Rest parameters](#rest-parameters)

If you need more flexibility in your URL routing, you can use a [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) in your `.astro` filename to match file paths of any depth:

src/pages/sequences/\[...path\].astro

```
---exportfunctiongetStaticPaths() {return [{ params: { path: "one/two/three" }},{ params: { path: "four" }},{ params: { path: undefined }}]}const { path } = Astro.params;---
```

This will generate `/sequences/one/two/three`, `/sequences/four`, and `/sequences`. (Setting the rest parameter to `undefined` allows it to match the top level page.)

Rest parameters can be used with **other named parameters**. For example, GitHub’s file viewer can be represented with the following dynamic route:

```
/[org]/[repo]/tree/[branch]/[...file]
```

In this example, a request for `/withastro/astro/tree/main/docs/public/favicon.svg` would be split into the following named parameters:

```
{org: "withastro",repo: "astro",branch: "main",file: "docs/public/favicon.svg"}
```


#### Example: Dynamic pages at multiple levels


[Section titled Example: Dynamic pages at multiple levels](#example-dynamic-pages-at-multiple-levels)

In the following example, a rest parameter (`[...slug]`) and the [`props`](/en/reference/routing-reference/#data-passing-with-props) feature of `getStaticPaths()` generate pages for slugs of different depths.

src/pages/\[...slug\].astro

```
---exportfunctiongetStaticPaths() {const pages = [{slug: undefined,title: "Astro Store",text: "Welcome to the Astro store!",},{slug: "products",title: "Astro products",text: "We have lots of products for you",},{slug: "products/astro-handbook",title: "The ultimate Astro handbook",text: "If you want to learn Astro, you must read this book.",},];return pages.map(({ slug,title,text })=> {return {params: { slug },props: { title, text },};});}const { title, text } = Astro.props;---<html><head><title>{title}</title></head><body><h1>{title}</h1><p>{text}</p></body></html>
```


### On-demand dynamic routes


[Section titled On-demand dynamic routes](#on-demand-dynamic-routes)

For [on-demand rendering](/en/guides/on-demand-rendering/) with an adapter, dynamic routes are defined the same way: include `[param]` or `[...path]` brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not “static” routes, `getStaticPaths` should not be used.

For on-demand rendered routes, only one rest parameter using the spread notation may be used in the file name (e.g. `src/pages/[locale]/[...slug].astro` or `src/pages/[...locale]/[slug].astro`, but not `src/pages/[...locale]/[...slug].astro`).

src/pages/resources/\[resource\]/\[id\].astro

```
---export const prerender = false; // Not needed in 'server' modeconst { resource, id } = Astro.params;---<h1>{resource}: {id}</h1>
```

This page will be served for any value of `resource` and `id`: `resources/users/1`, `resources/colors/blue`, etc.


#### Modifying the `[...slug]` example for SSR


[Section titled Modifying the \[...slug\] example for SSR](#modifying-the-slug-example-for-ssr)

Because SSR pages can’t use `getStaticPaths()`, they can’t receive props. The [previous example](#example-dynamic-pages-at-multiple-levels) can be adapted for SSR mode by looking up the value of the `slug` param in an object. If the route is at the root (”/”), the `slug` param will be `undefined`. If the value doesn’t exist in the object, we redirect to a 404 page.

src/pages/\[...slug\].astro

```
---const pages = [{slug: undefined,title: 'Astro Store',text: 'Welcome to the Astro store!',},{slug: 'products',title: 'Astro products',text: 'We have lots of products for you',},{slug: 'products/astro-handbook',title: 'The ultimate Astro handbook',text: 'If you want to learn Astro, you must read this book.',}];const { slug } = Astro.params;const page = pages.find((page) => page.slug === slug);if (!page) return Astro.redirect("/404");const { title, text } = page;---<html><head><title>{title}</title></head><body><h1>{title}</h1><p>{text}</p></body></html>
```


## Redirects


[Section titled Redirects](#redirects)

Sometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route.

You can define rules to [redirect users to permanently-moved pages](#configured-redirects) in your Astro config. Or, [redirect users dynamically](#dynamic-redirects) as they use your site.


### Configured Redirects


[Section titled Configured Redirects](#configured-redirects)

**Added in:** `astro@2.9.0`

You can specify a mapping of permanent redirects in your Astro config with the [`redirects`](/en/reference/configuration-reference/#redirects) value.

For internal redirects, this is a mapping of an old route path to the new route. As of Astro v5.2.0, it is also possible to redirect to external URLs that start with `http` or `https` and [can be parsed](https://developer.mozilla.org/en-US/docs/Web/API/URL/canParse_static):

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({redirects: {"/old-page": "/new-page","/blog": "https://example.com/blog"}});
```

These redirects follow [the same priority rules as file-based routes](#route-priority-order) and will always take lower precedence than an existing page file of the same name in your project. For example, `/old-page` will not redirect to `/new-page` if your project contains the file `src/pages/old-page.astro`.

Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example:

```
{"/blog/[...slug]": "/articles/[...slug]"}
```

Using SSR or a static adapter, you can also provide an object as the value, allowing you to specify the `status` code in addition to the new `destination`:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({redirects: {"/old-page": {status: 302,destination: "/new-page"},"/news": {status: 302,destination: "https://example.com/news"}}});
```

When running `astro build`, Astro will output HTML files with the [meta refresh](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#examples) tag by default. Supported adapters will instead write out the host’s configuration file with the redirects.

The status code is `301` by default. If building to HTML files the status code is not used by the server.


### Dynamic redirects


[Section titled Dynamic redirects](#dynamic-redirects)

On the `Astro` global, the `Astro.redirect` method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie.

src/pages/account.astro

```
---import { isLoggedIn } from"../utils";const cookie = Astro.request.headers.get("cookie");// If the user is not logged in, redirect them to the login pageif (!isLoggedIn(cookie)) {return Astro.redirect("/login");}---
```


## Rewrites


[Section titled Rewrites](#rewrites)

**Added in:** `astro@4.13.0`

A rewrite allows you to serve a different route without redirecting the browser to a different page. The browser will show the original address in the URL bar, but will instead display the content of the URL provided to [`Astro.rewrite()`](/en/reference/api-reference/#rewrite).

Tip

For content that has permanently moved, or to direct your user to a different page with a new URL (e.g. a user dashboard after logging in), use a [redirect](#redirects) instead.

Rewrites can be useful for showing the same content at multiple paths (e.g. `/products/shoes/men/` and `/products/men/shoes/`) without needing to maintain two different source files.

Rewrites are also useful for SEO purposes and user experience. They allow you to display content that otherwise would require redirecting your visitor to a different page or would return a 404 status. One common use of rewrites is to show the same localized content for different variants of a language.

The following example uses a rewrite to render the `/es/` version of a page when the `/es-CU/` (Cuban Spanish) URL path is visited. When a visitor navigates to the URL `/es-cu/articles/introduction`, Astro will render the content generated by the file `src/pages/es/articles/introduction.astro`.

src/pages/es-cu/articles/introduction.astro

```
---return Astro.rewrite("/es/articles/introduction");---
```

Use `context.rewrite()` in your endpoint files to reroute to a different page:

src/pages/api.js

```
exportfunctionGET(context) {if (!context.locals.allowed) {returncontext.rewrite("/");}}
```

If the URL passed to `Astro.rewrite()` emits a runtime error, Astro will show the overlay error in development and return a 500 status code in production. If the URL does not exist in your project, a 404 status code will be returned.

You can intentionally create a rewrite to render your `/404` page, for example to indicate that a product in your e-commerce shop is no longer available:

src/pages/\[item\].astro

```
---const { item } = Astro.params;if (!itemExists(item)) {return Astro.rewrite("/404");}---
```

You can also conditionally rewrite based on an HTTP response status, for example to display a certain page on your site when visiting a URL that doesn’t exist:

src/middleware.mjs

```
export const onRequest = async (context, next) => {const response = await next();if (response.status === 404) {return context.rewrite("/");}return response;}
```

Before displaying the content from the specified rewrite path, the function `Astro.rewrite()` will trigger a new, complete rendering phase. This re-executes any middleware for the new route/request.

See the [`Astro.rewrite()` API reference](/en/reference/api-reference/#rewrite) for more information.


## Route Priority Order


[Section titled Route Priority Order](#route-priority-order)

It’s possible for multiple defined routes to attempt to build the same URL path. For example, all of these routes could build `/posts/create`:

-   Directorysrc/pages/

    -   \[…slug\].astro
    -   Directoryposts/

        -   create.astro
        -   \[page\].astro
        -   \[pid\].ts
        -   \[…slug\].astro



Astro needs to know which route should be used to build the page. To do so, it sorts them according to the following rules in order:

-   Astro [reserved routes](#reserved-routes)
-   Routes with more path segments will take precedence over less specific routes. In the example above, all routes under `/posts/` take precedence over `/[...slug].astro` at the root.
-   Static routes without path parameters will take precedence over dynamic routes. E.g. `/posts/create.astro` takes precedence over all the other routes in the example.
-   Dynamic routes using named parameters take precedence over rest parameters. E.g. `/posts/[page].astro` takes precedence over `/posts/[...slug].astro`.
-   Pre-rendered dynamic routes take precedence over server dynamic routes.
-   Endpoints take precedence over pages.
-   File-based routes take precedence over redirects.
-   If none of the rules above decide the order, routes are sorted alphabetically based on the default locale of your Node installation.

Given the example above, here are a few examples of how the rules will match a requested URL to the route used to build the HTML:

-   `pages/posts/create.astro` - Will build only `/posts/create`
-   `pages/posts/[pid].ts` - Will build `/posts/abc`, `/posts/xyz`, etc. But not `/posts/create`
-   `pages/posts/[page].astro` - Will build `/posts/1`, `/posts/2`, etc. But not `/posts/create`, `/posts/abc` nor `/posts/xyz`
-   `pages/posts/[...slug].astro` - Will build `/posts/1/2`, `/posts/a/b/c`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc.
-   `pages/[...slug].astro` - Will build `/abc`, `/xyz`, `/abc/xyz`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc.


### Reserved routes


[Section titled Reserved routes](#reserved-routes)

Internal routes take priority over any user-defined or integration-defined routes as they are required for Astro features to work. The following are Astro’s reserved routes:

-   `_astro/`: Serves all of the static assets to the client, including CSS documents, bundled client scripts, optimized images, and any Vite assets.
-   `_server_islands/`: Serves the dynamic components deferred into a [server island](/en/guides/server-islands/).
-   `_actions/`: Serves any defined [actions](/en/guides/actions/).


## Pagination


[Section titled Pagination](#pagination)

Astro supports built-in pagination for large collections of data that need to be split into multiple pages. Astro will generate common pagination properties, including previous/next page URLs, total number of pages, and more.

Paginated route names should use the same `[bracket]` syntax as a standard dynamic route. For instance, the file name `/astronauts/[page].astro` will generate routes for `/astronauts/1`, `/astronauts/2`, etc, where `[page]` is the generated page number.

You can use the `paginate()` function to generate these pages for an array of values like so:

src/pages/astronauts/\[page\].astro

```
---exportfunctiongetStaticPaths({ paginate }) {const astronautPages = [{ astronaut: "Neil Armstrong" },{ astronaut: "Buzz Aldrin" },{ astronaut: "Sally Ride" },{ astronaut: "John Glenn" },];// Generate pages from our array of astronauts, with 2 to a pagereturnpaginate(astronautPages, { pageSize: 2 });}// All paginated data is passed on the "page" propconst { page } = Astro.props;---<!-- Display the current page number. `Astro.params.page` can also be used! --><h1>Page {page.currentPage}</h1><ul><!-- List the array of astronaut info -->{page.data.map(({ astronaut })=><li>{astronaut}</li>)}</ul>
```

This generates the following pages, with 2 items to a page:

-   `/astronauts/1` - Page 1: Displays “Neil Armstrong” and “Buzz Aldrin”
-   `/astronauts/2` - Page 2: Displays “Sally Ride” and “John Glenn”


### The `page` prop


[Section titled The page prop](#the-page-prop)

When you use the `paginate()` function, each page will be passed its data via a `page` prop. The `page` prop has many useful properties that you can use to build pages and links between them:

```
interface Page<T=any> {/** array containing the page’s slice of data that you passed to the paginate() function */data:T[];/** metadata *//** the count of the first item on the page, starting from 0 */start:number;/** the count of the last item on the page, starting from 0 */end:number;/** total number of results */total:number;/** the current page number, starting from 1 */currentPage:number;/** number of items per page (default: 10) */size:number;/** number of last page */lastPage:number;url: {/** url of the current page */current:string;/** url of the previous page (if there is one) */prev:string|undefined;/** url of the next page (if there is one) */next:string|undefined;/** url of the first page (if the current page is not the first page) */first:string|undefined;/** url of the last page (if the current page in not the last page) */last:string|undefined;};}
```

The following example displays current information for the page along with links to navigate between pages:

src/pages/astronauts/\[page\].astro

```
---// Paginate same list of `{ astronaut }` objects as the previous exampleexportfunctiongetStaticPaths({ paginate }) { /* ... */ }const { page } = Astro.props;---<h1>Page {page.currentPage}</h1><ul>{page.data.map(({ astronaut })=><li>{astronaut}</li>)}</ul>{page.url.first?<ahref={page.url.first}>First</a>:null}{page.url.prev?<ahref={page.url.prev}>Previous</a>:null}{page.url.next?<ahref={page.url.next}>Next</a>:null}{page.url.last?<ahref={page.url.last}>Last</a>:null}
```

Learn more about [the pagination `page` prop](/en/reference/routing-reference/#the-pagination-page-prop).


### Nested Pagination


[Section titled Nested Pagination](#nested-pagination)

A more advanced use-case for pagination is **nested pagination.** This is when pagination is combined with other dynamic route params. You can use nested pagination to group your paginated collection by some property or tag.

For example, if you want to group your paginated Markdown posts by some tag, you would use nested pagination by creating a `/src/pages/[tag]/[page].astro` page that would match the following URLS:

-   `/red/1` (tag=red)
-   `/red/2` (tag=red)
-   `/blue/1` (tag=blue)
-   `/green/1` (tag=green)

Nested pagination works by returning an array of `paginate()` results from `getStaticPaths()`, one for each grouping.

In the following example, we will implement nested pagination to build the URLs listed above:

src/pages/\[tag\]/\[page\].astro

```
---exportfunctiongetStaticPaths({ paginate }) {const allTags = ["red","blue","green"];const allPosts = Object.values(import.meta.glob("../pages/post/*.md", { eager: true }));// For every tag, return a `paginate()` result.// Make sure that you pass `{ params: { tag }}` to `paginate()`// so that Astro knows which tag grouping the result is for.return allTags.flatMap((tag)=> {const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);returnpaginate(filteredPosts, {params: { tag },pageSize: 10});});}const { page } = Astro.props;const params = Astro.params;
```


## Excluding pages


[Section titled Excluding pages](#excluding-pages)

You can exclude pages or directories within `src/pages` from being built by prefixing their names with an underscore (`_`). Files with the `_` prefix won’t be recognized by the router and won’t be placed into the `dist/` directory.

You can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages.

In this example, only `src/pages/index.astro` and `src/pages/projects/project1.md` will be built as page routes and HTML files.

-   Directorysrc/pages/

    -   Directory\_hidden-directory/

        -   page1.md
        -   page2.md

    -   \_hidden-page.astro
    -   **index.astro**
    -   Directoryprojects/

        -   \_SomeComponent.astro
        -   \_utils.js
        -   **project1.md**



Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 134. `en/guides/server-islands/.md`

```text
# Server islands


---
url: https://docs.astro.build/en/guides/server-islands/
description: Combine high performance static HTML with dynamic server-rendered content.
---


# Server islands


Server islands allow you to on-demand render dynamic or personalized “islands” individually, without sacrificing the performance of the rest of the page.

This means your visitor will see the most important parts of your page sooner, and allows your main content to be more aggressively cached, providing faster performance.


## Server island components


[Section titled Server island components](#server-island-components)

A server island is a normal server-rendered [Astro component](/en/basics/astro-components/) that is instructed to delay rendering until its contents are available.

Your page will be rendered immediately with any specified [fallback content as a placeholder](#server-island-fallback-content). Then, the component’s own contents are fetched on the client and displayed when available.

With [an adapter installed](/en/guides/on-demand-rendering/#server-adapters) to perform the delayed rendering, add the [`server:defer` directive](/en/reference/directives-reference/#server-directives) to any component on your page to turn it into its own island:

src/pages/index.astro

```
---import Avatar from'../components/Avatar.astro';---<Avatarserver:defer />
```

These components can do [anything you normally would in an on-demand rendered page](/en/guides/on-demand-rendering/#on-demand-rendering-features) using an adapter, such as fetch content, and access cookies:

src/components/Avatar.astro

```
---import { getUserAvatar } from'../sessions';const userSession = Astro.cookies.get('session');const avatarURL = await getUserAvatar(userSession);---<imgalt="User avatar"src={avatarURL} />
```


## Server island fallback content


[Section titled Server island fallback content](#server-island-fallback-content)

When using the `server:defer` attribute on a component to delay its rendering, you can “slot” in default loading content using the included named `"fallback"` slot.

Your fallback content will be rendered along with the rest of the page initially on page load and will be replaced with your component’s content when available.

To add fallback content, add `slot="fallback"` on a child (other components or HTML elements) passed to your server island component:

```
---import Avatar from'../components/Avatar.astro';import GenericAvatar from'../components/GenericAvatar.astro';---<Avatarserver:defer><GenericAvatarslot="fallback" /></Avatar>
```

This fallback content can be things like:

-   A generic avatar instead of the user’s own.
-   Placeholder UI such as custom messages.
-   Loading indicators such as spinners.


## How it works


[Section titled How it works](#how-it-works)

Server island implementation happens mostly at build-time where component content is swapped out for a small script.

Each of the islands marked with `server:defer` is split off into its own special route which the script fetches at run time. When Astro builds your site it will omit the component and inject a script in its place, and any content you’ve marked with `slot="fallback"`.

When the page loads in the browser, these components will be requested to a special endpoint that renders them and returns the HTML. This means that users will see the most critical parts of the page instantly. Fallback content will be visible for a short amount of time before the dynamic islands are then loaded.

Each island is loaded independently from the rest. This means a slower island won’t delay the rest of your personalized content from being available.

This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host you have, from a Node.js server in a Docker container to the serverless provider of your choice.


## Caching


[Section titled Caching](#caching)

The data for server islands is retrieved via a `GET` request, passing props as an encrypted string in the URL query. This allows caching data with the [`Cache-Control` HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) using standard `Cache-Control` directives.

However, [the browser limits URLs to a maximum length of 2048 bytes](https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md#url-length) for practical reasons and to avoid causing denial-of-service problems. If your query string causes your URL to exceed this limit, Astro will instead send a `POST` request that contains all props in the body.

`POST` requests are not cached by browsers because they are used to submit data, and could cause data integrity or security issues. Therefore, any existing caching logic in your project will break. Whenever possible, pass only necessary props to your server islands and avoid sending entire data objects and arrays to keep your query small.


## Accessing the page URL in a server island


[Section titled Accessing the page URL in a server island](#accessing-the-page-url-in-a-server-island)

In most cases you, your server island component can get information about the page rendering it by [passing props](/en/basics/astro-components/#component-props) like in normal components.

However, server islands run in their own isolated context outside of the page request. `Astro.url` and `Astro.request.url` in a server island component both return a URL that looks like `/_server-islands/Avatar` instead of the current page’s URL in the browser. Additionally, if you are prerendering the page you will not have access to information such as query parameters in order to pass as props.

To access information from the page’s URL, you can check the [Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) header, which will contain the address of the page that is loading the island in the browser:

```
---const referer = Astro.request.headers.get('Referer');const url = newURL(referer);const productId = url.searchParams.get('product');---
```


## Reusing the encryption key


[Section titled Reusing the encryption key](#reusing-the-encryption-key)

Astro uses [cryptography](https://developer.mozilla.org/en-US/docs/Glossary/Cryptography) to encrypt props passed to server islands, protecting sensitive data from accidental exposure. This encryption relies on a new, random key that is generated on each build and embedded in the server bundle.

Most deploy hosts will handle keeping your front end and back end in sync automatically. However, you may need a constant encryption key if you are using rolling deployments, multi-region hosting or a CDN that caches pages containing server islands.

In environments with rolling deployments (e.g., Kubernetes) where your frontend assets (which encrypt props) and your backend functions (which decrypt props) may be temporarily using different keys, or when a CDN is still serving pages built with an old key, encrypted props passed to your server island cannot be decrypted.

In these situations, use the Astro CLI to generate a reusable, encoded encryption key to set as an environment variable in your build environment:

Terminal window

```
astrocreate-key
```

Use this value to configure the `ASTRO_KEY` environment variable (e.g. in a `.env` file) and include it in your CI/CD or host’s build settings. This ensures the same key is always reused in the generated bundle so that encryption and decryption remain in sync.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 135. `en/guides/sessions/.md`

```text
# Sessions


---
url: https://docs.astro.build/en/guides/sessions/
description: Share data between requests for on-demand rendered pages.
---


# Sessions


**Added in:** `astro@5.7.0`

Sessions are used to share data between requests for [on-demand rendered pages](/en/guides/on-demand-rendering/).

Unlike [`cookies`](/en/guides/on-demand-rendering/#cookies), sessions are stored on the server, so you can store larger amounts of data without worrying about size limits or security issues. They are useful for storing things like user data, shopping carts, and form state, and they work without any client-side JavaScript:

src/components/CartButton.astro

```
---export const prerender = false; // Not needed with 'server' outputconst cart = await Astro.session?.get('cart');---<ahref="/checkout">🛒 {cart?.length??0} items</a>
```


## Configuring sessions


[Section titled Configuring sessions](#configuring-sessions)

Sessions require a storage driver to store the session data. The [Node](/en/guides/integrations-guide/node/#sessions), [Cloudflare](/en/guides/integrations-guide/cloudflare/#sessions), and [Netlify](/en/guides/integrations-guide/netlify/#sessions) adapters automatically configure a default driver for you, but other adapters currently require you to [specify a driver manually](/en/reference/configuration-reference/#sessiondriver).

astro.config.mjs

```
{adapter: vercel(),session: {driver: "redis",},}
```

See [the `session` configuration option](/en/reference/configuration-reference/#session-options) for more details on setting a storage driver, and other configurable options.


## Interacting with session data


[Section titled Interacting with session data](#interacting-with-session-data)

The [`session` object](/en/reference/api-reference/#session) allows you to interact with the stored user state (e.g. adding items to a shopping cart) and the session ID (e.g. deleting the session ID cookie when logging out). The object is accessible as `Astro.session` in your Astro components and pages and as `context.session` object in API endpoints, middleware, and actions.

The session is generated automatically when it is first used and can be regenerated at any time with [`session.regenerate()`](/en/reference/api-reference/#regenerate) or destroyed with [`session.destroy()`](/en/reference/api-reference/#destroy).

For many use cases, you will only need to use [`session.get()`](/en/reference/api-reference/#get) and [`session.set()`](/en/reference/api-reference/#set).

See [the Sessions API reference](/en/reference/api-reference/#session) for more details.


### Astro components and pages


[Section titled Astro components and pages](#astro-components-and-pages)

In `.astro` components and pages, you can access the session object via the global `Astro` object. For example, to display the number of items in a shopping cart:

src/components/CartButton.astro

```
---export const prerender = false; // Not needed with 'server' outputconst cart = await Astro.session?.get('cart');---<ahref="/checkout">🛒 {cart?.length??0} items</a>
```


### API endpoints


[Section titled API endpoints](#api-endpoints)

In API endpoints, the session object is available on the `context` object. For example, to add an item to a shopping cart:

src/pages/api/addToCart.ts

```
exportasyncfunctionPOST(context:APIContext) {const cart = await context.session?.get('cart') | [];const data = await context.request.json<{ item:string }>();if(!data?.item) {returnnewResponse('Item is required', { status: 400 });}cart.push(data.item);awaitcontext.session?.set('cart', cart);return Response.json(cart);}
```


### Actions


[Section titled Actions](#actions)

In actions, the session object is available on the `context` object. For example, to add an item to a shopping cart:

src/actions/addToCart.ts

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {addToCart: defineAction({input: z.object({ productId: z.string() }),handler: async (input, context) => {const cart = await context.session?.get('cart');cart.push(input.productId);await context.session?.set('cart', cart);return cart;},}),};
```


### Middleware


[Section titled Middleware](#middleware)

Note

Sessions are not supported in edge middleware.

In middleware, the session object is available on the `context` object. For example, to set the last visit time in the session:

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';export const onRequest = defineMiddleware(async (context, next) => {context.session?.set('lastVisit', newDate());return next();});
```


## Session data types


[Section titled Session data types](#session-data-types)

By default session data is untyped, and you can store arbitrary data in any key. Values are serialized and deserialized using [devalue](https://github.com/Rich-Harris/devalue), which is the same library used in content collections and actions. This means that supported types are the same, and include strings, numbers, `Date`, `Map`, `Set`, `URL`, arrays, and plain objects.

You can optionally define TypeScript types for your session data by creating a `src/env.d.ts` file and adding a declaration for the `App.SessionData` type:

src/env.d.ts

```
declarenamespace App {interface SessionData {user: {id:string;name:string;};cart:string[];}}
```

This will allow you to access the session data with type-checking and auto-completion in your editor:

src/components/CartButton.astro

```
---const cart = await Astro.session?.get('cart');// const cart: string[] | undefinedconst something = await Astro.session?.get('something');// const something: anyAstro.session?.set('user', { id: 1, name: 'Houston' });// Error: Argument of type '{ id: number; name: string }' is not assignable to parameter of type '{ id: string; name: string; }'.---
```

Caution

This is only used for type-checking and does not affect the runtime behavior of the session. Take extra care if you change the type when users have stored data in the session, as this could cause runtime errors.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 136. `en/guides/styling/.md`

```text
# Styles and CSS


---
url: https://docs.astro.build/en/guides/styling/
description: Learn how to style components in Astro with scoped styles, external CSS, and tooling like Sass and PostCSS.
---


# Styles and CSS


Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like [Tailwind](https://tailwindcss.com/docs/installation/framework-guides/astro). Advanced styling languages like [Sass](https://sass-lang.com/) and [Less](https://lesscss.org/) are also supported.


## Styling in Astro


[Section titled Styling in Astro](#styling-in-astro)

Styling an Astro component is as easy as adding a `<style>` tag to your component or page template. When you place a `<style>` tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.

src/components/MyComponent.astro

```
<style>h1 { color: red; }</style>
```


### Scoped Styles


[Section titled Scoped Styles](#scoped-styles)

Astro `<style>` CSS rules are automatically **scoped by default**. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.

This CSS:

src/pages/index.astro

```
<style>h1 {color: red;}.text {color: blue;}</style>
```

Compiles to this:

```
<style>h1[data-astro-cid-hhnqfkh6] {color: red;}.text[data-astro-cid-hhnqfkh6] {color: blue;}</style>
```

Scoped styles don’t leak and won’t impact the rest of your site. In Astro, it is okay to use low-specificity selectors like `h1 {}` or `p {}` because they will be compiled with scopes in the final output.

Scoped styles also won’t apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a `<div>` (or other element) that you can then style.

The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.


### Global Styles


[Section titled Global Styles](#global-styles)

While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the `<style is:global>` attribute.

src/components/GlobalStyles.astro

```
<styleis:global>/* Unscoped, delivered as-is to the browser.Applies to all <h1> tags on your site. */h1 { color: red; }</style>
```

You can also mix global & scoped CSS rules together in the same `<style>` tag using the `:global()` selector. This becomes a powerful pattern for applying CSS styles to children of your component.

src/components/MixedStyles.astro

```
<style>/* Scoped to this component, only. */h1 { color: red; }/* Mixed: Applies to child `h1` elements only. */article:global(h1) {color: blue;}</style><h1>Title</h1><article><slot /></article>
```

This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.

Scoped styles should be used as often as possible. Global styles should be used only as-needed.


### Combining classes with `class:list`


[Section titled Combining classes with class:list](#combining-classes-with-classlist)

If you need to combine classes on an element dynamically, you can use the `class:list` utility attribute in `.astro` files.

src/components/ClassList.astro

```
---const { isRed } = Astro.props;---<!-- If `isRed` is truthy, class will be "box red". --><!-- If `isRed` is falsy, class will be "box". --><divclass:list={['box', { red: isRed }]}><slot /></div><style>.box { border: 1pxsolidblue; }.red { border-color: red; }</style>
```

See our [directives reference](/en/reference/directives-reference/#classlist) page to learn more about `class:list`.


### CSS Variables


[Section titled CSS Variables](#css-variables)

**Added in:** `astro@0.21.0`

The Astro `<style>` can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the `define:vars` directive.

src/components/DefineVars.astro

```
---const foregroundColor = "rgb(221 243 228)";const backgroundColor = "rgb(24 121 78)";---<styledefine:vars={{ foregroundColor, backgroundColor }}>h1 {background-color: var(--backgroundColor);color: var(--foregroundColor);}</style><h1>Hello</h1>
```

See our [directives reference](/en/reference/directives-reference/#definevars) page to learn more about `define:vars`.


### Passing a `class` to a child component


[Section titled Passing a class to a child component](#passing-a-class-to-a-child-component)

In Astro, HTML attributes like `class` do not automatically pass through to child components.

Instead, accept a `class` prop in the child component and apply it to the root element. When destructuring, you must rename it, because `class` is a [reserved word](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words) in JavaScript.

Using the default scoped style strategy, you must also pass the `data-astro-cid-*` attribute. You can do this by passing the `...rest` of the props to the component. If you have changed `scopedStyleStrategy` to `'class'` or `'where'`, the `...rest` prop is not necessary.

src/components/MyComponent.astro

```
---const { class: className, ...rest } = Astro.props;---<divclass={className} {...rest}><slot/></div>
```

src/pages/index.astro

```
---import MyComponent from"../components/MyComponent.astro"---<style>.red {color: red;}</style><MyComponentclass="red">This will be red!</MyComponent>
```

Scoped styles from parent components

Because the `data-astro-cid-*` attribute includes the child in its parent’s scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.


### Inline styles


[Section titled Inline styles](#inline-styles)

You can style HTML elements inline using the `style` attribute. This can be a CSS string or an object of CSS properties:

src/pages/index.astro

```
// These are equivalent:<pstyle={{ color: "brown", textDecoration: "underline" }}>My text</p><pstyle="color: brown; text-decoration: underline;">My text</p>
```


## External Styles


[Section titled External Styles](#external-styles)

There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your `public/` directory, or hosted outside of your project.

Read more about using [static assets](/en/guides/imports/) located in `public/` or `src/`.


### Import a local stylesheet


[Section titled Import a local stylesheet](#import-a-local-stylesheet)

Using an npm package?

You may need to update your `astro.config` when importing from npm packages. See the [“import stylesheets from an npm package” section](#import-a-stylesheet-from-an-npm-package) below.

You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like [any other ESM import in an Astro component](/en/basics/astro-components/#the-component-script), which should be referenced as **relative to the component** and must be written at the **top** of your component script, with any other imports.

src/pages/index.astro

```
---// Astro will bundle and optimize this CSS for you automatically// This also works for preprocessor files like .scss, .styl, etc.import'../styles/utils.css';---<html><!-- Your page here --></html>
```

CSS `import` via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.


### Import a stylesheet from an npm package


[Section titled Import a stylesheet from an npm package](#import-a-stylesheet-from-an-npm-package)

You may also need to load stylesheets from an external npm package. This is especially common for utilities like [Open Props](https://open-props.style/). If your package **recommends using a file extension** (i.e. `package-name/styles.css` instead of `package-name/styles`), this should work like any local stylesheet:

src/pages/random-page.astro

```
---import'package-name/styles.css';---<html><!-- Your page here --></html>
```

If your package **does not suggest using a file extension** (i.e. `package-name/styles`), you’ll need to update your Astro config first!

Say you are importing a CSS file from `package-name` called `normalize` (with the file extension omitted). To ensure we can prerender your page correctly, add `package-name` to [the `vite.ssr.noExternal` array](https://vite.dev/config/ssr-options.html#ssr-noexternal):

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({vite: {ssr: {noExternal: ['package-name'],}}})
```

Note

This is a [Vite-specific setting](https://vite.dev/config/ssr-options.html#ssr-noexternal) that does *not* relate to (or require) [Astro SSR](/en/guides/on-demand-rendering/).

Now, you are free to import `package-name/normalize`. This will be bundled and optimized by Astro like any other local stylesheet.

src/pages/random-page.astro

```
---import'package-name/normalize';---<html><!-- Your page here --></html>
```


### Load a static stylesheet via “link” tags


[Section titled Load a static stylesheet via “link” tags](#load-a-static-stylesheet-via-link-tags)

You can also use the `<link>` element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your `/public` directory, or an URL to an external website. Relative `<link>` href values are not supported.

src/pages/index.astro

```
<head><!-- Local: /public/styles/global.css --><linkrel="stylesheet"href="/styles/global.css" /><!-- External --><linkrel="stylesheet"href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css" /></head>
```

Because this approach uses the `public/` directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the [Import a Stylesheet](#import-a-local-stylesheet) method above.


## Cascading Order


[Section titled Cascading Order](#cascading-order)

Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own `<style>` tag, *and* be rendered inside a layout that imports CSS.

When conflicting CSS rules apply to the same element, browsers first use *specificity* and then *order of appearance* to determine which value to show.

If one rule is more *specific* than another, no matter where the CSS rule appears, its value will take precedence:

src/components/MyComponent.astro

```
<style>h1 { color: red }div>h1 {color: purple}</style><div><h1>This header will be purple!</h1></div>
```

If two rules have the same specificity, then the *order of appearance* is evaluated, and the last rule’s value will take precedence:

src/components/MyComponent.astro

```
<style>h1 { color: purple }h1 { color: red }</style><div><h1>This header will be red!</h1></div>
```

Astro CSS rules are evaluated in this order of appearance:

-   **`<link>` tags in the head** (lowest precedence)
-   **imported styles**
-   **scoped styles** (highest precedence)


### Scoped Styles


[Section titled Scoped Styles](#scoped-styles-1)

Depending on your chosen value for [`scopedStyleStrategy`](/en/reference/configuration-reference/#scopedstylestrategy), scoped styles may or may not increase the [CLASS column specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity#class_column).

However, [scoped styles](#scoped-styles) will always come last in the order of appearance. These styles will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style’s value will apply:

src/components/make-it-purple.css

```
h1 {color: purple;}
```

src/components/MyComponent.astro

```
---import"./make-it-purple.css"---<style>h1 { color: red }</style><div><h1>This header will be red!</h1></div>
```

Scoped styles will be overwritten if the imported style is more specific. The style with a higher specificity will take precedence over the scoped style:

src/components/make-it-purple.css

```
#intro {color: purple;}
```

src/components/MyComponent.astro

```
---import"./make-it-purple.css"---<style>h1 { color: red }</style><div><h1id="intro">This header will be purple!</h1></div>
```


### Import Order


[Section titled Import Order](#import-order)

When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the *last one imported* wins:

src/components/make-it-purple.css

```
div>h1 {color: purple;}
```

src/components/make-it-green.css

```
div>h1 {color: green;}
```

src/components/MyComponent.astro

```
---import"./make-it-green.css"import"./make-it-purple.css"---<style>h1 { color: red }</style><div><h1>This header will be purple!</h1></div>
```

While `<style>` tags are scoped and only apply to the component that declares them, *imported* CSS can “leak”. Importing a component applies any CSS it imports, even if the component is never used:

src/components/PurpleComponent.astro

```
---import"./make-it-purple.css"---<div><h1>I import purple CSS.</h1></div>
```

src/components/MyComponent.astro

```
---import"./make-it-green.css"import PurpleComponent from"./PurpleComponent.astro";---<style>h1 { color: red }</style><div><h1>This header will be purple!</h1></div>
```

Tip

A common pattern in Astro is to import global CSS inside a [Layout component](/en/basics/layouts/). Be sure to import the Layout component before other imports so that it has the lowest precedence.


### Link Tags


[Section titled Link Tags](#link-tags)

Style sheets loaded via [link tags](#load-a-static-stylesheet-via-link-tags) are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:

src/pages/index.astro

```
---import"../components/make-it-purple.css"---<htmllang="en"><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><metaname="generator"content={Astro.generator} /><title>Astro</title><linkrel="stylesheet"href="/styles/make-it-blue.css" /></head><body><div><h1>This will be purple</h1></div></body></html>
```


## Tailwind


[Section titled Tailwind](#tailwind)

Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like [Tailwind](https://tailwindcss.com) and more!

Astro supports both Tailwind 3 and 4. You can [add Tailwind 4 support through a Vite plugin](#add-tailwind-4) to your project with a CLI command, or install legacy dependencies manually to add [Tailwind 3 support through an Astro integration](#legacy-tailwind-3-support).

To [upgrade your Astro project from Tailwind 3 to 4](#upgrade-from-tailwind-3) you will need to both add Tailwind 4 support, and remove legacy Tailwind 3 support.


### Add Tailwind 4


[Section titled Add Tailwind 4](#add-tailwind-4)

In Astro `>=5.2.0`, use the `astro add tailwind` command for your package manager to install the official Vite Tailwind plugin. To add Tailwind 4 support to earlier versions of Astro, follow the [instructions in the Tailwind docs](https://tailwindcss.com/docs/installation/framework-guides/astro) to add the `@tailwindcss/vite` Vite plugin manually.

-   [npm](#tab-panel-1807)
-   [pnpm](#tab-panel-1808)
-   [Yarn](#tab-panel-1809)

Terminal window

```
npxastroaddtailwind
```

Terminal window

```
pnpmastroaddtailwind
```

Terminal window

```
yarnastroaddtailwind
```

Then, import `tailwindcss` into `src/styles/global.css` (or another CSS file of your choosing) to make Tailwind classes available to your Astro project. This file including the import will be created by default if you used the `astro add tailwind` command to install the Vite plugin.

src/styles/global.css

```
@import"tailwindcss";
```

Import this file in the pages where you want Tailwind to apply. This is often done in a layout component so that Tailwind styles can be used on all pages sharing that layout:

src/layouts/Layout.astro

```
---import"../styles/global.css";---
```


### Upgrade from Tailwind 3


[Section titled Upgrade from Tailwind 3](#upgrade-from-tailwind-3)

Follow the steps to update an existing Astro project using Tailwind v3 (using the `@astrojs/tailwind` integration) to Tailwind 4 (using [the `@tailwindcss/vite` plugin](https://tailwindcss.com/docs/installation/framework-guides/astro)).

1.  [Add Tailwind 4 support to your project](#add-tailwind-4) through the CLI for the latest version of Astro, or by adding the Vite plugin manually.

2.  Uninstall the `@astrojs/tailwind` integration from your project:

    -   [npm](#tab-panel-1810)
    -   [pnpm](#tab-panel-1811)
    -   [Yarn](#tab-panel-1812)

    Terminal window

    ```
    npmuninstall@astrojs/tailwind
    ```

    Terminal window

    ```
    pnpmremove@astrojs/tailwind
    ```

    Terminal window

    ```
    yarnremove@astrojs/tailwind
    ```

3.  Remove the `@astrojs/tailwind` integration from your `astro.config.mjs`:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import tailwind from'@astrojs/tailwind';exportdefaultdefineConfig({// ...integrations: [tailwind()],// ...});
    ```

4.  Then, upgrade your project according to [Tailwind’s v4 upgrade guide](https://tailwindcss.com/docs/upgrade-guide#changes-from-v3).



### Legacy Tailwind 3 support


[Section titled Legacy Tailwind 3 support](#legacy-tailwind-3-support)

To add (or keep) support for Tailwind 3, you will need to have both `tailwindcss@3` and the official Astro Tailwind integration `@astrojs/tailwind` installed. Installing these dependencies manually is only used for legacy Tailwind 3 compatibility, and is not required for Tailwind 4. You will also need a [legacy Tailwind configuration](https://v3.tailwindcss.com/docs/configuration#creating-your-configuration-file):

1.  Install Tailwind and the Astro Tailwind integration to your project dependencies using your preferred package manager:

    -   [npm](#tab-panel-1813)
    -   [pnpm](#tab-panel-1814)
    -   [Yarn](#tab-panel-1815)

    Terminal window

    ```
    npminstalltailwindcss@3@astrojs/tailwind
    ```

    Terminal window

    ```
    pnpmaddtailwindcss@3@astrojs/tailwind
    ```

    Terminal window

    ```
    yarnaddtailwindcss@3@astrojs/tailwind
    ```

2.  Import the integration to your `astro.config.mjs` file, and add it to your `integrations[]` array:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import tailwind from'@astrojs/tailwind';exportdefaultdefineConfig({// ...integrations: [tailwind()],// ...});
    ```

3.  Create a `tailwind.config.mjs` file in your project’s root directory. You can use the following command to generate a basic configuration file for you:

    -   [npm](#tab-panel-1816)
    -   [pnpm](#tab-panel-1817)
    -   [Yarn](#tab-panel-1818)

    Terminal window

    ```
    npxtailwindcssinit
    ```

    Terminal window

    ```
    pnpmdlxtailwindcssinit
    ```

    Terminal window

    ```
    yarndlxtailwindcssinit
    ```

4.  Add the following basic configuration to your `tailwind.config.mjs` file:

    tailwind.config.mjs

    ```
    /** @type{import('tailwindcss').Config} */exportdefault {content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],theme: {extend: {},},plugins: [],};
    ```


**Related recipe:** [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/)


## CSS Preprocessors


[Section titled CSS Preprocessors](#css-preprocessors)

Astro supports CSS preprocessors such as [Sass](https://sass-lang.com/), [Stylus](https://stylus-lang.com/), and [Less](https://lesscss.org/) through [Vite](https://vite.dev/guide/features.html#css-pre-processors).


### Sass and SCSS


[Section titled Sass and SCSS](#sass-and-scss)

Terminal window

```
npminstallsass
```

Use `<style lang="scss">` or `<style lang="sass">` in `.astro` files.


### Stylus


[Section titled Stylus](#stylus)

Terminal window

```
npminstallstylus
```

Use `<style lang="styl">` or `<style lang="stylus">` in `.astro` files.


### Less


[Section titled Less](#less)

Terminal window

```
npminstallless
```

Use `<style lang="less">` in `.astro` files.


### LightningCSS


[Section titled LightningCSS](#lightningcss)

Terminal window

```
npminstalllightningcss
```

Update your `vite` configuration in `astro.config.mjs`:

astro.config.mjs

```
import { defineConfig } from'astro/config'exportdefaultdefineConfig({vite: {css: {transformer: "lightningcss",},},})
```


### In framework components


[Section titled In framework components](#in-framework-components)

You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:

-   **React** / **Preact**: `import Styles from './styles.module.scss';`
-   **Vue**: `<style lang="scss">`
-   **Svelte**: `<style lang="scss">`


## PostCSS


[Section titled PostCSS](#postcss)

Astro comes with PostCSS included as part of [Vite](https://vite.dev/guide/features.html#postcss). To configure PostCSS for your project, create a `postcss.config.cjs` file in the project root. You can import plugins using `require()` after installing them (for example `npm install autoprefixer`).

postcss.config.cjs

```
module.exports= {plugins: [require('autoprefixer'),require('cssnano'),],};
```


## Frameworks and Libraries


[Section titled Frameworks and Libraries](#frameworks-and-libraries)


### 📘 React / Preact


[Section titled 📘 React / Preact](#-react--preact)

`.jsx` files support both global CSS and CSS Modules. To enable the latter, use the `.module.css` extension (or `.module.scss`/`.module.sass` if using Sass).

src/components/MyReactComponent.jsx

```
import'./global.css'; // include global CSSimport Styles from'./styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
```


### 📗 Vue


[Section titled 📗 Vue](#-vue)

Vue in Astro supports the same methods as `vue-loader` does:

-   [vue-loader - Scoped CSS](https://vue-loader.vuejs.org/guide/scoped-css.html)
-   [vue-loader - CSS Modules](https://vue-loader.vuejs.org/guide/css-modules.html)


### 📕 Svelte


[Section titled 📕 Svelte](#-svelte)

Svelte in Astro also works exactly as expected: [Svelte Styling Docs](https://svelte.dev/docs#component-format-style).


## Markdown Styling


[Section titled Markdown Styling](#markdown-styling)

Any Astro styling methods are available to a [Markdown layout component](/en/basics/layouts/#markdown-layouts), but different methods will have different styling effects on your page.

You can apply global styles to your Markdown content by adding [imported stylesheets](#external-styles) to the layout that wraps your page content. It is also possible to style your Markdown with [`<style is:global>` tags](#global-styles) in the layout component. Note that any styles added are subject to [Astro’s cascading order](#cascading-order), and you should check your rendered page carefully to ensure your styles are being applied as intended.

You can also add CSS integrations including [Tailwind](/en/recipes/tailwind-rendered-markdown/). If you are using Tailwind, the [typography plugin](https://tailwindcss.com/docs/typography-plugin) can be useful for styling Markdown.


## Production


[Section titled Production](#production)


### Bundle control


[Section titled Bundle control](#bundle-control)

When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.

However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as `<link rel="stylesheet">` tags, while inlining smaller ones into `<style type="text/css">`. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.

You can configure the size at which stylesheets will be linked externally (in bytes) using the `assetsInlineLimit` vite build option. Note that this option affects script and image inlining as well.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({vite: {build: {assetsInlineLimit: 1024,}};});
```

If you would rather all project styles remain external, you can configure the `inlineStylesheets` build option.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({build: {inlineStylesheets: 'never'}});
```

You can also set this option to `'always'` which will inline all stylesheets.


## Advanced


[Section titled Advanced](#advanced)

Caution

Be careful when bypassing Astro’s built-in CSS bundling! Styles won’t be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.


### `?raw` CSS Imports


[Section titled ?raw CSS Imports](#raw-css-imports)

For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro’s automatic CSS handling.

This is not recommended for most users.

src/components/RawInlineStyles.astro

```
---// Advanced example! Not recommended for most users.import rawStylesCSS from'../styles/main.css?raw';---<styleis:inlineset:html={rawStylesCSS}></style>
```

See [Vite’s docs](https://vite.dev/guide/assets.html#importing-asset-as-string) for full details.


### `?url` CSS Imports


[Section titled ?url CSS Imports](#url-css-imports)

For advanced use cases, you can import a direct URL reference for a CSS file inside of your project `src/` directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .

This is not recommended for most users. Instead, place your CSS files inside of `public/` to get a consistent URL reference.

Caution

Importing a smaller CSS file with `?url` may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (`data:text/css;base64,...`) or set the [`vite.build.assetsInlineLimit`](https://vite.dev/config/#build-assetsinlinelimit) config option to `0` to disable this feature.

src/components/RawStylesUrl.astro

```
---// Advanced example! Not recommended for most users.import stylesUrl from'../styles/main.css?url';---<linkrel="preload"href={stylesUrl}as="style"><linkrel="stylesheet"href={stylesUrl}>
```

See [Vite’s docs](https://vite.dev/guide/assets.html#importing-asset-as-url) for full details.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 137. `en/guides/syntax-highlighting/.md`

```text
# Syntax Highlighting


---
url: https://docs.astro.build/en/guides/syntax-highlighting/
description: Learn how to highlight your code blocks in Astro.
---


# Syntax Highlighting


Astro comes with built-in support for [Shiki](https://shiki.style/) and [Prism](https://prismjs.com/). This provides syntax highlighting for:

-   all [code fences (\`\`\`)](#markdown-code-blocks) used in a Markdown or MDX file.
-   content within the [built-in `<Code />` component](#code-) (powered by Shiki) in `.astro` files.
-   content within the [`<Prism />` component](#prism-) (powered by Prism) in `.astro` files.

Add [community integrations such as Expressive Code](https://astro.build/integrations/?search=syntax+highlight) for even more text marking and annotation options in your code blocks.


## Markdown code blocks


[Section titled Markdown code blocks](#markdown-code-blocks)

A Markdown code block is indicated by a block with three backticks \`\`\` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read.

```
```js// Javascript code with syntax highlighting.var fun = function lang(l) {dateformat.i18n = require('./lang/' + l);return true;};```
```

Astro’s Markdown code blocks are styled by Shiki by default, preconfigured with the `github-dark` theme. The compiled output will be limited to inline `style`s without any extraneous CSS classes, stylesheets, or client-side JS.

You can [add a Prism stylesheet and switch to Prism’s highlighting](#add-a-prism-stylesheet), or disable Astro’s syntax highlighting entirely, with the [`markdown.syntaxHighlight`](/en/reference/configuration-reference/#markdownsyntaxhighlight) configuration option.

See the full [`markdown.shikiConfig` reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown syntax highlighting options available when using Shiki.


### Setting a default Shiki theme


[Section titled Setting a default Shiki theme](#setting-a-default-shiki-theme)

You can configure any [built-in Shiki theme](https://shiki.style/themes) for your Markdown code blocks in your Astro config:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {shikiConfig: {theme: 'dracula',},},});
```

See the full [Shiki config reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options.


### Setting light and dark mode themes


[Section titled Setting light and dark mode themes](#setting-light-and-dark-mode-themes)

You can specify dual Shiki themes for light and dark mode in your Astro config:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {shikiConfig: {themes: {light: 'github-light',dark: 'github-dark',},},},});
```

Then, [add Shiki’s dark mode CSS variables via media query or classes](https://shiki.style/guide/dual-themes#query-based-dark-mode) to apply to all your Markdown code blocks by default. Replace the `.shiki` class in the examples from Shiki’s documentation with `.astro-code`:

src/styles/global.css

```
@media(prefers-color-scheme: dark) {.shiki,.shikispan {.astro-code,.astro-codespan {color: var(--shiki-dark) !important;background-color: var(--shiki-dark-bg) !important;/* Optional, if you also want font styles */font-style: var(--shiki-dark-font-style) !important;font-weight: var(--shiki-dark-font-weight) !important;text-decoration: var(--shiki-dark-text-decoration) !important;}}
```

See the full [Shiki config reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options.


### Adding your own Shiki theme


[Section titled Adding your own Shiki theme](#adding-your-own-shiki-theme)

Instead of using one of Shiki’s predefined themes, you can import a custom Shiki theme from a local file.

astro.config.mjs

```
import { defineConfig } from'astro/config';import customTheme from'./my-shiki-theme.json';exportdefaultdefineConfig({markdown: {shikiConfig: {theme: customTheme,},},});
```


### Customizing Shiki themes


[Section titled Customizing Shiki themes](#customizing-shiki-themes)

You can follow [Shiki’s own theme documentation](https://shiki.style/themes) for more customization options for themes, [light vs dark mode toggles](https://shiki.style/guide/dual-themes), or styling via [CSS variables](https://shiki.style/guide/theme-colors#css-variables-theme).

You will need to adjust the examples from Shiki’s documentation for your Astro project by making the following substitutions:

-   Code blocks are styled using the `.astro-code` class instead of `.shiki`
-   When using the `css-variables` theme, custom properties are prefixed with `--astro-code-` instead of `--shiki-`


## Components for code blocks


[Section titled Components for code blocks](#components-for-code-blocks)

There are two Astro components available for `.astro` and `.mdx` files to render code blocks: [`<Code />`](#code-) and [`<Prism />`](#prism-).

You can reference the `Props` of these components using the [`ComponentProps` type](/en/guides/typescript/#componentprops-type) utility.


### `<Code />`


[Section titled &lt;Code /&gt;](#code-)

This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, [transformers](#transformers), and default colors.

These values are passed to the `<Code />` component using the `theme`, `lang`, `transformers`, and `defaultColor` attributes respectively as props. The `<Code />` component will not inherit your `shikiConfig` settings for Markdown code blocks.

```
---import { Code } from'astro:components';---<!-- Syntax highlight some JavaScript code. --><Codecode={`const foo = 'bar';`}lang="js" /><!-- Optional: Customize your theme. --><Codecode={`const foo = 'bar';`}lang="js"theme="dark-plus" /><!-- Optional: Enable word wrapping. --><Codecode={`const foo = 'bar';`}lang="js"wrap /><!-- Optional: Output inline code. --><p><Codecode={`const foo = 'bar';`}lang="js"inline />will be rendered inline.</p><!-- Optional: defaultColor --><Codecode={`const foo = 'bar';`}lang="js"defaultColor={false} />
```


#### Transformers


[Section titled Transformers](#transformers)

**Added in:** `astro@4.11.0`

[Shiki transformers](https://shiki.style/packages/transformers#shikijs-transformers) can optionally be applied to code by passing them in through the `transformers` property as an array. Since Astro v4.14.0, you can also provide a string for [Shiki’s `meta` attribute](https://shiki.style/guide/transformers#meta) to pass options to transformers.

Note that `transformers` only applies classes and you must provide your own CSS rules to target the elements of your code block.

src/pages/index.astro

```
---import { transformerNotationFocus, transformerMetaHighlight } from'@shikijs/transformers'import { Code } from'astro:components'const code = `const foo = 'hello'const bar = ' world'console.log(foo + bar) // [!code focus]`---<Codecode={code}lang="js"transformers={[transformerMetaHighlight()]}meta="{1,3}"/><styleis:global>pre.has-focused.line:not(.focused) {filter: blur(1px);}</style>
```


### `<Prism />`


[Section titled &lt;Prism /&gt;](#prism-)

This component provides language-specific syntax highlighting for code blocks by applying Prism’s CSS classes. Note that you must [provide a Prism CSS stylesheet](#add-a-prism-stylesheet) (or bring your own) to style the classes.

To use the `Prism` highlighter component, you must install the `@astrojs/prism` package:

-   [npm](#tab-panel-1804)
-   [pnpm](#tab-panel-1805)
-   [Yarn](#tab-panel-1806)

Terminal window

```
npminstall@astrojs/prism
```

Terminal window

```
pnpmadd@astrojs/prism
```

Terminal window

```
yarnadd@astrojs/prism
```

Then, you can import and use the `<Prism />` component like any other Astro component, passing a language and the code to render.

```
---import { Prism } from'@astrojs/prism';---<Prismlang="js"code={`const foo = 'bar';`} />
```

In addition to the [list of languages supported by Prism](https://prismjs.com/#supported-languages), you can also use `lang="astro"` to display Astro code blocks.


## Add a Prism stylesheet


[Section titled Add a Prism stylesheet](#add-a-prism-stylesheet)

If you opt to use Prism (either by configuring `markdown.syntaxHighlight: 'prism'` or with the `<Prism />` component), Astro will apply Prism’s CSS classes instead of Shiki’s to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear.

1.  Choose a premade stylesheet from the available [Prism Themes](https://github.com/PrismJS/prism-themes).

2.  Add this stylesheet to [your project’s `public/` directory](/en/basics/project-structure/#public).

3.  Load this into your page’s `<head>` in a [layout component](/en/basics/layouts/) via a `<link>` tag. (See [Prism basic usage](https://prismjs.com/#basic-usage).)


You can also visit the [list of languages supported by Prism](https://prismjs.com/#supported-languages) for options and usage.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 138. `en/guides/testing/.md`

```text
# Testing


---
url: https://docs.astro.build/en/guides/testing/
description: An intro to testing in Astro
---


# Testing


Testing helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, [Cypress](https://cypress.io) and [Playwright](https://playwright.dev). You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.

Testing frameworks allow you to state **assertions** or **expectations** about how your code should behave in specific situations, then compare these to the actual behavior of your current code.


## Unit and integration tests


[Section titled Unit and integration tests](#unit-and-integration-tests)


### Vitest


[Section titled Vitest](#vitest)

A Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.

Use Astro’s `getViteConfig()` helper in your [`vitest.config.ts` configuration file](https://vitest.dev/config/) to set up Vitest with your Astro project’s settings:

vitest.config.ts

```
/// <reference types="vitest"/>import { getViteConfig } from'astro/config';exportdefaultgetViteConfig({test: {// Vitest configuration options},});
```

By default, `getViteConfig()` will try to load an Astro config file in your project and apply it to the test environment. As of Astro 4.8, if you need to customize the Astro configuration applied in your tests, pass a second argument to `getViteConfig()`:

```
exportdefaultgetViteConfig({ test: { /* Vitest configuration options */ } },{site: 'https://example.com/',trailingSlash: 'always',},);
```

See the [Astro + Vitest starter template](https://github.com/withastro/astro/tree/latest/examples/with-vitest) on GitHub.


#### Vitest and Container API


[Section titled Vitest and Container API](#vitest-and-container-api)

**Added in:** `astro@4.9.0`

You can natively test Astro components using the [container API](/en/reference/container-reference/). First, setup [`vitest` as explained above](#vitest), then create a `.test.js` file to test your component:

example.test.js

```
import { experimental_AstroContaineras AstroContainer } from'astro/container';import { expect, test } from'vitest';import Card from'../src/components/Card.astro';test('Card with slots', async()=> {const container = await AstroContainer.create();const result = await container.renderToString(Card, {slots: {default: 'Card content',},});expect(result).toContain('This is a card');expect(result).toContain('Card content');});
```


## End-to-end tests


[Section titled End-to-end tests](#end-to-end-tests)


### Playwright


[Section titled Playwright](#playwright)

Playwright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.


#### Installation


[Section titled Installation](#installation)

You can get started and run your tests using the [VS Code Extension](https://playwright.dev/docs/getting-started-vscode).

Alternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.

-   [npm](#tab-panel-1819)
-   [pnpm](#tab-panel-1820)
-   [Yarn](#tab-panel-1821)

Terminal window

```
npminitplaywright@latest
```

Terminal window

```
pnpmcreateplaywright
```

Terminal window

```
yarncreateplaywright
```


#### Create your first Playwright test


[Section titled Create your first Playwright test](#create-your-first-playwright-test)

1.  Choose a page to test. This example will test the example page `index.astro` below.

    src/pages/index.astro

    ```
    ------<htmllang="en"><head><title>Astro is awesome!</title><metaname="description"content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." /></head><body></body></html>
    ```

2.  Create a new folder and add the following test file in `src/test`. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page `<title>` to match the page you are testing.

    src/test/index.spec.ts

    ```
    import { test, expect } from'@playwright/test';test('meta is correct', async({ page })=> {awaitpage.goto("http://localhost:4321/");awaitexpect(page).toHaveTitle('Astro is awesome!');});
    ```

    Set a `baseUrl`

    You can set [`"baseURL": "http://localhost:4321"`](https://playwright.dev/docs/api/class-testoptions#test-options-base-url) in the `playwright.config.ts` configuration file to use `page.goto("/")` instead of `page.goto("http://localhost:4321/")` for a more convenient URL.



#### Running your Playwright tests


[Section titled Running your Playwright tests](#running-your-playwright-tests)

You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.

1.  To run our test from the previous example using the command line, use the `test` command. Optionally, include the file name to run just the single test:

    Terminal window

    ```
    npxplaywrighttestindex.spec.ts
    ```

2.  To see the full HTML Test Report, open it using the following command:

    Terminal window

    ```
    npxplaywrightshow-report
    ```


Tip

Run your tests against your production code to more closely resemble your live, deployed site.


##### Advanced: Launching a development web server during the tests


[Section titled Advanced: Launching a development web server during the tests](#advanced-launching-a-development-web-server-during-the-tests)

You can also have Playwright start your server when you run your testing script by using the [`webServer`](https://playwright.dev/docs/test-advanced#launching-a-development-web-server-during-the-tests) option in the Playwright configuration file.

Here is an example of the configuration and commands required when using npm:

1.  Add a test script to your `package.json` file in the project root, such as `"test:e2e": "playwright test"`.

2.  In `playwright.config.ts`, add the `webServer` object and update the command value to `npm run preview`.

    playwright.config.ts

    ```
    import { defineConfig } from'@playwright/test';exportdefaultdefineConfig({webServer: {command: 'npm run preview',url: 'http://localhost:4321/',timeout: 120*1000,reuseExistingServer: !process.env.CI,},use: {baseURL: 'http://localhost:4321/',},});
    ```

3.  Run `npm run build`, then run `npm run test:e2e` to run the Playwright tests.


More information about Playwright can be found in the links below:

-   [Getting started with Playwright](https://playwright.dev/docs/intro)
-   [Use a development server](https://playwright.dev/docs/test-webserver#configuring-a-web-server)


### Cypress


[Section titled Cypress](#cypress)

Cypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.


#### Installation


[Section titled Installation](#installation-1)

You can install Cypress using the package manager of your choice. This will install Cypress locally as a dev dependency for your project.

-   [npm](#tab-panel-1822)
-   [pnpm](#tab-panel-1823)
-   [Yarn](#tab-panel-1824)

Terminal window

```
npminstallcypress--save-dev
```

Terminal window

```
pnpmadd--save-devcypress
```

Terminal window

```
yarnaddcypress--dev
```


#### Configuration


[Section titled Configuration](#configuration)

In the root of your project, create a `cypress.config.js` file with the following content:

cypress.config.js

```
import { defineConfig } from'cypress'exportdefaultdefineConfig({e2e: {supportFile: false}})
```


#### Create your first Cypress test


[Section titled Create your first Cypress test](#create-your-first-cypress-test)

1.  Choose a page to test. This example will test the example page `index.astro` below.

    src/pages/index.astro

    ```
    ------<htmllang="en"><head><title>Astro is awesome!</title><metaname="description"content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." /></head><body><h1>Hello world from Astro</h1></body></html>
    ```

2.  Create an `index.cy.js` file in the `cypress/e2e` folder. Use the following test in the file to verify that the page title and header are correct.

    cypress/e2e/index.cy.js

    ```
    it('titles are correct', ()=> {const page = cy.visit('http://localhost:4321');page.get('title').should('have.text', 'Astro is awesome!')page.get('h1').should('have.text', 'Hello world from Astro');});
    ```

    Set a `baseUrl`

    You can set [`"baseUrl": "http://localhost:4321"`](https://docs.cypress.io/guides/end-to-end-testing/testing-your-app#Step-3-Configure-Cypress) in the `cypress.config.js` configuration file to use `cy.visit("/")` instead of `cy.visit("http://localhost:4321/")` for a more convenient URL.



#### Running your Cypress tests


[Section titled Running your Cypress tests](#running-your-cypress-tests)

Cypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.

First, start the dev server so Cypress can access your live site.

To run our test from the previous example using the command line, execute the following command:

Terminal window

```
npxcypressrun
```

Alternatively, to run the test using the Cypress App, execute the following command:

Terminal window

```
npxcypressopen
```

Once the Cypress App is launched, choose **E2E Testing**, then select the browser to be used to run tests.

Once the test run is finished, you should see green check marks in the output confirming that your test passed:

Output from npx cypress run

```
Running:index.cy.js                                                                     (1 of1)✓titlesarecorrect (107ms)1passing (1s)
```

Fail the test

To check that your test really does work, you can change the following line in the `index.astro` file:

src/pages/index.astro

```
<body><h1>Hello world from Astro</h1><h1>Hello from Astro</h1></body>
```

Then run the test again. You should see a red “x” in the output confirming that your test failed.


#### Next steps


[Section titled Next steps](#next-steps)

More information about Cypress can be found in the links below:

-   [Introduction to Cypress](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress)
-   [Testing Your App](https://docs.cypress.io/guides/end-to-end-testing/testing-your-app)


### NightwatchJS


[Section titled NightwatchJS](#nightwatchjs)

Nightwatch.js is a test automation framework with a powerful set of tools to write, run, and debug your tests across the web with built-in support for all major browsers and their mobile equivalents, as well as native mobile applications.


#### Installation


[Section titled Installation](#installation-2)

You can install NightwatchJS within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and select whether or not to include component testing and testing on mobile browsers.

-   [npm](#tab-panel-1825)
-   [pnpm](#tab-panel-1826)
-   [Yarn](#tab-panel-1827)

Terminal window

```
npminitnightwatch@latest
```

Terminal window

```
pnpmcreatenightwatch
```

Terminal window

```
yarncreatenightwatch
```


#### Create your first Nightwatch test


[Section titled Create your first Nightwatch test](#create-your-first-nightwatch-test)

1.  Choose a page to test. This example will test the example page `index.astro` below.

    src/pages/index.astro

    ```
    ------<htmllang="en"><head><title>Astro is awesome!</title><metaname="description"content="Pull content from anywhere and serve it fast with Astro's next-gen islands architecture." /></head><body></body></html>
    ```

2.  Create a new folder `src/test/` and add the following test file:

    src/test/index.js

    ```
    describe('Astro testing with Nightwatch', function() {before(browser=>browser.navigateTo('http://localhost:4321/'));it("check that the title is correct",function(browser) {browser.assert.titleEquals('Astro is awesome!')});after(browser=>browser.end());});
    ```

    Set a `baseUrl`

    You can set [`"baseURL": "http://localhost:4321"`](https://nightwatchjs.org/guide/reference/settings.html#setting-the-baseurl-property) in the `nightwatch.conf.js` configuration file to use `browser.navigateTo("/")` instead of `browser.navigateTo("http://localhost:4321/")` for a more convenient URL.



#### Running your NightwatchJS tests


[Section titled Running your NightwatchJS tests](#running-your-nightwatchjs-tests)

You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.

You can run the tests with the [NightwatchJS VSCode Extension](https://marketplace.visualstudio.com/items?itemName=browserstackcom.nightwatch) or using the CLI steps below:

1.  To run all tests, enter the following command in the terminal. Optionally, include the file name to run just the single test:

    Terminal window

    ```
    npxnightwatchtest/index.js
    ```

    Additionally, you can run the tests against a specific browser using the `--environment` or `-e` CLI argument. If you don’t have the relevant browser installed, Nightwatch will attempt to set it up for you using [Selenium Manager](https://www.selenium.dev/blog/2022/introducing-selenium-manager/):

    Terminal window

    ```
    npxnightwatchtest/index.ts-efirefox
    ```

2.  To see the full HTML Test Report, open it using the following command:

    Terminal window

    ```
    npxnightwatchtest/index.ts--open
    ```


Tip

Run your tests against your production code to more closely resemble your live, deployed site.

More information about NightwatchJS can be found in the links below:

-   [Intro to Nightwatch](https://nightwatchjs.org/guide/overview/what-is-nightwatch.html)
-   [Testing with Nightwatch](https://nightwatchjs.org/guide/writing-tests/introduction.html)

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 139. `en/guides/troubleshooting/.md`

```text
# Troubleshooting


---
url: https://docs.astro.build/en/guides/troubleshooting/
description: Need help? Stuck on something? We've got you covered.
---


# Troubleshooting


Astro provides several different tools to help you troubleshoot and debug your code.


## Tips and tricks


[Section titled Tips and tricks](#tips-and-tricks)


### Debugging with `console.log()`


[Section titled Debugging with console.log()](#debugging-with-consolelog)

`console.log()` is a simple-but-popular method of debugging your Astro code. Where you write your `console.log()` statement will determine where your debugging output is printed:

```
---console.log('Hi! I’m the server. This is logged in the terminal where Astro is running.');---<script>console.log('Hi! I’m the client. This is logged in browser dev console.');</script>
```

A `console.log()` statement in Astro frontmatter will always output to the **terminal** running the Astro CLI. This is because Astro runs on the server, and never in the browser.

Code that is written or imported inside of an Astro `<script>` tag is run in the browser. Any `console.log()` statements or other debug output will be printed to the **console in your browser**.


### Debugging framework components


[Section titled Debugging framework components](#debugging-framework-components)

[Framework components](/en/guides/framework-components/) (like React and Svelte) are unique: They render server-side by default, meaning that `console.log()` debug output will be visible in the terminal. However, they can also be hydrated for the browser, which may cause your debug logs to also appear in the browser.

This can be useful for debugging differences between the server output and the hydrated components in the browser.


### Astro `<Debug />` component


[Section titled Astro &lt;Debug /&gt; component](#astro-debug--component)

To help you debug your Astro components, Astro provides a built-in `<Debug />` component which renders any value directly into your component HTML template.

This component provides a way to inspect values on the client-side, without any JavaScript. It can be useful for quick debugging in the browser without having to flip back-and-forth between your terminal and your browser.

```
---import { Debug } from'astro:components';const sum = (a, b) => a + b;---<!-- Example: Outputs {answer: 6} to the browser --><Debuganswer={sum(2, 4)} />
```

The Debug component supports a variety of syntax options for even more flexible and concise debugging:

```
---import { Debug } from'astro:components';const sum = (a, b) => a + b;const answer = sum(2, 4);---<!-- Example: All three examples are equivalent. --><Debuganswer={sum(2, 4)} /><Debug {{answer: sum(2, 4)}} /><Debug {answer} />
```


## Common Error Messages


[Section titled Common Error Messages](#common-error-messages)

Here are some common error messages you might see in the terminal, what they might mean, and what to do about them. See our [full error reference guide](/en/reference/error-reference/) for a complete list of Astro errors you may encounter.


### Cannot use import statement outside a module


[Section titled Cannot use import statement outside a module](#cannot-use-import-statement-outside-a-module)

In Astro components, `<script>` tags are loaded as [JS modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) by default. If you have included the [`is:inline` directive](/en/reference/directives-reference/#isinline) or any other attribute in your tag, this default behavior is removed.

**Solution**: If you have added any attributes to your `<script>` tag, you must also add the `type="module"` attribute to be able to use import statements.

**Status**: Expected Astro behavior, as intended.

**Not sure that this is your problem?** Check to see if anyone else has reported [this issue](https://github.com/withastro/astro/issues?q=is%3Aissue+is%3Aopen+Cannot+use+import+statement)!


### `document` (or `window`) is not defined


[Section titled document (or window) is not defined](#document-or-window-is-not-defined)

This error occurs when trying to access `document` or `window` on the server.

Astro components run on the server, so you can’t access these browser-specific objects within the frontmatter.

Framework components run on the server by default, so this error can occur when accessing `document` or `window` during rendering.

**Solution**: Determine the code that calls `document` or `window`. If you aren’t using `document` or `window` directly and still getting this error, check to see if any packages you’re importing are meant to run on the client.

-   If the code is in an Astro component, move it to a `<script>` tag outside of the frontmatter. This tells Astro to run this code on the client, where `document` and `window` are available.

-   If the code is in a framework component, try to access these objects after rendering using lifecycle methods (e.g. [`useEffect()`](https://react.dev/reference/react/useEffect) in React, [`onMounted()`](https://vuejs.org/api/composition-api-lifecycle.html#onmounted) in Vue, and [`onMount()`](https://svelte.dev/docs#run-time-svelte-onmount) in Svelte). Tell the framework component to hydrate client-side by using a [client:](/en/reference/directives-reference/#client-directives) directive, like `client:load`, to run these lifecycle methods. You can also prevent the component from rendering on the server at all by adding the [`client:only`](/en/reference/directives-reference/#clientonly) directive.


**Status**: Expected Astro behavior, as intended.


### Expected a default export


[Section titled Expected a default export](#expected-a-default-export)

This error can be thrown when trying to import or render an invalid component, or one that is not working properly. (This particular message occurs because of the way importing a UI component works in Astro.)

**Solution**: Try looking for errors in any component you are importing and rendering, and make sure it’s working correctly. Consider opening an Astro starter template from [astro.new](https://astro.new) and troubleshooting just your component in a minimal Astro project.

**Status**: Expected Astro behavior, as intended.


### Refused to execute inline script


[Section titled Refused to execute inline script](#refused-to-execute-inline-script)

You may see the following error logged in the browser console:

> Refused to execute inline script because it violates the following Content Security Policy directive: …

This means that your site’s [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) (CSP) disallows running inline `<script>` tags, which Astro outputs by default.

**Solution:** Update your CSP to include `script-src: 'unsafe-inline'` to allow inline scripts to run. Alternatively, you can use a third-party integration such as [`astro-shield`](https://github.com/KindSpells/astro-shield) to generate the CSP headers for you.


## Common gotchas


[Section titled Common gotchas](#common-gotchas)


### My component is not rendering


[Section titled My component is not rendering](#my-component-is-not-rendering)

First, check to see that you have **imported the component** in your [`.astro` component script](/en/basics/astro-components/#the-component-script) or [`.mdx` file](/en/guides/integrations-guide/mdx/#using-components-in-mdx).

Then check your import statement:

-   Is your import linking to the wrong place? (Check your import path.)

-   Does your import have the same name as the imported component? (Check your component name and that it [follows the `.astro` syntax](/en/reference/astro-syntax/#differences-between-astro-and-jsx).)

-   Have you included the extension in the import? (Check that your imported file contains an extension. e.g. `.astro`, `.md`, `.vue`, `.svelte`. Note: File extensions are **not** required for `.js(x)` and `.ts(x)` files only.)



### My component is not interactive


[Section titled My component is not interactive](#my-component-is-not-interactive)

If your component is rendering (see above) but is not responding to user interaction, then you may be missing a [`client:*` directive](/en/reference/directives-reference/#client-directives) to hydrate your component.

By default, a [UI Framework component is not hydrated in the client](/en/guides/framework-components/#hydrating-interactive-components). If no `client:*` directive is provided, its HTML is rendered onto the page without JavaScript.

Tip

[Astro components](/en/basics/astro-components/) are HTML-only templating components with no client-side runtime. But, you can use a `<script>` tag in your Astro component template to send JavaScript to the browser that executes in the global scope.


### Cannot find package ‘X’


[Section titled Cannot find package ‘X’](#cannot-find-package-x)

If you see a `"Cannot find package 'react'"` (or similar) warning when you start up Astro, that means that you need to install that package into your project. Not all package managers will install peer dependencies for you automatically. If you are on Node v16+ and using npm, you should not need to worry about this section.

React, for example, is a peer dependency of the `@astrojs/react` integration. That means that you should install the official `react` and `react-dom` packages alongside your integration. The integration will then pull from these packages automatically.

Terminal window

```

# Example: Install integrations and frameworks togethernpminstall@astrojs/reactreactreact-dom

```

See [Astro’s integration guide](/en/guides/integrations-guide/) for instructions on adding framework renderers, CSS tools and other packages to Astro.


### Using Astro with Yarn 2+ (Berry)


[Section titled Using Astro with Yarn 2+ (Berry)](#using-astro-with-yarn-2-berry)

Yarn 2+, a.k.a. Berry, uses a technique called [Plug’n’Play (PnP)](https://yarnpkg.com/features/pnp) to store and manage Node modules, which can [cause problems](https://github.com/withastro/astro/issues/3450) while initializing a new Astro project using `create astro` or while working with Astro. A workaround is to set the [`nodeLinker` property](https://yarnpkg.com/configuration/yarnrc#nodeLinker) in `.yarnrc.yml` to `node-modules`:

.yarnrc.yml

```
nodeLinker: "node-modules"
```


### Adding dependencies to Astro in a monorepo


[Section titled Adding dependencies to Astro in a monorepo](#adding-dependencies-to-astro-in-a-monorepo)

When working with Astro in a monorepo setup, project dependencies should be added in each project’s own `package.json` file.

However, you may also want to use Astro in the root of the monorepo (e.g. [Nx projects recommend installing dependencies at the root](https://github.com/nrwl/nx/issues/3023#issuecomment-630558318)). In this case, manually add Astro-related dependencies (e.g. `@astrojs/vue`, `astro-component-lib`) to the `vite.ssr.noExternal` part of Astro’s config to ensure that these dependencies are properly installed and bundled:

astro.config.mjs

```
import { defineConfig } from'astro/config'exportdefaultdefineConfig({vite: {ssr: {noExternal: ['@astrojs/vue','astro-component-lib',]}}})
```


### Using `<head>` in a component


[Section titled Using &lt;head&gt; in a component](#using-head-in-a-component)

In Astro, using a `<head>` tag works like any other HTML tag: it does not get moved to the top of the page or merged with the existing `<head>`. Because of this, you usually only want to include one `<head>` tag throughout a page. We recommend writing that single `<head>` and its contents in a [layout component](/en/basics/layouts/).


### An unexpected `<style>` is included


[Section titled An unexpected &lt;style&gt; is included](#an-unexpected-style-is-included)

You may notice an imported component’s `<style>` tag included in your HTML source even if that component doesn’t appear in the final output. For example, this will occur with [conditionally rendered](/en/reference/astro-syntax/#dynamic-html) components that are not displayed.

Astro’s build process works on the module graph: once a component is included in the template, its `<style>` tag is processed, optimized, and bundled, whether it appears in the final output or not.


## Escaping special characters in Markdown


[Section titled Escaping special characters in Markdown](#escaping-special-characters-in-markdown)

Certain characters have a special meaning in Markdown. You may need to use a different syntax if you want to display them. To do this, you can use [HTML entities](https://developer.mozilla.org/en-US/docs/Glossary/Entity) for these characters instead.

For example, to prevent `<` being interpreted as the beginning of an HTML element, write `&lt;`.


## Creating minimal reproductions


[Section titled Creating minimal reproductions](#creating-minimal-reproductions)

When troubleshooting your code, it can be helpful to create a **minimal reproduction** of the issue that you can share. This is a smaller, simplified Astro project that demonstrates your issue. Having a working reproduction in a new project helps to confirm that this is a repeatable problem, and is not caused by something else in your personal environment or existing project.

Sharing a minimal reproduction is helpful when asking for help in our support threads and is often required when filing a bug report to Astro.


### Create a StackBlitz via [astro.new](https://astro.new/repro)


[Section titled Create a StackBlitz via astro.new](#create-a-stackblitz-via-astronew)

You can use [astro.new](https://astro.new/repro) to create a new Astro project with a single click. For minimal reproductions, we strongly recommend starting from the minimal (empty) example running in [StackBlitz](https://stackblitz.com), with as little extra code as possible.

StackBlitz will run this Astro project in the browser, outside of your local environment. It will also provide you with a shareable link so that any Astro maintainer or support squad member can view your minimal reproduction outside of their own local environment. This means that everyone is viewing the exact same project, with the same configuration and dependencies. This makes it easy for someone else to help troubleshoot your code. If the issue is reproducible, it allows you to verify that the issue lies within the Astro code itself and you can feel confident submitting a bug report.

Note that not every issue is reproducible in StackBlitz. For example, your issue might be dependent on a specific environment or package manager, or it may involve HTML Streaming, which isn’t supported in StackBlitz. In this case, create a new minimal (empty) Astro project using the CLI, reproduce the issue, and upload it to a GitHub repository. Instead of sharing a StackBlitz URL, provide a link to the GitHub repository of your minimal reproduction.


### Minimal code


[Section titled Minimal code](#minimal-code)

Once your empty project is set up, go through the steps to reproduce the issue. This can include adding packages, changing configuration, and writing code.

You should only add the minimum amount of code necessary to reproduce the issue. Do not reproduce other elements of your existing project, and remove all code that is not directly related to the issue.


### Create an issue


[Section titled Create an issue](#create-an-issue)

If your issue can be reproduced, then it is time to create an issue and file a bug report!

Go to the appropriate Astro repository on GitHub and open a new issue. Most repositories have an issue template that will ask questions or require information in order to submit. It’s important that you follow these templates because if you don’t provide the information we need, then we have to ask you for it… and no one is working on your issue!

Include the link to your minimal reproduction on StackBlitz (or GitHub repository, if necessary). Start with a description of the expected versus actual behavior to provide context for the issue. Then, include clear, step-by-step instructions on how to replicate the issue in an Astro project.


## Need more?


[Section titled Need more?](#need-more)

Come and chat with us on [Discord](https://astro.build/chat) and explain your issue in the `#support` forum channel. We’re always happy to help!

Visit the current [open Issues in Astro](https://github.com/withastro/astro/issues/) to see if you are encountering a known problem or file a bug report.

You can also visit [RFC Discussions](https://github.com/withastro/rfcs/discussions/) to see whether you’ve found a known limitation of Astro, and check to see whether there are current proposals related to your use case.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 140. `en/guides/typescript/.md`

```text
# TypeScript


---
url: https://docs.astro.build/en/guides/typescript/
description: Learn how to use Astro's built-in TypeScript support.
---


# TypeScript


Astro ships with built-in support for [TypeScript](https://www.typescriptlang.org/). You can import `.ts` and `.tsx` files in your Astro project, write TypeScript code directly inside your [Astro component](/en/basics/astro-components/#the-component-script), and even use an [`astro.config.ts`](/en/guides/configuring-astro/#the-astro-config-file) file for your Astro configuration if you like.

Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to [type your component’s props](#component-props), you’ll get an error in your editor if you set a prop that your component doesn’t accept.

You don’t need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the [Astro VS Code Extension](/en/editor-setup/) will infer as much as it can to provide autocompletion, hints, and errors in your editor.

The Astro dev server won’t perform any type checking, but you can use a [separate script](#type-checking) to check for type errors from the command line.


## Setup


[Section titled Setup](#setup)

Astro starter projects include a `tsconfig.json` file in your project. Even if you don’t write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren’t fully supported in the editor without a `tsconfig.json` file. If you install Astro manually, be sure to create this file yourself.


### TSConfig templates


[Section titled TSConfig templates](#tsconfig-templates)

Three extensible `tsconfig.json` templates are included in Astro: `base`, `strict`, and `strictest`. The `base` template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using `strict` or `strictest` if you plan to write TypeScript in your project. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/).

To inherit from one of the templates, use [the `extends` setting](https://www.typescriptlang.org/tsconfig#extends):

tsconfig.json

```
{"extends": "astro/tsconfigs/base"}
```

Additionally, we recommend setting `include` and `exclude` as follows to benefit from Astro types and avoid checking built files:

tsconfig.json

```
{"extends": "astro/tsconfigs/base","include": [".astro/types.d.ts", "**/*"],"exclude": ["dist"]}
```

You can create `src/env.d.ts` as a convention for adding custom types declarations, or to benefit from Astro types if you don’t have a `tsconfig.json`:

src/env.d.ts

```
// Custom types declarationsdeclare var myString:string;// Astro types, not necessary if you already have a `tsconfig.json`/// <referencepath="../.astro/types.d.ts" />
```


### TypeScript editor plugin


[Section titled TypeScript editor plugin](#typescript-editor-plugin)

The [Astro TypeScript plugin](https://www.npmjs.com/package/@astrojs/ts-plugin) can be installed separately when you are not using the [official Astro VS Code extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode). This plugin is automatically installed and configured by the VS Code extension, and you do not need to install both.

This plugin runs only in the editor. When running `tsc` in the terminal, `.astro` files are ignored entirely. Instead, you can use [the `astro check` CLI command](/en/reference/cli-reference/#astro-check) to check both `.astro` and `.ts` files.

This plugin also supports importing `.astro` files from `.ts` files (which can be useful for re-exporting).

-   [npm](#tab-panel-1828)
-   [pnpm](#tab-panel-1829)
-   [Yarn](#tab-panel-1830)

Terminal window

```
npminstall@astrojs/ts-plugin
```

Terminal window

```
pnpmadd@astrojs/ts-plugin
```

Terminal window

```
yarnadd@astrojs/ts-plugin
```

Then, add the following to your `tsconfig.json`:

tsconfig.json

```
{"compilerOptions": {"plugins": [{"name": "@astrojs/ts-plugin"},],}}
```

To check that the plugin is working, create a `.ts` file and import an Astro component into it. You should have no warning messages from your editor.


### UI Frameworks


[Section titled UI Frameworks](#ui-frameworks)

If your project uses a [UI framework](/en/guides/framework-components/), additional settings depending on the framework might be needed. Please see your framework’s TypeScript documentation for more information. ([Vue](https://vuejs.org/guide/typescript/overview.html#using-vue-with-typescript), [React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript))


## Type Imports


[Section titled Type Imports](#type-imports)

Use explicit type imports and exports whenever possible.

```
import { SomeType } from"./script";importtype { SomeType } from"./script";
```

This way, you avoid edge cases where Astro’s bundler may try to incorrectly bundle your imported types as if they were JavaScript.

You can configure TypeScript to enforce type imports in your `tsconfig.json` file. Set [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) to `true`. TypeScript will check your imports and tell you when `import type` should be used. This setting is enabled by default in all our presets.

tsconfig.json

```
{"compilerOptions": {"verbatimModuleSyntax": true}}
```


## Import Aliases


[Section titled Import Aliases](#import-aliases)

Astro supports [import aliases](/en/guides/imports/#aliases) that you define in your `tsconfig.json` `paths` configuration. [Read our guide](/en/guides/imports/#aliases) to learn more.

src/pages/about/nate.astro

```
---import HelloWorld from"@components/HelloWorld.astro";import Layout from"@layouts/Layout.astro";---
```

tsconfig.json

```
{"compilerOptions": {"baseUrl": ".","paths": {"@components/*": ["src/components/*"],"@layouts/*": ["src/layouts/*"]}}}
```


## Extending `window` and `globalThis`


[Section titled Extending window and globalThis](#extending-window-and-globalthis)

You may want to add a property to the global object. You can do this by adding top-level declarations using the `declare` keyword to your `env.d.ts` file:

src/env.d.ts

```
declare var myString:string;declarefunctionmyFunction():boolean;
```

This will provide typing to `globalThis.myString` and `globalThis.myFunction`, as well as `window.myString` and `window.myFunction`.

Note that `window` is only available in client-side code. `globalThis` is available both server-side and client-side, but its server-side value won’t be shared with the client.

If you only want to type a property on the `window` object, provide a `Window` interface instead:

src/env.d.ts

```
interface Window {myFunction():boolean;}
```


## Component Props


[Section titled Component Props](#component-props)

Astro supports typing your component props via TypeScript. To enable, add a TypeScript `Props` interface to your component frontmatter. An `export` statement may be used, but is not necessary. The [Astro VS Code Extension](/en/editor-setup/) will automatically look for the `Props` interface and give you proper TS support when you use that component inside another template.

src/components/HelloProps.astro

```
---interface Props {name:string;greeting?:string;}const { greeting = "Hello", name } = Astro.props;---<h2>{greeting}, {name}!</h2>
```


### Common prop type patterns


[Section titled Common prop type patterns](#common-prop-type-patterns)

-   If your component takes no props or slotted content, you can use `type Props = Record<string, never>`.
-   If your component must be passed children to its default slot, you can enforce this by using `type Props = { children: any; };`.


## Type Utilities


[Section titled Type Utilities](#type-utilities)

**Added in:** `astro@1.6.0`

Astro comes with some built-in utility types for common prop type patterns. These are available under the `astro/types` entrypoint.


### Built-in HTML attributes


[Section titled Built-in HTML attributes](#built-in-html-attributes)

Astro provides the `HTMLAttributes` type to check that your markup is using valid HTML attributes. You can use these types to help build component props.

For example, if you were building a `<Link>` component, you could do the following to mirror the default HTML attributes for `<a>` tags in your component’s prop types.

src/components/Link.astro

```
---importtype { HTMLAttributes } from"astro/types";// use a `type`type Props =HTMLAttributes<"a">;// or extend with an `interface`interface Props extendsHTMLAttributes<"a"> {myProp?:boolean;}const { href, ...attrs } = Astro.props;---<ahref={href} {...attrs}><slot /></a>
```

It is also possible to extend the default JSX definitions to add non-standard attributes by redeclaring the `astroHTML.JSX` namespace in a `.d.ts` file.

src/custom-attributes.d.ts

```
declarenamespace astroHTML.JSX {interface HTMLAttributes {"data-count"?:number;"data-label"?:string;}// Add a CSS custom property to the style objectinterface CSSProperties {"--theme-color"?:"black"|"white";}}
```

Note

`astroHTML` is injected globally inside `.astro` components. To use it in TypeScript files, use a [triple-slash directive](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html):

```
/// <referencetypes="astro/astro-jsx" />type MyAttributes = astroHTML.JSX.ImgHTMLAttributes;
```


### `ComponentProps` type


[Section titled ComponentProps type](#componentprops-type)

**Added in:** `astro@4.3.0`

This type export allows you to reference the `Props` accepted by another component, even if that component doesn’t export that `Props` type directly.

The following example shows using the `ComponentProps` utility from `astro/types` to reference a `<Button />` component’s `Props` types:

src/pages/index.astro

```
---importtype { ComponentProps } from"astro/types";import Button from"./Button.astro";type ButtonProps =ComponentProps<typeof Button>;---
```


### Polymorphic type


[Section titled Polymorphic type](#polymorphic-type)

**Added in:** `astro@2.5.0`

Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like `<Link>` that can render as either `<a>` or `<button>` depending on the props passed to it.

The example below implements a fully-typed, polymorphic component that can render as any HTML element. The [`HTMLTag`](#built-in-html-attributes) type is used to ensure that the `as` prop is a valid HTML element.

```
---importtype { HTMLTag, Polymorphic } from"astro/types";type Props<TagextendsHTMLTag> =Polymorphic<{ as:Tag }>;const { as: Tag, ...props } = Astro.props;---<Tag {...props} />
```


### Infer `getStaticPaths()` types


[Section titled Infer getStaticPaths() types](#infer-getstaticpaths-types)

**Added in:** `astro@2.1.0`

Astro includes helpers for working with the types returned by your [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) function for dynamic routes.

You can get the type of [`Astro.params`](/en/reference/api-reference/#params) with `InferGetStaticParamsType` and the type of [`Astro.props`](/en/reference/api-reference/#props) with `InferGetStaticPropsType` or you can use `GetStaticPaths` to infer both at once:

src/pages/posts/\[...id\].astro

```
---importtype {InferGetStaticParamsType,InferGetStaticPropsType,GetStaticPaths,} from"astro";export const getStaticPaths = (async () => {const posts = await getCollection("blog");return posts.map((post) => {return {params: { id: post.id },props: { draft: post.data.draft, title: post.data.title },};});})satisfies GetStaticPaths;type Params =InferGetStaticParamsType<typeof getStaticPaths>;type Props =InferGetStaticPropsType<typeof getStaticPaths>;const { id } = Astro.params as Params;//                   ^? { id: string; }const { title } = Astro.props;//                      ^? { draft: boolean; title: string; }---
```


## Type checking


[Section titled Type checking](#type-checking)

To see type errors in your editor, please make sure that you have the [Astro VS Code extension](/en/editor-setup/) installed. Please note that the `astro start` and `astro build` commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your “build” script in `package.json` to the following:

package.json

```
{"scripts": {"build": "astro build","build": "astro check && astro build",},}
```

Note

`astro check` checks all the files included in your TypeScript project. To check types within Svelte and Vue files, you can use the [`svelte-check`](https://www.npmjs.com/package/svelte-check) and the [`vue-tsc`](https://www.npmjs.com/package/vue-tsc) packages respectively.

Read more about [`.ts` file imports](/en/guides/imports/#typescript) in Astro.

Read more about [TypeScript Configuration](https://www.typescriptlang.org/tsconfig/).


## Troubleshooting


[Section titled Troubleshooting](#troubleshooting)


### Errors typing multiple JSX frameworks at the same time


[Section titled Errors typing multiple JSX frameworks at the same time](#errors-typing-multiple-jsx-frameworks-at-the-same-time)

An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside `tsconfig.json`.

**Solution**: Set the [`jsxImportSource` setting](https://www.typescriptlang.org/tsconfig#jsxImportSource) to `react` (default), `preact` or `solid-js` depending on your most-used framework. Then, use a [pragma comment](https://www.typescriptlang.org/docs/handbook/jsx.html#configuring-jsx) inside any conflicting file from a different framework.

For the default setting of `jsxImportSource: react`, you would use:

```
// For Preact/** @jsxImportSource preact */// For Solid/** @jsxImportSource solid-js */
```

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 141. `en/guides/upgrade-to/v1/.md`

```text
# Legacy v0.x Upgrade Guide


---
url: https://docs.astro.build/en/guides/upgrade-to/v1/
description: Archived guide documenting changes between pre-v1 versions of Astro
---


# Legacy v0.x Upgrade Guide


This guide will help you upgrade through breaking changes in pre-v1 versions of Astro.

You can update your project’s version of Astro to the latest version using your package manager. If you’re using Astro integrations, you’ll also want to update those to the latest version.

-   [npm](#tab-panel-3379)
-   [pnpm](#tab-panel-3380)
-   [Yarn](#tab-panel-3381)

Terminal window

```

# updates the astro dependency:npmupgradeastro# or, to update all dependencies:npmupgrade

```

Terminal window

```

# updates the astro dependency:pnpmupgradeastro# or, to update all dependencies:pnpmupgrade

```

Terminal window

```

# updates the astro dependency:yarnupgradeastro# or, to update all dependencies:yarnupgrade

```

Read the guide below for major highlights and instructions on how to handle breaking changes.


## Astro 1.0


[Section titled Astro 1.0](#astro-10)

Astro v1.0 introduces some changes that you should be aware of when migrating from v0.x and v1.0-beta releases. See below for more details.


### Updated: Vite 3


[Section titled Updated: Vite 3](#updated-vite-3)

Astro v1.0 has upgraded from Vite 2 to [Vite 3](https://vite.dev/). We’ve handled most of the upgrade for you inside of Astro; however, some subtle Vite behaviors may still change between versions. Refer to the official [Vite Migration Guide](https://vite.dev/guide/migration.html#general-changes) if you run into trouble.


### Deprecated: `Astro.canonicalURL`


[Section titled Deprecated: Astro.canonicalURL](#deprecated-astrocanonicalurl)

You can now use the new [`Astro.url`](/en/reference/api-reference/#url) helper to construct your own canonical URL from the current page/request URL.

```
// Before:const canonicalURL = Astro.canonicalURL;// After:const canonicalURL = newURL(Astro.url.pathname, Astro.site);
```


### Changed: Scoped CSS specificity


[Section titled Changed: Scoped CSS specificity](#changed-scoped-css-specificity)

[Specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) will now be preserved in scoped CSS styles. This change will cause most scoped styles to *happen* to take precedence over global styles. But, this behavior is no longer explicitly guaranteed.

Technically, this is accomplished using [the `:where()` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:where) instead of using classes directly in Astro’s CSS output.

Let’s use the following style block in an Astro component as an example:

```
<style>div { color: red; } /* 0-0-1 specificity */</style>
```

Previously, Astro would transform this into the following CSS, which has a specificity of `0-1-1` — a higher specificity than the source CSS:

```
div.astro-XXXXXX { color: red; } /* 0-1-1 specificity */
```

Now, Astro wraps the class selector with `:where()`, maintaining the authored specificity:

```
div:where(.astro-XXXXXX) { color: red; } /* 0-0-1 specificity */
```

The previous specificity increase made it hard to combine scoped styles in Astro with other CSS files or styling libraries (e.g. Tailwind, CSS Modules, Styled Components, Stitches). This change will allow Astro’s scoped styles to work consistently alongside them while still preserving the exclusive boundaries that prevent styles from applying outside the component.

Caution

When upgrading, please visually inspect your site output to make sure everything is styled as expected. If not, find your scoped style and increase the selector specificity manually to match the old behavior.


### Deprecated: Components and JSX in Markdown


[Section titled Deprecated: Components and JSX in Markdown](#deprecated-components-and-jsx-in-markdown)

Astro no longer supports components or JSX expressions in Markdown pages by default. For long-term support you should migrate to the [`@astrojs/mdx`](/en/guides/integrations-guide/mdx/) integration.

To make migrating easier, a new `legacy.astroFlavoredMarkdown` flag (removed in v2.0) can be used to re-enable previous Markdown features.


### Converting existing `.md` files to `.mdx`


[Section titled Converting existing .md files to .mdx](#converting-existing-md-files-to-mdx)

If you’re not familiar with MDX, here are some steps you can follow to quickly convert an existing “Astro Flavored Markdown” file to MDX. As you learn more about MDX, feel free to explore other ways of writing your pages!

1.  Install the [`@astrojs/mdx`](/en/guides/integrations-guide/mdx/) integration.

2.  Change your existing `.md` file extensions to `.mdx`

3.  Remove any `setup:` properties from your frontmatter, and write any import statements below the frontmatter instead.

    src/pages/posts/my-post.mdx

    ```
    ---layout: '../../layouts/BaseLayout.astro'setup: |import ReactCounter from '../../components/ReactCounter.jsx'title: 'Migrating to MDX'date: 2022-07-26tags: ["markdown", "mdx", "astro"]---import ReactCounter from'../../components/ReactCounter.jsx'# {frontmatter.title}Here is my counter component, working in MDX:<ReactCounterclient:load/>
    ```

4.  Update any `Astro.glob()` statements that currently return `.md` files so that they will now return your `.mdx` files.

    Caution

    The object returned when importing `.mdx` files (including using Astro.glob) differs from the object returned when importing `.md` files. However, `frontmatter`, `file`, and `url` work identically.

5.  Update any use of the `<Content />` component to use the default export when importing MDX:

    src/pages/index.astro

    ```
    ---// Multiple imports with Astro.globconst mdxPosts = await Astro.glob('./posts/*.mdx');---{mdxPosts.map(Post=><Post.default />)}
    ```

    src/pages/index.astro

    ```
    ---// Import a single pageimport { defaultas About } from'./about.mdx';---<About />
    ```


Tip

While you are transitioning to MDX, you may wish to enable the `legacy.astroFlavoredMarkdown` flag (removed in v2.0) and include both **`.md` and `.mdx`** files, so that your site continues to function normally even before all your files have been converted. Here is one way you can do that:

```
---const mdPosts = await Astro.glob('../pages/posts/*.md');const mdxPosts = await Astro.glob('../pages/posts/*.mdx');const allPosts = [...mdxPosts, ...mdPosts];---
```


### `<Markdown />` Component Removed


[Section titled &lt;Markdown /&gt; Component Removed](#markdown--component-removed)

Astro’s built-in `<Markdown />` component has been moved to a separate package. To continue using this component, you will now need to install `@astrojs/markdown-component` and update your imports accordingly. For more details, see [the `@astrojs/markdown` README](https://github.com/withastro/astro/tree/main/packages/markdown/component).

Tip

Astro now has support for [MDX](https://mdxjs.com/) through our [MDX integration](https://github.com/withastro/astro/tree/main/packages/integrations/mdx). MDX gives you the ability to include both Markdown and imported components in the same file. MDX can be good alternative for the `<Markdown />` component due to its large community and stable APIs.


## Migrate to v1.0.0-beta


[Section titled Migrate to v1.0.0-beta](#migrate-to-v100-beta)

On April 4, 2022 we released the Astro 1.0 Beta! 🎉

If you are coming from v0.25 or earlier, make sure you have read and followed the [v0.26 Migration Guide](#migrate-to-v026) below, which contained several major breaking changes.

The `v1.0.0-beta.0` release of Astro contained no breaking changes. Below are small changes that were introduced during the beta period.


### Changed: RSS Feeds


[Section titled Changed: RSS Feeds](#changed-rss-feeds)

RSS feeds should now be generated using the `@astrojs/rss` package, as described in our [RSS guide](/en/recipes/rss/).


## Migrate to v0.26


[Section titled Migrate to v0.26](#migrate-to-v026)


### New Configuration API


[Section titled New Configuration API](#new-configuration-api)

Our Configuration API has been redesigned to solve a few glaring points of confusion that had built up over the last year. Most of the configuration options have just been moved or renamed, which will hopefully be a quick update for most users. A few options have been refactored more heavily, and may require a few additional changes:

-   `.buildOptions.site` has been replaced with `.site` (your deployed domain) and a new `.base` (your deployed subpath) option.
-   `.markdownOptions` has been replaced with `.markdown`, a mostly similar config object with some small changes to simplify Markdown configuration.
-   `.sitemap` has been moved into the [@astrojs/sitemap](https://www.npmjs.com/package/@astrojs/sitemap) integration.

If you run Astro with legacy configuration, you will see a warning with instructions on how to update. See our updated [Configuration Reference](/en/reference/configuration-reference/) for more information on upgrading.

Read [RFC0019](https://github.com/withastro/rfcs/blob/main/proposals/0019-config-finalization.md) for more background on these changes.


### New Markdown API


[Section titled New Markdown API](#new-markdown-api)

Astro v0.26 releases a brand new Markdown API for your content. This included three major user-facing changes:

-   You can now `import`/`import()` markdown content directly using an ESM import.
-   A new `Astro.glob()` API, for easier glob imports (especially for Markdown).
-   **BREAKING CHANGE:** `Astro.fetchContent()` has been removed and replaced by `Astro.glob()`
-   **BREAKING CHANGE:** Markdown objects have an updated interface.

```
// v0.25let allPosts = Astro.fetchContent('./posts/*.md');// v0.26+let allPosts = await Astro.glob('./posts/*.md');
```

When migrating, be careful about the new Markdown object interface. Frontmatter, for example, has been moved to the `.frontmatter` property, so references like `post.title` should change to `post.frontmatter.title`.

This should solve many issues for Markdown users, including some nice performance boosts for larger sites.

Read [RFC0017](https://github.com/withastro/rfcs/blob/main/proposals/0017-markdown-content-redesign.md) for more background on these changes.


### New Default Script Behavior


[Section titled New Default Script Behavior](#new-default-script-behavior)

`<script>` tags in Astro components are now built, bundled and optimized by default. This completes a long-term move to make our Astro component syntax more consistent, matching the default-optimized behavior our `<style>` tags have today.

This includes a few changes to be aware of:

-   **BREAKING:** `<script hoist>` is the new default `<script>` behavior. The `hoist` attribute has been removed. To use the new default behaviour, make sure there are no other attributes on the `<script>` tag. For example, remove `type="module"` if you were using it before.
-   New `<script is:inline>` directive, to revert a `<script>` tag to previous default behavior (unbuilt, unbundled, untouched by Astro).
-   New `<style is:inline>` directive, to leave a style tag inline in the page template (similar to previous `<script>` behavior).
-   New `<style is:global>` directive to replace `<style global>` in a future release.

```
// v0.25<scripthoisttype="module">// v0.26+<script>
```

See how to use [client-side scripts](/en/guides/client-side-scripts/) in Astro for full details.

Read [RFC0016](https://github.com/withastro/rfcs/blob/main/proposals/0016-style-script-defaults.md) for more background on these changes.


### Updated `Astro.request` API


[Section titled Updated Astro.request API](#updated-astrorequest-api)

`Astro.request` has been changed from our custom object to a standard `Request` object. This is part of a project to use more web standard APIs, especially where SSR is concerned.

This includes a few changes to be aware of:

-   Change `Astro.request` to become a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.
-   Move `Astro.request.params` to `Astro.params`.
-   Move `Astro.request.canonicalURL` to `Astro.canonicalURL`.

Read [RFC0018](https://github.com/withastro/rfcs/blob/main/proposals/0018-astro-request.md) for more background on these changes.


### Other Changes


[Section titled Other Changes](#other-changes)

-   Improve `Astro.slots` API to support passing arguments to function-based slots. This allows for more ergonomic utility components that accept a callback function as a child.
-   Update CLI output formatting, especially around error reporting.
-   Update `@astrojs/compiler`, fixing some bugs related to RegExp usage in frontmatter


## Migrate to v0.25


[Section titled Migrate to v0.25](#migrate-to-v025)


### Astro Integrations


[Section titled Astro Integrations](#astro-integrations)

The `renderers` config has been replaced by a new, official integration system! This unlocks some really exciting new features for Astro. You can read our [Using Integrations](/en/guides/integrations-guide/) guide for more details on how to use this new system.

Integrations replace our original `renderers` concept, and come with a few breaking changes and new defaults for existing users. These changes are covered below.


#### Removed: Built-in Framework Support


[Section titled Removed: Built-in Framework Support](#removed-built-in-framework-support)

Previously, React, Preact, Svelte, and Vue were all included with Astro by default. Starting in v0.25.0, Astro no longer comes with any built-in renderers. If you did not have a `renderers` configuration entry already defined for your project, you will now need to install those frameworks yourself.

Read our [step-by-step walkthrough](/en/guides/integrations-guide/) to learn how to add a new Astro integration for the framework(s) that you currently use.


#### Deprecated: Renderers


[Section titled Deprecated: Renderers](#deprecated-renderers)

Note

Read this section if you have custom “renderers” already defined in your configuration file.

The new integration system replaces the previous `renderers` system, including the published `@astrojs/renderer-*` packages on npm. Going forward, `@astrojs/renderer-react` becomes `@astrojs/react`, `@astrojs/renderer-vue` becomes `@astrojs/vue`, and so on.

**To migrate:** update Astro to `v0.25.0` and then run `astro dev` or `astro build` with your old configuration file containing the outdated `"renderers"` config. You will immediately see a notice telling you the exact changes you need to make to your `astro.config.mjs` file, based on your current config. You can also update your packages yourself, using the table below.

For a deeper walkthrough, read our [step-by-step guide](/en/guides/integrations-guide/) to learn how to replace existing renderers with a new Astro framework integration.

Terminal window

```

# Install your new integrations and frameworks:# (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)npminstall@astrojs/litlitnpminstall@astrojs/reactreactreact-dom

```

```
// Then, update your `astro.config.mjs` file:// (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)import lit from'@astrojs/lit';import react from'@astrojs/react';exportdefault {renderers: ['@astrojs/renderer-lit', '@astrojs/renderer-react'],integrations: [lit(), react()],}
```

Deprecated Renderers on npm

v0.25+ Integrations on npm

@astrojs/renderer-react

@astrojs/react

@astrojs/renderer-preact

@astrojs/preact

@astrojs/renderer-solid

@astrojs/solid-js

@astrojs/renderer-vue

@astrojs/vue

@astrojs/renderer-svelte

@astrojs/svelte


#### Handling Peer Dependencies


[Section titled Handling Peer Dependencies](#handling-peer-dependencies)

Note

Read this section if: You are on Node v14 **or** if you use any package manager other than npm.

Unlike the old renderers, integrations no longer mark the frameworks themselves (“react”, “svelte”, “vue”, etc.) as direct dependencies of the integration. Instead, you should now install your framework packages *in addition to* your integrations.

Terminal window

```

# Example: Install integrations and frameworks togethernpminstall@astrojs/reactreactreact-dom

```

If you see a `"Cannot find package 'react'"` (or similar) warning when you start up Astro, that means that you need to install that package into your project. See our [note on peer dependencies](/en/guides/troubleshooting/#cannot-find-package-x) in the troubleshooting guide for more information.

If you are using `npm` & Node v16+, then this may be automatically handled for you by `npm`, since the latest version of `npm` (v7+) installs peer dependencies like this for you automatically. In that case, installing a framework like “react” into your project is an optional but still recommended step.


### Updated: Syntax Highlighting


[Section titled Updated: Syntax Highlighting](#updated-syntax-highlighting)

We love to find sensible defaults that “just work” out-of-the-box. As part of this, we decided to make [Shiki](https://github.com/shikijs/shiki) our new default syntax highlighter. This comes pre-configured with the `github-dark` theme, providing zero-config highlighting in your code blocks without extraneous CSS classes, stylesheets, or client-side JS.

Check our new syntax highlighting docs for full details. **If you prefer to keep Prism as your syntax highlighter,** set the `syntaxHighlight` option to `'prism'` in your project’s markdown configuration.


#### The `<Prism />` component has a new home


[Section titled The &lt;Prism /&gt; component has a new home](#the-prism--component-has-a-new-home)

As part of our mission to keep Astro core as lean as possible, we’ve moved the built-in `Prism` component out of `astro/components` and into the `@astrojs/prism` package. You can now import this component from `@astrojs/prism` like so:

```
---import { Prism } from'@astrojs/prism';---
```

Since the `@astrojs/prism` package is still bundled with `astro` core, you won’t need to install anything new, nor add Prism as an integration! However, note that we *do* plan to extract `@astrojs/prism` (and Prism syntax highlighting in general) to a separate, installable package in the future. See the `<Prism />` component API reference for more details.


### CSS Parser Upgrade


[Section titled CSS Parser Upgrade](#css-parser-upgrade)

Our internal CSS parser has been updated, and comes with better support for advanced CSS syntax, like container queries. This should be a mostly invisible change for most users, but hopefully advanced users will enjoy the new CSS feature support.


## Migrate to v0.24


[Section titled Migrate to v0.24](#migrate-to-v024)

Note

The new build strategy is on by default on 0.24. If you run into a problem you can continue using the old build strategy by passing the `--legacy-build` flag. Please [open an issue](https://github.com/withastro/astro/issues/new/choose) so that we can resolve problems with the new build strategy.

0.24 introduced a new *static build* strategy that changes the behavior of a few features. In previous versions of Astro this was available behavior with an opt-in flag: `--experimental-static-build`.

To migrate for the transition, be aware of the following changes that will be required to move to this new build engine. You can make these changes to your codebase at any time so that you are ready ahead of schedule.


### Deprecated: `Astro.resolve()`


[Section titled Deprecated: Astro.resolve()](#deprecated-astroresolve)

`Astro.resolve()` allows you to get resolved URLs to assets that you might want to reference in the browser. This was most commonly used inside of `<link>` and `<img>` tags to load CSS files and images as needed. Unfortunately, this will no longer work due to Astro now building assets at *build time* rather than at *render time*. You’ll want to upgrade your asset references to one of the following future-proof options available going forward:


#### How to Resolve CSS Files


[Section titled How to Resolve CSS Files](#how-to-resolve-css-files)

**1\. ESM Import (Recommended)**

**Example:** `import './style.css';` **When to use this:** If your CSS file lives inside of the `src/` directory, and you want automatic CSS build and optimization features.

Use an ESM import to add some CSS onto the page. Astro detects these CSS imports and then builds, optimizes, and adds the CSS to the page automatically. This is the easiest way to migrate from `Astro.resolve()` while keeping the automatic building/bundling that Astro provides.

```
---// Example: Astro will include and optimize this CSS for you automaticallyimport'./style.css';---<html><!-- Your page here --></html>
```

Importing CSS files should work anywhere that ESM imports are supported, including:

-   JavaScript files
-   TypeScript files
-   Astro component frontmatter
-   non-Astro components like React, Svelte, and others

When a CSS file is imported using this method, any `@import` statements are also resolved and inlined into the imported CSS file. All `url()` references are also resolved relative to the source file, and any `url()` referenced assets will be included in the final build.

**2\. Absolute URL Path**

**Example:** `<link href="/style.css">` **When to use this:** If your CSS file lives inside of `public/`, and you prefer to create your HTML `link` element yourself.

You can reference any file inside of the `public/` directory by absolute URL path in your component template. This is a good option if you want to control the `<link>` tag on the page yourself. However, this approach also skips the CSS processing, bundling and optimizations that are provided by Astro when you use the `import` method described above.

We recommend using the `import` approach over the absolute URL approach since it provides the best possible CSS performance and features by default.


#### How to Resolve JavaScript Files


[Section titled How to Resolve JavaScript Files](#how-to-resolve-javascript-files)

**1\. Absolute URL Path**

**Example:** `<script src="/some-external-script.js" />` **When to use this:** If your JavaScript file lives inside of `public/`.

You can reference any file inside of the `public/` directory by absolute URL path in your Astro component templates. This is a good default option for external scripts because it lets you control the `<script>` tag on the page yourself.

Note that this approach skips the JavaScript processing, bundling and optimizations that are provided by Astro when you use the `import` method described below. However, this may be preferred for any external scripts that have already been published and minified separately from Astro. If your script was downloaded from an external source, then this method is probably preferred.

**2\. ESM Import via `<script hoist>`**

**Example:** `<script hoist>import './some-external-script.js';</script>` **When to use this:** If your external script lives inside of `src/` *and* it supports the ESM module type.

Use an ESM import inside of a `<script hoist>` element in your Astro template, and Astro will include the JavaScript file in your final build. Astro detects these JavaScript client-side imports and then builds, optimizes, and adds the JavaScript to the page automatically. This is the easiest way to migrate from `Astro.resolve()` while keeping the automatic building/bundling that Astro provides.

```
<scripthoist>import'./some-external-script.js';</script>
```

Note that Astro will bundle this external script with the rest of your client-side JavaScript, and load it in the `type="module"` script context. Some older JavaScript files may not be written for the `module` context, in which case they may need to be updated to use this method.


#### How to Resolve Images & Other Assets


[Section titled How to Resolve Images &amp; Other Assets](#how-to-resolve-images--other-assets)

**1\. Absolute URL Path (Recommended)**

**Example:** `<img src="/penguin.png">` **When to use this:** If your asset lives inside of `public/`.

If you place your images inside of `public/` you can safely reference them by absolute URL path directly in your component templates. This is the simplest way to reference an asset that you can use today, and it is recommended for most users who are getting started with Astro.

**2\. ESM Import**

**Example:** `import imgUrl from './penguin.png'` **When to use this:** If your asset lives inside of the `src/` directory, and you want automatic optimization features like filename hashing.

This works inside of any JavaScript or Astro component, and returns a resolved URL to the final image. Once you have the resolved URL, you can use it anywhere inside of the component template.

```
---// Example: Astro will include this image file in your final buildimport imgUrl from'./penguin.png';---<imgsrc={imgUrl} />
```

Similar to how Astro handles CSS, the ESM import allows Astro to perform some simple build optimizations for you automatically. For example, any asset inside of `src/` that is imported using an ESM import (ex: `import imgUrl from './penguin.png'`) will have its filename hashed automatically. This can let you cache the file more aggressively on the server, improving user performance. In the future, Astro may add more optimizations like this.

**Tip:** If you dislike static ESM imports, Astro also supports dynamic ESM imports. We only recommend this option if you prefer this syntax: `<img src={(await import('./penguin.png')).default} />`.


### Deprecated: `<script>` Default Processing


[Section titled Deprecated: &lt;script&gt; Default Processing](#deprecated-script-default-processing)

Previously, all `<script>` elements were read from the final HTML output and processed + bundled automatically. This behavior is no longer the default. Starting in 0.24, you must opt-in to `<script>` element processing via the `hoist` attribute. The `type="module"` is also required for hoisted modules.

```
<script>// Will be rendered into the HTML exactly as written!// ESM imports will not be resolved relative to the file.</script><scripttype="module"hoist>// Processed! Bundled! ESM imports work, even to npm packages.</script>
```


## Migrate to v0.23


[Section titled Migrate to v0.23](#migrate-to-v023)


### Missing Sass Error


[Section titled Missing Sass Error](#missing-sass-error)

```
Preprocessor dependency "sass" not found. Did you install it?
```

In our quest to reduce npm install size, we’ve moved [Sass](https://sass-lang.com/) out to an optional dependency. If you use Sass in your project, you’ll want to make sure that you run `npm install sass --save-dev` to save it as a dependency.


### Deprecated: Unescaped HTML


[Section titled Deprecated: Unescaped HTML](#deprecated-unescaped-html)

In Astro v0.23+, unescaped HTML content in expressions is now deprecated. In future releases, content within expressions will have strings escaped to protect against unintended HTML injection.

```
<h1>{title}</h1><!-- <h1>Hello <strong>World</strong></h1> --><h1>{title}</h1><!-- <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
```

To continue injecting unescaped HTML, you can now use `set:html`.

```
<h1>{title}</h1><h1set:html={title} />
```

To avoid a wrapper element, `set:html` can work alongside `<Fragment>`.

```
<h1>{title}!</h1><h1><Fragmentset:html={title}>!</h1>
```

You can also protect against unintended HTML injection with `set:text`.

```
<h1set:text={title} /><!-- <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
```


## Migrate to v0.21


[Section titled Migrate to v0.21](#migrate-to-v021)


### Vite


[Section titled Vite](#vite)

Starting in v0.21, Astro is built with [Vite](https://vite.dev). As a result, configurations written in `snowpack.config.mjs` should be moved into `astro.config.mjs`.

```
// @ts-check/** @type{import('astro').AstroUserConfig} */exportdefault {renderers: [],vite: {plugins: [],},};
```

To learn more about configuring Vite, please visit their [configuration guide](https://vite.dev/config/).


#### Vite Plugins


[Section titled Vite Plugins](#vite-plugins)

In Astro v0.21+, Vite plugins may be configured within `astro.config.mjs`.

```
import { imagetools } from'vite-imagetools';exportdefault {vite: {plugins: [imagetools()],},};
```

To learn more about Vite plugins, please visit their [plugin guide](https://vite.dev/guide/using-plugins.html).


#### Vite Changes to Renderers


[Section titled Vite Changes to Renderers](#vite-changes-to-renderers)

In Astro v0.21+, plugins should now use `viteConfig()`.

renderer-svelte/index.js

```
import { svelte } from'@sveltejs/vite-plugin-svelte';exportdefault {name: '@astrojs/renderer-svelte',client: './client.js',server: './server.js',snowpackPlugin: '@snowpack/plugin-svelte',snowpackPluginOptions: { compilerOptions: { hydratable: true } },viteConfig() {return {optimizeDeps: {include: ['@astrojs/renderer-svelte/client.js', 'svelte', 'svelte/internal'],exclude: ['@astrojs/renderer-svelte/server.js'],},plugins: [svelte({emitCss: true,compilerOptions: { hydratable: true },}),],};},}
```

To learn more about Vite plugins, please visit their [plugin guide](https://vite.dev/guide/using-plugins.html).

Note

In prior releases, these were configured with `snowpackPlugin` or `snowpackPluginOptions`.


### Aliasing


[Section titled Aliasing](#aliasing)

In Astro v0.21+, import aliases can be added in `tsconfig.json`.

```
{"compilerOptions": {"baseUrl": ".","paths": {"@/components/*": ["src/components/*"]}}}
```


### File Extensions in Imports


[Section titled File Extensions in Imports](#file-extensions-in-imports)

In Astro v0.21+, files need to be referenced by their actual extension, exactly as it is on disk. In this example, `Div.tsx` would need to be referenced as `Div.tsx`, not `Div.jsx`.

```
import Div from'./Div.jsx'// Astro v0.20import Div from'./Div.tsx'// Astro v0.21
```

This same change applies to a compile-to-css file like `Div.scss`:

```
<linkrel="stylesheet"href={Astro.resolve('./Div.css')}><linkrel="stylesheet"href={Astro.resolve('./Div.scss')}>
```


### Removed: Components in Frontmatter


[Section titled Removed: Components in Frontmatter](#removed-components-in-frontmatter)

Previously, you could create mini Astro Components inside of the Astro Frontmatter, using JSX syntax instead of Astro’s component syntax. This was always a bit of a hack, but in the new compiler it became impossible to support. We hope to re-introduce this feature in a future release of Astro using a different, non-JSX API.

To migrate to v0.21+, please convert all JSX Astro components (that is, any Astro components created inside of another component’s frontmatter) to standalone components.


### Styling Changes


[Section titled Styling Changes](#styling-changes)


#### Autoprefixer


[Section titled Autoprefixer](#autoprefixer)

Autoprefixer is no longer run by default. To enable:

1.  Install the latest version (`npm install autoprefixer`)

2.  Create a `postcss.config.cjs` file at the root of your project with:

    ```
    module.exports= {plugins: {autoprefixer: {},},};
    ```



#### Tailwind CSS


[Section titled Tailwind CSS](#tailwind-css)

Ensure you have PostCSS installed. This was optional in previous releases, but is required now:

1.  Install the latest version of postcss (`npm install -D postcss`)

2.  Create a `postcss.config.cjs` file at the root of your project with:

    ```
    module.exports= {plugins: {tailwindcss: {},},};
    ```

    For more information, read the [Tailwind CSS documentation](https://tailwindcss.com/docs/installation#add-tailwind-as-a-post-css-plugin)



### Known Issues


[Section titled Known Issues](#known-issues)


#### Imports on top


[Section titled Imports on top](#imports-on-top)

In Astro v0.21+, a bug has been introduced that requires imports inside components to be at the top of your frontmatter.

```
---import Component from'../components/Component.astro'const whereShouldIPutMyImports = "on top!"---
```

Upgrade Guides


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 142. `en/guides/upgrade-to/v2/.md`

```text
# Upgrade to Astro v2


---
url: https://docs.astro.build/en/guides/upgrade-to/v2/
description: How to upgrade your project to the latest version of Astro.
---


# Upgrade to Astro v2


This guide will help you migrate from Astro v1 to Astro v2.

Need to upgrade an older project to v1? See our [older migration guide](/en/guides/upgrade-to/v1/).


## Upgrade Astro


[Section titled Upgrade Astro](#upgrade-astro)

Update your project’s version of Astro to the latest version using your package manager. If you’re using Astro integrations, please also update those to the latest version.

-   [npm](#tab-panel-3382)
-   [pnpm](#tab-panel-3383)
-   [Yarn](#tab-panel-3384)

Terminal window

```

# Upgrade to Astro v2.xnpminstallastro@latest# Example: upgrade React and Tailwind integrationsnpminstall@astrojs/react@latest@astrojs/tailwind@latest

```

Terminal window

```

# Upgrade to Astro v2.xpnpmaddastro@latest# Example: upgrade React and Tailwind integrationspnpmadd@astrojs/react@latest@astrojs/tailwind@latest

```

Terminal window

```

# Upgrade to Astro v2.xyarnaddastro@latest# Example: upgrade React and Tailwind integrationsyarnadd@astrojs/react@latest@astrojs/tailwind@latest

```


## Astro v2.0 Breaking Changes


[Section titled Astro v2.0 Breaking Changes](#astro-v20-breaking-changes)

Astro v2.0 includes some breaking changes, as well as the removal of some previously deprecated features. If your project doesn’t work as expected after upgrading to v2.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See [the changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes.


### Removed: Support for Node 14


[Section titled Removed: Support for Node 14](#removed-support-for-node-14)

Node 14 is scheduled to reach its End of Life in April 2023.

Astro v2.0 drops Node 14 support entirely, so that all Astro users can take advantage of Node’s more modern features.


#### What should I do?


[Section titled What should I do?](#what-should-i-do)

Check that both your development environment and your deployment environment are using **Node `16.12.0` or later**.

1.  Check your local version of Node using:

    Terminal window

    ```
    node-v
    ```

    If your local development environment needs upgrading, [install Node](https://nodejs.org/en/download/).

2.  Check your [deployment environment’s](/en/guides/deploy/) own documentation to verify that they support Node 16.

    You can specify Node `16.12.0` for your Astro project either in a dashboard configuration setting, or a `.nvmrc` file.



### Reserved: `src/content/`


[Section titled Reserved: src/content/](#reserved-srccontent)

Astro v2.0 now includes the Collections API for organizing your Markdown and MDX files into [content collections](/en/guides/content-collections/). This API reserves `src/content/` as a special folder.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-1)

Rename an existing `src/content/` folder to avoid conflicts. This folder, if it exists, can now only be used for [content collections](/en/guides/content-collections/).


### Changed: `Astro.site` trailing slash


[Section titled Changed: Astro.site trailing slash](#changed-astrosite-trailing-slash)

In v1.x, Astro ensured the URL you set as `site` in `astro.config.mjs` always had a trailing slash when accessed using `Astro.site`.

Astro v2.0 no longer modifies the value of `site`. `Astro.site` will use the exact value defined, and a trailing slash must be specified if desired.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-2)

In `astro.config.mjs`, add a trailing slash to the URL set in `site`.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({site: 'https://example.com',site: 'https://example.com/',});
```


### Changed: `_astro/` folder for build assets


[Section titled Changed: \_astro/ folder for build assets](#changed-_astro-folder-for-build-assets)

In v1.x, assets were built to various locations, including `assets/`, `chunks/`, and to the root of the build output.

Astro v2.0 moves and unifies the location of all build output assets to a new `_astro/` folder.

-   Directorydist/

    -   Directory\_astro

        -   client.9218e799.js
        -   index.df3f880e0.css



You can control this location with the [new `build.assets` configuration option](/en/reference/configuration-reference/#buildassets).


#### What should I do?


[Section titled What should I do?](#what-should-i-do-3)

Update your deployment platform configuration if it relies on the location of these assets.


### Changed: Markdown plugin configuration


[Section titled Changed: Markdown plugin configuration](#changed-markdown-plugin-configuration)


#### Removed: `extendDefaultPlugins`


[Section titled Removed: extendDefaultPlugins](#removed-extenddefaultplugins)

In v1.x, Astro used `markdown.extendDefaultPlugins` to re-enable Astro’s default plugins when adding your own Markdown plugins.

Astro v2.0 removes this configuration option entirely because its behavior is now the default.

Applying remark and rehype plugins in your Markdown configuration **no longer disables Astro’s default plugins**. GitHub-Flavored Markdown and Smartypants are now applied whether or not custom `remarkPlugins` or `rehypePlugins` are configured.


##### What should I do?


[Section titled What should I do?](#what-should-i-do-4)

Remove `extendDefaultPlugins` in your configuration. This is now Astro’s default behavior in v2.0, and you can delete this line without any replacement.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {extendDefaultPlugins,}});
```


#### Added: `gfm` and `smartypants`


[Section titled Added: gfm and smartypants](#added-gfm-and-smartypants)

In v1.x, you could choose to disable both of Astro’s default Markdown plugins (GitHub-Flavored Markdown and SmartyPants) by setting `markdown.extendDefaultPlugins: false`.

Astro v2.0 replaces `markdown.extendDefaultPlugins: false` with separate Boolean options to individually control each of Astro’s built-in default Markdown plugins. These are enabled by default and can be set to `false` independently.


##### What should I do?


[Section titled What should I do?](#what-should-i-do-5)

Remove `extendDefaultPlugins: false` and add the flags to disable each plugin individually instead.

-   `markdown.gfm: false` disables GitHub-Flavored Markdown
-   `markdown.smartypants: false` disables SmartyPants

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {extendDefaultPlugins: false,smartypants: false,gfm: false,}});
```


### Changed: MDX plugin configuration


[Section titled Changed: MDX plugin configuration](#changed-mdx-plugin-configuration)


#### Replaced: `extendPlugins` changed to `extendMarkdownConfig`


[Section titled Replaced: extendPlugins changed to extendMarkdownConfig](#replaced-extendplugins-changed-to-extendmarkdownconfig)

In v1.x, the MDX integration’s `extendPlugins` option managed how your MDX files should inherit your Markdown configuration: all your Markdown configuration (`markdown`), or Astro’s default plugins only (`default`).

Astro v2.0 replaces the behavior controlled by `mdx.extendPlugins` with three new, independently-configurable options that are `true` by default:

-   **[`mdx.extendMarkdownConfig`](/en/guides/integrations-guide/mdx/#extendmarkdownconfig)** to inherit all or none of your Markdown configuration
-   **`mdx.gfm`** to enable or disable GitHub-Flavored Markdown in MDX
-   **`mdx.smartypants`** to enable or disable SmartyPants in MDX


##### What should I do?


[Section titled What should I do?](#what-should-i-do-6)

Delete `extendPlugins: 'markdown'` in your configuration. This is now the default behavior.

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({integrations: [mdx({extendPlugins: 'markdown',}),],});
```

Replace `extendPlugins: 'defaults'` with `extendMarkdownConfig: false` and add the separate options for GitHub-Flavored Markdown and SmartyPants to enable these default plugins individually in MDX.

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({integrations: [mdx({extendPlugins: 'defaults',extendMarkdownConfig: false,smartypants: true,gfm: true,}),],});
```


#### Added: More MDX config options to match Markdown


[Section titled Added: More MDX config options to match Markdown](#added-more-mdx-config-options-to-match-markdown)

Astro v2.0 allows you to now individually set [every available Markdown configuration option](/en/reference/configuration-reference/#markdown-options) (except `drafts`) separately in your MDX integration configuration.

astro.config.mjs

```
import { defineConfig } from'astro/config';import mdx from'@astrojs/mdx';exportdefaultdefineConfig({markdown: {remarkPlugins: [remarkPlugin1],gfm: true,},integrations: [mdx({remarkPlugins: [remarkPlugin2],gfm: false,})]});
```


##### What should I do?


[Section titled What should I do?](#what-should-i-do-7)

Revisit your Markdown and MDX configuration and compare your existing config with the new options available.


### Changed: Plugin access to frontmatter


[Section titled Changed: Plugin access to frontmatter](#changed-plugin-access-to-frontmatter)

In v1.x, remark and rehype plugins did not have access to user frontmatter. Astro merged plugin frontmatter with your file’s frontmatter, without passing the file frontmatter to your plugins.

Astro v2.0 gives remark and rehype plugins access to user frontmatter via frontmatter injection. This allows plugin authors to modify a user’s existing frontmatter, or compute new properties based on other properties.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-8)

Check any remark and rehype plugins you have written to see whether their behavior has changed. Note that `data.astro.frontmatter` is now the *complete* Markdown or MDX document’s frontmatter, rather than an empty object.


### Changed: RSS Configuration


[Section titled Changed: RSS Configuration](#changed-rss-configuration)

In v1.x, Astro’s RSS package allowed you to use `items: import.meta.glob(...)` to generate a list of RSS feed items. This usage is now deprecated and will eventually be removed.

Astro v2.0 introduces a `pagesGlobToRssItems()` wrapper to the `items` property.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-9)

Import, then wrap your existing function containing `import.meta.glob()` with the `pagesGlobToRssItems()` helper.

src/pages/rss.xml.js

```
import rss, {pagesGlobToRssItems} from'@astrojs/rss';exportasyncfunctionget(context) {returnrss({items: awaitpagesGlobToRssItems(import.meta.glob('./blog/*.{md,mdx}'),),});}
```


### Changed: Svelte IDE support


[Section titled Changed: Svelte IDE support](#changed-svelte-ide-support)

Astro v2.0 requires a `svelte.config.js` file in your project if you are using [the `@astrojs/svelte` integration](/en/guides/integrations-guide/svelte/). This is needed to provide IDE autocompletion.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-10)

Add a `svelte.config.js` file to the root of your project:

svelte.config.js

```
import { vitePreprocess } from'@astrojs/svelte';exportdefault {preprocess: vitePreprocess(),};
```

For new users, this file will be added automatically when running `astro add svelte`.


### Removed: `legacy.astroFlavoredMarkdown`


[Section titled Removed: legacy.astroFlavoredMarkdown](#removed-legacyastroflavoredmarkdown)

In v1.0, Astro moved the old Astro-Flavored Markdown (also known as Components in Markdown) to a legacy feature.

Astro v2.0 removes the `legacy.astroFlavoredMarkdown` option completely. Importing and using components in `.md` files will no longer work.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-11)

Remove this legacy flag. It is no longer available in Astro.

astro.config.mjs

```
exportdefaultdefineConfig({legacy: {astroFlavoredMarkdown: true,},})
```

If you were using this feature in v1.x, we recommend [using the MDX integration](/en/guides/integrations-guide/mdx/) which allows you to combine components and JSX expressions with Markdown syntax.


### Removed: `Astro.resolve()`


[Section titled Removed: Astro.resolve()](#removed-astroresolve)

In v0.24, Astro deprecated `Astro.resolve()` for getting resolved URLs to assets that you might want to reference in the browser.

Astro v2.0 removes this option entirely. `Astro.resolve()` in your code will cause an error.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-12)

Resolve asset paths using `import` instead. For example:

src/pages/index.astro

```
---import'style.css';import imageUrl from'./image.png';---<imgsrc={imageUrl} />
```


### Removed: `Astro.fetchContent()`


[Section titled Removed: Astro.fetchContent()](#removed-astrofetchcontent)

In v0.26, Astro deprecated `Astro.fetchContent()` for fetching data from your local Markdown files.

Astro v2.0 removes this option entirely. `Astro.fetchContent()` in your code will cause an error.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-13)

Use `Astro.glob()` to fetch Markdown files, or convert to the [Content Collections](/en/guides/content-collections/) feature.

src/pages/index.astro

```
---const allPosts = await Astro.glob('./posts/*.md');---
```


### Removed: `Astro.canonicalURL`


[Section titled Removed: Astro.canonicalURL](#removed-astrocanonicalurl)

In v1.0, Astro deprecated `Astro.canonicalURL` for constructing a canonical URL.

Astro v2.0 removes this option entirely. `Astro.canonicalURL` in your code will cause an error.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-14)

Use `Astro.url` to construct a canonical URL.

src/pages/index.astro

```
---const canonicalURL = newURL(Astro.url.pathname, Astro.site);---
```


### Updated: Vite 4


[Section titled Updated: Vite 4](#updated-vite-4)

Astro v2.0 upgrades from Vite 3 to [Vite 4](https://vite.dev/), released in December 2022.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-15)

There should be no changes to your code necessary! We’ve handled most of the upgrade for you inside of Astro; however, some subtle Vite behaviors may still change between versions.

Refer to the official [Vite Migration Guide](https://vite.dev/guide/migration.html) if you run into trouble.


## Astro v2.0 Experimental Flags Removed


[Section titled Astro v2.0 Experimental Flags Removed](#astro-v20-experimental-flags-removed)

Remove the following experimental flags from `astro.config.mjs`:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {contentCollections: true,prerender: true,errorOverlay: true,},})
```

These features are now available by default:

-   [Content collections](/en/guides/content-collections/) as a way to manage your Markdown and MDX files with type-safety.
-   [Prerendering individual pages to static HTML](/en/guides/on-demand-rendering/) when using SSR to improve speed and cacheability.
-   A redesigned error message overlay.


## Known Issues


[Section titled Known Issues](#known-issues)

There are currently no known issues.

Upgrade Guides


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 143. `en/guides/upgrade-to/v3/.md`

```text
# Upgrade to Astro v3


---
url: https://docs.astro.build/en/guides/upgrade-to/v3/
description: How to upgrade your project to the latest version of Astro (v3.0).
---


# Upgrade to Astro v3


This guide will help you migrate from Astro v2 to Astro v3.

Need to upgrade an older project to v2? See our [older migration guide](/en/guides/upgrade-to/v2/).


## Upgrade Astro


[Section titled Upgrade Astro](#upgrade-astro)

Update your project’s version of Astro to the latest version using your package manager. If you’re using Astro integrations, please also update those to the latest version.

-   [npm](#tab-panel-3388)
-   [pnpm](#tab-panel-3389)
-   [Yarn](#tab-panel-3390)

Terminal window

```

# Upgrade to Astro v3.xnpminstallastro@latest# Example: upgrade React and Tailwind integrationsnpminstall@astrojs/react@latest@astrojs/tailwind@latest

```

Terminal window

```

# Upgrade to Astro v3.xpnpmaddastro@latest# Example: upgrade React and Tailwind integrationspnpmadd@astrojs/react@latest@astrojs/tailwind@latest

```

Terminal window

```

# Upgrade to Astro v3.xyarnaddastro@latest# Example: upgrade React and Tailwind integrationsyarnadd@astrojs/react@latest@astrojs/tailwind@latest

```

Need to continue?

After upgrading Astro to the latest version, you may not need to make any changes to your project at all!

But, if you notice errors or unexpected behavior, please check below for what has changed that might need updating in your project.


## Astro v3.0 Experimental Flags Removed


[Section titled Astro v3.0 Experimental Flags Removed](#astro-v30-experimental-flags-removed)

Remove the following experimental flags from `astro.config.mjs`:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {assets: true,viewTransitions: true,},})
```

These features are now available by default:

-   View Transitions for animated page transitions and persistent islands. See [view transitions API breaking changes and upgrading advice](#upgrade-view-transitions-to-v3) if you were using this experimental flag.
-   A new image services API `astro:assets` for using images in Astro, including a new `<Image />` component and `getImage()` function. Please read the detailed [image upgrade advice](#upgrade-images-to-v3) **whether or not you were using this experimental flag** to see how this might affect your project.

Read more about these two exciting features and more in [the 3.0 Blog post](https://astro.build/blog/astro-3/)!


## Astro v3.0 Breaking Changes


[Section titled Astro v3.0 Breaking Changes](#astro-v30-breaking-changes)

Astro v3.0 includes some breaking changes, as well as the removal of some previously deprecated features. If your project doesn’t work as expected after upgrading to v3.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See [the changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes.


### Removed: Support for Node 16


[Section titled Removed: Support for Node 16](#removed-support-for-node-16)

Node 16 is scheduled to reach its End of Life in September 2023.

Astro v3.0 drops Node 16 support entirely so that all Astro users can take advantage of Node’s more modern features.


#### What should I do?


[Section titled What should I do?](#what-should-i-do)

Check that both your development environment and your deployment environment are using **Node `18.14.1` or higher**.

1.  Check your local version of Node using:

    Terminal window

    ```
    node-v
    ```

2.  Check your [deployment environment’s](/en/guides/deploy/) own documentation to verify that they support Node 18.

    You can specify Node `18.14.1` for your Astro project either in a dashboard configuration setting or a `.nvmrc` file.

    .nvmrc

    ```
    18.14.1
    ```



### Removed: Support for TypeScript 4


[Section titled Removed: Support for TypeScript 4](#removed-support-for-typescript-4)

In Astro v2.x, the `tsconfig.json` presets include support for both TypeScript 4.x and 5.x.

Astro v3.0 updates the `tsconfig.json` presets to only support TypeScript 5.x. Astro now assumes that you use TypeScript 5.0 (March 2023), or that your editor includes it (e.g. VS Code 1.77).


#### What should I do?


[Section titled What should I do?](#what-should-i-do-1)

If you have installed TypeScript locally, update to at least v5.0.

Terminal window

```
npminstalltypescript@latest--save-dev
```


### Removed: `@astrojs/image`


[Section titled Removed: @astrojs/image](#removed-astrojsimage)

In Astro v2.x, Astro offered an official image integration that included Astro `<Image />` and `<Picture />` components.

Astro v3.0 removes this integration from the codebase entirely. Astro’s new solution for images is a built-in image services API: `astro:assets`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-2)

Remove the `@astrojs/image` integration from your project. You will need to not only uninstall the integration but also update or remove any import statements and existing `<Image />` and `<Picture />` components. You might also need to configure a preferred default image processing service.

You will find [complete, step-by-step instructions for removing the old image integration](#remove-astrojsimage) in our Images guide.

Migrating to `astro:assets` will also bring some new image options and features that you may now wish to use. Please see the full [v3.0 Image Upgrade Advice](#upgrade-images-to-v3) for full details!

astro.config.mjs

```
import { defineConfig } from'astro/config';import image from'@astrojs/image';exportdefaultdefineConfig({integrations: [image(),]})
```


### Removed: `<Markdown />` component


[Section titled Removed: &lt;Markdown /&gt; component](#removed-markdown--component)

In Astro v1.x, Astro deprecated the `<Markdown />` component and moved it to an external package.

Astro v3.0 completely removes the package `@astrojs/markdown-component`. Astro’s `<Markdown />` component will no longer work in your project.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-3)

Remove all instances of the `@astrojs/markdown-component`.

src/components/MyAstroComponent.astro

```
---import Markdown from'@astrojs/markdown-component';---
```

To continue using a similar `<Markdown />` component in your code, consider using [community integrations](https://astro.build/integrations/) such as [`astro-remote`](https://github.com/natemoo-re/astro-remote). Be sure to update your `<Markdown />` component imports and attributes as necessary, according to the integration’s own documentation.

Otherwise, delete all references to importing Astro’s `<Markdown />` component and the component itself in your `.astro` files. You will need to rewrite your content as HTML directly or [import Markdown](/en/guides/markdown-content/#importing-markdown) from a `.md` file.


### Removed: deprecated 1.x APIs


[Section titled Removed: deprecated 1.x APIs](#removed-deprecated-1x-apis)

In Astro v1.x, Astro deprecated our original configuration settings as well as `<style global>` and `<script hoist>` support. However, these were still supported for backwards compatibility.

Astro v3.0 removes these deprecated APIs entirely. The officially supported [configuration settings](/en/reference/configuration-reference/) and modern `<style is:global>` and `<script>` syntax should be used instead.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-4)

If you are continuing to use v1.x APIs, use the new APIs for each feature instead:

-   Deprecated config options: See [the 0.26 migration guide](/en/guides/upgrade-to/v1/#new-configuration-api)
-   Deprecated script/style attribute types: See [the 0.26 migration guide](/en/guides/upgrade-to/v1/#new-default-script-behavior)


### Removed: Partial shims for Web APIs in server code


[Section titled Removed: Partial shims for Web APIs in server code](#removed-partial-shims-for-web-apis-in-server-code)

In Astro v2.x, Astro provided partial shims for Web APIs such as `document` or `localStorage` in server-rendered code. These shims were often incomplete and unreliable.

Astro v3.0 removes these partial shims entirely. Web APIs are no longer available in server-rendered code.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-5)

If you are using Web APIs in server-rendered components, you will need to either make the usage of those APIs conditional or use [the `client:only` client directive](/en/reference/directives-reference/#clientonly).


### Removed: `image` from `astro:content` in content collections schema


[Section titled Removed: image from astro:content in content collections schema](#removed-image-from-astrocontent-in-content-collections-schema)

In Astro v2.x, the content collections API deprecated an `image` export from `astro:content` for use in your content collections schemas.

Astro v3.0 removes this export entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-6)

If you are using the deprecated `image()` from `astro:content`, remove it as this no longer exists. Validate images through [the `image` helper from `schema`](#update-content-collections-schemas) instead:

src/content/config.ts

```
import { defineCollection, z, image } from"astro:content";import { defineCollection, z } from"astro:content";defineCollection({schema: ({ image })=>z.object({image: image(),}),});
```


### Removed: pre-0.14 Shiki theme names


[Section titled Removed: pre-0.14 Shiki theme names](#removed-pre-014-shiki-theme-names)

In Astro v2.x, some Shiki theme names had been renamed, but the original names were kept for backwards compatibility.

Astro v3.0 removes the original names in favor of the renamed theme names.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-7)

If your project uses any of the themes below, rename them to their updated name:

-   `material-darker` -> `material-theme-darker`
-   `material-default` -> `material-theme`
-   `material-lighter` -> `material-theme-lighter`
-   `material-ocean` -> `material-theme-ocean`
-   `material-palenight` -> `material-theme-palenight`


### Removed: `class:list` features


[Section titled Removed: class:list features](#removed-classlist-features)

In Astro v2.x, the [`class:list` directive](/en/reference/directives-reference/#classlist) used a custom implementation inspired by [`clsx`](https://github.com/lukeed/clsx) with a few extra features like deduplication and `Set` support.

Astro v3.0 now uses `clsx` directly for `class:list`, which does not support deduplication or `Set` values.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-8)

Replace any `Set` elements passed to the `class:list` directive with a plain `Array`.

src/components/MyAstroComponent.astro

```
<Componentclass:list={['a','b',newSet(['c', 'd'])['c', 'd']]} />
```


### Removed: passing `class:list` as a prop


[Section titled Removed: passing class:list as a prop](#removed-passing-classlist-as-a-prop)

In Astro v2.x, [`class:list` values](/en/reference/directives-reference/#classlist) were sent to components via [`Astro.props['class:list']`](/en/reference/api-reference/#props).

Astro v3.0 normalizes `class:list` values into a string before being sent to components via `Astro.props['class']`


#### What should I do?


[Section titled What should I do?](#what-should-i-do-9)

Remove any code that expects to receive the `class:list` prop.

src/components/MyAstroComponent.astro

```
---import { clsx } from'clsx';const { class: className, 'class:list': classList } = Astro.props;const { class: className } = Astro.props;---<divclass:list={[className, classList]}class:list={[className]}/>
```


### Removed: kebab-case transform for camelCase CSS variables


[Section titled Removed: kebab-case transform for camelCase CSS variables](#removed-kebab-case-transform-for-camelcase-css-variables)

In Astro v2.x, camelCase [CSS variables](/en/guides/styling/#css-variables) passed to the `style` attribute were rendered as both camelCase (as written) and kebab-case (kept for backwards compatibility).

Astro v3.0 removes the kebab-case transform for these camelCase CSS variable names, and only the original camelCase CSS variable is rendered.

src/components/MyAstroComponent.astro

```
---const myValue = "red"---<!-- input --><divstyle={{ "--myValue": myValue }}></div><!-- output (Astro 2.x) --><divstyle="--my-value:var(--myValue);--myValue:red"></div><!-- output (Astro 3.0) --><divstyle="--myValue:red"></div>
```


#### What should I do?


[Section titled What should I do?](#what-should-i-do-10)

If you were relying on Astro to transform kebab-case in your styles, update your existing styles to camelCase to prevent missing styles. For example:

src/components/MyAstroComponent.astro

```
<style>div {color: var(--my-value);color: var(--myValue);}</style>
```


### Removed: automatic flattening of `getStaticPaths()`’s return value


[Section titled Removed: automatic flattening of getStaticPaths()’s return value](#removed-automatic-flattening-of-getstaticpathss-return-value)

In Astro v2.x, the return value of [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) was automatically flattened to allow you to return an array of arrays without errors.

Astro v3.0 removes automatic flattening of `getStaticPaths()`’s result.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-11)

If you’re returning an array of arrays instead of an array of *objects* (as is expected), `.flatMap` and `.flat` should now be used to ensure that you are returning a flat array.

An [error message indicating that `getStaticPath()`’s return value must be an array of objects](/en/reference/errors/invalid-get-static-paths-entry/#what-went-wrong) will be provided if you need to update your code.


### Moved: `astro check` now requires an external package


[Section titled Moved: astro check now requires an external package](#moved-astro-check-now-requires-an-external-package)

In Astro v2.x, [`astro check`](/en/reference/cli-reference/#astro-check) was included in Astro by default, and its dependencies were bundled in Astro. This meant a larger package whether or not you ever used `astro check`. This also prevented you from having control over the version of TypeScript and the Astro Language Server to use.

Astro v3.0 moves the `astro check` command out of Astro core and now requires an external package `@astrojs/check`. Additionally, you must install `typescript` in your project to use the `astro check` command.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-12)

Run the `astro check` command after upgrading to Astro v3.0 and follow the prompts to install the required dependencies, or manually install `@astrojs/check` and `typescript` into your project.


### Deprecated: `build.excludeMiddleware` and `build.split`


[Section titled Deprecated: build.excludeMiddleware and build.split](#deprecated-buildexcludemiddleware-and-buildsplit)

In Astro v2.x, `build.excludeMiddleware` and `build.split` were used to change how specific files were emitted when using an adapter in SSR mode.

Astro v3.0 replaces these build config options with new [SSR adapter configuration options](/en/guides/integrations-guide/#official-integrations) to perform the same tasks: `edgeMiddleware` and `functionPerRoute`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-13)

Update the Astro config file to now use the new options **in the adapter configuration** directly.

astro.config.mjs

```
import { defineConfig } from"astro/config";import vercel from"@astrojs/vercel/serverless";exportdefaultdefineConfig({build: {excludeMiddleware: true},adapter: vercel({edgeMiddleware: true}),});
```

astro.config.mjs

```
import { defineConfig } from"astro/config";import netlify from"@astrojs/netlify/functions";exportdefaultdefineConfig({build: {split: true},adapter: netlify({functionPerRoute: true}),});
```


### Deprecated: `markdown.drafts`


[Section titled Deprecated: markdown.drafts](#deprecated-markdowndrafts)

In Astro v2.x, the `markdown.drafts` configuration allowed you to have draft pages that were available in when running the dev server, but not built in production.

Astro v3.0 deprecates this feature in favor of the content collections method of handling draft pages by filtering manually instead, which gives more control over the feature.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-14)

To continue to mark some pages in your project as drafts, [migrate to content collections](/en/guides/content-collections/) and manually filter out pages with the `draft: true` frontmatter property instead.


### Deprecated: returning simple object in endpoints


[Section titled Deprecated: returning simple object in endpoints](#deprecated-returning-simple-object-in-endpoints)

In Astro v2.x, endpoints could return a simple object, which would be converted to a JSON response.

Astro v3.0 deprecates this behavior in favor of returning a `Response` object directly.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-15)

Update your endpoints to return a `Response` object directly.

endpoint.json.ts

```
exportasyncfunctionGET() {return { body: { "title": "Bob's blog" }};returnnewResponse(JSON.stringify({ "title": "Bob's blog" }));}
```

If you really need to keep the previous format, you can use the `ResponseWithEncoding` object but will be deprecated in the future.

endpoint.json.ts

```
exportasyncfunctionGET() {return { body: { "title": "Bob's blog" } };returnnewResponseWithEncoding({ body: { "title": "Bob's blog" }});}
```


### Changed default: `verbatimModuleSyntax` in tsconfig.json presets


[Section titled Changed default: verbatimModuleSyntax in tsconfig.json presets](#changed-default-verbatimmodulesyntax-in-tsconfigjson-presets)

In Astro v2.x, the [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) setting was off by default, with its TypeScript 4.x equivalent `importsNotUsedAsValues` being enabled in the `strict` preset.

In Astro v3.0, `verbatimModuleSyntax` is enabled in every preset.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-16)

This option requires that types are imported using the `import type` syntax.

src/components/MyAstroComponent.astro

```
---import { type CollectionEntry, getEntry } from"astro:content";---
```

While we recommend keeping it on and properly making your type imports with `type` (as shown above), you can disable it by setting `verbatimModuleSyntax: false` in your `tsconfig.json` file if it causes any issues.

tsconfig.json

```
{"compilerOptions": {"verbatimModuleSyntax": false}}
```


### Changed default: port `3000`


[Section titled Changed default: port 3000](#changed-default-port-3000)

In Astro v2.x, Astro ran on port `3000` by default.

Astro v3.0 changes the [default port](/en/reference/cli-reference/#--port-number) to `4321`. 🚀


#### What should I do?


[Section titled What should I do?](#what-should-i-do-17)

Update any existing references to `localhost:3000`, for example in tests or in your `README`, to reflect the new port `localhost:4321`.


### Changed default: import.meta.env.BASE\_URL `trailingSlash`


[Section titled Changed default: import.meta.env.BASE\_URL trailingSlash](#changed-default-importmetaenvbase_url-trailingslash)

In Astro v2.x, `import.meta.env.BASE_URL` appended your [`base`](/en/reference/configuration-reference/#base) setting with a [trailingSlash](/en/reference/configuration-reference/#trailingslash) by default. `trailingSlash: "ignore"` also appended a trailing slash.

Astro v3.0 no longer appends `import.meta.env.BASE_URL` with a trailing slash by default, nor when `trailingSlash: "ignore"` is set. (The existing behavior of `base` in combination with `trailingSlash: "always"` or `trailingSlash: "never"` is unchanged.)


#### What should I do?


[Section titled What should I do?](#what-should-i-do-18)

If your `base` already has a trailing slash, no change is needed.

If your `base` does not have a trailing slash, add one if you wish to preserve the previous default (or `trailingSlash: "ignore"`) behavior:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({base: 'my-base',base: 'my-base/',});
```


### Changed default: `compressHTML`


[Section titled Changed default: compressHTML](#changed-default-compresshtml)

In Astro v2.x, Astro only compressed your emitted HTML when [`compressHTML`](/en/reference/configuration-reference/#compresshtml) was explicitly set to `true`. The default value was `false`.

Astro v3.0 now compresses emitted HTML by default.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-19)

You can now remove `compressHTML: true` from your configuration as this is the new default behavior.

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({compressHTML: true})
```

You must now set `compressHTML: false` to opt out of HTML compression.


### Changed default: `scopedStyleStrategy`


[Section titled Changed default: scopedStyleStrategy](#changed-default-scopedstylestrategy)

In Astro v2.x, the default value of [`scopedStyleStrategy`](/en/reference/configuration-reference/#scopedstylestrategy) was `"where"`.

Astro v3.0 introduces a new, default value: `"attribute"`. By default, styles are now applied using `data-*` attributes.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-20)

To retain your project’s current [style scoping](/en/guides/styling/#scoped-styles), update the configuration file to the previous default value:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({scopedStyleStrategy: "where"})
```


### Changed default: `inlineStyleSheets`


[Section titled Changed default: inlineStyleSheets](#changed-default-inlinestylesheets)

In Astro v2.x, all project stylesheets were sent as link tags by default. You could opt in to inlining them into `<style>` tags every time with `"always"`, or to inlining only stylesheets below a certain size with `"auto"` by setting the [`build.inlineStylesheets`](/en/reference/configuration-reference/#buildinlinestylesheets) configuration. The default setting was `"never"`.

Astro v3.0 changes the default value of `inlineStylesheets` to `"auto"`. Stylesheets smaller than `ViteConfig.build.assetsInlineLimit` (default: 4kb) are inlined by default. Otherwise, project styles are sent in external stylesheets.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-21)

If you want to keep your project’s current behavior, set `build.inlineStylesheets` to the previous default, `"never"`:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({build: {inlineStylesheets: "never"}})
```


### Changed default: image service


[Section titled Changed default: image service](#changed-default-image-service)

In Astro v2.x, Squoosh was the [default image processing service](/en/guides/images/#default-image-service).

Astro v3.0 now includes Sharp as the default image processing service and instead provides a configuration option to use Squoosh.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-22)

Note

When using a [strict package manager](https://pnpm.io/pnpm-vs-npm#npms-flat-tree) like `pnpm`, you may need to manually install Sharp into your project even though it is an Astro dependency:

Terminal window

```
pnpmaddsharp
```

If you would prefer to continue to use Squoosh to transform your images, update your config with the following:

astro.config.mjs

```
import { defineConfig, squooshImageService } from"astro/config";exportdefaultdefineConfig({image: {service: squooshImageService(),}})
```


### Changed: HTTP request methods case


[Section titled Changed: HTTP request methods case](#changed-http-request-methods-case)

In Astro v2.x, [HTTP request methods](/en/guides/endpoints/#http-methods) were written using lowercase function names: `get`, `post`, `put`, `all`, and `del`.

Astro v3.0 uses uppercase function names, including `DELETE` instead of `del`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-23)

Rename all functions to their uppercase equivalent:

-   `get` to `GET`
-   `post` to `POST`
-   `put` to `PUT`
-   `all` to `ALL`
-   `del` to `DELETE`

endpoint.ts

```
exportfunctionget() {exportfunctionGET() {returnnewResponse(JSON.stringify({ "title": "Bob's blog" }));}
```


### Changed: Multiple JSX framework configuration


[Section titled Changed: Multiple JSX framework configuration](#changed-multiple-jsx-framework-configuration)

In Astro v2.x, you could use [multiple JSX framework integrations](/en/guides/integrations-guide/#official-integrations) (React, Solid, Preact) in the same project without needing to identify which files belonged to which framework.

Astro v3.0 now requires you to specify which framework to use for your files with new `include` and `exclude` integration config options when you have multiple JSX framework integrations installed. This allows Astro to better support single-framework usage, as well as advanced features like React Fast Refresh.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-24)

If you are using multiple JSX frameworks in the same project, set `include` (and optionally `exclude`) to an array of files and/or folders. Wildcards may be used to include multiple file paths.

We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required:

```
import { defineConfig } from'astro/config';import preact from'@astrojs/preact';import react from'@astrojs/react';import svelte from'@astrojs/svelte';import vue from'@astrojs/vue';import solid from'@astrojs/solid-js';exportdefaultdefineConfig({// Enable many frameworks to support all different kinds of components.// No `include` is needed if you are only using a single framework!integrations: [preact({include: ['**/preact/*']}),react({include: ['**/react/*']}),solid({include: ['**/solid/*'],}),]});
```


### Changed: `Astro.cookies.get(key)` can return `undefined`


[Section titled Changed: Astro.cookies.get(key) can return undefined](#changed-astrocookiesgetkey-can-return-undefined)

In Astro v2.x, `Astro.cookies.get(key)` would always return an `AstroCookie` object, even if the cookie did not exist. To check for its existence, you needed to use `Astro.cookies.has(key)`.

Astro v3.0 returns `undefined` for `Astro.cookies.get(key)` if the cookie does not exist.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-25)

This change will not break any code that checks for the existence of the `Astro.cookie` object before using `Astro.cookies.get(key)`, but is now no longer required.

You can safely remove any code that uses `has()` to check if the value of `Astro.cookies` is `undefined`:

```
if (Astro.cookies.has(id)) {const id = Astro.cookies.get(id)!;}const id = Astro.cookies.get(id);if (id) {}
```


### Changed: running the Astro CLI programmatically


[Section titled Changed: running the Astro CLI programmatically](#changed-running-the-astro-cli-programmatically)

In Astro v2.x, the `"astro"` package entrypoint exported and ran the Astro CLI directly. It is not recommended to run Astro this way in practice.

Astro v3.0 removes the CLI from the entrypoint, and exports a new set of experimental JavaScript APIs, including `dev()`, `build()`, `preview()`, and `sync()`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-26)

To [run the Astro CLI programmatically](/en/reference/programmatic-reference/), use the new experimental JavaScript APIs:

```
import { dev, build } from"astro";// Start the Astro dev serverconst devServer = await dev();awaitdevServer.stop();// Build your Astro projectawaitbuild();
```


### Changed: internal Astro API entry point export paths


[Section titled Changed: internal Astro API entry point export paths](#changed-internal-astro-api-entry-point-export-paths)

In Astro v2.x, you could import internal Astro APIs from `astro/internal/*` and `astro/runtime/server/*`.

Astro v3.0 removes the two entry points in favor of the existing `astro/runtime/*` entrypoint. Additionally, a new `astro/compiler-runtime` export has been added for compiler-specific runtime code.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-27)

These are entry points for Astro’s internal API and should not affect your project. But if you do use these entrypoints, update as shown below:

```
import'astro/internal/index.js';import'astro/runtime/server/index.js';import'astro/server/index.js';import'astro/runtime/server/index.js';
```

```
import { transform } from'@astrojs/compiler';const result = await transform(source, {internalURL: 'astro/runtime/server/index.js',internalURL: 'astro/compiler-runtime',// ...});
```


## Feature Upgrades


[Section titled Feature Upgrades](#feature-upgrades)


### Upgrade images to v3


[Section titled Upgrade images to v3](#upgrade-images-to-v3)

`astro:assets` is no longer behind an experimental flag in Astro v3.0.

`<Image />` is now a built-in component and the previous `@astrojs/image` integration has been removed.

These and other accompanying changes to using images in Astro may cause some breaking changes when you upgrade your Astro project from an earlier version.

Please follow the instructions below as appropriate to upgrade an Astro v2.x project to v3.0.


#### Upgrade from `experimental.assets`


[Section titled Upgrade from experimental.assets](#upgrade-from-experimentalassets)

If you had previously enabled the experimental flag for `astro:assets`, you will need to update your project for Astro v3.0 which now includes assets features by default.


##### Remove `experimental.assets` flag


[Section titled Remove experimental.assets flag](#remove-experimentalassets-flag)

Remove the experimental flag:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {assets: true}});
```

If necessary, also update your `src/env.d.ts` file to replace the `astro/client-image` reference with `astro/client`:

src/env.d.ts

```
/// <referencetypes="astro/client-image" />/// <referencetypes="astro/client" />
```


##### Remove the `~/assets` import alias


[Section titled Remove the ~/assets import alias](#remove-the-assets-import-alias)

This import alias is no longer included by default with `astro:assets`. If you were using this alias with experimental assets, you must convert them to relative file paths, or [create your own import aliases](/en/guides/imports/#aliases).

src/pages/posts/post-1.astro

```
---import rocket from'~/assets/rocket.png';import rocket from'../../assets/rocket.png';---
```


##### Add simple asset support for Cloudflare, Deno, Vercel Edge and Netlify Edge


[Section titled Add simple asset support for Cloudflare, Deno, Vercel Edge and Netlify Edge](#add-simple-asset-support-for-cloudflare-deno-vercel-edge-and-netlify-edge)

Astro v3.0 allows `astro:assets` to work without errors in Cloudflare, Deno, Vercel Edge and Netlify Edge, which do not support Astro’s built-in Squoosh and Sharp image optimization. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using `astro:assets`, including no Cumulative Layout Shift (CLS), the enforced `alt` attribute, and a consistent authoring experience.

If you previously avoided using `astro:assets` because of these constraints, you can now use them without issues. You can configure the no-op image service to explicitly opt-in to this behavior:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({image: {service: {entrypoint: 'astro/assets/services/noop'}}});
```


#### Decide where to store your images


[Section titled Decide where to store your images](#decide-where-to-store-your-images)

See the Images guide to help you decide [where to store your images](/en/guides/images/#where-to-store-images). You may wish to take advantage of new options for storing your images with the added flexibility `astro:assets` brings. For example, relative images from your project `src/` can now be referenced in Markdown, MDX, and Markdoc using standard Markdown `![alt](src)` syntax.


#### Update existing `<img>` tags


[Section titled Update existing &lt;img&gt; tags](#update-existing-img-tags)

Previously, importing an image would return a simple `string` with the path of the image. Now, imported image assets match the following signature:

```
interface ImageMetadata {src:string;width:number;height:number;format:string;}
```

You must update the `src` attribute of any existing `<img>` tags (including any [images in UI framework components](/en/guides/images/#images-in-ui-framework-components)) and you may also update other attributes that are now available to you from the imported image.

src/components/MyComponent.astro

```
---import rocket from'../images/rocket.svg';---<imgsrc={rocket}width="250"height="250"alt="A rocketship in space." /><imgsrc={rocket.src}width={rocket.width}height={rocket.height}alt="A rocketship in space." />
```


#### Update your Markdown, MDX, and Markdoc files


[Section titled Update your Markdown, MDX, and Markdoc files](#update-your-markdown-mdx-and-markdoc-files)

Relative images from your project `src/` can now be referenced in Markdown, MDX, and Markdoc using standard Markdown `![alt](src)` syntax.

This allows you to move your images from the `public/` directory to your project `src/` where they will now be processed and optimized. Your existing images in `public/` and remote images are still valid but are not optimized by Astro’s build process.

src/pages/posts/post-1.md

```

# My Markdown Page<!-- Local images now possible! -->![A starry night sky.](../../images/stars.png)<!-- Keep your images next to your content! -->![A starry night sky.](./stars.png)

```

If you require more control over your image attributes, we recommend using the `.mdx` file format, which allows you to include Astro’s `<Image />` component or a JSX `<img />` tag in addition to the Markdown syntax. Use the [MDX integration](/en/guides/integrations-guide/mdx/) to add support for MDX to Astro.


#### Remove `@astrojs/image`


[Section titled Remove @astrojs/image](#remove-astrojsimage)

If you were using the image integration in Astro v2.x, complete the following steps:

1.  Remove the `@astrojs/image` integration.

    You must [remove the integration](/en/guides/integrations-guide/#removing-an-integration) by uninstalling and then removing it from your `astro.config.mjs` file.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import image from'@astrojs/image';exportdefaultdefineConfig({integrations: [image(),]})
    ```

2.  Update types (if required).

    If you had special types configured for `@astrojs/image` in `src/env.d.ts`, you may need to change them back to the default Astro types if your upgrade to v3 did not complete this step for you.

    src/env.d.ts

    ```
    /// <reference types="@astrojs/image/client" />/// <reference types="astro/client" />
    ```

    Similarly, update `tsconfig.json` if necessary:

    tsconfig.json

    ```
    {"compilerOptions": {"types": ["@astrojs/image/client"]"types": ["astro/client"]}}
    ```

3.  Migrate any existing `<Image />` components.

    Change all `import` statements from `@astrojs/image/components` to `astro:assets` in order to use the new built-in `<Image />` component.

    Remove any component attributes that are not [currently supported image asset properties](/en/reference/modules/astro-assets/#image-properties).

    For example, `aspectRatio` is no longer supported, as it is now automatically inferred from the `width` and `height` attributes.

    src/components/MyComponent.astro

    ```
    ---import { Image } from'@astrojs/image/components';import { Image } from'astro:assets';import localImage from'../assets/logo.png';const localAlt = 'The Astro Logo';---<Imagesrc={localImage}width={300}aspectRatio="16:9"alt={localAlt}/>
    ```

4.  Choose a default image service.

    [Sharp](https://github.com/lovell/sharp) is now the default image service used for `astro:assets`. If you would like to use Sharp, no configuration is required.

    If you would prefer to use [Squoosh](https://github.com/GoogleChromeLabs/squoosh) to transform your images, update your config with the following `image.service` option:

    astro.config.mjs

    ```
    import { defineConfig, squooshImageService } from'astro/config';exportdefaultdefineConfig({image: {service: squooshImageService(),},});
    ```



#### Update Content Collections schemas


[Section titled Update Content Collections schemas](#update-content-collections-schemas)

You can now declare an associated image for a content collections entry, such as a blog post’s cover image, in your frontmatter using its path relative to the current folder.

The new `image` helper for content collections lets you validate the image metadata using Zod. Learn more about [how to use images in content collections](/en/guides/images/#images-in-content-collections)


#### Navigating Image Imports in Astro v3.0


[Section titled Navigating Image Imports in Astro v3.0](#navigating-image-imports-in-astro-v30)

In Astro v3.0, if you have to preserve the old import behavior for images and require a string representation of the image’s URL, append `?url` to the end of your image path when importing it. For example:

src/pages/blog/MyImages.astro

```
---import Sprite from'../assets/logo.svg?url';---<svg><usexlink:href={Sprite+'#cart'} /></svg>
```

This approach ensures you obtain the URL string. Keep in mind that during development, Astro uses a `src/` path, but upon building, it generates hashed paths like `/_astro/cat.a6737dd3.png`.

If you prefer to work directly with the image object itself, you can access the `.src` property. This approach is best for tasks like managing image dimensions for Core Web Vitals metrics and preventing CLS.

If you are transitioning into the new import behavior, combining `?url` and `.src` methods might be the right method for seamless image handling.


### Upgrade view transitions to v3


[Section titled Upgrade view transitions to v3](#upgrade-view-transitions-to-v3)

View transitions are no longer behind an experimental flag in Astro v3.0.

If you had **not** enabled this experimental flag in Astro 2.x, this will not cause any breaking changes to your project. The new View Transitions API has no effect on your existing code.

If you were previously using experimental view transitions, there may be some breaking changes when you upgrade your Astro project from an earlier version.

Please follow the instructions below as appropriate to upgrade **an Astro v2.x project configured with `experimental.viewTransitions: true`** to v3.0.


#### Upgrade from `experimental.viewTransitions`


[Section titled Upgrade from experimental.viewTransitions](#upgrade-from-experimentalviewtransitions)

If you had previously enabled the experimental flag for view transitions, you will need to update your project for Astro v3.0 which now allows view transitions by default.


##### Remove `experimental.viewTransitions` flag


[Section titled Remove experimental.viewTransitions flag](#remove-experimentalviewtransitions-flag)

Remove the experimental flag:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {viewTransitions: true}});
```


##### Update import source


[Section titled Update import source](#update-import-source)

The `<ViewTransitions />` component has been moved from `astro:components` to `astro:transitions`. Update the import source across all occurrences in your project.

src/layouts/BaseLayout.astro

```
---import { ViewTransitions } from"astro:componentsastro:transitions"---<htmllang="en"><head><title>My Homepage</title><ViewTransitions /></head><body><h1>Welcome to my website!</h1></body></html>
```


#### Update `transition:animate` directives


[Section titled Update transition:animate directives](#update-transitionanimate-directives)

**Changed:** The `transition:animate` value `morph` has been renamed to `initial`. Also, this is no longer the default animation. If no `transition:animate` directive is specified, your animations will now default to `fade`.

1.  Rename any `morph` animations to `initial`.

    src/components/MyComponent.astro

    ```
    <divtransition:name="name"transition:animate="morphinitial" />
    ```

2.  To keep any animations that were previously using `morph` by default, explicitly add `transition:animate="initial"`

    src/components/MyComponent.astro

    ```
    <divtransition:name="name"transition:animate="initial" />
    ```

3.  You can safely remove any animations explicitly set to `fade`. This is now the default behavior:

    src/components/MyComponent.astro

    ```
    <divtransition:name="name"transition:animate="fade" />
    ```


**Added:** Astro also supports a new `transition:animate` value, `none`. This value can be used on a page’s `<html>` element to disable animated full-page transitions on an entire page. This will only override **default animation behavior** on page elements without an animation directive. You can still set animations on individual elements, and these specific animations will occur.

4.  You may now disable all default transitions on an individual page, animating only elements that explicitly use a `transition:animate` directive:

    ```
    <htmltransition:animate="none"><head></head><body><h1>Hello world!</h1></body></html>
    ```



##### Update event names


[Section titled Update event names](#update-event-names)

The event `astro:load` has been renamed to `astro:page-load`. Rename all occurrences in your project.

src/components/MyComponent.astro

```
<script>document.addEventListener('astro:loadastro:page-load', runSetupLogic);</script>
```

The event `astro:beforeload` has been renamed to `astro:after-swap`. Rename all occurrences in your project.

src/components/MyComponent.astro

```
<script>document.addEventListener('astro:beforeloadastro:after-swap', setDarkMode);</script>
```


## Community Resources


[Section titled Community Resources](#community-resources)

Know a good resource for Astro v3.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v3.mdx) and add a link below!


## Known Issues


[Section titled Known Issues](#known-issues)

There are currently no known issues.

Upgrade Guides


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 144. `en/guides/upgrade-to/v4/.md`

```text
# Upgrade to Astro v4


---
url: https://docs.astro.build/en/guides/upgrade-to/v4/
description: How to upgrade your project to the latest version of Astro (v4.0).
---


# Upgrade to Astro v4


This guide will help you migrate from Astro v3 to Astro v4.

Need to upgrade an older project to v3? See our [older migration guide](/en/guides/upgrade-to/v3/).

Need to see the v3 docs? Visit this [older version of the docs site (unmaintained v3.6 snapshot)](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/).


## Upgrade Astro


[Section titled Upgrade Astro](#upgrade-astro)

Update your project’s version of Astro and all official integrations to the latest versions using your package manager.

-   [npm](#tab-panel-3385)
-   [pnpm](#tab-panel-3386)
-   [Yarn](#tab-panel-3387)

Terminal window

```

# Upgrade Astro and official integrations togethernpx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetherpnpmdlx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetheryarndlx@astrojs/upgrade

```

You can also [upgrade your Astro integrations manually](/en/guides/integrations-guide/#manual-upgrading) if needed, and you may also need to upgrade other dependencies in your project.

Need to continue?

After upgrading Astro to the latest version, you may not need to make any changes to your project at all!

But, if you notice errors or unexpected behavior, please check below for what has changed that might need updating in your project.

Astro v4.0 includes [potentially breaking changes](#breaking-changes), as well as the [removal of some previously deprecated features](#previously-deprecated-features-now-removed).

If your project doesn’t work as expected after upgrading to v4.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See [the changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes.


## Astro v4.0 Experimental Flags Removed


[Section titled Astro v4.0 Experimental Flags Removed](#astro-v40-experimental-flags-removed)

Remove the `devOverlay` experimental flag and move any `i18n` config to the top level in `astro.config.mjs`:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {devOverlay: true,i18n: {locales: ["en", "fr", "pt-br", "es"],defaultLocale: "en",}},i18n: {locales: ["en", "fr", "pt-br", "es"],defaultLocale: "en",},})
```

These configurations, `i18n` and the renamed `devToolbar`, are now available in Astro v4.0.

Read more about these two exciting features and more in [the v4.0 Blog post](https://astro.build/blog/astro-4/)!


## Upgrades


[Section titled Upgrades](#upgrades)

Any major upgrades to Astro’s dependencies may cause breaking changes in your project.


### Upgraded: Vite 5.0


[Section titled Upgraded: Vite 5.0](#upgraded-vite-50)

In Astro v3.0, Vite 4 was used as the development server and production bundler.

Astro v4.0 upgrades from Vite 4 to Vite 5.


#### What should I do?


[Section titled What should I do?](#what-should-i-do)

If you are using Vite-specific plugins, configuration, or APIs, check the [Vite migration guide](https://vite.dev/guide/migration) for their breaking changes and upgrade your project as needed. There are no breaking changes to Astro itself.


### Upgraded: unified, remark, and rehype dependencies


[Section titled Upgraded: unified, remark, and rehype dependencies](#upgraded-unified-remark-and-rehype-dependencies)

In Astro v3.x, unified v10 and its related compatible remark/rehype packages were used to process Markdown and MDX.

Astro v4.0 upgrades [unified to v11](https://github.com/unifiedjs/unified/releases/tag/11.0.0) and the other remark/rehype packages to the latest version.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-1)

If you used custom remark/rehype packages, update all of them to the latest version using your package manager to ensure they support unified v11. The packages you are using can be found in `astro.config.mjs`.

There should not be any significant breaking changes if you use actively updated packages, but some packages may not yet be compatible with unified v11. Visually inspect your Markdown/MDX pages before deploying to ensure your site is functioning as intended.


## Breaking Changes


[Section titled Breaking Changes](#breaking-changes)

The following changes are considered breaking changes in Astro. Breaking changes may or may not provide temporary backwards compatibility, and all documentation is updated to refer to only the current, supported code.

If you need to refer to the documentation for a v3.x project, you can browse this [(unmaintained) snapshot of the docs from before v4.0 was released](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/).


### Renamed: `entrypoint` (Integrations API)


[Section titled Renamed: entrypoint (Integrations API)](#renamed-entrypoint-integrations-api)

In Astro v3.x, the property of the `injectRoute` integrations API that specified the route entry point was named `entryPoint`.

Astro v4.0 renames this property to `entrypoint` to be consistent with other Astro APIs. The `entryPoint` property is deprecated but will continue to work and logs a warning prompting you to update your code.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-2)

If you have integrations that use the `injectRoute` API, rename the `entryPoint` property to `entrypoint`. If you’re a library author who wants to support both Astro 3 and 4, you can specify both `entryPoint` and `entrypoint`, in which case, a warning will not be logged.

```
injectRoute({pattern: '/fancy-dashboard',entryPoint: '@fancy/dashboard/dashboard.astro'entrypoint: '@fancy/dashboard/dashboard.astro'});
```


### Changed: `app.render` signature in Integrations API


[Section titled Changed: app.render signature in Integrations API](#changed-apprender-signature-in-integrations-api)

In Astro v3.0, the `app.render()` method accepted `routeData` and `locals` as separate, optional arguments.

Astro v4.0 changes the `app.render()` signature. These two properties are now available in a single object. Both the object and these two properties are still optional.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-3)

If you are maintaining an adapter, the current signature will continue to work until the next major version. To migrate to the new signature, pass `routeData` and `locals` as properties of an object instead of as multiple independent arguments.

```
app.render(request, routeData, locals)app.render(request, { routeData, locals })
```


### Changed: adapters must now specify supported features


[Section titled Changed: adapters must now specify supported features](#changed-adapters-must-now-specify-supported-features)

In Astro v3.x, adapters were not required to specify the features they support.

Astro v4.0 requires adapters to pass the `supportedAstroFeatures{}` property to specify a list of features they support. This property is no longer optional.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-4)

Adapter authors need to pass the `supportedAstroFeatures{}` option to specify a list of features they support.

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',supportedAstroFeatures: {staticOutput: 'stable'}});},},};}
```


### Removed: Shiki language `path` property


[Section titled Removed: Shiki language path property](#removed-shiki-language-path-property)

In Astro v3.x, a Shiki language passed to `markdown.shikiConfig.langs` was automatically converted to a Shikiji-compatible language. Shikiji is the internal tooling used by Astro for syntax highlighting.

Astro v4.0 removes support for the `path` property of a Shiki language, which was confusing to configure. It is replaced by an import which can be passed to `langs` directly.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-5)

The language JSON file should be imported and passed to the option instead.

astro.config.js

```
import customLang from'./custom.tmLanguage.json'exportdefaultdefineConfig({markdown: {shikiConfig: {langs: [{ path: '../../custom.tmLanguage.json' },customLang,],},},})
```


## Deprecated


[Section titled Deprecated](#deprecated)

The following deprecated features are no longer supported and are no longer documented. Please update your project accordingly.

Some deprecated features may temporarily continue to function until they are completely removed. Others may silently have no effect, or throw an error prompting you to update your code.


### Deprecated: `handleForms` for View Transitions `submit` events


[Section titled Deprecated: handleForms for View Transitions submit events](#deprecated-handleforms-for-view-transitions-submit-events)

In Astro v3.x, projects using the `<ViewTransitions />` component were required to opt-in to handling `submit` events for `form` elements. This was done by passing a `handleForms` prop.

Astro v4.0 handles `submit` events for `form` elements by default when `<ViewTransitions />` are used. The `handleForms` prop has been deprecated and no longer has any effect.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-6)

Remove the `handleForms` property from your `ViewTransitions` component. It is no longer necessary.

src/pages/index.astro

```
---import { ViewTransitions } from"astro:transitions";---<html><head><ViewTransitionshandleForms /></head><body><!-- stuff here --></body></html>
```

To opt out of `submit` event handling, add the `data-astro-reload` attribute to relevant `form` elements.

src/components/Form.astro

```
<formaction="/contact"data-astro-reload><!-- --></form>
```


## Previously deprecated features now removed


[Section titled Previously deprecated features now removed](#previously-deprecated-features-now-removed)

The following deprecated features have now been entirely removed from the code base and can no longer be used. Some of these features may have continued to work in your project even after deprecation. Others may have silently had no effect.

Projects now containing these removed features will be unable to build, and there will no longer be any supporting documentation prompting you to remove these features.


### Removed: returning simple objects from endpoints


[Section titled Removed: returning simple objects from endpoints](#removed-returning-simple-objects-from-endpoints)

In Astro v3.x, returning simple objects from endpoints was deprecated, but was still supported to maintain compatibility with Astro v2. A `ResponseWithEncoding` utility was also provided to ease the migration.

Astro v4.0 removes support for simple objects and requires endpoints to always return a `Response`. The `ResponseWithEncoding` utility is also removed in favor of a proper `Response` type.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-7)

Update your endpoints to return a `Response` object directly.

```
exportasyncfunctionGET() {return { body: { "title": "Bob's blog" }};returnnewResponse(JSON.stringify({ "title": "Bob's blog" }));}
```

To remove usage of `ResponseWithEncoding`, refactor your code to use an `ArrayBuffer` instead:

```
exportasyncfunctionGET() {const file = await fs.readFile('./bob.png');returnnewResponseWithEncoding(file.toString('binary'),undefined,'binary');returnnewResponse(file.buffer);}
```


### Removed: `build.split` and `build.excludeMiddleware`


[Section titled Removed: build.split and build.excludeMiddleware](#removed-buildsplit-and-buildexcludemiddleware)

In Astro v3.0, `build.split` and `build.excludeMiddleware` build config options were deprecated and replaced with [adapter configuration options](/en/reference/adapter-reference/#adapter-features) to perform the same tasks.

Astro v4.0 removes these properties entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-8)

If you are using the deprecated `build.split` or `build.excludeMiddleware`, you must now remove them as these no longer exist.

Please see the v3 migration guide to [update these deprecated middleware properties](/en/guides/upgrade-to/v3/#deprecated-buildexcludemiddleware-and-buildsplit) with adapter configurations.


### Removed: `Astro.request.params`


[Section titled Removed: Astro.request.params](#removed-astrorequestparams)

In Astro v3.0, the `Astro.request.params` API was deprecated, but preserved for backwards compatibility.

Astro v4.0 removes this option entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-9)

Update all occurrences to [`Astro.params`](/en/reference/api-reference/#params), which is the supported replacement.

```
const { id } = Astro.request.params;const { id } = Astro.params;
```


### Removed: `markdown.drafts`


[Section titled Removed: markdown.drafts](#removed-markdowndrafts)

In Astro v3.0, using `markdown.drafts` to control the building of draft posts was deprecated.

Astro v4.0 removes this option entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-10)

If you are using the deprecated `markdown.drafts`, you must now remove it as it no longer exists.

To continue to mark some pages in your project as drafts, [migrate to content collections](/en/guides/content-collections/) and manually filter out pages with the `draft: true` frontmatter property instead.


### Removed: `getHeaders()`


[Section titled Removed: getHeaders()](#removed-getheaders)

In Astro v3.0, the `getHeaders()` Markdown export was deprecated and replaced with `getHeadings()`.

Astro v4.0 removes this option entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-11)

If you are using the deprecated `getHeaders()`, you must now remove it as it no longer exists. Replace any instances with `getHeadings()`, which is the supported replacement.

```
const posts = await Astro.glob('../content/blog/*.mdx');const firstPostHeadings = posts.at(0).getHeaders();const firstPostHeadings = posts.at(0).getHeadings();
```


### Removed: using `rss` in `getStaticPaths()`


[Section titled Removed: using rss in getStaticPaths()](#removed-using-rss-in-getstaticpaths)

In Astro v3.0, using the deprecated `rss` helper in `getStaticPaths()` would throw an error.

Astro v4.0 removes this helper entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-12)

If you are using the unsupported method for generating RSS feeds, you must now use the [`@astrojs/rss` integration](/en/recipes/rss/) for a complete RSS setup.


### Removed: lowercase HTTP method names


[Section titled Removed: lowercase HTTP method names](#removed-lowercase-http-method-names)

In Astro v3.0, using lowercase HTTP request method names (`get`, `post`, `put`, `all`, `del`) was deprecated.

Astro v4.0 removes support for lowercase names entirely. All HTTP request methods must now be written using uppercase.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-13)

If you are using the deprecated lowercase names, you must now replace them with their uppercase equivalents.

Please see the v3 migration guide [for guidance using uppercase HTTP request methods](/en/guides/upgrade-to/v3/#changed-http-request-methods-case).


### Removed: 301 redirects when missing a `base` prefix


[Section titled Removed: 301 redirects when missing a base prefix](#removed-301-redirects-when-missing-a-base-prefix)

In Astro v3.x, the Astro preview server returned a 301 redirect when accessing public directory assets without a base path.

Astro v4.0 returns a 404 status without a base path prefix for public directory assets when the preview server is running, matching the behavior of the dev server.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-14)

When using the Astro preview server, all of your static asset imports and URLs from the public directory must have [the base value](/en/reference/configuration-reference/#base) prefixed to the path.

The following example shows the `src` attribute required to display an image from the public folder when `base: '/docs'` is configured:

src/pages/index.astro

```
// To access public/images/my-image.png:<imgsrc="/docs/images/my-image.png"alt="">
```


### Removed: `astro/client-image` auto-conversion


[Section titled Removed: astro/client-image auto-conversion](#removed-astroclient-image-auto-conversion)

In Astro v3.x, the `astro/client-image` type (used for the deprecated image integration) was removed but was auto-converted to the default Astro type `astro/client` if found in your `env.d.ts` file.

Astro v4.0 ignores `astro/client-image` and will no longer update `env.d.ts` for you automatically.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-15)

If you had types configured for `@astrojs/image` in `src/env.d.ts` and upgrading to v3.0 did not automatically convert the type for you, replace the `astro/client-image` type manually with `astro/client`.

src/env.d.ts

```
/// <reference types="astro/client-image" />/// <reference types="astro/client" />
```


## Community Resources


[Section titled Community Resources](#community-resources)

Know a good resource for Astro v4.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v4.mdx) and add a link below!


## Known Issues


[Section titled Known Issues](#known-issues)

Please check [Astro’s issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.

Upgrade Guides


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 145. `en/guides/upgrade-to/v5/.md`

```text
# Upgrade to Astro v5


---
url: https://docs.astro.build/en/guides/upgrade-to/v5/
description: How to upgrade your project to Astro v5.0.
---


# Upgrade to Astro v5


This guide will help you migrate from Astro v4 to Astro v5.

Need to upgrade an older project to v4 first? See our [older migration guide](/en/guides/upgrade-to/v4/).

Need to see the v4 docs? Visit this [older version of the docs site (unmaintained v4.16 snapshot)](https://v4.docs.astro.build/).


## Upgrade Astro


[Section titled Upgrade Astro](#upgrade-astro)

Update your project’s version of Astro to the latest version using your package manager:

-   [npm](#tab-panel-3391)
-   [pnpm](#tab-panel-3392)
-   [Yarn](#tab-panel-3393)

Terminal window

```

# Upgrade Astro and official integrations togethernpx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetherpnpmdlx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetheryarndlx@astrojs/upgrade

```

You can also [upgrade your Astro integrations manually](/en/guides/integrations-guide/#manual-upgrading) if needed, and you may also need to upgrade other dependencies in your project.

Need to continue?

After upgrading Astro, you may not need to make any changes to your project at all!

But, if you notice errors or unexpected behavior, please check below for what has changed that might need updating in your project.

Astro v5.0 includes [potentially breaking changes](#breaking-changes), as well as the removal and deprecation of some features.

If your project doesn’t work as expected after upgrading to v5.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See [the Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes.


## Dependency Upgrades


[Section titled Dependency Upgrades](#dependency-upgrades)

Any major upgrades to Astro’s dependencies may cause breaking changes in your project.


### Vite 6.0


[Section titled Vite 6.0](#vite-60)

Astro v5.0 upgrades to Vite v6.0 as the development server and production bundler.


#### What should I do?


[Section titled What should I do?](#what-should-i-do)

If you are using Vite-specific plugins, configuration, or APIs, check the [Vite migration guide](https://vite.dev/guide/migration.html) for their breaking changes and upgrade your project as needed.


### `@astrojs/mdx`


[Section titled @astrojs/mdx](#astrojsmdx)

[Implementation PR: Cleanup unused JSX code (#11741)](https://github.com/withastro/astro/pull/11741)

In Astro v4.x, Astro performed internal JSX handling for the `@astrojs/mdx` integration.

Astro v5.0 moves this responsibility to handle and render JSX and MDX to the `@astrojs/mdx` package directly. This means that Astro 5.0 is no longer compatible with older versions of the MDX integration.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-1)

If your project includes `.mdx` files, you must upgrade `@astrojs/mdx` to the latest version (v4.0.0) so that your JSX can be handled properly by the integration.

If you are using an MDX server renderer with the experimental [Astro Container API](/en/reference/container-reference/) you must update the import to reflect the new location:

```
import mdxRenderer from"astro/jsx/server.js";import mdxRenderer from"@astrojs/mdx/server.js";
```

Learn more about [using MDX in your project](/en/guides/integrations-guide/mdx/).


## Legacy


[Section titled Legacy](#legacy)

The following features are now considered legacy features. They should function normally but are no longer recommended and are in maintenance mode. They will see no future improvements and documentation will not be updated. These features will eventually be deprecated, and then removed entirely.


### Legacy: v2.0 Content Collections API


[Section titled Legacy: v2.0 Content Collections API](#legacy-v20-content-collections-api)

In Astro 4.x, content collections were defined, queried, and rendered using [the Content Collections API first introduced in Astro v2.0](https://astro.build/blog/introducing-content-collections/). All collection entries were local files within the reserved `src/content/` folder. Additionally, Astro’s [file name convention to exclude building individual pages](/en/guides/routing/#excluding-pages) was built in to the Content Collections API.

Astro 5.0 introduces a new version of content collections using the Content Layer API which brings several performance improvements and added capabilities. While old (legacy) and new (Content Layer API) collections can continue exist together in this release, there are potentially breaking changes to existing legacy collections.

This release also removes the option to prefix collection entry file names with an underscore (`_`) to prevent building a route.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-2)

We recommend [converting any existing collections to the new Content Layer API](#updating-existing-collections) as soon as you are able and making any new collections using the Content Layer API.

If you are unable to convert your collections, then please consult the [legacy collections breaking changes](#breaking-changes-to-legacy-content-and-data-collections) to see whether your existing collections are affected and require updating.

If you are unable to make any changes to your collections at this time, you can [enable the `legacy.collections` flag](#enabling-the-legacycollections-flag) which will allow you to keep your collections in their current state until the legacy flag is no longer supported.

Learn more about the updated [content collections](/en/guides/content-collections/).


##### Updating existing collections


[Section titled Updating existing collections](#updating-existing-collections)

See the instructions below for updating an existing content collection (`type: 'content'` or `type: 'data'`) to use the Content Layer API.

Step-by-step instructions to update a collection

1.  **Move the content config file**. This file no longer lives within the `src/content/` folder. This file should now exist at `src/content.config.ts`.

2.  **Edit the collection definition**. Your updated collection requires a `loader` which indicates both a folder for the location of your collection (`base`) and a `pattern` defining the collection entry filenames and extensions to match. (You may need to update the example below accordingly. You can use [globster.xyz](https://globster.xyz/) to check your glob pattern.) The option to select a collection `type` is no longer available.

    src/content.config.ts

    ```
    import { defineCollection, z } from'astro:content';import { glob } from'astro/loaders';const blog = defineCollection({// For content layer you no longer define a `type`type: 'content',loader: glob({ pattern: '**/[^_]*.{md,mdx}', base: "./src/data/blog" }),schema: z.object({title: z.string(),description: z.string(),pubDate: z.coerce.date(),updatedDate: z.coerce.date().optional(),}),});
    ```

3.  **Change references from `slug` to `id`**. Content layer collections do not have a reserved `slug` field. Instead, all updated collections will have an `id`:

    src/pages/\[slug\].astro

    ```
    ---exportasyncfunctiongetStaticPaths() {const posts = await getCollection('blog');return posts.map((post)=> ({params: { slug: post.slug },params: { slug: post.id },props: post,}));}---
    ```

    You can also update the dynamic routing file names to match the value of the changed `getStaticPaths()` parameter.

4.  **Switch to the new `render()` function**. Entries no longer have a `render()` method, as they are now serializable plain objects. Instead, import the `render()` function from `astro:content`.

    src/pages/index.astro

    ```
    ---import { getEntry, render } from'astro:content';const post = await getEntry('blog', params.slug);const { Content, headings } = await post.render();const { Content, headings } = await render(post);---<Content />
    ```



##### Breaking changes to legacy `content` and `data` collections


[Section titled Breaking changes to legacy content and data collections](#breaking-changes-to-legacy-content-and-data-collections)

[Implementation PR: Implement legacy collections using glob (#11976)](https://github.com/withastro/astro/pull/11976)

By default, collections that use the old `type` property (`content` or `data`) and do not define a `loader` are now implemented under the hood using the Content Layer API’s built-in `glob()` loader, with extra backward-compatibility handling.

Additionally, temporary backwards compatibility exists for keeping the content config file in its original location of `src/content/config.ts`.

This backwards compatibility implementation is able to emulate most of the features of legacy collections and will allow many legacy collections to continue to work even without updating your code. However, **there are some differences and limitations that may cause breaking changes to existing collections**:

-   In previous versions of Astro, collections would be generated for all folders in `src/content/`, even if they were not defined in `src/content/config.ts`. This behavior is now deprecated, and collections should always be defined in `src/content.config.ts`. For existing collections, these can just be empty declarations (e.g. `const blog = defineCollection({})`) and Astro will implicitly define your legacy collection for you in a way that is compatible with the new loading behavior.
-   The special `layout` field is not supported in Markdown collection entries. This property is intended only for standalone page files located in `src/pages/` and not likely to be in your collection entries. However, if you were using this property, you must now create dynamic routes that include your page styling.
-   Sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling `getCollection()`, the order in which entries are returned may be different than before. If you need a specific order, you must sort the collection entries yourself.
-   `image().refine()` is not supported. If you need to validate the properties of an image you will need to do this at runtime in your page or component.
-   The `key` argument of `getEntry(collection, key)` is typed as `string`, rather than having types for every entry.
-   Previously when calling `getEntry(collection, key)` with a static string as the key, the return type was not nullable. The type now includes `undefined` so you must check if the entry is defined before using the result or you will have type errors.


##### Enabling the `legacy.collections` flag


[Section titled Enabling the legacy.collections flag](#enabling-the-legacycollections-flag)

[Implementation PR: Implement legacy collections using glob (#11976)](https://github.com/withastro/astro/pull/11976)

If you are not yet ready to update your existing collections, you can enable the [`legacy.collections`](/en/reference/legacy-flags/) flag and your existing collections will continue to function as before.


## Deprecated


[Section titled Deprecated](#deprecated)

The following deprecated features are no longer supported and are no longer documented. Please update your project accordingly.

Some deprecated features may temporarily continue to function until they are completely removed. Others may silently have no effect, or throw an error prompting you to update your code.


### Deprecated: `Astro.glob()`


[Section titled Deprecated: Astro.glob()](#deprecated-astroglob)

[Implementation PR: Deprecate glob (#11826)](https://github.com/withastro/astro/pull/11826)

In Astro v4.x, you could use `Astro.glob()` in your `.astro` components to query multiple files in your project. This had some limitations (where it could be used, performance, etc.), and using querying functions from the Content Collections API or Vite’s own `import.meta.glob()` often provided more function and flexibility.

Astro 5.0 deprecates `Astro.glob()` in favor of using `getCollection()` to query your collections, and `import.meta.glob()` to query other source files in your project.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-3)

Replace all use of `Astro.glob()` with `import.meta.glob()`. Note that `import.meta.glob()` no longer returns a `Promise`, so you may have to update your code accordingly. You should not require any updates to your [glob patterns](/en/guides/imports/#glob-patterns).

src/pages/blog.astro

```
---const posts = await Astro.glob('./posts/*.md');const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));---{posts.map((post)=><li><ahref={post.url}>{post.frontmatter.title}</a></li>)}
```

Where appropriate, consider using [content collections](/en/guides/content-collections/) to organize your content, which has its own newer, more performant querying functions.

You may also wish to consider using glob packages from NPM, such as [`fast-glob`](https://www.npmjs.com/package/fast-glob).

Learn more about [importing files with `import.meta.glob`](/en/guides/imports/#importmetaglob).


### Deprecated: `functionPerRoute` (Adapter API)


[Section titled Deprecated: functionPerRoute (Adapter API)](#deprecated-functionperroute-adapter-api)

[Implementation PR: Remove functionPerRoute option (#11714)](https://github.com/withastro/astro/pull/11714)

In Astro v4.x, you could opt into creating a separate file for each route defined in the project, mirroring your `src/pages/` directory in the build folder. By default, Astro emitted a single `entry.mjs` file, which was responsible for emitting the rendered page on each request.

Astro v5.0 removes the option to opt out of the default behavior. This behavior is now standard, and non-configurable.

Remove the `functionPerRoute` property from your `adapterFeatures` configuration. It is no longer available.

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',adapterFeatures: {functionPerRoute: true}});},},};}
```

Learn more about [the Adapter API](/en/reference/adapter-reference/) for building adapter integrations.


### Deprecated: `routes` on `astro:build:done` hook (Integration API)


[Section titled Deprecated: routes on astro:build:done hook (Integration API)](#deprecated-routes-on-astrobuilddone-hook-integration-api)

[Implementation PR: feat(next): astro:routes:resolved (#12329)](https://github.com/withastro/astro/pull/12329)

In Astro v4.x, integrations accessed routes from the `astro:build:done` hook.

Astro v5.0 deprecates the `routes` array passed to this hook. Instead, it exposes a new `astro:routes:resolved` hook that runs before `astro:config:done`, and whenever a route changes in development. It has all the same properties of the deprecated `routes` list, except `distURL` which is only available during build.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-4)

Remove any instance of `routes` passed to `astro:build:done` and replace it with the new `astro:routes:resolved` hook. Access `distURL` on the newly exposed `assets` map:

my-integration.mjs

```
const integration = () => {let routesreturn {name: 'my-integration',hooks: {'astro:routes:resolved': (params) => {routes = params.routes},'astro:build:done': ({routesassets}) => {for (const routeofroutes) {const distURL = assets.get(route.pattern)if (distURL) {Object.assign(route, { distURL })}}console.log(routes)}}}}
```

Learn more about [the Integration API `astro:routes:resolved` hook](/en/reference/integrations-reference/#astroroutesresolved) for building integrations.


## Removed


[Section titled Removed](#removed)

The following features have now been entirely removed from the code base and can no longer be used. Some of these features may have continued to work in your project even after deprecation. Others may have silently had no effect.

Projects now containing these removed features will be unable to build, and there will no longer be any supporting documentation prompting you to remove these features.


### Removed: The Lit integration


[Section titled Removed: The Lit integration](#removed-the-lit-integration)

[Implementation PR: Remove \`@astrojs/lit\` (#11680)](https://github.com/withastro/astro/pull/11680)

In Astro v4.x, [Lit](https://lit.dev/) was a core-maintained framework library through the `@astrojs/lit` package.

Astro v5.0 removes the integration and it will not receive further updates for compatibility with 5.x and above.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-5)

You can continue to use Lit for client components by adding a client-side script tag. For example:

```
<script>import"../components/MyTabs";</script><my-tabstitle="These are my tabs">...</my-tabs>
```

If you’re interested in maintaining a Lit integration yourself, you may wish to use the [last published version of `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) as a starting point and upgrade the relevant packages.

Learn more about [Astro’s official integrations](/en/guides/integrations-guide/).


### Removed: `hybrid` rendering mode


[Section titled Removed: hybrid rendering mode](#removed-hybrid-rendering-mode)

[Implementation PR: Merge output:hybrid and output:static (#11824)](https://github.com/withastro/astro/pull/11824)

In Astro v4.x, Astro provided three rendering `output` rendering modes: `'static'`, `'hybrid'`, and `'server'`

Astro v5.0 merges the `output: 'hybrid'` and `output: 'static'` configurations into one single configuration (now called `'static'`) that works the same way as the previous hybrid option.

It is no longer necessary to specify `output: 'hybrid'` in your Astro config to use server-rendered pages. The new `output: 'static'` has this capability included.

Astro will now automatically allow you to opt out of prerendering in your static site with no change to your output configuration required. Any page route or endpoint can include `export const prerender = false` to be server-rendered on demand, while the rest of your site is statically generated.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-6)

If your project used hybrid rendering, you must now remove the `output: 'hybrid'` option from your Astro config as it no longer exists. However, no other changes to your project are required, and you should have no breaking changes. The previous `'hybrid'` behavior is now the default, under a new name `'static'`.

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({output: 'hybrid',});
```

If you were using the `output: 'static'` (default) option, you can continue to use it as before. By default, all of your pages will continue to be prerendered and you will have a completely static site. You should have no breaking changes to your project.

An adapter is still required to deploy an Astro project with any server-rendered pages, no matter which `output` mode your project uses. Failure to include an adapter will result in a warning in development and an error at build time.

Learn more about [on-demand rendering in Astro](/en/guides/on-demand-rendering/).


### Removed: support for dynamic `prerender` values in routes


[Section titled Removed: support for dynamic prerender values in routes](#removed-support-for-dynamic-prerender-values-in-routes)

[Implementation PR: Merge output:hybrid and output:static (#11824)](https://github.com/withastro/astro/pull/11824)

In Astro 4.x, environment variables could be used to dynamically set the value of `prerender` exports in routes, for example `export const prerender = import.meta.env.SOME_VAR`.

Astro v5.0 removes support for dynamic values in `prerender` exports. Only the static values `true` and `false` are supported.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-7)

1.  Remove any dynamic `prerender` exports in your routes:

    src/pages/blog/\[slug\].astro

    ```
    ---export const prerender = import.meta.env.SOME_VAR;---
    ```

2.  Use an Astro integration in your `astro.config.mjs` file to set `prerender` values that need to be dynamic in the `"astro:route:setup"` hook:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import { loadEnv } from'vite';exportdefaultdefineConfig({integrations: [{name: 'set-prerender',hooks: {'astro:route:setup': ({ route })=> {// Load environment variables from .env files (if needed)const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), '');// Find routes matching the expected filename.if (route.component.endsWith('/blog/[slug].astro')) {// Set the prerender value on routes as needed.route.prerender=PRERENDER;}},},}],});
    ```



### Removed: Squoosh image service


[Section titled Removed: Squoosh image service](#removed-squoosh-image-service)

[Implementation PR: remove the squoosh image service (#11770)](https://github.com/withastro/astro/pull/11770)

In Astro 4.x, you could configure `image.service: squooshImageService()` to use Squoosh to transform your images instead of Sharp. However, the underlying library `libsquoosh` is no longer maintained and has memory and performance issues.

Astro 5.0 removes the Squoosh image optimization service entirely.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-8)

To switch to the built-in Sharp image service, remove the `squooshImageService` import from your Astro config. By default, you will use Sharp for `astro:assets`.

astro.config.mjs

```
import { squooshImageService } from"astro/config";import { defineConfig } from"astro/config";exportdefaultdefineConfig({image: {service: squooshImageService()}});
```

If you are using a strict package manager like `pnpm`, you may need to install the `sharp` package manually to use the Sharp image service, even though it is built into Astro by default.

If your adapter does not support Astro’s built-in Sharp image optimization, you can [configure a no-op image service](/en/guides/images/#configure-no-op-passthrough-service) to allow you to use the `<Image />` and `<Picture />` components.

Alternatively, you may wish to consider [a community-maintained Squoosh image service](https://github.com/Princesseuh/astro-image-service-squoosh) if you are unable to use the Sharp image service.


##### For adapters


[Section titled For adapters](#for-adapters)

If your adapter previously precised its compatibility status with Squoosh, you should now remove this information from your adapter configuration.

my-adapter.mjs

```
supportedAstroFeatures: {assets: {isSquooshCompatible: true}}
```

Read more about [configuring your default image service](/en/guides/images/#default-image-service).


### Removed: some public-facing types


[Section titled Removed: some public-facing types](#removed-some-public-facing-types)

[Implementation PR: Refactor/types (#11715)](https://github.com/withastro/astro/pull/11715)

In Astro v4.x, `@types/astro.ts` exposed all types publicly to users, whether or not they were still actively used or only intended for internal use.

Astro v5.0 refactors this file to remove outdated and internal types. This refactor brings improvements to your editor (e.g. faster completions, lower memory usage, and more relevant completion options). However, this refactor may cause errors in some projects that have been relying on types that are no longer available to the public.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-9)

Remove any types that now cause errors in your project as you no longer have access to them. These are mostly APIs that have previously been deprecated and removed, but may also include types that are now internal.

See the [public types exposed for use](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public).


### Experimental Flags


[Section titled Experimental Flags](#experimental-flags)

The following experimental flags have been removed in Astro v5.0 and these features are available for use:

-   `env`
-   `serverIslands`

Additionally, the following experimental flags have been removed and **are now the default or recommended behavior in Astro v5.0**.

-   `directRenderScript` (See below for breaking changes to [default `<script>` behavior](#script-tags-are-rendered-directly-as-declared).)
-   `globalRoutePriority` (See below for breaking changes to [default route priority order](#route-priority-order-for-injected-routes-and-redirects).)
-   `contentLayer` (See guidance for [upgrading existing content collections](#legacy-v20-content-collections-api) to the new, preferred Content Layer API.)

The following experimental flags have been removed and **their corresponding features are not part of Astro v5.0**.

-   `contentCollectionsCache`

Remove these experimental flags if you were previously using them, and move your `env` configuration to the root of your Astro config:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {directRenderScript: true,globalRoutePriority: true,contentLayer: true,serverIslands: true,contentCollectionsCache: true,env: {schema: {...}}},env: {schema: {...}}})
```

These features are all available by default in Astro v5.0.

Read about these exciting features and more in [the v5.0 Blog post](https://astro.build/blog/astro-5/).


## Changed Defaults


[Section titled Changed Defaults](#changed-defaults)

Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes.

In most cases, the only action needed is to review your existing project’s deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior.


### CSRF protection is now set by default


[Section titled CSRF protection is now set by default](#csrf-protection-is-now-set-by-default)

[Implementation PR: change default value of checkOrigin (#11788)](https://github.com/withastro/astro/pull/11788)

In Astro v4.x, The default value of `security.checkOrigin` was `false`. Previously, you had to explicitly set this value to `true` to enable Cross-Site Request Forgery (CSRF) protection.

Astro v5.0 changes the default value of this option to `true`, and will automatically check that the “origin” header matches the URL sent by each request in on-demand rendered pages.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-10)

If you had previously configured `security.checkOrigin: true`, you no longer need this line in your Astro config. This is now the default.

To disable this behavior, you must explicitly set `security.checkOrigin: false`.

astro.config.mjs

```
exportdefaultdefineConfig({output: "server",security: {checkOrigin: false}})
```

Read more about [security configuration options](/en/reference/configuration-reference/#security)


### Route priority order for injected routes and redirects


[Section titled Route priority order for injected routes and redirects](#route-priority-order-for-injected-routes-and-redirects)

[Implementation PR: Remove legacy route prioritization (#11798)](https://github.com/withastro/astro/pull/11798)

In Astro v4.x, `experimental.globalRoutePriority` was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the [route priority order rules for all routes](/en/guides/routing/#route-priority-order). This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order.

Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes.

Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-11)

If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below.

In a project containing the following routes:

-   File-based route: `/blog/post/[pid]`
-   File-based route: `/[page]`
-   Injected route: `/blog/[...slug]`
-   Redirect: `/blog/tags/[tag] -> /[tag]`
-   Redirect: `/posts -> /blog`

The following URLs will be built (instead of following the route priority order of Astro v4.x):

-   `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`)
-   `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`)
-   `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`)

In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

Read more about the [route priority order rules](/en/guides/routing/#route-priority-order).


### `<script>` tags are rendered directly as declared


[Section titled &lt;script&gt; tags are rendered directly as declared](#script-tags-are-rendered-directly-as-declared)

[Implementation PR: Make directRenderScript the default (#11791)](https://github.com/withastro/astro/pull/11791)

In Astro v4.x, `experimental.directRenderScript` was an optional flag to directly render `<scripts>` as declared in `.astro` files (including existing features like TypeScript, importing `node_modules`, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used. Additionally, conditionally rendered scripts were previously implicitly inlined, as if an `is:inline` directive was automatically added to them.

Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the `<head>`, multiple scripts on a page are no longer bundled together, and a `<script>` tag may interfere with CSS styling. Additionally, conditionally rendered scripts are no longer implicitly inlined.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-12)

Please review your `<script>` tags and ensure they behave as desired.

If you previously had conditionally rendered `<script>` tags, you will need to add an `is:inline` attribute to preserve the same behavior as before:

src/components/MyComponent.astro

```
---type Props = {showAlert:boolean}const { showAlert } = Astro.props;---{showAlert &&<scriptis:inline>alert("Some very important code!!")</script>}
```

Read more about [using `script` tags in Astro](/en/guides/client-side-scripts/#using-script-in-astro).


## Breaking Changes


[Section titled Breaking Changes](#breaking-changes)

The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry.


### Renamed: `<ViewTransitions />` component


[Section titled Renamed: &lt;ViewTransitions /&gt; component](#renamed-viewtransitions--component)

[Implementation PR: Rename the ViewTransitions component to ClientRouter (#11980)](https://github.com/withastro/astro/pull/11980)

In Astro 4.x, Astro’s View Transitions API included a `<ViewTransitions />` router component to enable client-side routing, page transitions, and more.

Astro 5.0 renames this component to `<ClientRouter />` to clarify the role of the component within the API. This makes it more clear that the features you get from Astro’s `<ClientRouter />` routing component are slightly different from the native CSS-based MPA router.

No functionality has changed. This component has only changed its name.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-13)

Replace all occurrences of the `ViewTransitions` import and component with `ClientRouter`:

src/layouts/MyLayout.astro

```
import { ViewTransitions } from 'astro:transitions';import { ClientRouter } from 'astro:transitions';<html><head>...<ViewTransitions /><ClientRouter /></head></html>
```

Read more about [view transitions and client-side routing in Astro](/en/guides/view-transitions/).


### Changed: TypeScript configuration


[Section titled Changed: TypeScript configuration](#changed-typescript-configuration)

[Implementation PR: better tsconfig (#11859)](https://github.com/withastro/astro/pull/11859)

In Astro v4.x, Astro relied on a `src/env.d.ts` file for type inferencing and defining modules for features that relied on generated types.

Astro 5.0 instead uses a `.astro/types.d.ts` file for type inferencing, and now recommends setting `include` and `exclude` in `tsconfig.json` to benefit from Astro types and avoid checking built files.

Running `astro sync` no longer creates, nor updates, `src/env.d.ts` as it is not required for type-checking standard Astro projects.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-14)

To update your project to Astro’s recommended TypeScript settings, add the following `include` and `exclude` properties to your existing `tsconfig.json`:

tsconfig.json

```
{"extends": "astro/tsconfigs/base","include": [".astro/types.d.ts", "**/*"],"exclude": ["dist"]}
```

Note that `src/env.d.ts` is only necessary if you have added custom configurations, or if you’re not using a `tsconfig.json` file.

Read more about [TypeScript configuration in Astro](/en/guides/typescript/#setup).


### Changed: Actions submitted by HTML forms no longer use cookie redirects


[Section titled Changed: Actions submitted by HTML forms no longer use cookie redirects](#changed-actions-submitted-by-html-forms-no-longer-use-cookie-redirects)

[Implementation PR: Actions middleware (#12373)](https://github.com/withastro/astro/pull/12373)

In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage.

Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a “confirm form resubmission?” dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-15)

You should update handling for action results that relies on redirects, and optionally address the “confirm form resubmission?” dialog with middleware.


##### To redirect to the previous route on error


[Section titled To redirect to the previous route on error](#to-redirect-to-the-previous-route-on-error)

If your HTML form action is directed to a different route (i.e. `action={"/success-page" + actions.name}`), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise:

src/pages/newsletter.astro

```
---import { actions } from'astro:actions';const result = Astro.getActionResult(actions.newsletter);if (!result?.error) {// Embed relevant result data in the URL if needed// example: redirect(`/confirmation?email=${result.data.email}`);returnredirect('/confirmation');}---<formmethod="POST"action={'/confirmation'+actions.newsletter}><label>E-mail <inputrequiredtype="email"name="email" /></label><button>Sign up</button></form>
```


##### (Optional) To remove the confirm dialog on refresh


[Section titled (Optional) To remove the confirm dialog on refresh](#optional-to-remove-the-confirm-dialog-on-refresh)

To address the “confirm form resubmission?” dialog on refresh, or to preserve action results across sessions, you can now [customize action result handling from middleware](/en/guides/actions/#advanced-persist-action-results-with-a-session).

We recommend using a session storage provider [as described in our Netlify Blob example](/en/guides/actions/#advanced-persist-action-results-with-a-session). However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet:

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {// Skip requests for prerendered pagesif (context.isPrerendered) return next();const { action, setActionResult, serializeActionResult } = getActionContext(context);// If an action result was forwarded as a cookie, set the result// to be accessible from `Astro.getActionResult()`const payload = context.cookies.get('ACTION_PAYLOAD');if (payload) {const { actionName, actionResult } = payload.json();setActionResult(actionName, actionResult);context.cookies.delete('ACTION_PAYLOAD');return next();}// If an action was called from an HTML form action,// call the action handler and redirect with the result as a cookie.if (action?.calledFrom === 'form') {const actionResult = await action.handler();context.cookies.set('ACTION_PAYLOAD', {actionName: action.name,actionResult: serializeActionResult(actionResult),});if (actionResult.error) {// Redirect back to the previous page on errorconst referer = context.request.headers.get('Referer');if (!referer) {throw newError('Internal: Referer unexpectedly missing from Action POST request.');}return context.redirect(referer);}// Redirect to the destination page on successreturn context.redirect(context.originPathname);}return next();})
```


### Changed: `compiledContent()` is now an async function


[Section titled Changed: compiledContent() is now an async function](#changed-compiledcontent-is-now-an-async-function)

[Implementation PR: Remove TLA by making compiledContent async (#11782)](https://github.com/withastro/astro/pull/11782)

In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message.

Astro 5.0 makes the `compiledContent()` property on Markdown import an async function, requiring an `await` to resolve the content.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-16)

Update your code to use `await` when calling `compiledContent()`.

src/pages/post.astro

```
---import*as myPost from"../blog/post.md";const content = myPost.compiledContent();const content = await myPost.compiledContent();---<Fragmentset:html={content} />
```

Read more about the [`compiledContent()` function](/en/guides/markdown-content/#importing-markdown) for returning compiled Markdown.


### Changed: `astro:content` can no longer be used on the client


[Section titled Changed: astro:content can no longer be used on the client](#changed-astrocontent-can-no-longer-be-used-on-the-client)

[Implementation PR: Prevent usage of \`astro:content\` in the client (#11827)](https://github.com/withastro/astro/pull/11827)

In Astro 4.x, it was possible to access the `astro:content` module on the client.

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-17)

If you are currently using `astro:content` in the client, pass the data you need through props to your client components instead:

src/pages/blog.astro

```
---import { getCollection } from'astro:content';import ClientComponent from'../components/ClientComponent';const posts = await getCollection('blog');const postsData = posts.map(post => post.data);---<ClientComponentposts={postsData} />
```

Read more about [the `astro:content` API](/en/reference/modules/astro-content/).


### Renamed: Shiki `css-variables` theme color token names


[Section titled Renamed: Shiki css-variables theme color token names](#renamed-shiki-css-variables-theme-color-token-names)

[Implementation PR: Update to new shiki token names (#11661)](https://github.com/withastro/astro/pull/11661)

In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively.

Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-18)

You can perform a global find and replace in your project to migrate to the new token names.

src/styles/global.css

```
:root {--astro-code-color-text: #000;--astro-code-color-background: #fff;--astro-code-foreground: #000;--astro-code-background: #fff;}
```

Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).


### Changed: internal Shiki rehype plugin for highlighting code blocks


[Section titled Changed: internal Shiki rehype plugin for highlighting code blocks](#changed-internal-shiki-rehype-plugin-for-highlighting-code-blocks)

[Implementation PR: Refactor createShikiHighlighter (#11825)](https://github.com/withastro/astro/pull/11825)

In Astro 4.x, Astro’s internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-19)

If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information).

Code blocks in `.mdoc` files and Astro’s built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected.

Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).


### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages


[Section titled Changed: Automatic charset=utf-8 behavior for Markdown and MDX pages](#changed-automatic-charsetutf-8-behavior-for-markdown-and-mdx-pages)

[Implementation PR: Unset charset=utf-8 content-type for md/mdx pages (#12231)](https://github.com/withastro/astro/pull/12231)

In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages.

Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro’s special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component.

If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-20)

If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so.

Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts).


### Changed: Astro-specific metadata attached in remark and rehype plugins


[Section titled Changed: Astro-specific metadata attached in remark and rehype plugins](#changed-astro-specific-metadata-attached-in-remark-and-rehype-plugins)

[Implementation PR: Clean up Astro metadata in vfile.data (#11861)](https://github.com/withastro/astro/pull/11861)

In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names.

Astro 5 cleans up the API and the metadata is now renamed as below:

-   `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
-   `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-21)

While we don’t consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro’s metadata. If you are using these APIs, make sure to access them in the new locations.

Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins).


### Changed: image endpoint configuration


[Section titled Changed: image endpoint configuration](#changed-image-endpoint-configuration)

[Implementation PR: Allow customising the route of the image endpoint (#11908)](https://github.com/withastro/astro/pull/11908)

In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization.

Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-22)

If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`:

astro.config.mjs

```
import { defineConfig } from"astro/config";defineConfig({image: {endpoint: './src/image-endpoint.ts',endpoint: {route: "/image",entrypoint: "./src/image_endpoint.ts"}},})
```

Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint).


### Changed: `build.client` and `build.server` resolve behavior


[Section titled Changed: build.client and build.server resolve behavior](#changed-buildclient-and-buildserver-resolve-behavior)

[Implementation PR: Fix build.client and build.server resolve behaviour (#11916)](https://github.com/withastro/astro/pull/11916)

In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn’t always work as expected.

Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default:

-   `build.client` will resolve to `<root>/dist/nested/client/`
-   `build.server` will resolve to `<root>/dist/nested/server/`

Previously the values were incorrectly resolved:

-   `build.client` was resolved to `<root>/dist/nested/dist/client/`
-   `build.server` was resolved to `<root>/dist/nested/dist/server/`


#### What should I do?


[Section titled What should I do?](#what-should-i-do-23)

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options).


### Changed: JS dependencies in config file are no longer processed by Vite


[Section titled Changed: JS dependencies in config file are no longer processed by Vite](#changed-js-dependencies-in-config-file-are-no-longer-processed-by-vite)

[Implementation PR: Set external: true when loading astro config (#11819)](https://github.com/withastro/astro/pull/11819)

In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file.

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`.

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it’s also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it’s an implementation detail of Astro’s config loading flow.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-24)

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite).


### Changed: URLs returned by `paginate()`


[Section titled Changed: URLs returned by paginate()](#changed-urls-returned-by-paginate)

[Implementation PR: Add base to paginate (#11253)](https://github.com/withastro/astro/pull/11253)

In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path.

Astro 5.0 automatically includes the `base` value in `page.url`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-25)

If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you:

```
---exportasyncfunctiongetStaticPaths({ paginate }) {const astronautPages = [{astronaut: 'Neil Armstrong',}, {astronaut: 'Buzz Aldrin',}, {astronaut: 'Sally Ride',}, {astronaut: 'John Glenn',}];returnpaginate(astronautPages, { pageSize: 1 });}const { page } = Astro.props;// `base: /'docs'` configured in `astro.config.mjs`const prev = "/docs" + page.url.prev;const prev = page.url.prev;---<aid="prev"href={prev}>Back</a>
```

Read more about [pagination in Astro](/en/guides/routing/#pagination).


### Changed: non-boolean HTML attribute values


[Section titled Changed: non-boolean HTML attribute values](#changed-non-boolean-html-attribute-values)

[Implementation PR: Fix attribute rendering for boolean values (take 2) (#11660)](https://github.com/withastro/astro/pull/11660)

In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers.

In the following `.astro` examples, only `allowfullscreen` is a boolean attribute:

src/pages/index.astro

```
<!-- `allowfullscreen` is a boolean attribute --><pallowfullscreen={true}></p><pallowfullscreen={false}></p><!-- `inherit` is *not* a boolean attribute --><pinherit={true}></p><pinherit={false}></p><!-- `data-*` attributes are not boolean attributes --><pdata-light={true}></p><pdata-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```
<pallowfullscreen></p><p></p><pinherit="true"></p><pinherit></p><pinherit="false"></p><pdata-light></p><pdata-light="true"></p><p></p><pdata-light="false"></p>
```


#### What should I do?


[Section titled What should I do?](#what-should-i-do-26)

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```
el.getAttribute('inherit') ===''el.getAttribute('inherit') ==='false'el.hasAttribute('data-light')el.dataset.light==='true'
```

Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes).


### Changed: adding values to `context.locals`


[Section titled Changed: adding values to context.locals](#changed-adding-values-to-contextlocals)

[Implementation PR: TODOs (#11987)](https://github.com/withastro/astro/pull/11987)

In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values.

Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-27)

Where you previously were overwriting the object, you must now instead assign values to it:

src/middleware.js

```
ctx.locals= {Object.assign(ctx.locals, {one: 1,two: 2}})
```

See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals).


### Changed: `params` no longer decoded


[Section titled Changed: params no longer decoded](#changed-params-no-longer-decoded)

[Implementation PR: decode pathname early, don't decode params (#12079)](https://github.com/withastro/astro/pull/12079)

In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`.

Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-28)

If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`.

src/pages/\[id\].astro

```
---exportfunctiongetStaticPaths() {return [{ params: { id: "%5Bpage%5D" } },{ params: { id: decodeURI("%5Bpage%5D") } },]}const { id } = Astro.params;---
```

Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more.

Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode).


### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API)


[Section titled Changed: RouteData type replaced by IntegrationsRouteData (Integrations API)](#changed-routedata-type-replaced-by-integrationsroutedata-integrations-api)

[Implementation PR: send \`IntegrationRouteData\` to integrations (#11864)](https://github.com/withastro/astro/pull/11864)

In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`.

Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-29)

Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`.

```
importtype {RouteData} from'astro';importtype {IntegrationRouteData} from"astro"functionuseRoute(route:RouteData) {functionuseRoute(route:IntegrationRouteData) {}
```

See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).


### Changed: `distURL` is now an array (Integrations API)


[Section titled Changed: distURL is now an array (Integrations API)](#changed-disturl-is-now-an-array-integrations-api)

[Implementation PR: send \`IntegrationRouteData\` to integrations (#11864)](https://github.com/withastro/astro/pull/11864)

In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`.

Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-30)

Update your code to handle `IntegrationRouteData.distURL` as an array.

```
if (route.distURL) {if (route.distURL.endsWith('index.html')) {// do something}for (const urlofroute.distURL) {if (url.endsWith('index.html')) {// do something}}}
```

See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).


### Changed: Arguments passed to `app.render()` (Adapter API)


[Section titled Changed: Arguments passed to app.render() (Adapter API)](#changed-arguments-passed-to-apprender-adapter-api)

[Implementation PR: TODOs (#11987)](https://github.com/withastro/astro/pull/11987)

In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`.

Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-31)

Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties.

```
const response = await app.render(request, routeData, locals);const response = await app.render(request, {routeData, locals});
```

See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions).


### Changed: Properties on `supportedAstroFeatures` (Adapter API)


[Section titled Changed: Properties on supportedAstroFeatures (Adapter API)](#changed-properties-on-supportedastrofeatures-adapter-api)

[Implementation PR: rework supportedAstroFeatures (#11806)](https://github.com/withastro/astro/pull/11806)

In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro’s image services were supported.

Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service.

v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-32)

If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`.

You may also wish to update your supported features with the new `limited` option and include a message about your adapter’s support.

my-adapter.mjs

```
supportedAstroFeatures: {assets: {supportKind: "stable",isSharpCompatible: true,isSquooshCompatible: true,},sharpImageService: {support: "limited",message: 'This adapter supports the built-in sharp image service, but with some limitations.'}}
```

Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features).


### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)


[Section titled Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)](#removed-deprecated-definition-shape-for-dev-toolbar-apps-dev-toolbar-api)

[Implementation PR: Remove deprecated dev toolbar app shape (#11987)](https://github.com/withastro/astro/pull/11987)

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app’s `entrypoint`.

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that’s more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-33)

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

my-integration.mjs

```
// Old shapeaddDevToolbarApp("./my-dev-toolbar-app.mjs");// New shapeaddDevToolbarApp({id: "my-app",name: "My App",icon: "<svg>...</svg>",entrypoint: "./my-dev-toolbar-app.mjs",});
```

my-dev-toolbar-app.mjs

```
exportdefault {id: 'my-dev-toolbar-app',title: 'My Dev Toolbar App',icon: '🚀',init() {// ...}}
```

Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/).


### Removed: configuring Typescript during `create-astro`


[Section titled Removed: configuring Typescript during create-astro](#removed-configuring-typescript-during-create-astro)

[Implementation PR: create-astro updates (#12083)](https://github.com/withastro/astro/pull/12083)

In Astro v4.x, it was possible to choose between Astro’s three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting.

Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The “strict” preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`.


#### What should I do?


[Section titled What should I do?](#what-should-i-do-34)

If you were using the `--typescript` flag with `create-astro`, remove it from your command.

-   [npm](#tab-panel-3394)
-   [pnpm](#tab-panel-3395)
-   [Yarn](#tab-panel-3396)

Terminal window

```
npmcreateastro@latest----template<example-name>--typescriptstrictnpmcreateastro@latest----template<example-name>
```

Terminal window

```
pnpmcreateastro@latest--template<example-name>--typescriptstrictpnpmcreateastro@latest--template<example-name>
```

Terminal window

```
yarncreateastro--template<example-name>--typescriptstrictyarncreateastro--template<example-name>
```

See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)


## Community Resources


[Section titled Community Resources](#community-resources)

Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below!


## Known Issues


[Section titled Known Issues](#known-issues)

Please check [Astro’s issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.

Upgrade Guides


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 146. `en/guides/view-transitions/.md`

```text
# View transitions


---
url: https://docs.astro.build/en/guides/view-transitions/
description: Enable seamless navigation between pages in Astro with view transitions.
---


# View transitions


Astro supports view transitions with just a few lines of code. View transitions update your page content without the browser’s normal, full-page navigation refresh and provide seamless animations between pages. Where [browser support for the View Transition API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API#browser_compatibility) is lacking, Astro allows you to [control fallback strategies](#fallback-control) for the best possible experience for all visitors.

Astro provides a `<ClientRouter />` routing component that can be added to a single page’s `<head>` to control page transitions as you navigate away to another page. It provides a lightweight client-side router that [intercepts navigation](#client-side-navigation-process) and allows you to customize the transition between pages.

Add this component to a reusable `.astro` component, such as a common head or layout, for [animated page transitions across your entire site (SPA mode)](#full-site-view-transitions-spa-mode).

Astro’s view transitions support is powered by the new [View Transitions](https://developer.chrome.com/docs/web-platform/view-transitions/) browser API and also includes:

-   A few [built-in animation options](#built-in-animation-directives), such as `fade`, `slide`, and `none`.
-   Support for both forwards and backwards navigation animations.
-   The ability to fully [customize all aspects of transition animation](#customizing-animations), and build your own animations.
-   The option to [prevent client-side navigation for non-page links](#preventing-client-side-navigation).
-   [Control over fallback behavior](#fallback-control) for browsers that do not yet support the View Transition APIs.
-   Automatic support for [`prefers-reduced-motion`](#prefers-reduced-motion).

Note

By default, every page will use regular, full-page, browser navigation. You must opt in to view transitions and can use them either on a per-page basis or site-wide.


## Adding View Transitions to a Page


[Section titled Adding View Transitions to a Page](#adding-view-transitions-to-a-page)

Opt in to using view transitions on individual pages by importing and adding the `<ClientRouter />` routing component to `<head>` on every desired page.

src/pages/index.astro

```
---import { ClientRouter } from"astro:transitions";---<htmllang="en"><head><title>My Homepage</title><ClientRouter /></head><body><h1>Welcome to my website!</h1></body></html>
```


## Full site view transitions (SPA mode)


[Section titled Full site view transitions (SPA mode)](#full-site-view-transitions-spa-mode)

Import and add the `<ClientRouter />` component to your common `<head>` or shared layout component. Astro will create default page animations based on the similarities between the old and new page, and will also provide fallback behavior for unsupported browsers.

The example below shows adding Astro’s default page navigation animations site-wide, including the default fallback control option for non-supporting browsers, by importing and adding this component to a `<CommonHead />` Astro component:

src/components/CommonHead.astro

```
---import { ClientRouter } from"astro:transitions";---<linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="generator"content={Astro.generator} /><!-- Primary Meta Tags --><title>{title}</title><metaname="title"content={title} /><metaname="description"content={description} /><ClientRouter />
```

No other configuration is necessary to enable Astro’s default client-side navigation!

Use [transition directives](#transition-directives) or [override default client-side navigation](#preventing-client-side-navigation) on individual elements for finer control.


## Transition Directives


[Section titled Transition Directives](#transition-directives)

Astro will automatically assign corresponding elements found in both the old page and the new page a shared, unique `view-transition-name`. This pair of matching elements is inferred by both the type of element and its location in the DOM.

Use optional `transition:*` directives on page elements in your `.astro` components for finer control over the page transition behaviour during navigation.

-   `transition:name`: Allows you to override Astro’s default element matching for old/new content animation and [specify a transition name](#naming-a-transition) to associate a pair of DOM elements.
-   `transition:animate`: Allows you to override Astro’s default animation while replacing the old element with the new one by specifying an animation type. Use Astro’s [built-in animation directives](#built-in-animation-directives) or [create custom transition animations](#customizing-animations).
-   `transition:persist`: Allows you to override Astro’s default replacing old elements for new ones and instead [persist components and HTML elements](#maintaining-state) when navigating to another page.


### Naming a transition


[Section titled Naming a transition](#naming-a-transition)

In some cases, you may want or need to identify the corresponding view transition elements yourself. You can specify a name for a pair of elements using the `transition:name` directive.

src/pages/old-page.astro

```
<asidetransition:name="hero">
```

src/pages/new-page.astro

```
<asidetransition:name="hero">
```

Note that the provided `transition:name` value can only be used once on each page. Set this manually when Astro can’t infer a proper name itself, or for more fine control over matching elements.


### Maintaining State


[Section titled Maintaining State](#maintaining-state)

**Added in:** `astro@2.10.0`

You can persist components and HTML elements (instead of replacing them) across page navigations using the `transition:persist` directive.

For example, the following `<video>` will continue to play as you navigate to another page that contains the same video element. This works for both forwards and backwards navigation.

src/components/Video.astro

```
<videocontrolsmutedautoplaytransition:persist><sourcesrc="https://ia804502.us.archive.org/33/items/GoldenGa1939_3/GoldenGa1939_3_512kb.mp4"type="video/mp4"/></video>
```

You can also place the directive on an [Astro island](/en/concepts/islands/) (a UI framework component with a [`client:` directive](/en/reference/directives-reference/#client-directives)). If that component exists on the next page, the island from the old page **with its current state** will continue to be displayed, instead of replacing it with the island from the new page.

In the example below, the component’s internal state of the count will not be reset when navigating back and forth across pages that contain the `<Counter />` component with the `transition:persist` attribute.

components/Header.astro

```
<Counterclient:loadtransition:persistinitialCount={5} />
```

Known limitations

Not all state can be preserved in this way. The restart of CSS animations and the reload of iframes cannot be avoided during view transitions even when using `transition:persist`.

You can also [manually identify corresponding elements](#naming-a-transition) if the island/element is in a different component between the two pages.

src/pages/old-page.astro

```
<videocontrolsmutedautoplaytransition:name="media-player"transition:persist/>
```

src/pages/new-page.astro

```
<MyVideocontrolsmutedautoplaytransition:name="media-player"transition:persist/>
```

As a convenient shorthand, `transition:persist` can alternatively take a transition name as a value.

src/pages/index.astro

```
<videocontrolsmutedautoplaytransition:persist="media-player">
```


#### `transition:persist-props`


[Section titled transition:persist-props](#transitionpersist-props)

**Added in:** `astro@4.5.0`

This allows you to control whether or not an island’s props should be persisted upon navigation.

By default, when you add `transition:persist` to an island, the state is retained upon navigation, but your component will re-render with new props. This is useful, for example, when a component receives page-specific props such as the current page’s `title`.

You can override this behavior by setting `transition:persist-props` in addition to `transition:persist`. Adding this directive will keep an island’s existing props (not re-render with new values) in addition to maintaining its existing state.


### Built-in Animation Directives


[Section titled Built-in Animation Directives](#built-in-animation-directives)

Astro comes with a few built-in animations to override the default `fade` transition. Add the `transition:animate` directive to individual elements to customize the behavior of specific transitions.

-   `fade` (default): An opinionated crossfade animation. The old content fades out and the new content fades in.
-   `initial`: Opt out of Astro’s opinionated crossfade animation and use the browser’s default styling.
-   `slide`: An animation where the old content slides out to the left and new content slides in from the right. On backwards navigation, the animations are the opposite.
-   `none`: Disable the browser’s default animations. Use on a page’s `<html>` element to disable the default fade for every element on the page.

Combine directives for full control over your page animation. Set a page default on the `<html>` element, and override on any individual elements as desired.

The example below produces a slide animation for the body content while disabling the browser’s default fade animation for the rest of the page:

```
---import CommonHead from"../components/CommonHead.astro";---<htmltransition:name="root"transition:animate="none"><head><CommonHead /></head><body><header>...</header><!-- Override your page default on a single element --><maintransition:animate="slide">...</main></body></html>
```


### Customizing Animations


[Section titled Customizing Animations](#customizing-animations)

You can customize all aspects of a transition with any CSS animation properties.

To customize a built-in animation, first import the animation from `astro:transitions`, and then pass in customization options.

The example below customizes the duration of the built-in `fade` animation:

```
---import { fade } from"astro:transitions";---<headertransition:animate={fade({ duration: "0.4s" })}>
```

You can also define your own animations for use with `transition:animate` by defining both the forwards and backwards behavior, as well as new and old pages, according to the following types:

```
exportinterface TransitionAnimation {name:string; // The name of the keyframedelay?:number|string;duration?:number|string;easing?:string;fillMode?:string;direction?:string;}exportinterface TransitionAnimationPair {old:TransitionAnimation|TransitionAnimation[];new:TransitionAnimation|TransitionAnimation[];}exportinterface TransitionDirectionalAnimations {forwards:TransitionAnimationPair;backwards:TransitionAnimationPair;}
```

The following example shows all the necessary properties to define a custom `bump` animation inside a `<style is:global>` tag in your root layout file:

src/layouts/Layout.astro

```
---import { ClientRouter } from"astro:transitions";---<htmllang="en"><head><ClientRouter /></head><body><slot /></body></html><styleis:global>@keyframesbump {0% {opacity: 0;transform: scale(1) translateX(200px);}50% {opacity: 0.5;transform: scale(1.1);}100% {opacity: 1;transform: scale(1) translateX(0);}}</style>
```

The animation’s behavior must be defined in the frontmatter of every component using the animation:

src/pages/index.astro

```
---const anim = {old: {name: "bump",duration: "0.5s",easing: "ease-in",direction: "reverse",},new: {name: "bump",duration: "0.5s",easing: "ease-in-out",},};const customTransition = {forwards: anim,backwards: anim,};---<headertransition:animate={customTransition}> ... </header>
```

You have great flexibility when defining custom animations. To achieve your desired result, you may wish to consider unusual combinations such as using different objects for forward and backward, or providing separate keyframe animations for old and new.


## Router control


[Section titled Router control](#router-control)

The `<ClientRouter />` router handles navigation by listening to:

-   Clicks on `<a>` elements.
-   Backwards and forwards navigation events.

The following options allow you to further control when navigation occurs within the router:

-   `data-astro-reload`: an `<a>` tag attribute to [force a full-page navigation](#preventing-client-side-navigation)
-   `data-astro-history="auto | push | replace"`: an `<a>` tag attribute to [control the browser’s history](#replace-entries-in-the-browser-history)
-   `navigate(href, options)`: a method available to any client script or client component to [trigger navigation](#trigger-navigation)


### Preventing client-side navigation


[Section titled Preventing client-side navigation](#preventing-client-side-navigation)

There are some cases where you cannot navigate via client-side routing since both pages involved must use the `<ClientRouter />` router to prevent a full-page reload. You may also not want client-side routing on every navigation change and would prefer a traditional page navigation on select routes instead.

You can opt out of client-side routing on a per-link basis by adding the `data-astro-reload` attribute to any `<a>` or `<form>` tag. This attribute will override any existing `<ClientRouter />` component and instead trigger a browser refresh during navigation.

The following example shows preventing client-side routing when navigating to an article from the home page only. This still allows you to have animation on shared elements, such as a hero image, when navigating to the same page from an article listing page:

src/pages/index.astro

```
<ahref="/articles/emperor-penguins"data-astro-reload>
```

src/pages/articles.astro

```
<ahref="/articles/emperor-penguins">
```

Links with the `data-astro-reload` attribute will be ignored by the router and a full-page navigation will occur.


### Trigger navigation


[Section titled Trigger navigation](#trigger-navigation)

You can also trigger client-side navigation via events not normally listened to by the `<ClientRouter />` router using `navigate`. This function from the `astro:transitions/client` module can be used in scripts, and in framework components that are hydrated with a [client directive](/en/reference/directives-reference/#client-directives).

The following example shows an Astro component that navigates a visitor to another page they select from a menu:

src/components/Form.astro

```
<script>import { navigate } from"astro:transitions/client";// Navigate to the selected option automatically.document.querySelector("select").onchange=(event)=> {let href = event.target.value;navigate(href);};</script><select><optionvalue="/play">Play</option><optionvalue="/blog">Blog</option><optionvalue="/about">About</option><optionvalue="/contact">Contact</option></select>
```

src/pages/index.astro

```
---import Form from"../components/Form.astro";import { ClientRouter } from"astro:transitions";---<html><head><ClientRouter /></head><body><Form /></body></html>
```

The following example implements the same using `navigate()` in a React `<Form />` component:

src/components/Form.jsx

```
import { navigate } from"astro:transitions/client";exportdefaultfunctionForm() {return (<selectonChange={(e)=>navigate(e.target.value)}><optionvalue="/play">Play</option><optionvalue="/blog">Blog</option><optionvalue="/about">About</option><optionvalue="/contact">Contact</option></select>);}
```

The `<Form />` component can then be rendered on an Astro page that uses the `<ClientRouter />` router, with a client directive:

src/pages/index.astro

```
---import Form from"../components/Form.jsx";import { ClientRouter } from"astro:transitions";---<html><head><ClientRouter /></head><body><Formclient:load /></body></html>
```

The `navigate` method takes these arguments:

-   `href` (required) - The new page to navigate to.
-   `options` - An optional object with the following properties:
    -   `history`: `"push"` | `"replace"` | `"auto"`
        -   `"push"`: the router will use `history.pushState` to create a new entry in the browser history.
        -   `"replace"`: the router will use `history.replaceState` to update the URL without adding a new entry into navigation.
        -   `"auto"` (default): the router will attempt `history.pushState`, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.
    -   `formData`: A [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object for `POST` requests.

For backward and forward navigation through the browser history, you can combine `navigate()` with the built-in `history.back()`, `history.forward()` and `history.go()` functions of the browser. If `navigate()` is called during the server-side render of your component, it has no effect.


### Replace entries in the browser history


[Section titled Replace entries in the browser history](#replace-entries-in-the-browser-history)

Normally, each time you navigate, a new entry is written to the browser’s history. This allows navigation between pages using the browser’s `back` and `forward` buttons.

The `<ClientRouter />` router allows you to overwrite history entries by adding the `data-astro-history` attribute to any individual `<a>` tag.

The `data-astro-history` attribute can be set to the same three values as the [`history` option of the `navigate()` function](#trigger-navigation):

`data-astro-history`: `"push"` | `"replace"` | `"auto"`

-   `"push"`: the router will use `history.pushState` to create a new entry in the browser history.
-   `"replace"`: the router will use `history.replaceState` to update the URL without adding a new entry into navigation.
-   `"auto"` (default): the router will attempt `history.pushState`, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.

The following example navigates to the `/main` page but does not add a new entry to the browsing history. Instead, it reuses the current entry in the history (`/confirmation`) and overwrites it.

src/pages/confirmation.astro

```
<ahref="/main"data-astro-history="replace">
```

This has the effect that if you go back from the `/main` page, the browser will not display the `/confirmation` page, but the page before it.


### Transitions with forms


[Section titled Transitions with forms](#transitions-with-forms)

**Added in:** `astro@4.0.0`

The `<ClientRouter />` router will trigger in-page transitions from `<form>` elements, supporting both `GET` and `POST` requests.

By default, Astro submits your form data as `multipart/form-data` when your `method` is set to `POST`. If you want to match the default behavior of web browsers, use the `enctype` attribute to submit your data encoded as `application/x-www-form-urlencoded`:

src/components/Form.astro

```
<formaction="/contact"method="POST"enctype="application/x-www-form-urlencoded">
```

You can opt out of router transitions on any individual form using the `data-astro-reload` attribute:

src/components/Form.astro

```
<formaction="/contact"data-astro-reload>
```


## Fallback control


[Section titled Fallback control](#fallback-control)

The `<ClientRouter />` router works best in browsers that support View Transitions (i.e. Chromium browsers), but also includes default fallback support for other browsers. Even if the browser does not support the View Transitions API, Astro’s client router can still provide in-browser navigation using one of the fallback options.

Depending on browser support, you may need to explicitly set the `name` or `animate` [transition directives](#transition-directives) on the elements you wish to animate for a comparable experience across all browsers:

src/pages/about.astro

```
---import Layout from"../layouts/LayoutUsingClientRouter.astro";---<titletransition:animate="fade">About my site</title>
```

You can override Astro’s default fallback support by adding a `fallback` property on the `<ClientRouter />` component and setting it to `swap` or `none`:

-   `animate` (default, recommended): Astro will simulate view transitions using custom attributes before updating page content.
-   `swap`: Astro will not attempt to animate the page. Instead, the old page will be immediately replaced by the new one.
-   `none`: Astro will not do any animated page transitions at all. Instead, you will get full page navigation in non-supporting browsers.

```
---import { ClientRouter } from"astro:transitions";---<title>My site</title><ClientRouterfallback="swap" />
```

Known limitations

The `initial` browser animation is not simulated by Astro. So any element using this animation will not currently be animated.


## Client-side navigation process


[Section titled Client-side navigation process](#client-side-navigation-process)

When using the `<ClientRouter />` router, the following steps occur to produce Astro’s client-side navigation:

1.  A visitor to your site triggers navigation by any of the following actions:

    -   Clicking an `<a>` tag linking internally to another page on your site.
    -   Clicking the back button.
    -   Clicking the forward button.
2.  The router starts fetching the next page.

3.  The router adds the `data-astro-transition` attribute to the HTML element with a value of `"forward"` or `"back"` as appropriate.

4.  The router calls `document.startViewTransition`. This triggers the browser’s own [view transition process](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API/Using#the_view_transition_process). Importantly, the browser screenshots the current state of the page.

5.  Inside the `startViewTransition` callback, the router performs a **swap**, which consists of the following sequence of events:

    -   The contents of the `<head>` are swapped out, with some elements kept:

        -   Stylesheet DOM nodes are left in if they exist on the new page, to prevent FOUC.
        -   Scripts are left in if they exist on the new page.
        -   Any other head elements with `transition:persist` are left in if there is a corresponding element in the new page.
    -   The `<body>` is completely replaced with the new page’s body.

    -   Elements marked `transition:persist` are moved over to the new DOM if they exist on the new page.

    -   Scroll position is restored if necessary.

    -   The `astro:after-swap` event is triggered on the `document`. This is the end of the **swap** process.

6.  The router waits for any new stylesheets to load before resolving the transition.

7.  The router executes any new scripts added to the page.

8.  The `astro:page-load` event fires. This is the end of the navigation process.



## Script behavior with view transitions


[Section titled Script behavior with view transitions](#script-behavior-with-view-transitions)

When you add view transitions to an existing Astro project, some of your scripts may no longer re-run after page navigation like they did with full-page browser refreshes. Use the following information to ensure that your scripts execute as expected.


### Script order


[Section titled Script order](#script-order)

When navigating between pages with the `<ClientRouter />` component, scripts are run in sequential order to match browser behavior.


### Script re-execution


[Section titled Script re-execution](#script-re-execution)

[Bundled module scripts](/en/guides/client-side-scripts/#script-processing), which are the default scripts in Astro, are only ever executed once. After initial execution they will be ignored, even if the script exists on the new page after a transition.

Unlike bundled module scripts, [inline scripts](/en/guides/client-side-scripts/#opting-out-of-processing) have the potential to be re-executed during a user’s visit to a site if they exist on a page that is visited multiple times. Inline scripts might also re-execute when a visitor navigates to a page without the script, and then back to one with the script.

With view transitions, some scripts may no longer re-run after page navigation like they do with full-page browser refreshes. There are several [events during client-side routing that you can listen for](#lifecycle-events), and fire events when they occur. You can wrap an existing script in an event listener to ensure it runs at the proper time in the navigation cycle.

The following example wraps a script for a mobile “hamburger” menu in an event listener for `astro:page-load` which runs at the end of page navigation to make the menu responsive to being clicked after navigating to a new page:

src/scripts/menu.js

```
document.addEventListener("astro:page-load", ()=> {document.querySelector(".hamburger").addEventListener("click", ()=> {document.querySelector(".nav-links").classList.toggle("expanded");});});
```

The following example shows a function that runs in response to the `astro:after-swap` event, which happens immediately after the new page has replaced the old page and before the DOM elements are painted to the screen. This avoids a flash of light mode theme after page navigation by checking and, if necessary, setting the dark mode theme before the new page is rendered:

src/components/ThemeToggle.astro

```
<scriptis:inline>functionapplyTheme() {localStorage.theme==="dark"?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark");}document.addEventListener("astro:after-swap", applyTheme);applyTheme();</script>
```


#### `data-astro-rerun`


[Section titled data-astro-rerun](#data-astro-rerun)

**Added in:** `astro@4.5.0`

To force inline scripts to re-execute after every transition, add the `data-astro-rerun` property. Adding any attribute to a script also implicitly adds `is:inline`, so this is only available for scripts that are not bundled and processed by Astro.

```
<scriptis:inlinedata-astro-rerun>...</script>
```

To ensure that a script runs every time a page is loaded during client-side navigation, it should be executed by a [lifecycle event](#lifecycle-events). For example, event listeners for `DOMContentLoaded` can be replaced by the [`astro:page-load`](/en/guides/view-transitions/#astropage-load) lifecycle event.

If you have code that sets up a global state in an inline script, this state will need to take into account that the script might execute more than once. Check for the global state in your `<script>` tag, and conditionally execute your code where possible. This works because `window` is preserved.

```
<scriptis:inline>if (!window.SomeGlobal) {window.SomeGlobal= {};}</script>
```


## Lifecycle events


[Section titled Lifecycle events](#lifecycle-events)

The `<ClientRouter />` router fires a number of events on the `document` during navigation. These events provide hooks into the lifecycle of navigation, allowing you to do things like show indicators that a new page is loading, override default behavior, and restore state as navigation is completing.

The navigation process involves a **preparation** phase, when new content is loaded; a **DOM swap** phase, where the old page’s content is replaced by the new page’s content; and a **completion** phase where scripts are executed, loading is reported as completed and clean-up work is carried out.

Astro’s View Transition API lifecycle events in order are:

-   [`astro:before-preparation`](#astrobefore-preparation)
-   [`astro:after-preparation`](#astroafter-preparation)
-   [`astro:before-swap`](#astrobefore-swap)
-   [`astro:after-swap`](#astroafter-swap)
-   [`astro:page-load`](#astropage-load)

Tip

`before-` events allow you to influence and modify actions that are about to take place, and `after-` events are notifications that a phase is complete.

While some actions can be triggered during any event, some tasks can only be performed during a specific event for best results, such as displaying a loading spinner before preparation or overriding animation pairs before swapping content.


### `astro:before-preparation`


[Section titled astro:before-preparation](#astrobefore-preparation)

**Added in:** `astro@3.6.0`

An event that fires at the beginning of the preparation phase, after navigation has started (e.g. after the user has clicked a link), but before content is loaded.

This event is used:

-   To do something before loading has started, such as showing a loading spinner.
-   To alter loading, such as loading content you’ve defined in a template rather than from the external URL.
-   To change the `direction` of the navigation (which is usually either `forward` or `backward`) for custom animation.

Here is an example of using the `astro:before-preparation` event to load a spinner before the content is loaded and stop it immediately after loading. Note that using the `loader` callback in this way allows asynchronous execution of code.

```
<scriptis:inline>document.addEventListener("astro:before-preparation", (event)=> {const originalLoader = event.loader;event.loader=asyncfunction() {const { startSpinner } = await import("./spinner.js");const stop = startSpinner();awaitoriginalLoader();stop();};});</script>
```


### `astro:after-preparation`


[Section titled astro:after-preparation](#astroafter-preparation)

**Added in:** `astro@3.6.0`

An event that fires at the end of the preparation phase, after the new page’s content has been loaded and parsed into a document. This event occurs before the view transitions phase.

This example uses the `astro:before-preparation` event to start a loading indicator and the `astro:after-preparation` event to stop it:

```
<scriptis:inline>document.addEventListener("astro:before-preparation", ()=> {document.querySelector("#loading").classList.add("show");});document.addEventListener("astro:after-preparation", ()=> {document.querySelector("#loading").classList.remove("show");});</script>
```

This is a simpler version of loading a spinner than the example shown above: if all of the listener’s code can be executed synchronously, there is no need to hook into the `loader` callback.


### `astro:before-swap`


[Section titled astro:before-swap](#astrobefore-swap)

**Added in:** `astro@3.6.0`

An event that fires before the new document (which is populated during the preparation phase) replaces the current document. This event occurs inside of the view transition, where the user is still seeing a snapshot of the old page.

This event can be used to make changes before the swap occurs. The `newDocument` property on the event represents the incoming document. Here is an example of ensuring the browser’s light or dark mode preference in `localStorage` is carried over to the new page:

```
<scriptis:inline>functionsetDarkMode(document) {let theme = localStorage.darkMode ? "dark" : "light";document.documentElement.dataset.theme=theme;}setDarkMode(document);document.addEventListener("astro:before-swap", (event)=> {// Pass the incoming document to set the theme on itsetDarkMode(event.newDocument);});</script>
```

The `astro:before-swap` event can also be used to change the *implementation* of the swap. The default swap implementation diffs head content, moves **persistent** elements from the old document to the `newDocument`, and then replaces the entire `body` with the body of the new document.

At this point of the lifecycle, you could choose to define your own swap implementation, for example to diff the entire contents of the existing document (which some other routers do):

```
<scriptis:inline>document.addEventListener("astro:before-swap", (event)=> {event.swap=()=> {diff(document, event.newDocument);};});</script>
```


#### Building a custom swap function


[Section titled Building a custom swap function](#building-a-custom-swap-function)

**Added in:** `astro@4.15.0`

The `swapFunctions` object of the `astro:transitions/client` module provides five utility functions that handle specific swap-related tasks, including handling document attributes, page elements, and script execution. These functions can be used directly to define a custom swap implementation.

The following example demonstrates how to use these functions to recreate Astro’s built-in swap implementation:

```
<script>import { swapFunctions } from"astro:transitions/client";// substitutes `window.document` with `doc`functionmySwap(doc:Document) {swapFunctions.deselectScripts(doc);swapFunctions.swapRootAttributes(doc);swapFunctions.swapHeadElements(doc);const restoreFocusFunction = swapFunctions.saveFocus();swapFunctions.swapBodyElement(doc.body,document.body);restoreFocusFunction();}event.swap=()=>mySwap(event.newDocument);<script>
```

Custom swap implementations can start with this template and add or replace individual steps with custom logic as needed.


### `astro:after-swap`


[Section titled astro:after-swap](#astroafter-swap)

An event that fires immediately after the new page replaces the old page. You can listen to this event on the `document` and trigger actions that will occur before the new page’s DOM elements render and scripts run.

This event, when listened to on the **outgoing page**, is useful to pass along and restore any state on the DOM that needs to transfer over to the new page.

This is the latest point in the lifecycle where it is still safe to, for example, add a dark mode class name (`<html class="dark-mode">`), though you may wish to do so in an earlier event.

The `astro:after-swap` event occurs immediately after the browser history has been updated and the scroll position has been set. Therefore, one use of targeting this event is to override the default scroll restore for history navigation. The following example resets the horizontal and vertical scroll position to the top left corner of the page for each navigation.

```
document.addEventListener("astro:after-swap", ()=>window.scrollTo({ left: 0, top: 0, behavior: "instant" }),);
```


### `astro:page-load`


[Section titled astro:page-load](#astropage-load)

An event that fires at the end of page navigation, after the new page is visible to the user and blocking styles and scripts are loaded. You can listen to this event on the `document`.

The `<ClientRouter />` component fires this event both on initial page navigation for a pre-rendered page and on any subsequent navigation, either forwards or backwards.

You can use this event to run code on every page navigation, for example to set up event listeners that would otherwise be lost during navigation.

```
<script>document.addEventListener("astro:page-load", ()=> {// This runs on first page load and after every navigation.setupStuff(); // e.g. add event listeners});</script>
```


## Accessibility


[Section titled Accessibility](#accessibility)

Enabling client-side routing and animating page transitions both come with accessibility challenges, and Astro aims to make sites opting in to View Transitions as accessible-by-default as possible.


### Route announcement


[Section titled Route announcement](#route-announcement)

**Added in:** `astro@3.2.0`

The `<ClientRouter />` component includes a route announcer for page navigation during client-side routing. No configuration or action is needed to enable this.

Assistive technologies let visitors know that the page has changed by announcing the new page title after navigation. When using server-side routing with traditional full-page browser refreshes, this happens by default after the new page loads. In client-side routing, the `<ClientRouter />` component performs this action.

To add route announcement to client-side routing, the component adds an element to the new page with the `aria-live` attribute set to `assertive`. This tells AT (assistive technology) to announce immediately. The component also checks for the following, in priority order, to determine the announcement text:

-   The `<title>`, if it exists.
-   The first `<h1>` it finds.
-   The `pathname` of the page.

We strongly recommend you always include a `<title>` in each page for accessibility.


### `prefers-reduced-motion`


[Section titled prefers-reduced-motion](#prefers-reduced-motion)

Astro’s `<ClientRouter />` component includes a CSS media query that disables *all* view transition animations, including fallback animation, whenever the [`prefer-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion) setting is detected. Instead, the browser will simply swap the DOM elements without an animation.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 147. `en/install-and-setup/.md`

```text
# Install Astro


---
url: https://docs.astro.build/en/install-and-setup/
description: How to install Astro and start a new project.
---

Astro v5 is here! [Learn how to upgrade your site](/en/guides/upgrade-to/v5/)


# Install Astro


The [`create astro` CLI command](#install-from-the-cli-wizard) is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates.

You can also run the CLI command with the `template` flag to begin your project using any existing theme or starter template. Explore our [themes and starters showcase](https://astro.build/themes/) where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more!

To install Astro manually instead, see our [step-by-step manual installation guide](#manual-setup).

Online previews

Prefer to try Astro in your browser? Visit [astro.new](https://astro.new/) to browse our starter templates and spin up a new Astro project without ever leaving your browser.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   **Node.js** - `v18.20.8` or `v20.3.0`, `v22.0.0` or higher. ( `v19` and `v21` are not supported.)
-   **Text editor** - We recommend [VS Code](https://code.visualstudio.com/) with our [Official Astro extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode).
-   **Terminal** - Astro is accessed through its command-line interface (CLI).


## Browser compatibility


[Section titled Browser compatibility](#browser-compatibility)

Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the [list of currently supported browser versions in Vite](https://vite.dev/guide/build.html#browser-compatibility).


## Install from the CLI wizard


[Section titled Install from the CLI wizard](#install-from-the-cli-wizard)

You can run `create astro` anywhere on your machine, so there’s no need to create a new empty directory for your project before you begin. If you don’t have an empty directory yet for your new project, the wizard will help create one for you automatically.

1.  Run the following command in your terminal to start the install wizard:

    -   [npm](#tab-panel-1283)
    -   [pnpm](#tab-panel-1284)
    -   [Yarn](#tab-panel-1285)

    Terminal window

    ```
    # create a new project with npmnpmcreateastro@latest
    ```

    Terminal window

    ```
    # create a new project with pnpmpnpmcreateastro@latest
    ```

    Terminal window

    ```
    # create a new project with yarnyarncreateastro
    ```

    If all goes well, you will see a success message followed by some recommended next steps.

2.  Now that your project has been created, you can `cd` into your new project directory to begin using Astro.

3.  If you skipped the “Install dependencies?” step during the CLI wizard, then be sure to install your dependencies before continuing.

    -   [npm](#tab-panel-1286)
    -   [pnpm](#tab-panel-1287)
    -   [Yarn](#tab-panel-1288)

    Terminal window

    ```
    npminstall
    ```

    Terminal window

    ```
    pnpminstall
    ```

    Terminal window

    ```
    yarninstall
    ```

4.  You can now [start the Astro dev server](/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build!



## CLI installation flags


[Section titled CLI installation flags](#cli-installation-flags)

You can run the `create astro` command with additional flags to customize the setup process (e.g. answering “yes” to all questions, skipping the Houston animation) or your new project (e.g. install git or not, add integrations).

See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)


### Add integrations


[Section titled Add integrations](#add-integrations)

You can start a new Astro project and install any [official integrations](/en/guides/integrations-guide/) or community integrations that support the `astro add` command at the same time by passing the `--add` argument to the `create astro` command.

Run the following command in your terminal, substituting any integration that supports the `astro add` command:

-   [npm](#tab-panel-1289)
-   [pnpm](#tab-panel-1290)
-   [Yarn](#tab-panel-1291)

Terminal window

```

# create a new project with React and Partytownnpmcreateastro@latest----addreact--addpartytown

```

Terminal window

```

# create a new project with React and Partytownpnpmcreateastro@latest--addreact--addpartytown

```

Terminal window

```

# create a new project with React and Partytownyarncreateastro--addreact--addpartytown

```


### Use a theme or starter template


[Section titled Use a theme or starter template](#use-a-theme-or-starter-template)

You can start a new Astro project based on an [official example](https://github.com/withastro/astro/tree/main/examples) or the `main` branch of any GitHub repository by passing a `--template` argument to the `create astro` command.

Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:

-   [npm](#tab-panel-1292)
-   [pnpm](#tab-panel-1293)
-   [Yarn](#tab-panel-1294)

Terminal window

```

# create a new project with an official examplenpmcreateastro@latest----template<example-name># create a new project based on a GitHub repository’s main branchnpmcreateastro@latest----template<github-username>/<github-repo>

```

Terminal window

```

# create a new project with an official examplepnpmcreateastro@latest--template<example-name># create a new project based on a GitHub repository’s main branchpnpmcreateastro@latest--template<github-username>/<github-repo>

```

Terminal window

```

# create a new project with an official exampleyarncreateastro--template<example-name># create a new project based on a GitHub repository’s main branchyarncreateastro--template<github-username>/<github-repo>

```

By default, this command will use the template repository’s `main` branch. To use a different branch name, pass it as part of the `--template` argument: `<github-username>/<github-repo>#<branch>`.


## Manual Setup


[Section titled Manual Setup](#manual-setup)

This guide will walk you through the steps to manually install and configure a new Astro project.

If you prefer not to use our automatic `create astro` CLI tool, you can set up your project yourself by following the guide below.

1.  Create your directory

    Create an empty directory with the name of your project, and then navigate into it.

    Terminal window

    ```
    mkdirmy-astro-projectcdmy-astro-project
    ```

    Once you are in your new directory, create your project `package.json` file. This is how you will manage your project dependencies, including Astro. If you aren’t familiar with this file format, run the following command to create one.

    -   [npm](#tab-panel-1295)
    -   [pnpm](#tab-panel-1296)
    -   [Yarn](#tab-panel-1297)

    Terminal window

    ```
    npminit--yes
    ```

    Terminal window

    ```
    pnpminit
    ```

    Terminal window

    ```
    yarninit--yes
    ```

2.  Install Astro

    First, install the Astro project dependencies inside your project.

    Important

    Astro must be installed locally, not globally. Make sure you are *not* running `npm install -g astro` `pnpm add -g astro` or `yarn add global astro`.

    -   [npm](#tab-panel-1298)
    -   [pnpm](#tab-panel-1299)
    -   [Yarn](#tab-panel-1300)

    Terminal window

    ```
    npminstallastro
    ```

    Terminal window

    ```
    pnpmaddastro
    ```

    Terminal window

    ```
    yarnaddastro
    ```

    Then, replace any placeholder “scripts” section of your `package.json` with the following:

    package.json

    ```
    {"scripts": {"test": "echo \"Error: no test specified\" && exit 1","dev": "astro dev","build": "astro build","preview": "astro preview"},}
    ```

    You’ll use these scripts later in the guide to start Astro and run its different commands.

3.  Create your first page

    In your text editor, create a new file in your directory at `src/pages/index.astro`. This will be your first Astro page in the project.

    For this guide, copy and paste the following code snippet (including `---` dashes) into your new file:

    src/pages/index.astro

    ```
    ---// Welcome to Astro! Everything between these triple-dash code fences// is your "component frontmatter". It never runs in the browser.console.log('This runs in your terminal, not the browser!');---<!-- Below is your "component template." It's just HTML, but withsome magic sprinkled in to help you build great templates. --><html><body><h1>Hello, World!</h1></body></html><style>h1 {color: orange;}</style>
    ```

4.  Create your first static asset

    You will also want to create a `public/` directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.

    In your text editor, create a new file in your directory at `public/robots.txt`. `robots.txt` is a simple file that most sites will include to tell search bots like Google how to treat your site.

    For this guide, copy and paste the following code snippet into your new file:

    public/robots.txt

    ```
    # Example: Allow all bots to scan and index your site.# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txtUser-agent: *Allow: /
    ```

5.  Create `astro.config.mjs`

    Astro is configured using `astro.config.mjs`. This file is optional if you do not need to configure Astro, but you may wish to create it now.

    Create `astro.config.mjs` at the root of your project, and copy the code below into it:

    astro.config.mjs

    ```
    import { defineConfig } from"astro/config";// https://astro.build/configexportdefaultdefineConfig({});
    ```

    If you want to include [UI framework components](/en/guides/framework-components/) such as React, Svelte, etc. or use other tools such as MDX or Partytown in your project, here is where you will [manually import and configure integrations](/en/guides/integrations-guide/).

    Read Astro’s [API configuration reference](/en/reference/configuration-reference/) for more information.

6.  Add TypeScript support

    TypeScript is configured using `tsconfig.json`. Even if you don’t write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren’t fully supported in the editor without a `tsconfig.json` file.

    If you do intend to write TypeScript code, using Astro’s `strict` or `strictest` template is recommended. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/).

    Create `tsconfig.json` at the root of your project, and copy the code below into it. (You can use `base`, `strict`, or `strictest` for your TypeScript template):

    tsconfig.json

    ```
    {"extends": "astro/tsconfigs/base"}
    ```

    Read Astro’s [TypeScript setup guide](/en/guides/typescript/#setup) for more information.

7.  Next Steps

    If you have followed the steps above, your project directory should now look like this:

    -   Directorynode\_modules/

        -   …

    -   Directorypublic/

        -   robots.txt

    -   Directorysrc/

        -   Directorypages/

            -   index.astro


    -   astro.config.mjs
    -   package-lock.json or `yarn.lock`, `pnpm-lock.yaml`, etc.
    -   package.json
    -   tsconfig.json

8.  You can now [start the Astro dev server](/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build!


Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 148. `en/recipes/.md`

```text
# Astro recipes


---
url: https://docs.astro.build/en/recipes/
description: Short, focused how-to guides.
---


# Astro recipes


See guided examples of adding features to your Astro project.


## Official Recipes


[Section titled Official Recipes](#official-recipes)

Astro’s official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions!

-   ### [Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/)

    Learn how you can import YAML data by adding a Rollup plugin to your project.

-   ### [Analyze bundle size](/en/recipes/analyze-bundle-size/)

    Learn how to analyze the bundle generated by Astro using \`rollup-plugin-visualizer\`.

-   ### [Build a custom image component](/en/recipes/build-custom-img-component/)

    Learn how to build a custom image component that supports media queries using the getImage function.

-   ### [Build forms with API routes](/en/recipes/build-forms-api/)

    Learn how to use JavaScript to send form submissions to an API Route.

-   ### [Build HTML forms in Astro pages](/en/recipes/build-forms/)

    Learn how to build HTML forms and handle submissions in your frontmatter.

-   ### [Use Bun with Astro](/en/recipes/bun/)

    Learn how to use Bun with your Astro site.

-   ### [Call endpoints from the server](/en/recipes/call-endpoints/)

    Learn how to call endpoints from the server in Astro.

-   ### [Verify a Captcha](/en/recipes/captcha/)

    Learn how to create an API route and fetch it from the client.

-   ### [Build your Astro site with Docker](/en/recipes/docker/)

    Learn how to build your Astro site using Docker.

-   ### [Dynamically import images](/en/recipes/dynamically-importing-images/)

    Learn how to dynamically import images using Vite's import.meta.glob function.

-   ### [Add icons to external links](/en/recipes/external-links/)

    Learn how to install a rehype plugin to add icons to external links in your Markdown files.

-   ### [Add i18n features](/en/recipes/i18n/)

    Use dynamic routing and content collections to add internationalization support to your Astro site.

-   ### [Create a dev toolbar app](/en/recipes/making-toolbar-apps/)

    Learn how to create a dev toolbar app for your site.

-   ### [Add last modified time](/en/recipes/modified-time/)

    Build a remark plugin to add the last modified time to your Markdown and MDX.

-   ### [Add reading time](/en/recipes/reading-time/)

    Build a remark plugin to add reading time to your Markdown or MDX files.

-   ### [Add an RSS feed](/en/recipes/rss/)

    Add an RSS feed to your Astro site to let users subscribe to your content.

-   ### [Share state between islands](/en/recipes/sharing-state-islands/)

    Learn how to share state across framework components with Nano Stores.

-   ### [Share state between Astro components](/en/recipes/sharing-state/)

    Learn how to share state across Astro components with Nano Stores.

-   ### [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/)

    Learn how to use streaming to improve page performance.

-   ### [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/)

    Learn how to use @tailwind/typography to style your rendered Markdown.



## Community Resources


[Section titled Community Resources](#community-resources)

Find more recipes written and submitted by the community at [Astro Tips](https://astro-tips.dev).

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 149. `en/recipes/add-yaml-support/.md`

```text
# Installing a Vite or Rollup plugin


---
url: https://docs.astro.build/en/recipes/add-yaml-support/
description: Learn how you can import YAML data by adding a Rollup plugin to your project.
---


# Installing a Vite or Rollup plugin


Astro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (`.yml`) file in Astro.


## Recipe


[Section titled Recipe](#recipe)

1.  Install `@rollup/plugin-yaml`:

    -   [npm](#tab-panel-1686)
    -   [pnpm](#tab-panel-1687)
    -   [Yarn](#tab-panel-1688)

    Terminal window

    ```
    npminstall@rollup/plugin-yaml--save-dev
    ```

    Terminal window

    ```
    pnpmadd@rollup/plugin-yaml--save-dev
    ```

    Terminal window

    ```
    yarnadd@rollup/plugin-yaml--dev
    ```

2.  Import the plugin in your `astro.config.mjs` and add it to the Vite plugins array:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import yaml from'@rollup/plugin-yaml';exportdefaultdefineConfig({vite: {plugins: [yaml()]}});
    ```

3.  Finally, you can import YAML data using an `import` statement:

    ```
    import yml from'./data.yml';
    ```

    Note

    While you can now import YAML data in your Astro project, your editor will not provide types for the imported data. To add types, create or find an existing `*.d.ts` file in the `src` directory of your project and add the following:

    src/files.d.ts

    ```
    // Specify the file extension you want to importdeclaremodule"*.yml" {const value:any; // Add type definitions here if desiredexportdefault value;}
    ```

    This will allow your editor to provide type hints for your YAML data.


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 150. `en/recipes/analyze-bundle-size/.md`

```text
# Analyze bundle size


---
url: https://docs.astro.build/en/recipes/analyze-bundle-size/
description: Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.
---


# Analyze bundle size


Understanding what is a part of an Astro bundle is important for improving site performance. Visualizing the bundle can give clues as to where changes can be made in your project to reduce the bundle size.


## Recipe


[Section titled Recipe](#recipe)

The [`rollup-plugin-visualizer` library](https://github.com/btd/rollup-plugin-visualizer) allows you to visualize and analyze your Rollup bundle to see which modules are taking up space.

1.  Install `rollup-plugin-visualizer`:

    -   [npm](#tab-panel-1689)
    -   [pnpm](#tab-panel-1690)
    -   [Yarn](#tab-panel-1691)

    Terminal window

    ```
    npminstallrollup-plugin-visualizer--save-dev
    ```

    Terminal window

    ```
    pnpmaddrollup-plugin-visualizer--save-dev
    ```

    Terminal window

    ```
    yarnaddrollup-plugin-visualizer--save-dev
    ```

2.  Add the plugin to the `astro.config.mjs` file:

    ```
    // @ts-checkimport { defineConfig } from'astro/config';import { visualizer } from"rollup-plugin-visualizer";exportdefaultdefineConfig({vite: {plugins: [visualizer({emitFile: true,filename: "stats.html",})]}});
    ```

3.  Run the build command:

    -   [npm](#tab-panel-1692)
    -   [pnpm](#tab-panel-1693)
    -   [Yarn](#tab-panel-1694)

    Terminal window

    ```
    npmrunbuild
    ```

    Terminal window

    ```
    pnpmbuild
    ```

    Terminal window

    ```
    yarnbuild
    ```

4.  Find the `stats.html` file(s) for your project.

    This will be at the root of your `dist/` directory for entirely static sites and will allow you to see what is included in the bundle.

    If your Astro project uses on-demand rendering, you will have two `stats.html` files. One will be for the client, and the other for the server, and each will be located at the root of the `dist/client` and `dist/server/` directories.

    See [the Rollup Plugin Visualizer documentation](https://github.com/btd/rollup-plugin-visualizer#how-to-use-generated-files) for guidance on how to interpret these files, or configure specific options.


Note

Given Astro’s unique approach to hydration, the build isn’t necessarily representative of the bundle that the client will receive.

The Rollup visualizer shows all dependencies that are used across the site, but it does not break down the bundle size on a per-page basis.

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 151. `en/recipes/bun/.md`

```text
# Use Bun with Astro


---
url: https://docs.astro.build/en/recipes/bun/
description: Learn how to use Bun with your Astro site.
---


# Use Bun with Astro


[Bun](https://bun.sh/) is an all-in-one JavaScript runtime & toolkit. See [Bun’s documentation](https://bun.sh/docs) for more information.

Caution

Using Bun with Astro may reveal rough edges. Some integrations may not work as expected. Consult [Bun’s official documentation for working with Astro](https://bun.sh/guides/ecosystem/astro) for details.

If you have any problems using Bun, please [open an Issue on GitHub with Bun directly](https://github.com/oven-sh/bun/issues/new/choose).


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   Bun installed locally on your machine. See the [installation instructions](https://bun.sh/docs/installation) in Bun’s official documentation.


## Create a new Astro project with Bun


[Section titled Create a new Astro project with Bun](#create-a-new-astro-project-with-bun)

Create a new Astro project with Bun using the following `create-astro` command:

Terminal window

```
bunxcreate-astro@latestmy-astro-project-using-bun
```

Tip

You may also [create a new Astro project from any existing Astro GitHub repository](/en/install-and-setup/#install-from-the-cli-wizard) using the `--template` flag:

Terminal window

```
bunxcreate-astro@latestmy-astro-project-using-bun--templateeliancodes/brutal
```


## Install dependencies


[Section titled Install dependencies](#install-dependencies)

If you’re starting a new project using `bunx create-astro`, the CLI will automatically use Bun to install dependencies and you can skip this step.

Otherwise, you’ll need to install your dependencies with Bun:

Terminal window

```
buninstall
```


## Add Types


[Section titled Add Types](#add-types)

Bun publishes the [`@types/bun`](https://www.npmjs.com/package/@types/bun) package, containing the runtime types for Bun.

Install `@types/bun` using the following command:

Terminal window

```
bunadd-d@types/bun
```


## Using Astro integrations


[Section titled Using Astro integrations](#using-astro-integrations)

You can also use any of the official Astro integrations with the `astro add` command:

Terminal window

```
bunxastroaddreact
```


## Run Astro with Bun


[Section titled Run Astro with Bun](#run-astro-with-bun)

Note

Use the [`--bun` CLI flag](https://bun.sh/docs/cli/bunx#shebangs) before every `astro` command to use Bun’s own runtime in place of Node.


### Run the development server


[Section titled Run the development server](#run-the-development-server)

To run the development server using Bun as the runtime, use the following command:

Terminal window

```
bunx--bunastrodev
```


### Building your site with Bun


[Section titled Building your site with Bun](#building-your-site-with-bun)

To build your site using Bun as the runtime, use the following command:

Terminal window

```
bunx--bunastrobuild
```

Astro will output your site to the `dist/` directory. Then, you can serve your site using the `preview` command:

Terminal window

```
bunx--bunastropreview
```


## Add SSR with Bun


[Section titled Add SSR with Bun](#add-ssr-with-bun)

Since Bun features [Node.js API compatibility](https://bun.sh/docs/runtime/nodejs-apis), you can use any Astro adapter for [on-demand rendering](/en/guides/on-demand-rendering/) with your Astro project:

Terminal window

```
bunxastroaddvercel
```


## Testing in Bun


[Section titled Testing in Bun](#testing-in-bun)

Bun ships with a fast, built-in, Jest-compatible test runner through the `bun test` command. If you like to use that read [`bun test` documentation](https://bun.sh/docs/cli/test).

However, it is also possible to use Cypress or Playwright for a modern approach to testing web apps.


### Cypress


[Section titled Cypress](#cypress)

Cypress is a front-end testing tool and is on a mission to “make the testing experience enjoyable and generate developer happiness”. This enables you to write end-to-end tests for your Astro site.

Install Cypress with the following command:

Terminal window

```
bunaddcypress--dev
```

For the rest of the configuration and to start your first test, follow the rest of Cypress process in the [Astro Testing Guide](/en/guides/testing/#configuration).


### Playwright


[Section titled Playwright](#playwright)

Playwright is an end-to-end testing framework that allows you to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.

Install Playwright using the following command:

Terminal window

```
buncreateplaywright
```

To create your first Playwright test, follow the instructions for the rest of the Playwright process in the [Astro Testing Guide](/en/guides/testing/#create-your-first-playwright-test).


## Official Resources


[Section titled Official Resources](#official-resources)

-   [Build an app with Astro and Bun](https://bun.sh/guides/ecosystem/astro)


## Community Resources


[Section titled Community Resources](#community-resources)

Using Bun with Astro? Add your blog post or video to this page!

-   [Building a Cloudflare Pages site with Bun](https://blog.otterlord.dev/posts/hello-from-bun/) - blog post
-   [Using Bun with Astro and Cloudflare Pages](https://handerson.hashnode.dev/using-bun-with-astro-and-cloudflare-pages) - blog post

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 152. `en/recipes/call-endpoints/.md`

```text
# Call endpoints from the server


---
url: https://docs.astro.build/en/recipes/call-endpoints/
description: Learn how to call endpoints from the server in Astro.
---


# Call endpoints from the server


Endpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page’s component script to display a greeting, without requiring an additional fetch request.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A project with [SSR](/en/guides/on-demand-rendering/) (output: ‘server’) enabled


## Recipe


[Section titled Recipe](#recipe)

1.  Create an endpoint in a new file `src/pages/api/hello.ts` that returns some data:

    src/pages/api/hello.ts

    ```
    importtype { APIRoute } from'astro'export const GET:APIRoute = () => {return newResponse(JSON.stringify({greeting: 'Hello',}),)}
    ```

2.  On any Astro page, import the `GET()` method from the endpoint. Call it with the [`Astro` global](/en/reference/api-reference/) to provide the request context, and use the response on the page:

    src/pages/index.astro

    ```
    ---import { GET } from'./api/hello.ts'let response = await GET(Astro)const data = await response.json()---<h1>{data.greeting} world!</h1>
    ```


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 153. `en/recipes/captcha/.md`

```text
# Verify a Captcha


---
url: https://docs.astro.build/en/recipes/captcha/
description: Learn how to create an API route and fetch it from the client.
---


# Verify a Captcha


[Server endpoints](/en/guides/endpoints/#server-endpoints-api-routes) can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client.

In this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   A project with [SSR](/en/guides/on-demand-rendering/) (`output: 'server'`) enabled


## Recipe


[Section titled Recipe](#recipe)

1.  Create a `POST` endpoint that accepts recaptcha data, then verifies it with reCAPTCHA’s API. Here, you can safely define secret values or read environment variables.

    src/pages/recaptcha.js

    ```
    exportasyncfunctionPOST({ request }) {const data = await request.json();const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify';const requestHeaders = {'Content-Type': 'application/x-www-form-urlencoded'};const requestBody = newURLSearchParams({secret: "YOUR_SITE_SECRET_KEY",// This can be an environment variableresponse: data.recaptcha// The token passed in from the client});const response = await fetch(recaptchaURL, {method: "POST",headers: requestHeaders,body: requestBody.toString()});const responseData = await response.json();returnnewResponse(JSON.stringify(responseData), { status: 200 });}
    ```

2.  Access your endpoint using `fetch` from a client script:

    src/pages/index.astro

    ```
    <html><head><scriptis:inlinesrc="https://www.google.com/recaptcha/api.js"></script></head><body><buttonclass="g-recaptcha"data-sitekey="PUBLIC_SITE_KEY"data-callback="onSubmit"data-action="submit"> Click me to verify the captcha challenge! </button><scriptis:inline>functiononSubmit(token) {fetch("/recaptcha", {method: "POST",body: JSON.stringify({ recaptcha: token })}).then((response)=>response.json()).then((gResponse)=> {if (gResponse.success) {// Captcha verification was a success} else {// Captcha verification failed}})}</script></body></html>
    ```


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 154. `en/recipes/docker/.md`

```text
# Build your Astro site with Docker


---
url: https://docs.astro.build/en/recipes/docker/
description: Learn how to build your Astro site using Docker.
---


# Build your Astro site with Docker


[Docker](https://docker.com) is a tool to build, deploy, and run applications using containers.

Docker images and containers can be deployed to many different platforms, like AWS, Azure, and [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static). This recipe won’t cover how to deploy your site to a specific platform but will show you how to set up Docker for your project.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   Docker installed on your local machine. You can find [installation instructions for your operating system here](https://docs.docker.com/get-docker/).
-   A Dockerfile in your project. You can [learn more about Dockerfiles here](https://docs.docker.com/engine/reference/builder/) and use the Dockerfiles in the following section as a starting point.


## Creating a Dockerfile


[Section titled Creating a Dockerfile](#creating-a-dockerfile)

Create a file called `Dockerfile` in your project’s root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can’t show all possible options but will give you starting points for SSR and static mode.

If you’re using another package manager than npm, you’ll need to adjust the commands accordingly.


### SSR


[Section titled SSR](#ssr)

This Dockerfile will build your site and serve it using Node.js on port `4321` and therefore requires the [Node adapter](/en/guides/integrations-guide/node/) installed in your Astro project.

Dockerfile

```
FROM node:lts AS runtimeWORKDIR /appCOPY . .RUN npm installRUN npm run buildENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD node ./dist/server/entry.mjs
```

Keep this in mind

These are just examples of Dockerfiles. You can customize them to your needs. For example, you could use another image, like `node:lts-alpine`:

Dockerfile

```
FROM node:lts as runtimeFROM node:lts-alpine as runtime
```


### Adding a .dockerignore


[Section titled Adding a .dockerignore](#adding-a-dockerignore)

Adding a `.dockerignore` file to your project is best practice. This file describes which files or folders should be ignored in the Docker `COPY` or `ADD` commands, very similar to how `.gitignore` works. This speeds up the build process and reduces the size of the final image.

.dockerignore

```
.DS_Storenode_modulesdist
```

This file should go in the same directory as the `Dockerfile` itself. [Read the `.dockerignore` documentation for extra info](https://docs.docker.com/engine/reference/builder/#dockerignore-file)


### Static


[Section titled Static](#static)


#### Apache (httpd)


[Section titled Apache (httpd)](#apache-httpd)

The following Dockerfile will build your site and serve it using Apache httpd on port `80` with the default configuration.

Dockerfile

```
FROM node:lts AS buildWORKDIR /appCOPY . .RUN npm iRUN npm run buildFROM httpd:2.4 AS runtimeCOPY --from=build /app/dist /usr/local/apache2/htdocs/EXPOSE 80
```

Recommendation

Use this approach for simple websites that don’t need any special configuration. For more complex websites, it is recommended to use a custom configuration, either in Apache or NGINX.


#### NGINX


[Section titled NGINX](#nginx)

Dockerfile

```
FROM node:lts AS buildWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .RUN npm run buildFROM nginx:alpine AS runtimeCOPY ./nginx/nginx.conf /etc/nginx/nginx.confCOPY --from=build /app/dist /usr/share/nginx/htmlEXPOSE 8080
```

In order to build the Dockerfile above, you’ll also need to create a configuration file for NGINX. Create a folder called `nginx` in your project’s root directory and create a file called `nginx.conf` inside.

nginx.conf

```
worker_processes 1;events {worker_connections 1024;}http {server {listen 8080;server_name   _;root   /usr/share/nginx/html;index  index.html index.htm;include /etc/nginx/mime.types;gzip on;gzip_min_length 1000;gzip_proxied expired no-cache no-store private auth;gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;error_page 404 /404.html;location=/404.html {root /usr/share/nginx/html;internal;}location / {try_files $uri $uri/index.html =404;}}}
```


### Multi-stage build (using SSR)


[Section titled Multi-stage build (using SSR)](#multi-stage-build-using-ssr)

Here’s an example of a more advanced Dockerfile that, thanks to Docker’s [multi-stage builds](https://docs.docker.com/build/building/multi-stage/), optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies.

Dockerfile

```
FROM node:lts AS baseWORKDIR /app# By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code.# Therefore, the `-deps` steps will be skipped if only the source code changes.COPY package.json package-lock.json ./FROM base AS prod-depsRUN npm install --omit=devFROM base AS build-depsRUN npm installFROM build-deps AS buildCOPY . .RUN npm run buildFROM base AS runtimeCOPY --from=prod-deps /app/node_modules ./node_modulesCOPY --from=build /app/dist ./distENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD node ./dist/server/entry.mjs
```


## Recipe


[Section titled Recipe](#recipe)

1.  Build your container by running the following command in your project’s root directory. Use any name for `<your-astro-image-name>`:

    Terminal window

    ```
    dockerbuild-t<your-astro-image-name>.
    ```

    This will output an image, which you can run locally or deploy to a platform of your choice.

2.  To run your image as a local container, use the following command.

    Replace `<local-port>` with an open port on your machine. Replace `<container-port>` with the port exposed by your Docker container (`4321`, `80`, or `8080` in the above examples.)

    Terminal window

    ```
    dockerrun-p<local-port>:<container-port><your-astro-image-name>
    ```

    You should be able to access your site at `http://localhost:<local-port>`.

3.  Now that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static) deployment guide for one example, and the [Deploy your app](https://docs.docker.com/language/nodejs/deploy/) page in the Docker docs.


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 155. `en/recipes/dynamically-importing-images/.md`

```text
# Dynamically import images


---
url: https://docs.astro.build/en/recipes/dynamically-importing-images/
description: Learn how to dynamically import images using Vite's import.meta.glob function.
---


# Dynamically import images


Local [images](/en/guides/images/) must be imported into `.astro` files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image.

In this recipe, you will learn how to dynamically import your images using Vite’s `import.meta.glob` function. You will build a card component that displays the name, age, and photo of a person.


## Recipe


[Section titled Recipe](#recipe)

1.  Create a new `assets` folder under the `src` directory and add your images inside that new folder.

    -   Directorysrc/

        -   Directoryassets/

            -   avatar-1.jpg
            -   avatar-2.png
            -   avatar-3.jpeg



    Note

    `assets` is a popular folder name convention for placing images but you are free to name the folder whatever you like.

2.  Create a new Astro component for your card and import the `<Image />` component.

    src/components/MyCustomCardComponent.astro

    ```
    ---import { Image } from'astro:assets';---
    ```

3.  Specify the `props` that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project.

    src/components/MyCustomCardComponent.astro

    ```
    ---import { Image } from'astro:assets';interface Props {imagePath:string;altText:string;name:string;age:number;}const { imagePath, altText, name, age } = Astro.props;---
    ```

4.  Create a new `images` variable and use the `import.meta.glob` function which returns an object of all of the image paths inside the `assets` folder. You will also need to import `ImageMetadata` type to help define the type of the `images` variable.

    src/components/MyCustomCardComponent.astro

    ```
    ---importtype { ImageMetadata } from'astro';import { Image } from'astro:assets';interface Props {imagePath:string;altText:string;name:string;age:number;}const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default:ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}')---
    ```

5.  Use the props to create the markup for your card component.

    src/components/MyCustomCardComponent.astro

    ```
    ---importtype { ImageMetadata } from'astro';import { Image } from'astro:assets';interface Props {imagePath:string;altText:string;name:string;age:number;}const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default:ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');---<divclass="card"><h2>{name}</h2><p>Age: {age}</p><Imagesrc={}alt={altText} /></div>
    ```

6.  Inside the `src` attribute, pass in the `images` object and use bracket notation for the image path. Then make sure to invoke the glob function.

    Since you are accessing the `images` object which has an unknown type, you should also `throw` an error in case an invalid file path is passed as a prop.

    src/components/MyCustomCardComponent.astro

    ```
    ---importtype { ImageMetadata } from'astro';import { Image } from'astro:assets';interface Props {imagePath:string;altText:string;name:string;age:number;}const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default:ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');if (!images[imagePath]) thrownewError(`"${imagePath}" does not exist in glob: "src/assets/*.{jpeg,jpg,png,gif}"`);---<divclass="card"><h2>{name}</h2><p>Age: {age}</p><Imagesrc={images[imagePath]()}alt={altText} /></div>
    ```

    Note

    `images` is an object that contains all of the image paths inside the `assets` folder.

    ```
    const images = {'./assets/avatar-1.jpg': () => import('./assets/avatar-1.jpg'),'./assets/avatar-2.png': () => import('./assets/avatar-2.png'),'./assets/avatar-3.jpeg': () => import('./assets/avatar-3.jpeg')}
    ```

    The `imagePath` prop is a string that contains the path to the image that you want to display. The `import.meta.glob()` is doing the work of finding the image path that matches the `imagePath` prop and handling the import for you.

7.  Import and use the card component inside an Astro page, passing in the values for the `props`.

    src/pages/index.astro

    ```
    ---import MyCustomCardComponent from'../components/MyCustomCardComponent.astro';---<MyCustomCardComponentimagePath="/src/assets/avatar-1.jpg"altText="A headshot of Priya against a brick wall background."name="Priya"age={25}/>
    ```


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 156. `en/recipes/external-links/.md`

```text
# Add icons to external links


---
url: https://docs.astro.build/en/recipes/external-links/
description: Learn how to install a rehype plugin to add icons to external links in your Markdown files.
---


# Add icons to external links


Using a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

-   An Astro project using Markdown for content pages.


## Recipe


[Section titled Recipe](#recipe)

1.  Install the `rehype-external-links` plugin.

    -   [npm](#tab-panel-1710)
    -   [pnpm](#tab-panel-1711)
    -   [Yarn](#tab-panel-1712)

    Terminal window

    ```
    npminstallrehype-external-links
    ```

    Terminal window

    ```
    pnpmaddrehype-external-links
    ```

    Terminal window

    ```
    yarnaddrehype-external-links
    ```

2.  Import the plugin into your `astro.config.mjs` file.

    Pass `rehypeExternalLinks` to the `rehypePlugins` array, along with an options object that includes a content property. Set this property’s `type` to `text` if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property `type` to `raw`.

    ```
    // ...import rehypeExternalLinks from'rehype-external-links';exportdefaultdefineConfig({// ...markdown: {rehypePlugins: [[rehypeExternalLinks,{content: { type: 'text', value: ' 🔗' }}],]},});
    ```

    Note

    The value of the `content` property is [not represented in the accessibility tree](https://developer.mozilla.org/en-US/docs/Web/CSS/content#accessibility_concerns). As such, it’s best to make clear that the link is external in the surrounding content, rather than relying on the icon alone.



## Resources


[Section titled Resources](#resources)

-   [rehype-external-links](https://www.npmjs.com/package/rehype-external-links)

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 157. `en/recipes/i18n/.md`

```text
# Add i18n features


---
url: https://docs.astro.build/en/recipes/i18n/
description: Use dynamic routing and content collections to add internationalization support to your Astro site.
---


# Add i18n features


In this recipe, you will learn how to use content collections and dynamic routing to build your own internationalization (i18n) solution and serve your content in different languages.

Tip

In v4.0, Astro added built-in support for i18n routing that allows you to configure default and supported languages and includes valuable helper functions to assist you in serving an international audience. If you want to use this instead, see our [internationalization guide](/en/guides/internationalization/) to learn about these features.

This example serves each language at its own subpath, e.g. `example.com/en/blog` for English and `example.com/fr/blog` for French.

If you prefer the default language to not be visible in the URL unlike other languages, there are [instructions to hide the default language](/en/recipes/i18n/#hide-default-language-in-the-url) below.

See the [resources section](#resources) for external links to related topics such as right-to-left (RTL) styling and choosing language tags.


## Recipe


[Section titled Recipe](#recipe)


### Set up pages for each language


[Section titled Set up pages for each language](#set-up-pages-for-each-language)

1.  Create a directory for each language you want to support. For example, `en/` and `fr/` if you are supporting English and French:

    -   Directorysrc/

        -   Directorypages/

            -   Directory**en/**

                -   about.astro
                -   index.astro

            -   Directory**fr/**

                -   about.astro
                -   index.astro

            -   index.astro



2.  Set up `src/pages/index.astro` to redirect to your default language.

    -   [Static](#tab-panel-1713)
    -   [On demand](#tab-panel-1714)

    src/pages/index.astro

    ```
    <metahttp-equiv="refresh"content="0;url=/en/" />
    ```

    This approach uses a [meta refresh](https://en.wikipedia.org/wiki/Meta_refresh) and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform’s documentation for more details.

    If you are using an SSR adapter, you can use [`Astro.redirect`](/en/guides/routing/#dynamic-redirects) to redirect to the default language on the server.

    src/pages/index.astro

    ```
    ---return Astro.redirect('/en/');---
    ```



### Use collections for translated content


[Section titled Use collections for translated content](#use-collections-for-translated-content)

1.  Create a folder in `src/content/` for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts:

    -   Directorysrc/

        -   Directorycontent/

            -   Directoryblog/

                -   Directory**en/** Blog posts in English

                    -   post-1.md
                    -   post-2.md

                -   Directory**fr/** Blog posts in French

                    -   post-1.md
                    -   post-2.md





2.  Create a `src/content.config.ts` file and export a collection for each type of content.

    src/content.config.ts

    ```
    import { defineCollection, z } from'astro:content';const blogCollection = defineCollection({schema: z.object({title: z.string(),author: z.string(),date: z.date()})});export const collections = {'blog': blogCollection};
    ```

    Read more about [Content Collections](/en/guides/content-collections/).

3.  Use [dynamic routes](/en/guides/routing/#dynamic-routes) to fetch and render content based on a `lang` and a `slug` parameter.

    -   [Static](#tab-panel-1715)
    -   [On demand](#tab-panel-1716)

    In static rendering mode, use `getStaticPaths` to map each content entry to a page:

    src/pages/\[lang\]/blog/\[...slug\].astro

    ```
    ---import { getCollection, render } from'astro:content';exportasyncfunctiongetStaticPaths() {const pages = await getCollection('blog');const paths = pages.map(page => {const [lang,...slug] = page.id.split('/');return { params: { lang, slug: slug.join('/') | undefined }, props: page };});return paths;}const { lang, slug } = Astro.params;const page = Astro.props;const formattedDate = page.data.date.toLocaleString(lang);const { Content } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} • {formattedDate}</p><Content/>
    ```

    In [SSR mode](/en/guides/on-demand-rendering/), fetch the requested entry directly:

    src/pages/\[lang\]/blog/\[...slug\].astro

    ```
    ---import { getEntry, render } from'astro:content';const { lang, slug } = Astro.params;const page = await getEntry('blog', `${lang}/${slug}`);if (!page) {return Astro.redirect('/404');}const formattedDate = page.data.date.toLocaleString(lang);const { Content, headings } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} • {formattedDate}</p><Content/>
    ```

    Read more about [dynamic routing](/en/guides/routing/#dynamic-routes).

    Date formatting

    The example above uses the built-in [`toLocaleString()` date-formatting method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString) to create a human-readable string from the frontmatter date. This ensures the date and time are formatted to match the user’s language.



### Translate UI strings


[Section titled Translate UI strings](#translate-ui-strings)

Create dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language.

1.  Create a `src/i18n/ui.ts` file to store your translation strings:

    src/i18n/ui.ts

    ```
    export const languages = {en: 'English',fr: 'Français',};export const defaultLang = 'en';export const ui = {en: {'nav.home': 'Home','nav.about': 'About','nav.twitter': 'Twitter',},fr: {'nav.home': 'Accueil','nav.about': 'À propos',},} as const;
    ```

2.  Create two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in `src/i18n/utils.ts`:

    src/i18n/utils.ts

    ```
    import { ui, defaultLang } from'./ui';exportfunctiongetLangFromUrl(url:URL) {const [,lang] = url.pathname.split('/');if (langinui) returnlangaskeyoftypeofui;returndefaultLang;}exportfunctionuseTranslations(lang:keyoftypeofui) {returnfunctiont(key:keyoftypeofui[typeofdefaultLang]) {returnui[lang][key] |ui[defaultLang][key];}}
    ```

    Did you notice?

    In step 1, the `nav.twitter` string was not translated to French. You may not want every term translated, such as proper names or common industry terms. The `useTranslations` helper will return the default language’s value if a key is not translated. In this example, French users will also see “Twitter” in the nav bar.

3.  Import the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like:

    src/components/Nav.astro

    ```
    ---import { getLangFromUrl, useTranslations } from'../i18n/utils';const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);---<ul><li><ahref={`/${lang}/home/`}>{t('nav.home')}</a></li><li><ahref={`/${lang}/about/`}>{t('nav.about')}</a></li><li><ahref="https://twitter.com/astrodotbuild">{t('nav.twitter')}</a></li></ul>
    ```

4.  Each page must have a `lang` attribute on the `<html>` element that matches the language on the page. In this example, a [reusable layout](/en/basics/layouts/) extracts the language from the current route:

    src/layouts/Base.astro

    ```
    ---import { getLangFromUrl } from'../i18n/utils';const lang = getLangFromUrl(Astro.url);---<htmllang={lang}><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><slot /></body></html>
    ```

    You can then use this base layout to ensure that pages use the correct `lang` attribute automatically.

    src/pages/en/about.astro

    ```
    ---import Base from'../../layouts/Base.astro';---<Base><h1>About me</h1>...</Base>
    ```



### Let users switch between languages


[Section titled Let users switch between languages](#let-users-switch-between-languages)

Create links to the different languages you support so users can choose the language they want to read your site in.

1.  Create a component to show a link for each language:

    src/components/LanguagePicker.astro

    ```
    ---import { languages } from'../i18n/ui';---<ul>{Object.entries(languages).map(([lang, label])=> (<li><ahref={`/${lang}/`}>{label}</a></li>))}</ul>
    ```

2.  Add `<LanguagePicker />` to your site so it is shown on every page. The example below adds it to the site footer in a base layout:

    src/layouts/Base.astro

    ```
    ---import LanguagePicker from'../components/LanguagePicker.astro';import { getLangFromUrl } from'../i18n/utils';const lang = getLangFromUrl(Astro.url);---<htmllang={lang}><head><metacharset="utf-8" /><linkrel="icon"type="image/svg+xml"href="/favicon.svg" /><metaname="viewport"content="width=device-width" /><title>Astro</title></head><body><slot /><footer><LanguagePicker /></footer></body></html>
    ```



### Hide default language in the URL


[Section titled Hide default language in the URL](#hide-default-language-in-the-url)

1.  Create a directory for each language except the default language. For example, store your default language pages directly in `pages/`, and your translated pages in `fr/`:

    -   Directorysrc/

        -   Directorypages/

            -   about.astro
            -   index.astro
            -   Directory**fr/**

                -   about.astro
                -   index.astro




2.  Add another line to the `src/i18n/ui.ts` file to toggle the feature:

    src/i18n/ui.ts

    ```
    export const showDefaultLang = false;
    ```

3.  Add a helper function to `src/i18n/utils.ts`, to translate paths based on the current language:

    src/i18n/utils.ts

    ```
    import { ui, defaultLang, showDefaultLang } from'./ui';exportfunctionuseTranslatedPath(lang:keyoftypeofui) {returnfunctiontranslatePath(path:string, l:string=lang) {return!showDefaultLang&&l===defaultLang?path:`/${l}${path}`}}
    ```

4.  Import the helper where needed. For example, a `nav` component might look like:

    src/components/Nav.astro

    ```
    ---import { getLangFromUrl, useTranslations, useTranslatedPath } from'../i18n/utils';const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);const translatePath = useTranslatedPath(lang);---<ul><li><ahref={translatePath('/home/')}>{t('nav.home')}</a></li><li><ahref={translatePath('/about/')}>{t('nav.about')}</a></li><li><ahref="https://twitter.com/astrodotbuild">{t('nav.twitter')}</a></li></ul>
    ```

5.  The helper function can also be used to translate paths for a specific language. For example, when users switch between languages:

    src/components/LanguagePicker.astro

    ```
    ---import { languages } from'../i18n/ui';import { getLangFromUrl, useTranslatedPath } from'../i18n/utils';const lang = getLangFromUrl(Astro.url);const translatePath = useTranslatedPath(lang);---<ul>{Object.entries(languages).map(([lang, label])=> (<li><ahref={translatePath('/', lang)}>{label}</a></li>))}</ul>
    ```



### Translate Routes


[Section titled Translate Routes](#translate-routes)

Translate the routes of your pages for each language.

1.  Add route mappings to `src/i18n/ui.ts`:

    src/i18n/ui.ts

    ```
    export const routes = {de: {'services': 'leistungen',},fr: {'services': 'prestations-de-service',},}
    ```

2.  Update the `useTranslatedPath` helper function in `src/i18n/utils.ts` to add router translation logic.

    src/i18n/utils.ts

    ```
    import { ui, defaultLang, showDefaultLang, routes } from'./ui';exportfunctionuseTranslatedPath(lang:keyoftypeofui) {returnfunctiontranslatePath(path:string, l:string=lang) {const pathName = path.replaceAll('/','')const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefinedconst translatedPath = hasTranslation ? '/' + routes[l][pathName] : pathreturn!showDefaultLang&&l===defaultLang?translatedPath:`/${l}${translatedPath}`}}
    ```

3.  Create a helper function to get the route, if it exists based on the current URL, in `src/i18n/utils.ts`:

    src/i18n/utils.ts

    ```
    import { ui, defaultLang, showDefaultLang, routes } from'./ui';exportfunctiongetRouteFromUrl(url:URL):string|undefined {const pathname = newURL(url).pathname;const parts = pathname?.split('/');const path = parts.pop() | parts.pop();if (path===undefined) {returnundefined;}const currentLang = getLangFromUrl(url);if (defaultLang===currentLang) {const route = Object.values(routes)[0];returnroute[path] !==undefined?route[path] :undefined;}const getKeyByValue = (obj:Record<string,string>, value:string):string|undefined  => {return Object.keys(obj).find((key) => obj[key] === value);}const reversedKey = getKeyByValue(routes[currentLang],path);if (reversedKey!==undefined) {returnreversedKey;}returnundefined;}
    ```

4.  The helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page:

    src/components/LanguagePicker.astro

    ```
    ---import { languages } from'../i18n/ui';import { getRouteFromUrl, useTranslatedPath } from'../i18n/utils';const route = getRouteFromUrl(Astro.url);---<ul>{Object.entries(languages).map(([lang, label])=> {const translatePath = useTranslatedPath(lang);return (<li><ahref={translatePath(`/${route?route:''}`)}>{label}</a></li>)})}</ul>
    ```



## Resources


[Section titled Resources](#resources)

-   [Choosing a Language Tag](https://www.w3.org/International/questions/qa-choosing-language-tags)
-   [Right-to-left (RTL) Styling 101](https://rtlstyling.com/)


## Community libraries


[Section titled Community libraries](#community-libraries)

-   [astro-i18next](https://github.com/yassinedoghri/astro-i18next) — An Astro integration for i18next including some utility components.
-   [astro-i18n](https://github.com/alexandre-fernandez/astro-i18n) — A TypeScript-first internationalization library for Astro.
-   [astro-i18n-aut](https://github.com/jlarmstrongiv/astro-i18n-aut) — An Astro integration for i18n that supports the `defaultLocale` without page generation. The integration is adapter agnostic and UI framework agnostic.
-   [astro-react-i18next](https://github.com/jeremyxgo/astro-react-i18next) — An Astro integration that seamlessly enables the use of i18next and react-i18next in React components on Astro websites.
-   [paraglide](https://inlang.com/c/astro) — A fully type-safe i18n library specifically designed for partial hydration patterns like Astro islands.
-   [astro-loader-i18n](https://github.com/openscript/astro-loader-i18n) — An Astro glob content loader for i18n files and folder structures supporting the translation of routes.

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 158. `en/recipes/making-toolbar-apps/.md`

```text
# Create a dev toolbar app


---
url: https://docs.astro.build/en/recipes/making-toolbar-apps/
description: Learn how to create a dev toolbar app for your site.
---


# Create a dev toolbar app


Astro includes a [development toolbar](/en/guides/dev-toolbar/) that you can use to inspect your site, check for accessibility and performance issues, and more. This toolbar can be extended with custom apps.


## Build a motivational dev toolbar app


[Section titled Build a motivational dev toolbar app](#build-a-motivational-dev-toolbar-app)

In this recipe, you’ll learn how to create a dev toolbar app that helps you stay motivated while working on your site. This app will display a motivational message every time you toggle it on.

Tip

Just want to get started quickly? Jump start your app by creating a new Astro project with the `toolbar-app` template.

-   [npm](#tab-panel-1717)
-   [pnpm](#tab-panel-1718)
-   [Yarn](#tab-panel-1719)

Terminal window

```
npmcreateastro@latest----templatetoolbar-app
```

Terminal window

```
pnpmcreateastro----templatetoolbar-app
```

Terminal window

```
yarncreateastro----templatetoolbar-app
```

Or, keep reading to learn how to build an app from scratch.


### Creating the Astro integration


[Section titled Creating the Astro integration](#creating-the-astro-integration)

Dev toolbar apps can only be added by [Astro Integrations](/en/guides/integrations-guide/) using [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup). You will need to create both a toolbar app and the integration that will add it to the toolbar of your existing Astro project.

1.  In the root of your existing Astro project, create a new folder named `my-toolbar-app/` for your app and integration files. Create two new files in this folder: `app.ts` and `my-integration.ts`.

    -   Directory**my-toolbar-app/**

        -   **app.ts**
        -   **my-integration.ts**

    -   Directorysrc/

        -   Directorypages/

            -   …

        -   …

    -   astro.config.mjs
    -   package.json
    -   tsconfig.json

2.  In `my-integration.ts`, add the following code to provide both the name of your integration and the [`addDevToolbarApp()` function](/en/reference/dev-toolbar-app-reference/#toolbar-app-integration-setup) needed to add your dev toolbar app with the `astro:config:setup` hook:

    my-toolbar-app/my-integration.ts

    ```
    import { fileURLToPath } from'node:url';importtype { AstroIntegration } from'astro';exportdefault {name: 'my-astro-integration',hooks: {'astro:config:setup': ({ addDevToolbarApp })=> {addDevToolbarApp({id: "my-toolbar-app",name: "My Toolbar App",icon: "🚀",entrypoint: fileURLToPath(newURL('./app.ts', import.meta.url))});},},} satisfiesAstroIntegration;
    ```

    Using relative paths to the entrypoint

    The `entrypoint` is the path to your dev toolbar app file **relative to the root of your existing Astro project**, not to the integration folder (`my-toolbar-app`) itself.

    To use relative paths for entrypoints, get the path to the current file using `import.meta.url` and resolve the path to the entrypoint from there.

3.  To use this integration in your project, add it to the `integrations` array in your `astro.config.mjs` file.

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import myIntegration from'./my-toolbar-app/my-integration.ts';exportdefaultdefineConfig({integrations: [myIntegration],})
    ```

4.  If not already running, start the dev server. If your integration has been successfully added to your project, you should see a new “undefined” app in the dev toolbar.

    But, you will also see an error message that your dev toolbar app has failed to load. This is because you have not yet built the app itself. You will do that in the next section.


See the [Astro Integration API documentation](/en/reference/integrations-reference/) for more about building Astro integrations.


### Creating the app


[Section titled Creating the app](#creating-the-app)

Dev toolbar apps are defined using the `defineToolbarApp()` function from the `astro/toolbar` module. This function takes an object with an `init()` function that will be called when the dev toolbar app is loaded.

This `init()` function contains your app logic to render elements to the screen, send and receive client-side events from the dev toolbar, and communicate with the server.

app.ts

```
import { defineToolbarApp } from"astro/toolbar";exportdefaultdefineToolbarApp({init(canvas, app, server) {// ...},});
```

To display motivational messages on the screen, you will use the `canvas` property to access a standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot). Elements can be created and added to the ShadowRoot using the standard DOM APIs.

1.  Copy the following code into `my-toolbar-app/app.ts`. This provides a list of motivational messages, and the logic to create a new `<h1>` element with a random message:

    my-toolbar-app/app.ts

    ```
    import { defineToolbarApp } from"astro/toolbar";const motivationalMessages = ["You're doing great!","Keep up the good work!","You're awesome!","You're a star!",];exportdefaultdefineToolbarApp({init(canvas) {consth1 = document.createElement('h1');h1.textContent= motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];canvas.append(h1);},});
    ```

2.  Start the dev server if it is not already running and toggle the app on in the dev toolbar. If your app is working successfully, you will see a motivational message displayed in the top-left corner of the screen. (And, it’s true!)

    However, this message will not change when the app is toggled on and off, as the `init()` function is only called once when the app is loaded.

3.  To add client-side interactivity to your app, add the `app` argument and use `onAppToggled()` to select a new random message each time your toolbar app is toggled on:

    app.ts

    ```
    import { defineToolbarApp } from"astro/toolbar";const motivationalMessages = ["You're doing great!","Keep up the good work!","You're awesome!","You're a star!",];exportdefaultdefineToolbarApp({init(canvas, app) {consth1 = document.createElement('h1');h1.textContent= motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];canvas.append(h1);// Display a random message when the app is toggledapp.onToggled(({ state })=> {constnewMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];h1.textContent= newMessage;});},});
    ```

4.  In your browser preview, toggle your app on and off several times. With this change, a new random message will be selected every time you toggle the app on, providing you with an infinite source of motivation!


See the [Astro Dev Toolbar API documentation](/en/reference/dev-toolbar-app-reference/) for more about building dev toolbar apps.


## Building apps with a UI framework


[Section titled Building apps with a UI framework](#building-apps-with-a-ui-framework)

UI frameworks like React, Vue, or Svelte can also be used to create dev toolbar apps. These frameworks provide a more declarative way to create UIs and can make your code more maintainable and easier to read.

The same motivational dev toolbar app built into your existing Astro project earlier on this page with JavaScript can be built using a UI framework (e.g. Preact) instead. Depending on your chosen framework, you may or may not require a build step.

Note

However you choose to build your dev toolbar app, using JavaScript or a UI framework, you will still need to [create the integration](#creating-the-astro-integration) that adds your app to the dev toolbar.


### Without a build step


[Section titled Without a build step](#without-a-build-step)

If your framework supports it, you can create a dev toolbar app without a build step. For example, you can use Preact’s `h` function to create elements and render them directly to the ShadowRoot:

app.ts

```
import { defineToolbarApp } from"astro/toolbar";import { render, h } from"preact";const motivationalMessages = ["You're doing great!","Keep up the good work!","You're awesome!","You're a star!",];exportdefaultdefineToolbarApp({init(canvas) {constmessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];render(h('h1', null, message), canvas);},});
```

Alternatively, the [`htm` package](https://github.com/developit/htm) is a good choice for creating dev toolbar apps without a build step, offering native integration for React and Preact and support for other frameworks:

app.ts

```
import { defineToolbarApp } from"astro/toolbar";import { render } from"preact";import { html } from'htm/preact';const motivationalMessages = ["You're doing great!","Keep up the good work!","You're awesome!","You're a star!",];exportdefaultdefineToolbarApp({init(canvas) {constmessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];render(html`<h1>${message}</h1>`, canvas);},});
```

In both cases, you can now start your project and see the motivational message displayed in the top-left corner of the screen when you toggle the app on.


### With a build step


[Section titled With a build step](#with-a-build-step)

Astro does not preprocess JSX code in dev toolbar apps, so a build step is required in order to use JSX components in your dev toolbar app.

The following steps will use TypeScript to do this, but any other tools that compile JSX code will also work (e.g. Babel, Rollup, ESBuild).

1.  Install TypeScript inside your project:

    -   [npm](#tab-panel-1720)
    -   [pnpm](#tab-panel-1721)
    -   [Yarn](#tab-panel-1722)

    Terminal window

    ```
    npminstall--save-devtypescript
    ```

    Terminal window

    ```
    pnpminstall--save-devtypescript
    ```

    Terminal window

    ```
    yarnadd--devtypescript
    ```

2.  Create a `tsconfig.json` file in the root of your toolbar app’s folder with the appropriate settings to build and for the framework you’re using ([React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript)). For example, for Preact:

    my-toolbar-app/tsconfig.json

    ```
    {"compilerOptions": {"skipLibCheck": true,"module": "NodeNext","jsx": "react-jsx","jsxImportSource": "preact",}}
    ```

3.  Adjust the `entrypoint` in your integration to point to the compiled file, remembering that this file is relative to the root of your Astro project:

    my-integration.ts

    ```
    addDevToolbarApp({id: "my-toolbar-app",name: "My Toolbar App",icon: "🚀",entrypoint: join(__dirname, "./app.js"),});
    ```

4.  Run `tsc` to build your toolbar app, or `tsc --watch` to automatically rebuild your app when you make changes.

    With these changes, you can now rename your `app.ts` file to `app.tsx` (or `.jsx`) and use JSX syntax to create your dev toolbar app:

    app.tsx

    ```
    import { defineToolbarApp } from"astro/toolbar";import { render } from"preact";const motivationalMessages = ["You're doing great!","Keep up the good work!","You're awesome!","You're a star!",];exportdefaultdefineToolbarApp({init(canvas) {constmessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];render(<h1>{message}</h1>, canvas);},});
    ```


You should now have all the tools you need to create a dev toolbar app using a UI framework of your choice!

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 159. `en/recipes/modified-time/.md`

```text
# Add last modified time


---
url: https://docs.astro.build/en/recipes/modified-time/
description: Build a remark plugin to add the last modified time to your Markdown and MDX.
---


# Add last modified time


Learn how to build a [remark plugin](https://github.com/remarkjs/remark) that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to display the modified time in your pages.

Uses Git history

This recipe calculates time based on your repository’s Git history and may not be accurate on some deployment platforms. Your host may be performing **shallow clones** which do not retrieve the full git history.


## Recipe


[Section titled Recipe](#recipe)

1.  Install Helper Packages

    Install [`Day.js`](https://www.npmjs.com/package/dayjs) to modify and format times:

    -   [npm](#tab-panel-1723)
    -   [pnpm](#tab-panel-1724)
    -   [Yarn](#tab-panel-1725)

    Terminal window

    ```
    npminstalldayjs
    ```

    Terminal window

    ```
    pnpmadddayjs
    ```

    Terminal window

    ```
    yarnadddayjs
    ```

2.  Create a Remark Plugin

    This plugin uses `execSync` to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file.

    remark-modified-time.mjs

    ```
    import { execSync } from"child_process";exportfunctionremarkModifiedTime() {returnfunction(tree, file) {const filepath = file.history[0];const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`);file.data.astro.frontmatter.lastModified=result.toString();};}
    ```

    Using the file system instead of Git

    Although using Git is the recommended way to get the last modified timestamp from a file, it is possible to use the file system modified time. This plugin uses `statSync` to get the `mtime` (modified time) of the file in ISO 8601 format. The timestamp is then added to the frontmatter of the file.

    remark-modified-time.mjs

    ```
    import { statSync } from"fs";exportfunctionremarkModifiedTime() {returnfunction(tree, file) {const filepath = file.history[0];const result = statSync(filepath);file.data.astro.frontmatter.lastModified=result.mtime.toISOString();};}
    ```

3.  Add the plugin to your config

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import { remarkModifiedTime } from'./remark-modified-time.mjs';exportdefaultdefineConfig({markdown: {remarkPlugins: [remarkModifiedTime],},});
    ```

    Now all Markdown documents will have a `lastModified` property in their frontmatter.

4.  Display Last Modified Time

    If your content is stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then render `lastModified` in your template wherever you would like it to appear.

    src/pages/posts/\[slug\].astro

    ```
    ---import { getCollection, render } from'astro:content';import dayjs from"dayjs";import utc from"dayjs/plugin/utc";dayjs.extend(utc);exportasyncfunctiongetStaticPaths() {const blog = await getCollection('blog');return blog.map(entry=> ({params: { slug: entry.id },props: { entry },}));}const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);const lastModified = dayjs(remarkPluginFrontmatter.lastModified).utc().format("HH:mm:ss DD MMMM YYYY UTC");---<html><head>...</head><body>...<p>Last Modified: {lastModified}</p>...</body></html>
    ```

    If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `lastModified` frontmatter property from `Astro.props` in your layout template.

    src/layouts/BlogLayout.astro

    ```
    ---import dayjs from"dayjs";import utc from"dayjs/plugin/utc";dayjs.extend(utc);const lastModified = dayjs().utc(Astro.props.frontmatter.lastModified).format("HH:mm:ss DD MMMM YYYY UTC");---<html><head>...</head><body><p>{lastModified}</p><slot /></body></html>
    ```


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 160. `en/recipes/reading-time/.md`

```text
# Add reading time


---
url: https://docs.astro.build/en/recipes/reading-time/
description: Build a remark plugin to add reading time to your Markdown or MDX files.
---


# Add reading time


Create a [remark plugin](https://github.com/remarkjs/remark) which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page.


## Recipe


[Section titled Recipe](#recipe)

1.  Install Helper Packages

    Install these two helper packages:

    -   [`reading-time`](https://www.npmjs.com/package/reading-time) to calculate minutes read
    -   [`mdast-util-to-string`](https://www.npmjs.com/package/mdast-util-to-string) to extract all text from your markdown

    -   [npm](#tab-panel-1726)
    -   [pnpm](#tab-panel-1727)
    -   [Yarn](#tab-panel-1728)

    Terminal window

    ```
    npminstallreading-timemdast-util-to-string
    ```

    Terminal window

    ```
    pnpmaddreading-timemdast-util-to-string
    ```

    Terminal window

    ```
    yarnaddreading-timemdast-util-to-string
    ```

2.  Create a remark plugin.

    This plugin uses the `mdast-util-to-string` package to get the Markdown file’s text. This text is then passed to the `reading-time` package to calculate the reading time in minutes.

    remark-reading-time.mjs

    ```
    import getReadingTime from'reading-time';import { toString } from'mdast-util-to-string';exportfunctionremarkReadingTime() {returnfunction(tree, { data }) {const textOnPage = toString(tree);const readingTime = getReadingTime(textOnPage);// readingTime.text will give us minutes read as a friendly string,// i.e. "3 min read"data.astro.frontmatter.minutesRead=readingTime.text;};}
    ```

3.  Add the plugin to your config:

    astro.config.mjs

    ```
    import { defineConfig } from'astro/config';import { remarkReadingTime } from'./remark-reading-time.mjs';exportdefaultdefineConfig({markdown: {remarkPlugins: [remarkReadingTime],},});
    ```

    Now all Markdown documents will have a calculated `minutesRead` property in their frontmatter.

4.  Display Reading Time

    If your blog posts are stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then, render `minutesRead` in your template wherever you would like it to appear.

    src/pages/posts/\[slug\].astro

    ```
    ---import { getCollection, render } from'astro:content';exportasyncfunctiongetStaticPaths() {const blog = await getCollection('blog');return blog.map(entry=> ({params: { slug: entry.id },props: { entry },}));}const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);---<html><head>...</head><body>...<p>{remarkPluginFrontmatter.minutesRead}</p>...</body></html>
    ```

    If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `minutesRead` frontmatter property from `Astro.props` in your layout template.

    src/layouts/BlogLayout.astro

    ```
    ---const { minutesRead } = Astro.props.frontmatter;---<html><head>...</head><body><p>{minutesRead}</p><slot /></body></html>
    ```


Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 161. `en/recipes/sharing-state/.md`

```text
# Share state between Astro components


---
url: https://docs.astro.build/en/recipes/sharing-state/
description: Learn how to share state across Astro components with Nano Stores.
---


# Share state between Astro components


Tip

Using framework components? See [how to share state between Islands](/en/recipes/sharing-state-islands/)!

When building an Astro website, you may need to share state across components. Astro recommends the use of [Nano Stores](https://github.com/nanostores/nanostores) for shared client storage.


## Recipe


[Section titled Recipe](#recipe)

1.  Install Nano Stores:

    -   [npm](#tab-panel-1761)
    -   [pnpm](#tab-panel-1762)
    -   [Yarn](#tab-panel-1763)

    Terminal window

    ```
    npminstallnanostores
    ```

    Terminal window

    ```
    pnpmaddnanostores
    ```

    Terminal window

    ```
    yarnaddnanostores
    ```

2.  Create a store. In this example, the store tracks whether a dialog is open or not:

    src/store.js

    ```
    import { atom } from'nanostores';export const isOpen = atom(false);
    ```

3.  Import and use the store in a `<script>` tag in the components that will share state.

    The following `Button` and `Dialog` components each use the shared `isOpen` state to control whether a particular `<div>` is hidden or displayed:

    src/components/Button.astro

    ```
    <buttonid="openDialog">Open</button><script>import { isOpen } from'../store.js';// Set the store to true when the button is clickedfunctionopenDialog() {isOpen.set(true);}// Add an event listener to the buttondocument.getElementById('openDialog').addEventListener('click', openDialog);</script>
    ```

    src/components/Dialog.astro

    ```
    <divid="dialog"style="display: none">Hello world!</div><script>import { isOpen } from'../store.js';// Listen to changes in the store, and show/hide the dialog accordinglyisOpen.subscribe(open=> {if (open) {document.getElementById('dialog').style.display='block';} else {document.getElementById('dialog').style.display='none';}})</script>
    ```



## Resources


[Section titled Resources](#resources)

-   [Nano Stores on NPM](https://www.npmjs.com/package/nanostores)
-   [Nano Stores documentation for Vanilla JS](https://github.com/nanostores/nanostores#vanilla-js)

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 162. `en/recipes/sharing-state-islands/.md`

```text
# Share state between islands


---
url: https://docs.astro.build/en/recipes/sharing-state-islands/
description: Learn how to share state across framework components with Nano Stores.
---


# Share state between islands


When building an Astro website with [islands architecture / partial hydration](/en/concepts/islands/), you may have run into this problem: **I want to share state between my components.**

UI frameworks like React or Vue may encourage [“context” providers](https://react.dev/learn/passing-data-deeply-with-context) for other components to consume. But when [partially hydrating components](/en/guides/framework-components/#hydrating-interactive-components) within Astro or Markdown, you can’t use these context wrappers.

Astro recommends a different solution for shared client-side storage: [**Nano Stores**](https://github.com/nanostores/nanostores).

**Related recipe:** [Share state between Astro components](/en/recipes/sharing-state/)


## Why Nano Stores?


[Section titled Why Nano Stores?](#why-nano-stores)

The [Nano Stores](https://github.com/nanostores/nanostores) library allows you to author stores that any component can interact with. We recommend Nano Stores because:

-   **They’re lightweight.** Nano Stores ship the bare minimum JS you’ll need (less than 1 KB) with zero dependencies.
-   **They’re framework-agnostic.** This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference.

Still, there are a number of alternatives you can explore. These include:

-   [Svelte’s built-in stores](https://svelte.dev/tutorial/writable-stores)
-   [Solid signals](https://www.solidjs.com/docs/latest) outside of a component context
-   [Vue’s reactivity API](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api)
-   [Sending custom browser events](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) between components

FAQ

**🙋 Can I use Nano Stores in `.astro` files or other server-side components?**

Nano Stores can be used in `<script>` tags to [share state between `.astro` components](/en/recipes/sharing-state/). However, Using Nano Stores in the frontmatter of server-side components is not recommended because of the following restrictions:

-   Writing to a store from a `.astro` file or [non-hydrated component](/en/guides/framework-components/#hydrating-interactive-components) will *not* affect the value received by [client-side components](/en/reference/directives-reference/#client-directives).
-   You cannot pass a Nano Store as a “prop” to client-side components.
-   You cannot subscribe to store changes from a `.astro` file, since Astro components do not re-render.

If you understand these restrictions and still find a use case, you can give Nano Stores a try! Just remember that Nano Stores are built for reactivity to changes on the **client** specifically.

**🙋 How do Svelte stores compare to Nano Stores?**

**Nano Stores and [Svelte stores](https://svelte.dev/tutorial/writable-stores) are very similar!** In fact, [nanostores allow you to use the same `$` shortcut](https://github.com/nanostores/nanostores#svelte) for subscriptions that you might use with Svelte stores.

If you want to avoid third-party libraries, [Svelte stores](https://svelte.dev/tutorial/writable-stores) are a great cross-island communication tool on their own. Still, you might prefer Nano Stores if a) you like their add-ons for [“objects”](https://github.com/nanostores/nanostores#maps) and [async state](https://github.com/nanostores/nanostores#lazy-stores), or b) you want to communicate between Svelte and other UI frameworks like Preact or Vue.

**🙋 How do Solid signals compare to Nano Stores?**

If you’ve used Solid for a while, you may have tried moving [signals](https://www.solidjs.com/docs/latest#createsignal) or [stores](https://www.solidjs.com/docs/latest#createstore) outside of your components. This is a great way to share state between Solid islands! Try exporting signals from a shared file:

sharedStore.js

```
import { createSignal } from'solid-js';export const sharedCount = createSignal(0);
```

…and all components importing `sharedCount` will share the same state. Though this works well, you might prefer Nano Stores if a) you like their add-ons for [“objects”](https://github.com/nanostores/nanostores#maps) and [async state](https://github.com/nanostores/nanostores#lazy-stores), or b) you want to communicate between Solid and other UI frameworks like Preact or Vue.


## Installing Nano Stores


[Section titled Installing Nano Stores](#installing-nano-stores)

To get started, install Nano Stores alongside their helper package for your favorite UI framework:

-   [Preact](#tab-panel-1736)
-   [React](#tab-panel-1737)
-   [Solid](#tab-panel-1738)
-   [Svelte](#tab-panel-1739)
-   [Vue](#tab-panel-1740)

Terminal window

```
npminstallnanostores@nanostores/preact
```

Terminal window

```
npminstallnanostores@nanostores/react
```

Terminal window

```
npminstallnanostores@nanostores/solid
```

Terminal window

```
npminstallnanostores
```

Note

No helper package here! Nano Stores can be used like standard Svelte stores.

Terminal window

```
npminstallnanostores@nanostores/vue
```

You can jump into the [Nano Stores usage guide](https://github.com/nanostores/nanostores#guide) from here, or follow along with our example below!


## Usage example - ecommerce cart flyout


[Section titled Usage example - ecommerce cart flyout](#usage-example---ecommerce-cart-flyout)

Let’s say we’re building a simple ecommerce interface with three interactive elements:

-   An “add to cart” submission form
-   A cart flyout to display those added items
-   A cart flyout toggle

*[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz.*

Your base Astro file may look like this:

src/pages/index.astro

```
---import CartFlyoutToggle from'../components/CartFlyoutToggle';import CartFlyout from'../components/CartFlyout';import AddToCartForm from'../components/AddToCartForm';---<!DOCTYPEhtml><htmllang="en"><head>...</head><body><header><nav><ahref="/">Astro storefront</a><CartFlyoutToggleclient:load /></nav></header><main><AddToCartFormclient:load><!-- ... --></AddToCartForm></main><CartFlyoutclient:load /></body></html>
```


### Using “atoms”


[Section titled Using “atoms”](#using-atoms)

Let’s start by opening our `CartFlyout` whenever `CartFlyoutToggle` is clicked.

First, create a new JS or TS file to contain our store. We’ll use an [“atom”](https://github.com/nanostores/nanostores#atoms) for this:

src/cartStore.js

```
import { atom } from'nanostores';export const isCartOpen = atom(false);
```

Now, we can import this store into any file that needs to read or write. We’ll start by wiring up our `CartFlyoutToggle`:

-   [Preact](#tab-panel-1741)
-   [React](#tab-panel-1742)
-   [Solid](#tab-panel-1743)
-   [Svelte](#tab-panel-1744)
-   [Vue](#tab-panel-1745)

src/components/CartFlyoutToggle.jsx

```
import { useStore } from'@nanostores/preact';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartButton() {// read the store value with the `useStore` hookconst $isCartOpen = useStore(isCartOpen);// write to the imported store using `.set`return (<buttononClick={()=>isCartOpen.set(!$isCartOpen)}>Cart</button>)}
```

src/components/CartFlyoutToggle.jsx

```
import { useStore } from'@nanostores/react';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartButton() {// read the store value with the `useStore` hookconst $isCartOpen = useStore(isCartOpen);// write to the imported store using `.set`return (<buttononClick={()=>isCartOpen.set(!$isCartOpen)}>Cart</button>)}
```

src/components/CartFlyoutToggle.jsx

```
import { useStore } from'@nanostores/solid';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartButton() {// read the store value with the `useStore` hookconst $isCartOpen = useStore(isCartOpen);// write to the imported store using `.set`return (<buttononClick={()=>isCartOpen.set(!$isCartOpen())}>Cart</button>)}
```

src/components/CartFlyoutToggle.svelte

```
<script>import { isCartOpen } from'../cartStore';</script><!--use "$" to read the store value--><buttonon:click={()=>isCartOpen.set(!$isCartOpen)}>Cart</button>
```

src/components/CartFlyoutToggle.vue

```
<template><!--write to the imported store using `.set`--><button @click="isCartOpen.set(!$isCartOpen)">Cart</button></template><scriptsetup>import { isCartOpen } from'../cartStore';import { useStore } from'@nanostores/vue';// read the store value with the `useStore` hookconst $isCartOpen = useStore(isCartOpen);</script>
```

Then, we can read `isCartOpen` from our `CartFlyout` component:

-   [Preact](#tab-panel-1746)
-   [React](#tab-panel-1747)
-   [Solid](#tab-panel-1748)
-   [Svelte](#tab-panel-1749)
-   [Vue](#tab-panel-1750)

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/preact';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);return$isCartOpen?<aside>...</aside>:null;}
```

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/react';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);return$isCartOpen?<aside>...</aside>:null;}
```

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/solid';import { isCartOpen } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);return$isCartOpen() ?<aside>...</aside>:null;}
```

src/components/CartFlyout.svelte

```
<script>import { isCartOpen } from'../cartStore';</script>{#if $isCartOpen}<aside>...</aside>{/if}
```

src/components/CartFlyout.vue

```
<template><asidev-if="$isCartOpen">...</aside></template><scriptsetup>import { isCartOpen } from'../cartStore';import { useStore } from'@nanostores/vue';const $isCartOpen = useStore(isCartOpen);</script>
```


### Using “maps”


[Section titled Using “maps”](#using-maps)

Tip

**[Maps](https://github.com/nanostores/nanostores#maps) are a great choice for objects you write to regularly!** Alongside the standard `get()` and `set()` helpers an `atom` provides, you’ll also have a `.setKey()` function to efficiently update individual object keys.

Now, let’s keep track of the items inside your cart. To avoid duplicates and keep track of “quantity,” we can store your cart as an object with the item’s ID as a key. We’ll use a [Map](https://github.com/nanostores/nanostores#maps) for this.

Let’s add a `cartItem` store to our `cartStore.js` from earlier. You can also switch to a TypeScript file to define the shape if you’re so inclined.

-   [JavaScript](#tab-panel-1732)
-   [TypeScript](#tab-panel-1733)

src/cartStore.js

```
import { atom, map } from'nanostores';export const isCartOpen = atom(false);/*** @typedef{Object}CartItem* @property{string}id* @property{string}name* @property{string}imageSrc* @property{number}quantity*//** @type{import('nanostores').MapStore<Record<string, CartItem>>} */export const cartItems = map({});
```

src/cartStore.ts

```
import { atom, map } from'nanostores';export const isCartOpen = atom(false);exporttype CartItem = {id:string;name:string;imageSrc:string;quantity:number;}export const cartItems = map<Record<string, CartItem>>({});
```

Now, let’s export an `addCartItem` helper for our components to use.

-   **If that item doesn’t exist in your cart**, add the item with a starting quantity of 1.
-   **If that item *does* already exist**, bump the quantity by 1.

-   [JavaScript](#tab-panel-1734)
-   [TypeScript](#tab-panel-1735)

src/cartStore.js

```
...exportfunctionaddCartItem({ id,name,imageSrc }) {const existingEntry = cartItems.get()[id];if (existingEntry) {cartItems.setKey(id, {...existingEntry,quantity: existingEntry.quantity+1,})} else {cartItems.setKey(id,{ id,name,imageSrc, quantity: 1 });}}
```

src/cartStore.ts

```
...type ItemDisplayInfo =Pick<CartItem, 'id'|'name'|'imageSrc'>;exportfunctionaddCartItem({ id,name,imageSrc }:ItemDisplayInfo) {const existingEntry = cartItems.get()[id];if (existingEntry) {cartItems.setKey(id, {...existingEntry,quantity: existingEntry.quantity+1,});} else {cartItems.setKey(id,{ id, name, imageSrc, quantity: 1 });}}
```

Note

**🙋 Why use `.get()` here instead of a `useStore` helper?**

You may have noticed we’re calling `cartItems.get()` here, instead of grabbing that `useStore` helper from our React / Preact / Solid / Vue examples. This is because **useStore is meant to trigger component re-renders.** In other words, `useStore` should be used whenever the store value is being rendered to the UI. Since we’re reading the value when an **event** is triggered (`addToCart` in this case), and we aren’t trying to render that value, we don’t need `useStore` here.

With our store in place, we can call this function inside our `AddToCartForm` whenever that form is submitted. We’ll also open the cart flyout so you can see a full cart summary.

-   [Preact](#tab-panel-1751)
-   [React](#tab-panel-1752)
-   [Solid](#tab-panel-1753)
-   [Svelte](#tab-panel-1754)
-   [Vue](#tab-panel-1755)

src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from'../cartStore';exportdefaultfunctionAddToCartForm({ children }) {// we'll hardcode the item info for simplicity!const hardcodedItemInfo = {id: 'astronaut-figurine',name: 'Astronaut Figurine',imageSrc: '/images/astronaut-figurine.png',}functionaddToCart(e) {e.preventDefault();isCartOpen.set(true);addCartItem(hardcodedItemInfo);}return (<formonSubmit={addToCart}>{children}</form>)}
```

src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from'../cartStore';exportdefaultfunctionAddToCartForm({ children }) {// we'll hardcode the item info for simplicity!const hardcodedItemInfo = {id: 'astronaut-figurine',name: 'Astronaut Figurine',imageSrc: '/images/astronaut-figurine.png',}functionaddToCart(e) {e.preventDefault();isCartOpen.set(true);addCartItem(hardcodedItemInfo);}return (<formonSubmit={addToCart}>{children}</form>)}
```

src/components/AddToCartForm.jsx

```
import { addCartItem, isCartOpen } from'../cartStore';exportdefaultfunctionAddToCartForm({ children }) {// we'll hardcode the item info for simplicity!const hardcodedItemInfo = {id: 'astronaut-figurine',name: 'Astronaut Figurine',imageSrc: '/images/astronaut-figurine.png',}functionaddToCart(e) {e.preventDefault();isCartOpen.set(true);addCartItem(hardcodedItemInfo);}return (<formonSubmit={addToCart}>{children}</form>)}
```

src/components/AddToCartForm.svelte

```
<formon:submit|preventDefault={addToCart}><slot></slot></form><script>import { addCartItem, isCartOpen } from'../cartStore';// we'll hardcode the item info for simplicity!const hardcodedItemInfo = {id: 'astronaut-figurine',name: 'Astronaut Figurine',imageSrc: '/images/astronaut-figurine.png',}functionaddToCart() {isCartOpen.set(true);addCartItem(hardcodedItemInfo);}</script>
```

src/components/AddToCartForm.vue

```
<template><form @submit="addToCart"><slot></slot></form></template><scriptsetup>import { addCartItem, isCartOpen } from'../cartStore';// we'll hardcode the item info for simplicity!const hardcodedItemInfo = {id: 'astronaut-figurine',name: 'Astronaut Figurine',imageSrc: '/images/astronaut-figurine.png',}functionaddToCart(e) {e.preventDefault();isCartOpen.set(true);addCartItem(hardcodedItemInfo);}</script>
```

Finally, we’ll render those cart items inside our `CartFlyout`:

-   [Preact](#tab-panel-1756)
-   [React](#tab-panel-1757)
-   [Solid](#tab-panel-1758)
-   [Svelte](#tab-panel-1759)
-   [Vue](#tab-panel-1760)

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/preact';import { isCartOpen, cartItems } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);const $cartItems = useStore(cartItems);return$isCartOpen? (<aside>{Object.values($cartItems).length? (<ul>{Object.values($cartItems).map(cartItem=> (<li><imgsrc={cartItem.imageSrc}alt={cartItem.name} /><h3>{cartItem.name}</h3><p>Quantity: {cartItem.quantity}</p></li>))}</ul>) :<p>Your cart is empty!</p>}</aside>) :null;}
```

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/react';import { isCartOpen, cartItems } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);const $cartItems = useStore(cartItems);return$isCartOpen? (<aside>{Object.values($cartItems).length? (<ul>{Object.values($cartItems).map(cartItem=> (<li><imgsrc={cartItem.imageSrc}alt={cartItem.name} /><h3>{cartItem.name}</h3><p>Quantity: {cartItem.quantity}</p></li>))}</ul>) :<p>Your cart is empty!</p>}</aside>) :null;}
```

src/components/CartFlyout.jsx

```
import { useStore } from'@nanostores/solid';import { isCartOpen, cartItems } from'../cartStore';exportdefaultfunctionCartFlyout() {const $isCartOpen = useStore(isCartOpen);const $cartItems = useStore(cartItems);return$isCartOpen() ? (<aside>{Object.values($cartItems()).length? (<ul>{Object.values($cartItems()).map(cartItem=> (<li><imgsrc={cartItem.imageSrc}alt={cartItem.name} /><h3>{cartItem.name}</h3><p>Quantity: {cartItem.quantity}</p></li>))}</ul>) :<p>Your cart is empty!</p>}</aside>) :null;}
```

src/components/CartFlyout.svelte

```
<script>import { isCartOpen, cartItems } from'../cartStore';</script>{#if $isCartOpen}{#if Object.values($cartItems).length}<aside>{#each Object.values($cartItems) as cartItem}<li><imgsrc={cartItem.imageSrc}alt={cartItem.name} /><h3>{cartItem.name}</h3><p>Quantity: {cartItem.quantity}</p></li>{/each}</aside>{:else}<p>Your cart is empty!</p>{/if}{/if}
```

src/components/CartFlyout.vue

```
<template><asidev-if="$isCartOpen"><ulv-if="Object.values($cartItems).length"><liv-for="cartIteminObject.values($cartItems)"v-bind:key="cartItem.name"><img :src=cartItem.imageSrc :alt=cartItem.name /><h3>{{cartItem.name}}</h3><p>Quantity: {{cartItem.quantity}}</p></li></ul><pv-else>Your cart is empty!</p></aside></template><scriptsetup>import { cartItems, isCartOpen } from'../cartStore';import { useStore } from'@nanostores/vue';const $isCartOpen = useStore(isCartOpen);const $cartItems = useStore(cartItems);</script>
```

Now, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy 🚀

[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz!

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 163. `en/recipes/streaming-improve-page-performance/.md`

```text
# Using streaming to improve page performance


---
url: https://docs.astro.build/en/recipes/streaming-improve-page-performance/
description: Learn how to use streaming to improve page performance.
---


# Using streaming to improve page performance


Astro’s SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page’s performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches.

The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering.

The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser.

src/pages/index.astro

```
---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<html><head><title>A name and a fact</title></head><body><h2>A name</h2><p>{randomPerson.name.first}</p><h2>A fact</h2><p>{factData.fact}</p></body></html>
```

Moving the `await` calls into smaller components allows you to take advantage of Astro’s streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready.

src/components/RandomName.astro

```
---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];---<p>{randomPerson.name.first}</p>
```

src/components/RandomFact.astro

```
---const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<p>{factData.fact}</p>
```

The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h2>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser.

src/pages/index.astro

```
---import RandomName from'../components/RandomName.astro';import RandomFact from'../components/RandomFact.astro';---<html><head><title>A name and a fact</title></head><body><h2>A name</h2><RandomName /><h2>A fact</h2><RandomFact /></body></html>
```


#### Including Promises directly


[Section titled Including Promises directly](#including-promises-directly)

You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it.

src/pages/index.astro

```
---const personPromise = fetch('https://randomuser.me/api/').then(response=> response.json()).then(personData=> personData.results[0].name.first);const factPromise = fetch('https://catfact.ninja/fact').then(response=> response.json()).then(factData=> factData.fact);---<html><head><title>A name and a fact</title></head><body><h2>A name</h2><p>{personPromise}</p><h2>A fact</h2><p>{factPromise}</p></body></html>
```

In this example, `A name` will render while `personPromise` and `factPromise` are loading. Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it’s finished loading.

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 164. `en/recipes/tailwind-rendered-markdown/.md`

```text
# Style rendered Markdown with Tailwind Typography


---
url: https://docs.astro.build/en/recipes/tailwind-rendered-markdown/
description: Learn how to use @tailwind/typography to style your rendered Markdown.
---


# Style rendered Markdown with Tailwind Typography


You can use [Tailwind](https://tailwindcss.com)’s Typography plugin to style rendered Markdown from sources such as Astro’s [**content collections**](/en/guides/content-collections/).

This recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind’s utility classes.


## Prerequisites


[Section titled Prerequisites](#prerequisites)

An Astro project that:

-   has [Tailwind’s Vite plugin](/en/guides/styling/#tailwind) installed.
-   uses Astro’s [content collections](/en/guides/content-collections/).


## Setting Up `@tailwindcss/typography`


[Section titled Setting Up @tailwindcss/typography](#setting-up-tailwindcsstypography)

First, install `@tailwindcss/typography` using your preferred package manager.

-   [npm](#tab-panel-1764)
-   [pnpm](#tab-panel-1765)
-   [Yarn](#tab-panel-1766)

Terminal window

```
npminstall-D@tailwindcss/typography
```

Terminal window

```
pnpmadd-D@tailwindcss/typography
```

Terminal window

```
yarnadd--dev@tailwindcss/typography
```

Then, add the package as a plugin in your Tailwind configuration file.

src/styles/global.css

```
@import'tailwindcss';@plugin '@tailwindcss/typography';
```


## Recipe


[Section titled Recipe](#recipe)

1.  Create a `<Prose />` component to provide a wrapping `<div>` with a `<slot />` for your rendered Markdown. Add the style class `prose` alongside any desired [Tailwind element modifiers](https://tailwindcss.com/docs/typography-plugin#element-modifiers) in the parent element.

    src/components/Prose.astro

    ```
    ------<divclass="prose dark:prose-invertprose-h1:font-bold prose-h1:text-xlprose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xlprose-headings:underline"><slot /></div>
    ```

    Tip

    The `@tailwindcss/typography` plugin uses [**element modifiers**](https://tailwindcss.com/docs/typography-plugin#element-modifiers) to style child components of a container with the `prose` class.

    These modifiers follow the following general syntax:

    ```
    prose-[element]:class-to-apply
    ```

    For example, `prose-h1:font-bold` gives all `<h1>` tags the `font-bold` Tailwind class.

2.  Query your collection entry on the page you want to render your Markdown. Pass the `<Content />` component from `await render(entry)` to `<Prose />` as a child to wrap your Markdown content in Tailwind styles.

    src/pages/index.astro

    ```
    ---import Prose from'../components/Prose.astro';import Layout from'../layouts/Layout.astro';import { getEntry, render } from'astro:content';const entry = await getEntry('collection', 'entry');const { Content } = await render(entry);---<Layout><Prose><Content /></Prose></Layout>
    ```



## Resources


[Section titled Resources](#resources)

-   [Tailwind Typography Documentation](https://tailwindcss.com/docs/typography-plugin)

Recipes


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 165. `en/reference/adapter-reference/.md`

```text
# Astro Adapter API



# Astro Adapter API


Astro is designed to make it easy to deploy to any cloud provider for on-demand rendering, also known as server-side rendering (SSR). This ability is provided by **adapters**, which are [integrations](/en/reference/integrations-reference/). See the [on-demand rendering guide](/en/guides/on-demand-rendering/) to learn how to use an existing adapter.


## What is an adapter?


[Section titled What is an adapter?](#what-is-an-adapter)

An adapter is a special kind of [integration](/en/reference/integrations-reference/) that provides an entrypoint for server rendering at request time. An adapter does two things:

-   Implements host-specific APIs for handling requests.
-   Configures the build according to host conventions.


## Building an Adapter


[Section titled Building an Adapter](#building-an-adapter)

An adapter is an [integration](/en/reference/integrations-reference/) and can do anything that an integration can do.

An adapter **must** call the `setAdapter` API in the `astro:config:done` hook like so:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',supportedAstroFeatures: {staticOutput: 'stable'}});},},};}
```

The object passed into `setAdapter` is defined as:

```
interface AstroAdapter {name:string;serverEntrypoint?:string;previewEntrypoint?:string;exports?:string[];args?:any;adapterFeatures?:AstroAdapterFeatures;supportedAstroFeatures:AstroAdapterFeatureMap;}exportinterface AstroAdapterFeatures {/*** Creates an edge function that will communicate with the Astro middleware.*/edgeMiddleware:boolean;/*** Determine the type of build output the adapter is intended for. Defaults to `server`;*/buildOutput?:'static'|'server';}exporttype AdapterSupportsKind ='unsupported'|'stable'|'experimental'|'deprecated'|'limited';exporttype AdapterSupportWithMessage = {support:Exclude<AdapterSupportsKind, 'stable'>;message:string;};exporttype AdapterSupport =AdapterSupportsKind|AdapterSupportWithMessage;exporttype AstroAdapterFeatureMap = {/*** The adapter is able to serve static pages*/staticOutput?:AdapterSupport;/*** The adapter is able to serve pages that are static or rendered via server*/hybridOutput?:AdapterSupport;/*** The adapter is able to serve pages rendered on demand*/serverOutput?:AdapterSupport;/*** The adapter is able to support i18n domains*/i18nDomains?:AdapterSupport;/*** The adapter is able to support `getSecret` exported from `astro:env/server`*/envGetSecret?:AdapterSupport;/*** The adapter supports the Sharp image service*/sharpImageService?:AdapterSupport;};
```

The properties are:

-   **name**: A unique name for your adapter, used for logging.
-   **serverEntrypoint**: The entrypoint for on-demand server rendering.
-   **exports**: An array of named exports when used in conjunction with `createExports` (explained below).
-   **adapterFeatures**: An object that enables specific features that must be supported by the adapter. These features will change the built output, and the adapter must implement the proper logic to handle the different output.
-   **supportedAstroFeatures**: A map of Astro built-in features. This allows Astro to determine which features an adapter is unable or unwilling to support so appropriate error messages can be provided.


### Server Entrypoint


[Section titled Server Entrypoint](#server-entrypoint)

Astro’s adapter API attempts to work with any type of host, and gives a flexible way to conform to the host APIs.


#### Exports


[Section titled Exports](#exports)

Some serverless hosts expect you to export a function, such as `handler`:

```
exportfunctionhandler(event, context) {// ...}
```

With the adapter API you achieve this by implementing `createExports` in your `serverEntrypoint`:

```
import { App } from'astro/app';exportfunctioncreateExports(manifest) {const app = newApp(manifest);const handler = (event, context) => {// ...};return { handler };}
```

And then in your integration, where you call `setAdapter`, provide this name in `exports`:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',exports: ['handler'],});},},};}
```


#### Start


[Section titled Start](#start)

Some hosts expect you to *start* the server yourselves, for example by listening to a port. For these types of hosts, the adapter API allows you to export a `start` function which will be called when the bundle script is run.

```
import { App } from'astro/app';exportfunctionstart(manifest) {const app = newApp(manifest);addEventListener('fetch',event=> {// ...});}
```


#### `astro/app`


[Section titled astro/app](#astroapp)

This module is used for rendering pages that have been prebuilt through `astro build`. Astro uses the standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects. Hosts that have a different API for request/response should convert to these types in their adapter.

```
import { App } from'astro/app';import http from'http';exportfunctionstart(manifest) {const app = newApp(manifest);addEventListener('fetch',event=> {event.respondWith(app.render(event.request));});}
```

The following methods are provided:


##### `app.render()`


[Section titled app.render()](#apprender)

**Type:** `(request: Request, options?: RenderOptions) => Promise<Response>`

This method calls the Astro page that matches the request, renders it, and returns a Promise to a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object. This also works for API routes that do not render pages.

```
const response = await app.render(request);
```


##### `RenderOptions`


[Section titled RenderOptions](#renderoptions)

**Type:** `{addCookieHeader?: boolean; clientAddress?: string; locals?: object; prerenderedErrorPageFetch?: (url: ErrorPagePath) => Promise<Response>; routeData?: RouteData;}`

The `app.render()` method accepts a mandatory `request` argument, and an optional `RenderOptions` object for [`addCookieHeader`](#addcookieheader), [`clientAddress`](#clientaddress), [`locals`](#locals), [`prerenderedErrorPageFetch`](#prerenderederrorpagefetch), and [`routeData`](#routedata).


###### `addCookieHeader`


[Section titled addCookieHeader](#addcookieheader)

**Type:** `boolean` **Default:** `false`

Whether or not to automatically add all cookies written by `Astro.cookie.set()` to the response headers.

When set to `true`, they will be added to the `Set-Cookie` header of the response as comma separated key-value pairs. You can use the standard `response.headers.getSetCookie()` API to read them individually. When set to `false`(default), the cookies will only be available from `App.getSetCookieFromResponse(response)`.

```
const response = await app.render(request, { addCookieHeader: true });
```


###### `clientAddress`


[Section titled clientAddress](#clientaddress)

**Type:** `string` **Default:** `request[Symbol.for("astro.clientAddress")]`

The client IP address that will be made available as [`Astro.clientAddress`](/en/reference/api-reference/#clientaddress) in pages, and as `ctx.clientAddress` in API routes and middleware.

The example below reads the `x-forwarded-for` header and passes it as `clientAddress`. This value becomes available to the user as `Astro.clientAddress`.

```
const clientAddress = request.headers.get("x-forwarded-for");const response = await app.render(request, { clientAddress });
```


###### `locals`


[Section titled locals](#locals)

**Type:** `object`

The [`context.locals` object](/en/reference/api-reference/#locals) used to store and access information during the lifecycle of a request.

The example below reads a header named `x-private-header`, attempts to parse it as an object and pass it to `locals`, which can then be passed to any [middleware function](/en/guides/middleware/).

```
const privateHeader = request.headers.get("x-private-header");let locals = {};try {if (privateHeader) {locals=JSON.parse(privateHeader);}} finally {const response = await app.render(request, { locals });}
```


###### `prerenderedErrorPageFetch`


[Section titled prerenderedErrorPageFetch](#prerenderederrorpagefetch)

**Type:** `(url: ErrorPagePath) => Promise<Response>` **Default:** `fetch`

**Added in:** `astro@5.6.0`

A function that allows you to provide custom implementations for fetching prerendered error pages.

This is used to override the default `fetch()` behavior, for example, when `fetch()` is unavailable or when you cannot call the server from itself.

The following example reads `500.html` and `404.html` from disk instead of performing an HTTP call:

```
returnapp.render(request, {prerenderedErrorPageFetch: async(url:string):Promise<Response> => {if (url.includes("/500")) {const content = await fs.promises.readFile("500.html", "utf-8");returnnewResponse(content, {status: 500,headers: { "Content-Type": "text/html" },});}const content = await fs.promises.readFile("404.html", "utf-8");returnnewResponse(content, {status: 404,headers: { "Content-Type": "text/html" },});});
```

If not provided, Astro will fallback to its default behavior for fetching error pages.


###### `routeData`


[Section titled routeData](#routedata)

**Type:** `RouteData` **Default:** `app.match(request)`

Provide a value for [`integrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference) if you already know the route to render. Doing so will bypass the internal call to [`app.match`](#appmatch) to determine the route to render.

```
const routeData = app.match(request);if (routeData) {returnapp.render(request, { routeData });} else {/* adapter-specific 404 response */returnnewResponse(..., { status: 404 });}
```


##### `app.match()`


[Section titled app.match()](#appmatch)

**Type:** `(request: Request) => RouteData | undefined`

This method is used to determine if a request is matched by the Astro app’s routing rules.

```
if(app.match(request)) {const response = await app.render(request);}
```

You can usually call `app.render(request)` without using `.match` because Astro handles 404s if you provide a `404.astro` file. Use `app.match(request)` if you want to handle 404s in a different way.


## Allow installation via `astro add`


[Section titled Allow installation via astro add](#allow-installation-via-astro-add)

[The `astro add` command](/en/reference/cli-reference/#astro-add) allows users to easily add integrations and adapters to their project. If you want *your* adapter to be installable with this tool, **add `astro-adapter` to the `keywords` field in your `package.json`**:

```
{"name": "example","keywords": ["astro-adapter"],}
```

Once you [publish your adapter to npm](https://docs.npmjs.com/cli/v8/commands/npm-publish), running `astro add example` will install your package with any peer dependencies specified in your `package.json`. We will also instruct users to update their project config manually.


## Astro features


[Section titled Astro features](#astro-features)

**Added in:** `astro@3.0.0`

Astro features are a way for an adapter to tell Astro whether they are able to support a feature, and also the adapter’s level of support.

When using these properties, Astro will:

-   run specific validation;
-   emit contextual to the logs;

These operations are run based on the features supported or not supported, their level of support, and the configuration that the user uses.

The following configuration tells Astro that this adapter has experimental support for the Sharp-powered built-in image service:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',supportedAstroFeatures: {sharpImageService: 'experimental'}});},},};}
```

If the Sharp image service is used, Astro will log a warning and error to the terminal based on your adapter’s support:

```
[@matthewp/my-adapter] The feature is experimental and subject to issues or changes.[@matthewp/my-adapter] The currently selected adapter `@matthewp/my-adapter` is not compatible with the service "Sharp". Your project will NOT be able to build.
```

A message can additionally be provided to give more context to the user:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',supportedAstroFeatures: {sharpImageService: {support: 'limited',message: 'This adapter has limited support for Sharp, certain features may not work as expected.'}}});},},};}
```


## Adapter features


[Section titled Adapter features](#adapter-features)

A set of features that changes the output of the emitted files. When an adapter opts in to these features, they will get additional information inside specific hooks.


### `edgeMiddleware`


[Section titled edgeMiddleware](#edgemiddleware)

**Type:** `boolean`

Defines whether any on-demand rendering middleware code will be bundled when built.

When enabled, this prevents middleware code from being bundled and imported by all pages during the build:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',adapterFeatures: {edgeMiddleware: true}});},},};}
```

Then, consume the hook [`astro:build:ssr`](/en/reference/integrations-reference/#astrobuildssr), which will give you a `middlewareEntryPoint`, an `URL` to the physical file on the file system.

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',adapterFeatures: {edgeMiddleware: true}});},'astro:build:ssr': ({ middlewareEntryPoint })=> {// remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the featureif (middlewareEntryPoint) {createEdgeMiddleware(middlewareEntryPoint)}}},};}functioncreateEdgeMiddleware(middlewareEntryPoint) {// emit a new physical file using your bundler}
```


### envGetSecret


[Section titled envGetSecret](#envgetsecret)

**Type:** `AdapterSupportsKind`

This is a feature to allow your adapter to retrieve secrets configured by users in `env.schema`.

Enable the feature by passing any valid `AdapterSupportsKind` value to the adapter:

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',adapterFeatures: {envGetSecret: 'stable'}});},},};}
```

The `astro/env/setup` module allows you to provide an implementation for `getSecret()`. In your server entrypoint, call `setGetEnv()` as soon as possible:

```
import { App } from'astro/app';import { setGetEnv } from"astro/env/setup"setGetEnv((key)=>process.env[key])exportfunctioncreateExports(manifest) {const app = newApp(manifest);const handler = (event, context) => {// ...};return { handler };}
```

If you support secrets, be sure to call `setGetEnv()` before `getSecret()` when your environment variables are tied to the request:

```
importtype { SSRManifest } from'astro';import { App } from'astro/app';import { setGetEnv } from'astro/env/setup';import { createGetEnv } from'../utils/env.js';type Env = {[key:string]:unknown;};exportfunctioncreateExports(manifest:SSRManifest) {const app = newApp(manifest);const fetch = async (request:Request, env:Env) => {setGetEnv(createGetEnv(env));const response = await app.render(request);return response;};return { default: { fetch } };}
```


### buildOutput


[Section titled buildOutput](#buildoutput)

**Type:** `'static' | 'server'`

**Added in:** `astro@5.0.0`

This property allows you to force a specific output shape for the build. This can be useful for adapters that only work with a specific output type, for instance, your adapter might expect a static website, but uses an adapter to create host-specific files. Defaults to `server` if not specified.

my-adapter.mjs

```
exportdefaultfunctioncreateIntegration() {return {name: '@matthewp/my-adapter',hooks: {'astro:config:done': ({ setAdapter })=> {setAdapter({name: '@matthewp/my-adapter',serverEntrypoint: '@matthewp/my-adapter/server.js',adapterFeatures: {buildOutput: 'static'}});},},};}
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 166. `en/reference/astro-syntax/.md`

```text
# Template expressions reference



# Template expressions reference


Astro component syntax is a superset of HTML. The syntax was designed to feel familiar to anyone with experience writing HTML or JSX, and adds support for including components and JavaScript expressions.


## JSX-like Expressions


[Section titled JSX-like Expressions](#jsx-like-expressions)

You can define local JavaScript variables inside of the frontmatter component script between the two code fences (`---`) of an Astro component. You can then inject these variables into the component’s HTML template using JSX-like expressions!

Dynamic vs reactive

Using this approach, you can include **dynamic** values that are calculated in the frontmatter. But once included, these values are not **reactive** and will never change. Astro components are templates that only run once, during the rendering step.

See below for more examples of [differences between Astro and JSX](#differences-between-astro-and-jsx).


### Variables


[Section titled Variables](#variables)

Local variables can be added into the HTML using the curly braces syntax:

src/components/Variables.astro

```
---const name = "Astro";---<div><h1>Hello {name}!</h1><!-- Outputs <h1>Hello Astro!</h1> --></div>
```


### Dynamic Attributes


[Section titled Dynamic Attributes](#dynamic-attributes)

Local variables can be used in curly braces to pass attribute values to both HTML elements and components:

src/components/DynamicAttributes.astro

```
---const name = "Astro";---<h1class={name}>Attribute expressions are supported</h1><MyComponenttemplateLiteralNameAttribute={`MyNameIs${name}`} />
```

Caution

HTML attributes will be converted to strings, so it is not possible to pass functions and objects to HTML elements. For example, you can’t assign an event handler to an HTML element in an Astro component:

dont-do-this.astro

```
---functionhandleClick() {console.log("button clicked!");}---<!-- ❌ This doesn't work! ❌ --><buttononClick={handleClick}>Nothing will happen when you click me!</button>
```

Instead, use a client-side script to add the event handler, like you would in vanilla JavaScript:

do-this-instead.astro

```
------<buttonid="button">Click Me</button><script>functionhandleClick() {console.log("button clicked!");}document.getElementById("button").addEventListener("click", handleClick);</script>
```


### Dynamic HTML


[Section titled Dynamic HTML](#dynamic-html)

Local variables can be used in JSX-like functions to produce dynamically-generated HTML elements:

src/components/DynamicHtml.astro

```
---const items = ["Dog", "Cat", "Platypus"];---<ul>{items.map((item)=> (<li>{item}</li>))}</ul>
```

Astro can conditionally display HTML using JSX logical operators and ternary expressions.

src/components/ConditionalHtml.astro

```
---const visible = true;---{visible&&<p>Show me!</p>}{visible?<p>Show me!</p>:<p>Else show me!</p>}
```


### Dynamic Tags


[Section titled Dynamic Tags](#dynamic-tags)

You can also use dynamic tags by assigning an HTML tag name to a variable or with a component import reassignment:

src/components/DynamicTags.astro

```
---import MyComponent from"./MyComponent.astro";const Element = 'div'const Component = MyComponent;---<Element>Hello!</Element><!-- renders as <div>Hello!</div> --><Component /><!-- renders as <MyComponent /> -->
```

When using dynamic tags:

-   **Variable names must be capitalized.** For example, use `Element`, not `element`. Otherwise, Astro will try to render your variable name as a literal HTML tag.

-   **Hydration directives are not supported.** When using [`client:*` hydration directives](/en/guides/framework-components/#hydrating-interactive-components), Astro needs to know which components to bundle for production, and the dynamic tag pattern prevents this from working.

-   **The [define:vars directive](/en/reference/directives-reference/#definevars) is not supported.** If you cannot wrap the children with an extra element (e.g `<div>`), then you can manually add a ``style={`--myVar:${value}`}`` to your Element.



### Fragments


[Section titled Fragments](#fragments)

Astro supports `<> </>` notation and also provides a built-in `<Fragment />` component. This component can be useful to avoid wrapper elements when adding [`set:*` directives](/en/reference/directives-reference/#sethtml) to inject an HTML string.

The following example renders paragraph text using the `<Fragment />` component:

src/components/SetHtml.astro

```
---const htmlString = '<p>Raw HTML content</p>';---<Fragmentset:html={htmlString} />
```


### Differences between Astro and JSX


[Section titled Differences between Astro and JSX](#differences-between-astro-and-jsx)

Astro component syntax is a superset of HTML. It was designed to feel familiar to anyone with HTML or JSX experience, but there are a couple of key differences between `.astro` files and JSX.


#### Attributes


[Section titled Attributes](#attributes)

In Astro, you use the standard `kebab-case` format for all HTML attributes instead of the `camelCase` used in JSX. This even works for `class`, which is not supported by React.

example.astro

```
<divclassName="box"dataValue="3" /><divclass="box"data-value="3" />
```


#### Multiple Elements


[Section titled Multiple Elements](#multiple-elements)

An Astro component template can render multiple elements with no need to wrap everything in a single `<div>` or `<>`, unlike JavaScript or JSX.

src/components/RootElements.astro

```
---// Template with multiple elements---<p>No need to wrap elements in a single containing element.</p><p>Astro supports multiple root elements in a template.</p>
```


#### Comments


[Section titled Comments](#comments)

In Astro, you can use standard HTML comments or JavaScript-style comments.

example.astro

```
------<!-- HTML comment syntax is valid in .astro files -->{/* JS comment syntax is also valid */}
```

Caution

HTML-style comments will be included in browser DOM, while JS ones will be skipped. To leave TODO messages or other development-only explanations, you may wish to use JavaScript-style comments instead.


## Component utilities


[Section titled Component utilities](#component-utilities)


### `Astro.slots`


[Section titled Astro.slots](#astroslots)

`Astro.slots` contains utility functions for modifying an Astro component’s slotted children.


#### `Astro.slots.has()`


[Section titled Astro.slots.has()](#astroslotshas)

**Type:** `(slotName: string) => boolean`

You can check whether content for a specific slot name exists with `Astro.slots.has()`. This can be useful when you want to wrap slot contents but only want to render the wrapper elements when the slot is being used.

src/pages/index.astro

```
------<slot />{Astro.slots.has('more') && (<aside><h2>More</h2><slotname="more" /></aside>)}
```


#### `Astro.slots.render()`


[Section titled Astro.slots.render()](#astroslotsrender)

**Type:** `(slotName: string, args?: any[]) => Promise<string>`

You can asynchronously render the contents of a slot to a string of HTML using `Astro.slots.render()`.

```
---const html = await Astro.slots.render('default');---<Fragmentset:html={html} />
```

Note

This is for advanced use cases! In most circumstances, it is simpler to render slot contents with [the `<slot />` element](/en/basics/astro-components/#slots).

`Astro.slots.render()` optionally accepts a second argument: an array of parameters that will be forwarded to any function children. This can be useful for custom utility components.

For example, this `<Shout />` component converts its `message` prop to uppercase and passes it to the default slot:

src/components/Shout.astro

```
---const message = Astro.props.message.toUpperCase();let html = '';if (Astro.slots.has('default')) {html =await Astro.slots.render('default', [message]);}---<Fragmentset:html={html} />
```

A callback function passed as `<Shout />`’s child will receive the all-caps `message` parameter:

src/pages/index.astro

```
---import Shout from"../components/Shout.astro";---<Shoutmessage="slots!">{(message)=><div>{message}</div>}</Shout><!-- renders as <div>SLOTS!</div> -->
```

Callback functions can be passed to named slots inside a wrapping HTML element tag with a `slot` attribute. This element is only used to transfer the callback to a named slot and will not be rendered onto the page.

```
<Shoutmessage="slots!"><fragmentslot="message">{(message)=><div>{message}</div>}</fragment></Shout>
```

Use a standard HTML element for the wrapping tag or any lowercase tag (e.g. `<fragment>` instead of `<Fragment />`) that will not be interpreted as a component. Do not use the HTML `<slot>` element as this will be interpreted as an Astro slot.


### `Astro.self`


[Section titled Astro.self](#astroself)

`Astro.self` allows Astro components to be recursively called. This behavior lets you render an Astro component from within itself by using `<Astro.self>` in the component template. This can help iterate over large data stores and nested data structures.

NestedList.astro

```
---const { items } = Astro.props;---<ulclass="nested-list">{items.map((item)=> (<li><!-- If there is a nested data-structure we render `<Astro.self>` --><!-- and can pass props through with the recursive call -->{Array.isArray(item) ? (<Astro.selfitems={item} />) : (item)}</li>))}</ul>
```

This component could then be used like this:

```
---import NestedList from'./NestedList.astro';---<NestedListitems={['A', ['B', 'C'], 'D']} />
```

And would render HTML like this:

```
<ulclass="nested-list"><li>A</li><li><ulclass="nested-list"><li>B</li><li>C</li></ul></li><li>D</li></ul>
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 167. `en/reference/cli-reference/.md`

```text
# CLI Commands



# CLI Commands


You can use the Command-Line Interface (CLI) provided by Astro to develop, build, and preview your project from a terminal window.


### `astro` commands


[Section titled astro commands](#astro-commands)

Use the CLI by running one of the **commands** documented on this page with your preferred package manager, optionally followed by any **flags**. Flags customize the behavior of a command.

One of the commands you’ll use most often is `astro dev`. This command starts the development server and gives you a live, updating preview of your site in a browser as you work:

-   [npm](#tab-panel-1861)
-   [pnpm](#tab-panel-1862)
-   [Yarn](#tab-panel-1863)

Terminal window

```

# start the development servernpxastrodev

```

Terminal window

```

# start the development serverpnpmastrodev

```

Terminal window

```

# start the development serveryarnastrodev

```

You can type `astro --help` in your terminal to display a list of all available commands:

-   [npm](#tab-panel-1864)
-   [pnpm](#tab-panel-1865)
-   [Yarn](#tab-panel-1866)

Terminal window

```
npxastro--help
```

Terminal window

```
pnpmastro--help
```

Terminal window

```
yarnastro--help
```

The following message will display in your terminal:

Terminal window

```
astro [command] [...flags]CommandsaddAddanintegration.buildBuildyourprojectandwriteittodisk.checkCheckyourprojectforerrors.create-keyCreateacryptographykeydevStartthedevelopmentserver.docsOpendocumentationinyourwebbrowser.infoListinfoaboutyourcurrentAstrosetup.previewPreviewyourbuildlocally.syncGenerateTypeScripttypesforallAstromodules.preferencesConfigureuserpreferences.telemetryConfiguretelemetrysettings.GlobalFlags--config<path>Specifyyourconfigfile.--root<path>Specifyyourprojectrootfolder.--site<url>Specifyyourprojectsite.--base<pathname>Specifyyourprojectbase.--verboseEnableverboselogging.--silentDisablealllogging.--versionShowtheversionnumberandexit.--helpShowthishelpmessage.
```

You can add the `--help` flag after any command to get a list of all the flags for that command.

-   [npm](#tab-panel-1867)
-   [pnpm](#tab-panel-1868)
-   [Yarn](#tab-panel-1869)

Terminal window

```

# get a list of all flags for the `dev` commandnpmrundev----help

```

Terminal window

```

# get a list of all flags for the `dev` commandpnpmdev--help

```

Terminal window

```

# get a list of all flags for the `dev` commandyarndev--help

```

The following message will display in your terminal:

Terminal window

```
astrodev [...flags]Flags--portSpecifywhichporttorunon.Defaultsto4321.--hostListenonalladdresses,includingLANandpublicaddresses.--host<custom-address>ExposeonanetworkIPaddressat<custom-address>--openAutomaticallyopentheappinthebrowseronserverstart--forceClearthecontentlayercache,forcingafullrebuild.--help (-h)  See all available flags.
```

Note

The extra `--` before any flag is necessary for `npm` to pass your flags to the `astro` command.


### `package.json` scripts


[Section titled package.json scripts](#packagejson-scripts)

You can also use scripts in `package.json` for shorter versions of these commands. Using a script allows you to use the same commands that you may be familiar with from other projects, such as `npm run build`.

The following scripts for the most common `astro` commands (`astro dev`, `astro build`, and `astro preview`) are added for you automatically when you create a project using [the `create astro` wizard](/en/install-and-setup/).

When you follow the instructions to [install Astro manually](/en/install-and-setup/#manual-setup), you are instructed to add these scripts yourself. You can also add more scripts to this list manually for any commands you use frequently.

package.json

```
{"scripts": {"dev": "astro dev","build": "astro build","preview": "astro preview"}}
```

You will often use these `astro` commands, or the scripts that run them, without any flags. Add flags to the command when you want to customize the command’s behavior. For example, you may wish to start the development server on a different port, or build your site with verbose logs for debugging.

-   [npm](#tab-panel-1870)
-   [pnpm](#tab-panel-1871)
-   [Yarn](#tab-panel-1872)

Terminal window

```

# run the dev server on port 8080 using the `dev` script in `package.json`npmrundev----port8080# build your site with verbose logs using the `build` script in `package.json`npmrunbuild----verbose

```

Terminal window

```

# run the dev server on port 8080 using the `dev` script in `package.json`pnpmdev--port8080# build your site with verbose logs using the `build` script in `package.json`pnpmbuild--verbose

```

Terminal window

```

# run the dev server on port 8080 using the `dev` script in `package.json`yarndev--port8080# build your site with verbose logs using the `build` script in `package.json`yarnbuild--verbose

```


## `astro dev`


[Section titled astro dev](#astro-dev)

Runs Astro’s development server. This is a local HTTP server that doesn’t bundle assets. It uses Hot Module Replacement (HMR) to update your browser as you save changes in your editor.

The following hotkeys can be used in the terminal where the Astro development server is running:

-   `s + enter` to sync the content layer data (content and types).
-   `o + enter` to open your Astro site in the browser.
-   `q + enter` to quit the development server.


## `astro build`


[Section titled astro build](#astro-build)

Builds your site for deployment. By default, this will generate static files and place them in a `dist/` directory. If any routes are [rendered on demand](/en/guides/on-demand-rendering/), this will generate the necessary server files to serve your site.


### Flags


[Section titled Flags](#flags)

The command accepts [common flags](#common-flags) and the following additional flags:


#### `--devOutput`


[Section titled --devOutput](#--devoutput)

**Added in:** `astro@5.0.0`

Outputs a development-based build similar to code transformed in `astro dev`. This can be useful to test build-only issues with additional debugging information included.


## `astro preview`


[Section titled astro preview](#astro-preview)

Starts a local server to serve the contents of your static directory (`dist/` by default) created by running `astro build`.

This command allows you to preview your site locally [after building](#astro-build) to catch any errors in your build output before deploying it. It is not designed to be run in production. For help with production hosting, check out our guide on [Deploying an Astro Website](/en/guides/deploy/).

Since Astro 1.5.0, the [Node adapter](/en/guides/integrations-guide/node/) supports `astro preview` for builds generated with on-demand rendering.

Can be combined with the [common flags](#common-flags) documented below.


## `astro check`


[Section titled astro check](#astro-check)

Runs diagnostics (such as type-checking within `.astro` files) against your project and reports errors to the console. If any errors are found the process will exit with a code of **1**.

This command is intended to be used in CI workflows.


### Flags


Use these flags to customize the behavior of the command.


#### `--watch`


[Section titled --watch](#--watch)

The command will watch for any changes in your project, and will report any errors.


#### `--root <path-to-dir>`


[Section titled --root &lt;path-to-dir&gt;](#--root-path-to-dir)

Specifies a different root directory to check. Uses the current working directory by default.


#### `--tsconfig <path-to-file>`


[Section titled --tsconfig &lt;path-to-file&gt;](#--tsconfig-path-to-file)

Specifies a `tsconfig.json` file to use manually. If not provided, Astro will attempt to find a config, or infer the project’s config automatically.


#### `--minimumFailingSeverity <error|warning|hint>`


[Section titled --minimumFailingSeverity &lt;error|warning|hint&gt;](#--minimumfailingseverity-errorwarninghint)

Specifies the minimum severity needed to exit with an error code. Defaults to `error`.

For example, running `astro check --minimumFailingSeverity warning` will cause the command to exit with an error if any warnings are detected.


#### `--minimumSeverity <error|warning|hint>`


[Section titled --minimumSeverity &lt;error|warning|hint&gt;](#--minimumseverity-errorwarninghint)

Specifies the minimum severity to output. Defaults to `hint`.

For example, running `astro check --minimumSeverity warning` will show errors and warning, but not hints.


#### `--preserveWatchOutput`


[Section titled --preserveWatchOutput](#--preservewatchoutput)

Specifies not to clear the output between checks when in watch mode.


#### `--noSync`


[Section titled --noSync](#--nosync)

Specifies not to run `astro sync` before checking the project.

Read more about [type checking in Astro](/en/guides/typescript/#type-checking).


## `astro sync`


[Section titled astro sync](#astro-sync)

**Added in:** `astro@2.0.0`

Tip

Running `astro dev`, `astro build` or `astro check` will run the `sync` command as well.

Generates TypeScript types for all Astro modules. This sets up a [`.astro/types.d.ts` file](/en/guides/typescript/#setup) for type inferencing, and defines modules for features that rely on generated types:

-   The `astro:content` module for the [Content Collections API](/en/guides/content-collections/).
-   The `astro:db` module for [Astro DB](/en/guides/astro-db/).
-   The `astro:env` module for [Astro Env](/en/guides/environment-variables/).
-   The `astro:actions` module for [Astro Actions](/en/guides/actions/)


## `astro add`


[Section titled astro add](#astro-add)

Adds an integration to your configuration. Read more in [the integrations guide](/en/guides/integrations-guide/#automatic-integration-setup).


## `astro docs`


[Section titled astro docs](#astro-docs)

Launches the Astro Docs website directly from the terminal.


## `astro info`


[Section titled astro info](#astro-info)

Reports useful information about your current Astro environment. Useful for providing information when opening an issue.

Terminal window

```
astroinfo
```

Example output:

```
Astro                    v3.0.12Node                     v20.5.1System                   macOS (arm64)Package Manager          pnpmOutput                   serverAdapter                  @astrojs/vercel/serverlessIntegrations             none
```


## `astro preferences`


[Section titled astro preferences](#astro-preferences)

Manage user preferences with the `astro preferences` command. User preferences are specific to individual Astro users, unlike the `astro.config.mjs` file which changes behavior for everyone working on a project.

User preferences are scoped to the current project by default, stored in a local `.astro/settings.json` file.

Using the `--global` flag, user preferences can also be applied to every Astro project on the current machine. Global user preferences are stored in an operating system-specific location.


### Available preferences


-   `devToolbar` — Enable or disable the development toolbar in the browser. (Default: `true`)
-   `checkUpdates` — Enable or disable automatic update checks for the Astro CLI. (Default: `true`)

The `list` command prints the current settings of all configurable user preferences. It also supports a machine-readable `--json` output.

Terminal window

```
astropreferenceslist
```

Example terminal output:

Preference

Value

devToolbar.enabled

true

checkUpdates.enabled

true

You can `enable`, `disable`, or `reset` preferences to their default.

For example, to disable the devToolbar in a specific Astro project:

Terminal window

```
astropreferencesdisabledevToolbar
```

To disable the devToolbar in all Astro projects on the current machine:

Terminal window

```
astropreferencesdisable--globaldevToolbar
```

The devToolbar can later be enabled with:

Terminal window

```
astropreferencesenabledevToolbar
```

The `reset` command resets a preference to its default value:

Terminal window

```
astropreferencesresetdevToolbar
```


## `astro telemetry`


[Section titled astro telemetry](#astro-telemetry)

Sets telemetry configuration for the current CLI user. Telemetry is anonymous data that provides the Astro team insights into which Astro features are most often used. For more information see [Astro’s telemetry page](https://astro.build/telemetry/).

Telemetry can be disabled with this CLI command:

Terminal window

```
astrotelemetrydisable
```

Telemetry can later be re-enabled with:

Terminal window

```
astrotelemetryenable
```

The `reset` command resets the telemetry data:

Terminal window

```
astrotelemetryreset
```

Want to disable telemetry in CI environments?

Add the `astro telemetry disable` command to your CI scripts or set the `ASTRO_TELEMETRY_DISABLED` environment variable.


## Common flags


[Section titled Common flags](#common-flags)


### `--root <path>`


[Section titled --root &lt;path&gt;](#--root-path)

Specifies the path to the project root. If not specified, the current working directory is assumed to be the root.

The root is used for finding the Astro configuration file.

Terminal window

```
astro--rootmyRootFolder/myProjectFolderdev
```


### `--config <path>`


[Section titled --config &lt;path&gt;](#--config-path)

Specifies the path to the config file relative to the project root. Defaults to `astro.config.mjs`. Use this if you use a different name for your configuration file or have your config file in another folder.

Terminal window

```
astro--configconfig/astro.config.mjsdev
```


### `--force <string>`


[Section titled --force &lt;string&gt;](#--force-string)

**Added in:** `astro@5.0.0`

Clear the [content layer cache](/en/guides/content-collections/#defining-the-collection-loader), forcing a full rebuild.


### `--mode <string>`


[Section titled --mode &lt;string&gt;](#--mode-string)

**Added in:** `astro@5.0.0`

Configures the [`mode`](/en/reference/programmatic-reference/#mode) inline config for your project.


### `--outDir <path>`


[Section titled --outDir &lt;path&gt;](#--outdir-path)

**Added in:** `astro@3.3.0`

Configures the [`outDir`](/en/reference/configuration-reference/#outdir) for your project. Passing this flag will override the `outDir` value in your `astro.config.mjs` file, if one exists.


### `--site <url>`


[Section titled --site &lt;url&gt;](#--site-url)

Configures the [`site`](/en/reference/configuration-reference/#site) for your project. Passing this flag will override the `site` value in your `astro.config.mjs` file, if one exists.


### `--base <pathname>`


[Section titled --base &lt;pathname&gt;](#--base-pathname)

**Added in:** `astro@1.4.1`

Configures the [`base`](/en/reference/configuration-reference/#base) for your project. Passing this flag will override the `base` value in your `astro.config.mjs` file, if one exists.


### `--port <number>`


[Section titled --port &lt;number&gt;](#--port-number)

Specifies which port to run the dev server and preview server on. Defaults to `4321`.


### `--host [optional host address]`


[Section titled --host \[optional host address\]](#--host-optional-host-address)

Sets which network IP addresses the dev server and preview server should listen on (i.e. non-localhost IPs). This can be useful for testing your project on local devices like a mobile phone during development.

-   `--host` — listen on all addresses, including LAN and public addresses
-   `--host <custom-address>` — expose on a network IP address at `<custom-address>`

Caution

Do not use the `--host` flag to expose the dev server and preview server in a production environment. The servers are designed for local use while developing your site only.


### `--allowed-hosts`


[Section titled --allowed-hosts](#--allowed-hosts)

**Added in:** `astro@5.4.0`

Specifies the hostnames that Astro is allowed to respond to in `dev` or `preview` modes. Can be passed a comma-separated list of hostnames or `true` to allow any hostname.

Refer to [Vite’s `allowedHosts` feature](https://vite.dev/config/server-options.html#server-allowedhosts) for more information, including security implications of allowing hostnames.


### `--verbose`


[Section titled --verbose](#--verbose)

Enables verbose logging, which is helpful when debugging an issue.


### `--silent`


[Section titled --silent](#--silent)

Enables silent logging, which will run the server without any console output.


### `--open`


[Section titled --open](#--open)

Automatically opens the app in the browser on server start. Can be passed a full URL string (e.g. `--open http://example.com`) or a pathname (e.g. `--open /about`) to specify the URL to open.


## Global flags


[Section titled Global flags](#global-flags)

Use these flags to get information about the `astro` CLI.


### `--version`


[Section titled --version](#--version)

Prints the Astro version number and exits.


### `--help`


[Section titled --help](#--help)

Prints the help message and exits.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 168. `en/reference/configuration-reference/.md`

```text
# Configuration Reference



# Configuration Reference


The following reference covers all supported configuration options in Astro. To learn more about configuring Astro, read our guide on [Configuring Astro](/en/guides/configuring-astro/).

astro.config.mjs

```
import { defineConfig } from'astro/config'exportdefaultdefineConfig({// your configuration options here...})
```


## Top-Level Options


[Section titled Top-Level Options](#top-level-options)


### site


[Section titled site](#site)

**Type:** `string`

Your final, deployed URL. Astro uses this full URL to generate your sitemap and canonical URLs in your final build. It is strongly recommended that you set this configuration to get the most out of Astro.

```
{site: 'https://www.my-site.dev'}
```


### base


[Section titled base](#base)

**Type:** `string`

The base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.

In the example below, `astro dev` will start your server at `/docs`.

```
{base: '/docs'}
```

When using this option, all of your static asset imports and URLs should add the base as a prefix. You can access this value via `import.meta.env.BASE_URL`.

The value of `import.meta.env.BASE_URL` will be determined by your `trailingSlash` config, no matter what value you have set for `base`.

A trailing slash is always included if `trailingSlash: "always"` is set. If `trailingSlash: "never"` is set, `BASE_URL` will not include a trailing slash, even if `base` includes one.

Additionally, Astro will internally manipulate the configured value of `config.base` before making it available to integrations. The value of `config.base` as read by integrations will also be determined by your `trailingSlash` configuration in the same way.

In the example below, the values of `import.meta.env.BASE_URL` and `config.base` when processed will both be `/docs`:

```
{base: '/docs/',trailingSlash: "never"}
```

In the example below, the values of `import.meta.env.BASE_URL` and `config.base` when processed will both be `/docs/`:

```
{base: '/docs',trailingSlash: "always"}
```


### trailingSlash


[Section titled trailingSlash](#trailingslash)

**Type:** `'always' | 'never' | 'ignore'` **Default:** `'ignore'`

Set the route matching behavior for trailing slashes in the dev server and on-demand rendered pages. Choose from the following options:

-   `'ignore'` - Match URLs regardless of whether a trailing ”/” exists. Requests for “/about” and “/about/” will both match the same route.
-   `'always'` - Only match URLs that include a trailing slash (e.g: “/about/”). In production, requests for on-demand rendered URLs without a trailing slash will be redirected to the correct URL for your convenience. However, in development, they will display a warning page reminding you that you have `always` configured.
-   `'never'` - Only match URLs that do not include a trailing slash (e.g: “/about”). In production, requests for on-demand rendered URLs with a trailing slash will be redirected to the correct URL for your convenience. However, in development, they will display a warning page reminding you that you have `never` configured.

When redirects occur in production for GET requests, the redirect will be a 301 (permanent) redirect. For all other request methods, it will be a 308 (permanent, and preserve the request method) redirect.

Trailing slashes on prerendered pages are handled by the hosting platform, and may not respect your chosen configuration. See your hosting platform’s documentation for more information. You cannot use Astro [redirects](#redirects) for this use case at this point.

```
{// Example: Require a trailing slash during developmenttrailingSlash: 'always'}
```

**See Also:**

-   build.format


### redirects


[Section titled redirects](#redirects)

**Type:** `Record<string, RedirectConfig>` **Default:** `{}`

**Added in:** `astro@2.9.0`

Specify a mapping of redirects where the key is the route to match and the value is the path to redirect to.

You can redirect both static and dynamic routes, but only to the same kind of route. For example, you cannot have a `'/article': '/blog/[...slug]'` redirect.

```
exportdefaultdefineConfig({redirects: {'/old': '/new','/blog/[...slug]': '/articles/[...slug]','/about': 'https://example.com/about','/news': {status: 302,destination: 'https://example.com/news'},// '/product1/', '/product1' // Note, this is not supported}})
```

For statically-generated sites with no adapter installed, this will produce a client redirect using a [`<meta http-equiv="refresh">` tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv) and does not support status codes.

When using SSR or with a static adapter in `output: static` mode, status codes are supported. Astro will serve redirected GET requests with a status of `301` and use a status of `308` for any other request method.

You can customize the [redirection status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages) using an object in the redirect config:

```
exportdefaultdefineConfig({redirects: {'/other': {status: 302,destination: '/place',},}})
```


### output


[Section titled output](#output)

**Type:** `'static' | 'server'` **Default:** `'static'`

Specifies the output target for builds.

-   `'static'` - Prerender all your pages by default, outputting a completely static site if none of your pages opt out of prerendering.
-   `'server'` - Use server-side rendering (SSR) for all pages by default, always outputting a server-rendered site.

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({output: 'static'})
```

**See Also:**

-   adapter


### adapter


[Section titled adapter](#adapter)

**Type:** `AstroIntegration`

Deploy to your favorite server, serverless, or edge host with build adapters. Import one of our first-party adapters ([Cloudflare](/en/guides/integrations-guide/cloudflare/), [Netlify](/en/guides/integrations-guide/netlify/), [Node.js](/en/guides/integrations-guide/node/), [Vercel](/en/guides/integrations-guide/vercel/)) or explore [community adapters](https://astro.build/integrations/2/?search=&categories%5B%5D=adapters) to enable on-demand rendering in your Astro project.

See our [on-demand rendering guide](/en/guides/on-demand-rendering/) for more on Astro’s server rendering options.

```
import netlify from'@astrojs/netlify';{// Example: Build for Netlify serverless deploymentadapter: netlify(),}
```

**See Also:**

-   output


### integrations


[Section titled integrations](#integrations)

**Type:** `AstroIntegration[]`

Extend Astro with custom integrations. Integrations are your one-stop-shop for adding framework support (like Solid.js), new features (like sitemaps), and new libraries (like Partytown).

Read our [Integrations Guide](/en/guides/integrations-guide/) for help getting started with Astro Integrations.

```
import react from'@astrojs/react';import mdx from'@astrojs/mdx';{// Example: Add React + MDX support to Astrointegrations: [react(), mdx()]}
```


### root


[Section titled root](#root)

**Type:** `string` **CLI:** `--root` **Default:** `"."` (current working directory)

You should only provide this option if you run the `astro` CLI commands in a directory other than the project root directory. Usually, this option is provided via the CLI instead of the Astro config file, since Astro needs to know your project root before it can locate your config file.

If you provide a relative path (ex: `--root: './my-project'`) Astro will resolve it against your current working directory.


#### Examples


[Section titled Examples](#examples)

```
{root: './my-project-directory'}
```

Terminal window

```
$astrobuild--root./my-project-directory
```


### srcDir


[Section titled srcDir](#srcdir)

**Type:** `string` **Default:** `"./src"`

Set the directory that Astro will read your site from.

The value can be either an absolute file system path or a path relative to the project root.

```
{srcDir: './www'}
```


### publicDir


[Section titled publicDir](#publicdir)

**Type:** `string` **Default:** `"./public"`

Set the directory for your static assets. Files in this directory are served at `/` during dev and copied to your build directory during build. These files are always served or copied as-is, without transform or bundling.

The value can be either an absolute file system path or a path relative to the project root.

```
{publicDir: './my-custom-publicDir-directory'}
```


### outDir


[Section titled outDir](#outdir)

**Type:** `string` **Default:** `"./dist"`

Set the directory that `astro build` writes your final build to.

The value can be either an absolute file system path or a path relative to the project root.

```
{outDir: './my-custom-build-directory'}
```

**See Also:**

-   build.server


### cacheDir


[Section titled cacheDir](#cachedir)

**Type:** `string` **Default:** `"./node_modules/.astro"`

Set the directory for caching build artifacts. Files in this directory will be used in subsequent builds to speed up the build time.

The value can be either an absolute file system path or a path relative to the project root.

```
{cacheDir: './my-custom-cache-directory'}
```


### compressHTML


[Section titled compressHTML](#compresshtml)

**Type:** `boolean` **Default:** `true`

This is an option to minify your HTML output and reduce the size of your HTML files.

By default, Astro removes whitespace from your HTML, including line breaks, from `.astro` components in a lossless manner. Some whitespace may be kept as needed to preserve the visual rendering of your HTML. This occurs both in development mode and in the final build.

To disable HTML compression, set `compressHTML` to false.

```
{compressHTML: false}
```


### scopedStyleStrategy


[Section titled scopedStyleStrategy](#scopedstylestrategy)

**Type:** `'where' | 'class' | 'attribute'` **Default:** `'attribute'`

**Added in:** `astro@2.4`

Specify the strategy used for scoping styles within Astro components. Choose from:

-   `'where'` - Use `:where` selectors, causing no specificity increase.
-   `'class'` - Use class-based selectors, causing a +1 specificity increase.
-   `'attribute'` - Use `data-` attributes, causing a +1 specificity increase.

Using `'class'` is helpful when you want to ensure that element selectors within an Astro component override global style defaults (e.g. from a global stylesheet). Using `'where'` gives you more control over specificity, but requires that you use higher-specificity selectors, layers, and other tools to control which selectors are applied. Using `'attribute'` is useful when you are manipulating the `class` attribute of elements and need to avoid conflicts between your own styling logic and Astro’s application of styles.


### security


[Section titled security](#security)

**Type:** `Record<"checkOrigin", boolean> | undefined` **Default:** `{checkOrigin: true}`

**Added in:** `astro@4.9.0`

Enables security measures for an Astro website.

These features only exist for pages rendered on demand (SSR) using `server` mode or pages that opt out of prerendering in `static` mode.

By default, Astro will automatically check that the “origin” header matches the URL sent by each request in on-demand rendered pages. You can disable this behavior by setting `checkOrigin` to `false`:

astro.config.mjs

```
exportdefaultdefineConfig({output: "server",security: {checkOrigin: false}})
```


#### security.checkOrigin


[Section titled security.checkOrigin](#securitycheckorigin)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@4.9.0`

Performs a check that the “origin” header, automatically passed by all modern browsers, matches the URL sent by each `Request`. This is used to provide Cross-Site Request Forgery (CSRF) protection.

The “origin” check is executed only for pages rendered on demand, and only for the requests `POST`, `PATCH`, `DELETE` and `PUT` with one of the following `content-type` headers: `'application/x-www-form-urlencoded'`, `'multipart/form-data'`, `'text/plain'`.

If the “origin” header doesn’t match the `pathname` of the request, Astro will return a 403 status code and will not render the page.


### vite


[Section titled vite](#vite)

**Type:** `ViteUserConfig`

Pass additional configuration options to Vite. Useful when Astro doesn’t support some advanced configuration that you may need.

View the full `vite` configuration object documentation on [vite.dev](https://vite.dev/config/).


#### Examples


[Section titled Examples](#examples-1)

```
{vite: {ssr: {// Example: Force a broken package to skip SSR processing, if neededexternal: ['broken-npm-package'],}}}
```

```
{vite: {// Example: Add custom vite plugins directly to your Astro projectplugins: [myPlugin()],}}
```


## Build Options


[Section titled Build Options](#build-options)


### build.format


[Section titled build.format](#buildformat)

**Type:** `('file' | 'directory' | 'preserve')` **Default:** `'directory'`

Control the output file format of each page. This value may be set by an adapter for you.

-   `'file'`: Astro will generate an HTML file named for each page route. (e.g. `src/pages/about.astro` and `src/pages/about/index.astro` both build the file `/about.html`)
-   `'directory'`: Astro will generate a directory with a nested `index.html` file for each page. (e.g. `src/pages/about.astro` and `src/pages/about/index.astro` both build the file `/about/index.html`)
-   `'preserve'`: Astro will generate HTML files exactly as they appear in your source folder. (e.g. `src/pages/about.astro` builds `/about.html` and `src/pages/about/index.astro` builds the file `/about/index.html`)

```
{build: {// Example: Generate `page.html` instead of `page/index.html` during build.format: 'file'}}
```


#### Effect on Astro.url


[Section titled Effect on Astro.url](#effect-on-astrourl)

Setting `build.format` controls what `Astro.url` is set to during the build. When it is:

-   `directory` - The `Astro.url.pathname` will include a trailing slash to mimic folder behavior. (e.g. `/foo/`)
-   `file` - The `Astro.url.pathname` will include `.html`. (e.g. `/foo.html`)

This means that when you create relative URLs using `new URL('./relative', Astro.url)`, you will get consistent behavior between dev and build.

To prevent inconsistencies with trailing slash behaviour in dev, you can restrict the [`trailingSlash` option](#trailingslash) to `'always'` or `'never'` depending on your build format:

-   `directory` - Set `trailingSlash: 'always'`
-   `file` - Set `trailingSlash: 'never'`


### build.client


[Section titled build.client](#buildclient)

**Type:** `string` **Default:** `'./client'`

Controls the output directory of your client-side CSS and JavaScript when building a website with server-rendered pages. `outDir` controls where the code is built to.

This value is relative to the `outDir`.

```
{output: 'server',build: {client: './client'}}
```


### build.server


[Section titled build.server](#buildserver)

**Type:** `string` **Default:** `'./server'`

Controls the output directory of server JavaScript when building to SSR.

This value is relative to the `outDir`.

```
{build: {server: './server'}}
```


### build.assets


[Section titled build.assets](#buildassets)

**Type:** `string` **Default:** `'_astro'`

**Added in:** `astro@2.0.0`

Specifies the directory in the build output where Astro-generated assets (bundled JS and CSS for example) should live.

```
{build: {assets: '_custom'}}
```

**See Also:**

-   outDir


### build.assetsPrefix


[Section titled build.assetsPrefix](#buildassetsprefix)

**Type:** `string | Record<string, string>` **Default:** `undefined`

**Added in:** `astro@2.2.0`

Specifies the prefix for Astro-generated asset links. This can be used if assets are served from a different domain than the current site.

This requires uploading the assets in your local `./dist/_astro` folder to a corresponding `/_astro/` folder on the remote domain. To rename the `_astro` path, specify a new directory in `build.assets`.

To fetch all assets uploaded to the same domain (e.g. `https://cdn.example.com/_astro/...`), set `assetsPrefix` to the root domain as a string (regardless of your `base` configuration):

```
{build: {assetsPrefix: 'https://cdn.example.com'}}
```

**Added in:** `astro@4.5.0`

You can also pass an object to `assetsPrefix` to specify a different domain for each file type. In this case, a `fallback` property is required and will be used by default for any other files.

```
{build: {assetsPrefix: {'js': 'https://js.cdn.example.com','mjs': 'https://js.cdn.example.com','css': 'https://css.cdn.example.com','fallback': 'https://cdn.example.com'}}}
```


### build.serverEntry


[Section titled build.serverEntry](#buildserverentry)

**Type:** `string` **Default:** `'entry.mjs'`

Specifies the file name of the server entrypoint when building to SSR. This entrypoint is usually dependent on which host you are deploying to and will be set by your adapter for you.

Note that it is recommended that this file ends with `.mjs` so that the runtime detects that the file is a JavaScript module.

```
{build: {serverEntry: 'main.mjs'}}
```


### build.redirects


[Section titled build.redirects](#buildredirects)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@2.6.0`

Specifies whether redirects will be output to HTML during the build. This option only applies to `output: 'static'` mode; in SSR redirects are treated the same as all responses.

This option is mostly meant to be used by adapters that have special configuration files for redirects and do not need/want HTML based redirects.

```
{build: {redirects: false}}
```


### build.inlineStylesheets


[Section titled build.inlineStylesheets](#buildinlinestylesheets)

**Type:** `'always' | 'auto' | 'never'` **Default:** `auto`

**Added in:** `astro@2.6.0`

Control whether project styles are sent to the browser in a separate css file or inlined into `<style>` tags. Choose from the following options:

-   `'always'` - project styles are inlined into `<style>` tags
-   `'auto'` - only stylesheets smaller than `ViteConfig.build.assetsInlineLimit` (default: 4kb) are inlined. Otherwise, project styles are sent in external stylesheets.
-   `'never'` - project styles are sent in external stylesheets

```
{build: {inlineStylesheets: `never`,},}
```


### build.concurrency


[Section titled build.concurrency](#buildconcurrency)

**Type:** `number` **Default:** `1`

**Added in:** `astro@4.16.0`

The number of pages to build in parallel.

**In most cases, you should not change the default value of `1`.**

Use this option only when other attempts to reduce the overall rendering time (e.g. batch or cache long running tasks like fetch calls or data access) are not possible or are insufficient. If the number is set too high, page rendering may slow down due to insufficient memory resources and because JS is single-threaded.

```
{build: {concurrency: 2}}
```

Breaking changes possible

This feature is stable and is not considered experimental. However, this feature is only intended to address difficult performance issues, and breaking changes may occur in a [minor release](/en/upgrade-astro/#semantic-versioning) to keep this option as performant as possible. Please check the [Astro CHANGELOG](https://github.com/withastro/astro/blob/refs/heads/next/packages/astro/CHANGELOG.md) for every minor release if you are using this feature.


## Server Options


[Section titled Server Options](#server-options)

Customize the Astro dev server, used by both `astro dev` and `astro preview`.

```
{server: { port: 1234, host: true}}
```

To set different configuration based on the command run (“dev”, “preview”) a function can also be passed to this configuration option.

```
{// Example: Use the function syntax to customize based on commandserver: ({ command })=> ({ port: command==='dev'?4321:4000 })}
```


### server.host


[Section titled server.host](#serverhost)

**Type:** `string | boolean` **Default:** `false`

**Added in:** `astro@0.24.0`

Set which network IP addresses the server should listen on (i.e. non-localhost IPs).

-   `false` - do not expose on a network IP address
-   `true` - listen on all addresses, including LAN and public addresses
-   `[custom-address]` - expose on a network IP address at `[custom-address]` (ex: `192.168.0.1`)


### server.port


[Section titled server.port](#serverport)

**Type:** `number` **Default:** `4321`

Set which port the server should listen on.

If the given port is already in use, Astro will automatically try the next available port.

```
{server: { port: 8080 }}
```


### server.allowedHosts


[Section titled server.allowedHosts](#serverallowedhosts)

**Type:** `Array<string> | true` **Default:** `[]`

**Added in:** `astro@5.4.0`

A list of hostnames that Astro is allowed to respond to. When the value is set to `true`, any hostname is allowed.

```
{server: {allowedHosts: ['staging.example.com', 'qa.example.com']}}
```


### server.open


[Section titled server.open](#serveropen)

**Type:** `string | boolean` **Default:** `false`

**Added in:** `astro@4.1.0`

Controls whether the dev server should open in your browser window on startup.

Pass a full URL string (e.g. “[http://example.com](http://example.com)”) or a pathname (e.g. “/about”) to specify the URL to open.

```
{server: { open: "/about" }}
```


### server.headers


[Section titled server.headers](#serverheaders)

**Type:** `OutgoingHttpHeaders` **Default:** `{}`

**Added in:** `astro@1.7.0`

Set custom HTTP response headers to be sent in `astro dev` and `astro preview`.


## Session Options


[Section titled Session Options](#session-options)

**Added in:** `astro@5.7.0`

Configures session storage for your Astro project. This is used to store session data in a persistent way, so that it can be accessed across different requests. Some adapters may provide a default session driver, but you can override it with your own configuration.

See [the sessions guide](/en/guides/sessions/) for more information.

astro.config.mjs

```
{session: {// The name of the Unstorage driverdriver: 'redis',// The required options depend on the driveroptions: {url: process.env.REDIS_URL,},ttl: 3600, // 1 hour}}
```


### session.driver


[Section titled session.driver](#sessiondriver)

**Type:** `string | undefined`

**Added in:** `astro@5.7.0`

The Unstorage driver to use for session storage. The [Node](/en/guides/integrations-guide/node/#sessions), [Cloudflare](/en/guides/integrations-guide/cloudflare/#sessions), and [Netlify](/en/guides/integrations-guide/netlify/#sessions) adapters automatically configure a default driver for you, but you can specify your own if you would prefer or if you are using an adapter that does not provide one.

The value is the “Driver name” from the [Unstorage driver documentation](https://unstorage.unjs.io/drivers).

astro.config.mjs

```
{adapter: vercel(),session: {driver: "redis",},}
```

Note

Some drivers may need extra packages to be installed. Some drivers may also require environment variables or credentials to be set. See the [Unstorage documentation](https://unstorage.unjs.io/drivers) for more information.


### session.options


[Section titled session.options](#sessionoptions)

**Type:** `Record<string, unknown> | undefined` **Default:** `{}`

**Added in:** `astro@5.7.0`

The driver-specific options to use for session storage. The options depend on the driver you are using. See the [Unstorage documentation](https://unstorage.unjs.io/drivers) for more information on the options available for each driver.

astro.config.mjs

```
{session: {driver: "redis",options: {url: process.env.REDIS_URL},}}
```


### session.cookie


[Section titled session.cookie](#sessioncookie)

**Type:** `string | AstroCookieSetOptions | undefined` **Default:** `{ name: "astro-session", sameSite: "lax", httpOnly: true, secure: true }`

**Added in:** `astro@5.7.0`

The session cookie configuration. If set to a string, it will be used as the cookie name. Alternatively, you can pass an object with additional options. These will be merged with the defaults.

astro.config.mjs

```
{session: {// If set to a string, it will be used as the cookie name.cookie: "my-session-cookie",}}
```

astro.config.mjs

```
{session: {// If set to an object, it will be used as the cookie options.cookie: {name: "my-session-cookie",sameSite: "lax",secure: true,}}}
```


### session.ttl


[Section titled session.ttl](#sessionttl)

**Type:** `number | undefined` **Default:** Infinity

**Added in:** `astro@5.7.0`

An optional default time-to-live expiration period for session values, in seconds.

By default, session values persist until they are deleted or the session is destroyed, and do not automatically expire because a particular amount of time has passed. Set `session.ttl` to add a default expiration period for your session values. Passing a `ttl` option to [`session.set()`](/en/reference/api-reference/#set) will override the global default for that individual entry.

astro.config.mjs

```
{session: {// Set a default expiration period of 1 hour (3600 seconds)ttl: 3600,}}
```

Note

Setting a value for `ttl` does not automatically delete the value from storage after the time limit has passed.

Values from storage will only be deleted when there is an attempt to access them after the `ttl` period has expired. At this time, the session value will be undefined and only then will the value be deleted.

Individual drivers may also support a `ttl` option that will automatically delete sessions after the specified time. See your chosen driver’s documentation for more information.


## Dev Toolbar Options


[Section titled Dev Toolbar Options](#dev-toolbar-options)


### devToolbar.enabled


[Section titled devToolbar.enabled](#devtoolbarenabled)

**Type:** `boolean` **Default:** `true`

Whether to enable the Astro Dev Toolbar. This toolbar allows you to inspect your page islands, see helpful audits on performance and accessibility, and more.

This option is scoped to the entire project, to only disable the toolbar for yourself, run `npm run astro preferences disable devToolbar`. To disable the toolbar for all your Astro projects, run `npm run astro preferences disable devToolbar --global`.


## Prefetch Options


[Section titled Prefetch Options](#prefetch-options)

**Type:** `boolean | object`

Enable prefetching for links on your site to provide faster page transitions. (Enabled by default on pages using the `<ClientRouter />` router. Set `prefetch: false` to opt out of this behaviour.)

This configuration automatically adds a prefetch script to every page in the project giving you access to the `data-astro-prefetch` attribute. Add this attribute to any `<a />` link on your page to enable prefetching for that page.

```
<ahref="/about"data-astro-prefetch>About</a>
```

Further customize the default prefetching behavior using the [`prefetch.defaultStrategy`](#prefetchdefaultstrategy) and [`prefetch.prefetchAll`](#prefetchprefetchall) options.

See the [Prefetch guide](/en/guides/prefetch/) for more information.


### prefetch.prefetchAll


[Section titled prefetch.prefetchAll](#prefetchprefetchall)

**Type:** `boolean`

Enable prefetching for all links, including those without the `data-astro-prefetch` attribute. This value defaults to `true` when using the `<ClientRouter />` router. Otherwise, the default value is `false`.

```
prefetch: {prefetchAll: true}
```

When set to `true`, you can disable prefetching individually by setting `data-astro-prefetch="false"` on any individual links.

```
<ahref="/about"data-astro-prefetch="false">About</a>
```


### prefetch.defaultStrategy


[Section titled prefetch.defaultStrategy](#prefetchdefaultstrategy)

**Type:** `'tap' | 'hover' | 'viewport' | 'load'` **Default:** `'hover'`

The default prefetch strategy to use when the `data-astro-prefetch` attribute is set on a link with no value.

-   `'tap'`: Prefetch just before you click on the link.
-   `'hover'`: Prefetch when you hover over or focus on the link. (default)
-   `'viewport'`: Prefetch as the links enter the viewport.
-   `'load'`: Prefetch all links on the page after the page is loaded.

You can override this default value and select a different strategy for any individual link by setting a value on the attribute.

```
<ahref="/about"data-astro-prefetch="viewport">About</a>
```


## Image Options


[Section titled Image Options](#image-options)


### image.endpoint


[Section titled image.endpoint](#imageendpoint)

**Type:** `Object` **Default:** `{route: '/_image', entrypoint: undefined}`

**Added in:** `astro@3.1.0`

Set the endpoint to use for image optimization in dev and SSR. The `entrypoint` property can be set to `undefined` to use the default image endpoint.

```
{image: {// Example: Use a custom image endpoint at `/custom_endpoint`endpoint: {route: '/custom_endpoint',entrypoint: 'src/my_endpoint.ts',},},}
```


### image.service


[Section titled image.service](#imageservice)

**Type:** `Object` **Default:** `{entrypoint: 'astro/assets/services/sharp', config?: {}}`

**Added in:** `astro@2.1.0`

Set which image service is used for Astro’s assets support.

The value should be an object with an entrypoint for the image service to use and optionally, a config object to pass to the service.

The service entrypoint can be either one of the included services, or a third-party package.

```
{image: {// Example: Enable the Sharp-based image service with a custom configservice: {entrypoint: 'astro/assets/services/sharp',config: {limitInputPixels: false,},},},}
```


#### image.service.config.limitInputPixels


[Section titled image.service.config.limitInputPixels](#imageserviceconfiglimitinputpixels)

**Type:** `number | boolean` **Default:** `true`

**Added in:** `astro@4.1.0`

Whether or not to limit the size of images that the Sharp image service will process.

Set `false` to bypass the default image size limit for the Sharp image service and process large images.


### image.domains


[Section titled image.domains](#imagedomains)

**Type:** `Array<string>` **Default:** `[]`

**Added in:** `astro@2.10.10`

Defines a list of permitted image source domains for remote image optimization. No other remote images will be optimized by Astro.

This option requires an array of individual domain names as strings. Wildcards are not permitted. Instead, use [`image.remotePatterns`](#imageremotepatterns) to define a list of allowed source URL patterns.

astro.config.mjs

```
{image: {// Example: Allow remote image optimization from a single domaindomains: ['astro.build'],},}
```


### image.remotePatterns


[Section titled image.remotePatterns](#imageremotepatterns)

**Type:** `Array<RemotePattern>` **Default:** `[]`

**Added in:** `astro@2.10.10`

Defines a list of permitted image source URL patterns for remote image optimization.

`remotePatterns` can be configured with four properties:

1.  protocol
2.  hostname
3.  port
4.  pathname

```
{image: {// Example: allow processing all images from your aws s3 bucketremotePatterns: [{protocol: 'https',hostname: '**.amazonaws.com',}],},}
```

You can use wildcards to define the permitted `hostname` and `pathname` values as described below. Otherwise, only the exact values provided will be configured: `hostname`:

-   Start with ’\*\*.’ to allow all subdomains (‘endsWith’).
-   Start with ’\*.’ to allow only one level of subdomain.

`pathname`:

-   End with ’/\*\*’ to allow all sub-routes (‘startsWith’).
-   End with ’/\*’ to allow only one level of sub-route.


### image.experimentalLayout


[Section titled image.experimentalLayout](#imageexperimentallayout)

**Type:** `ImageLayout` **Default:** `undefined`

The default layout type for responsive images. Can be overridden by the `layout` prop on the image component. Requires the `experimental.responsiveImages` flag to be enabled.

-   `constrained` - The image will scale to fit the container, maintaining its aspect ratio, but will not exceed the specified dimensions.
-   `fixed` - The image will maintain its original dimensions.
-   `full-width` - The image will scale to fit the container, maintaining its aspect ratio.


### image.experimentalObjectFit


[Section titled image.experimentalObjectFit](#imageexperimentalobjectfit)

**Type:** `ImageFit` **Default:** `"cover"`

The default object-fit value for responsive images. Can be overridden by the `fit` prop on the image component. Requires the `experimental.responsiveImages` flag to be enabled.


### image.experimentalObjectPosition


[Section titled image.experimentalObjectPosition](#imageexperimentalobjectposition)

**Type:** `string` **Default:** `"center"`

The default object-position value for responsive images. Can be overridden by the `position` prop on the image component. Requires the `experimental.responsiveImages` flag to be enabled.


### image.experimentalBreakpoints


[Section titled image.experimentalBreakpoints](#imageexperimentalbreakpoints)

**Type:** `Array<number>` **Default:** `[640, 750, 828, 1080, 1280, 1668, 2048, 2560] | [640, 750, 828, 960, 1080, 1280, 1668, 1920, 2048, 2560, 3200, 3840, 4480, 5120, 6016]`

The breakpoints used to generate responsive images. Requires the `experimental.responsiveImages` flag to be enabled. The full list is not normally used, but is filtered according to the source and output size. The defaults used depend on whether a local or remote image service is used. For remote services the more comprehensive list is used, because only the required sizes are generated. For local services, the list is shorter to reduce the number of images generated.


### image.experimentalDefaultStyles


[Section titled image.experimentalDefaultStyles](#imageexperimentaldefaultstyles)

**Type:** `boolean` **Default:** `true`

Whether to automatically add global styles to ensure that experimental images resize correctly. This is enabled by default, but can be disabled if you want to manage the styles yourself. This option is only used when the `experimental.responsiveImages` flag is enabled.


## Markdown Options


[Section titled Markdown Options](#markdown-options)


### markdown.shikiConfig


[Section titled markdown.shikiConfig](#markdownshikiconfig)

**Type:** `Partial<ShikiConfig>`

Shiki is our default syntax highlighter. You can configure all options via the `markdown.shikiConfig` object:

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {shikiConfig: {// Choose from Shiki's built-in themes (or add your own)// https://shiki.style/themestheme: 'dracula',// Alternatively, provide multiple themes// See note below for using dual light/dark themesthemes: {light: 'github-light',dark: 'github-dark',},// Disable the default colors// https://shiki.style/guide/dual-themes#without-default-color// (Added in v4.12.0)defaultColor: false,// Add custom languages// Note: Shiki has countless langs built-in, including .astro!// https://shiki.style/languageslangs: [],// Add custom aliases for languages// Map an alias to a Shiki language ID: https://shiki.style/languages#bundled-languages// https://shiki.style/guide/load-lang#custom-language-aliaseslangAlias: {cjs: "javascript"},// Enable word wrap to prevent horizontal scrollingwrap: true,// Add custom transformers: https://shiki.style/guide/transformers// Find common transformers: https://shiki.style/packages/transformerstransformers: [],},},});
```

See the [code syntax highlighting guide](/en/guides/syntax-highlighting/) for usage and examples.


### markdown.syntaxHighlight


[Section titled markdown.syntaxHighlight](#markdownsyntaxhighlight)

**Type:** `SyntaxHighlightConfig | SyntaxHighlightConfigType | false` **Default:** `{ type: 'shiki', excludeLangs: ['math'] }`

Which syntax highlighter to use for Markdown code blocks (\`\`\`), if any. This determines the CSS classes that Astro will apply to your Markdown code blocks.

-   `shiki` - use the [Shiki](https://shiki.style) highlighter (`github-dark` theme configured by default)
-   `prism` - use the [Prism](https://prismjs.com/) highlighter and [provide your own Prism stylesheet](/en/guides/syntax-highlighting/#add-a-prism-stylesheet)
-   `false` - do not apply syntax highlighting.

```
{markdown: {// Example: Switch to use prism for syntax highlighting in MarkdownsyntaxHighlight: 'prism',}}
```

For more control over syntax highlighting, you can instead specify a configuration object with the properties listed below.


#### markdown.syntaxHighlight.type


[Section titled markdown.syntaxHighlight.type](#markdownsyntaxhighlighttype)

**Type:** `'shiki' | 'prism'` **Default:** `'shiki'`

**Added in:** `astro@5.5.0`

The default CSS classes to apply to Markdown code blocks. (If no other syntax highlighting configuration is needed, you can instead set `markdown.syntaxHighlight` directly to `shiki`, `prism`, or `false`.)


#### markdown.syntaxHighlight.excludeLangs


[Section titled markdown.syntaxHighlight.excludeLangs](#markdownsyntaxhighlightexcludelangs)

**Type:** `Array<string>` **Default:** `['math']`

**Added in:** `astro@5.5.0`

An array of languages to exclude from the default syntax highlighting specified in `markdown.syntaxHighlight.type`. This can be useful when using tools that create diagrams from Markdown code blocks, such as Mermaid.js and D2.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({markdown: {syntaxHighlight: {type: 'shiki',excludeLangs: ['mermaid', 'math'],},},});
```


### markdown.remarkPlugins


[Section titled markdown.remarkPlugins](#markdownremarkplugins)

**Type:** `RemarkPlugins`

Pass [remark plugins](https://github.com/remarkjs/remark) to customize how your Markdown is built. You can import and apply the plugin function (recommended), or pass the plugin name as a string.

```
import remarkToc from'remark-toc';{markdown: {remarkPlugins: [ [remarkToc, { heading: "contents"} ] ]}}
```


### markdown.rehypePlugins


[Section titled markdown.rehypePlugins](#markdownrehypeplugins)

**Type:** `RehypePlugins`

Pass [rehype plugins](https://github.com/remarkjs/remark-rehype) to customize how your Markdown’s output HTML is processed. You can import and apply the plugin function (recommended), or pass the plugin name as a string.

```
import { rehypeAccessibleEmojis } from'rehype-accessible-emojis';{markdown: {rehypePlugins: [rehypeAccessibleEmojis]}}
```


### markdown.gfm


[Section titled markdown.gfm](#markdowngfm)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@2.0.0`

Astro uses [GitHub-flavored Markdown](https://github.com/remarkjs/remark-gfm) by default. To disable this, set the `gfm` flag to `false`:

```
{markdown: {gfm: false,}}
```


### markdown.smartypants


[Section titled markdown.smartypants](#markdownsmartypants)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@2.0.0`

Astro uses the [SmartyPants formatter](https://daringfireball.net/projects/smartypants/) by default. To disable this, set the `smartypants` flag to `false`:

```
{markdown: {smartypants: false,}}
```


### markdown.remarkRehype


[Section titled markdown.remarkRehype](#markdownremarkrehype)

**Type:** `RemarkRehype`

Pass options to [remark-rehype](https://github.com/remarkjs/remark-rehype#api).

```
{markdown: {// Example: Translate the footnotes text to another language, here are the default English valuesremarkRehype: { footnoteLabel: "Footnotes", footnoteBackLabel: "Back to reference 1"},},};
```


## i18n


[Section titled i18n](#i18n)

**Type:** `object`

**Added in:** `astro@3.5.0`

Configures i18n routing and allows you to specify some customization options.

See our guide for more information on [internationalization in Astro](/en/guides/internationalization/)


### i18n.locales


[Section titled i18n.locales](#i18nlocales)

**Type:** `Locales`

**Added in:** `astro@3.5.0`

A list of all locales supported by the website. This is a required field.

Languages can be listed either as individual codes (e.g. `['en', 'es', 'pt-br']`) or mapped to a shared `path` of codes (e.g. `{ path: "english", codes: ["en", "en-US"]}`). These codes will be used to determine the URL structure of your deployed site.

No particular language code format or syntax is enforced, but your project folders containing your content files must match exactly the `locales` items in the list. In the case of multiple `codes` pointing to a custom URL path prefix, store your content files in a folder with the same name as the `path` configured.


### i18n.defaultLocale


[Section titled i18n.defaultLocale](#i18ndefaultlocale)

**Type:** `string`

**Added in:** `astro@3.5.0`

The default locale of your website/application, that is one of the specified `locales`. This is a required field.

No particular language format or syntax is enforced, but we suggest using lower-case and hyphens as needed (e.g. “es”, “pt-br”) for greatest compatibility.


### i18n.fallback


[Section titled i18n.fallback](#i18nfallback)

**Type:** `Record<string, string>`

**Added in:** `astro@3.5.0`

The fallback strategy when navigating to pages that do not exist (e.g. a translated page has not been created).

Use this object to declare a fallback `locale` route for each language you support. If no fallback is specified, then unavailable pages will return a 404.


##### Example


[Section titled Example](#example)

The following example configures your content fallback strategy to redirect unavailable pages in `/pt-br/` to their `es` version, and unavailable pages in `/fr/` to their `en` version. Unavailable `/es/` pages will return a 404.

```
exportdefaultdefineConfig({i18n: {defaultLocale: "en",locales: ["en", "fr", "pt-br", "es"],fallback: {pt: "es",fr: "en"}}})
```


### i18n.routing


[Section titled i18n.routing](#i18nrouting)

**Type:** `object | "manual"` **Default:** `object`

**Added in:** `astro@3.7.0`

Controls the routing strategy to determine your site URLs. Set this based on your folder/URL path configuration for your default language.

```
exportdefaultdefineConfig({i18n: {defaultLocale: "en",locales: ["en", "fr"],routing: {prefixDefaultLocale: false,redirectToDefaultLocale: true,fallbackType: "redirect",}}})
```

Since 4.6.0, this option can also be set to `manual`. When this routing strategy is enabled, Astro will **disable** its i18n middleware and no other `routing` options (e.g. `prefixDefaultLocale`) may be configured. You will be responsible for writing your own routing logic, or executing Astro’s i18n middleware manually alongside your own.

```
exportdefaultdefineConfig({i18n: {defaultLocale: "en",locales: ["en", "fr"],routing: "manual"}})
```


#### i18n.routing.prefixDefaultLocale


[Section titled i18n.routing.prefixDefaultLocale](#i18nroutingprefixdefaultlocale)

**Type:** `boolean` **Default:** `false`

**Added in:** `astro@3.7.0`

When `false`, only non-default languages will display a language prefix. The `defaultLocale` will not show a language prefix and content files do not exist in a localized folder. URLs will be of the form `example.com/[locale]/content/` for all non-default languages, but `example.com/content/` for the default locale.

When `true`, all URLs will display a language prefix. URLs will be of the form `example.com/[locale]/content/` for every route, including the default language. Localized folders are used for every language, including the default.

```
exportdefaultdefineConfig({i18n: {defaultLocale: "en",locales: ["en", "fr", "pt-br", "es"],routing: {prefixDefaultLocale: true,}}})
```


#### i18n.routing.redirectToDefaultLocale


[Section titled i18n.routing.redirectToDefaultLocale](#i18nroutingredirecttodefaultlocale)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@4.2.0`

Configures whether or not the home URL (`/`) generated by `src/pages/index.astro` will redirect to `/[defaultLocale]` when `prefixDefaultLocale: true` is set.

Set `redirectToDefaultLocale: false` to disable this automatic redirection at the root of your site:

astro.config.mjs

```
exportdefaultdefineConfig({i18n:{defaultLocale: "en",locales: ["en", "fr"],routing: {prefixDefaultLocale: true,redirectToDefaultLocale: false}}})
```


#### i18n.routing.fallbackType


[Section titled i18n.routing.fallbackType](#i18nroutingfallbacktype)

**Type:** `"redirect" | "rewrite"` **Default:** `"redirect"`

**Added in:** `astro@4.15.0`

When [`i18n.fallback`](#i18nfallback) is configured to avoid showing a 404 page for missing page routes, this option controls whether to [redirect](/en/guides/routing/#redirects) to the fallback page, or to [rewrite](/en/guides/routing/#rewrites) the fallback page’s content in place.

By default, Astro’s i18n routing creates pages that redirect your visitors to a new destination based on your fallback configuration. The browser will refresh and show the destination address in the URL bar.

When `i18n.routing.fallback: "rewrite"` is configured, Astro will create pages that render the contents of the fallback page on the original, requested URL.

With the following configuration, if you have the file `src/pages/en/about.astro` but not `src/pages/fr/about.astro`, the `astro build` command will generate `dist/fr/about.html` with the same content as the `dist/en/about.html` page. Your site visitor will see the English version of the page at `https://example.com/fr/about/` and will not be redirected.

astro.config.mjs

```
exportdefaultdefineConfig({i18n: {defaultLocale: "en",locales: ["en", "fr"],routing: {prefixDefaultLocale: false,fallbackType: "rewrite",},fallback: {fr: "en",}},})
```


### i18n.domains


[Section titled i18n.domains](#i18ndomains)

**Type:** `Record<string, string>` **Default:** `{}`

**Added in:** `astro@4.3.0`

Configures the URL pattern of one or more supported languages to use a custom domain (or sub-domain).

When a locale is mapped to a domain, a `/[locale]/` path prefix will not be used. However, localized folders within `src/pages/` are still required, including for your configured `defaultLocale`.

Any other locale not configured will default to a localized path-based URL according to your `prefixDefaultLocale` strategy (e.g. `https://example.com/[locale]/blog`).

astro.config.mjs

```
exportdefaultdefineConfig({site: "https://example.com",output: "server", // required, with no prerendered pagesadapter: node({mode: 'standalone',}),i18n: {defaultLocale: "en",locales: ["en", "fr", "pt-br", "es"],prefixDefaultLocale: false,domains: {fr: "https://fr.example.com",es: "https://example.es"}},})
```

Both page routes built and URLs returned by the `astro:i18n` helper functions [`getAbsoluteLocaleUrl()`](/en/reference/modules/astro-i18n/#getabsolutelocaleurl) and [`getAbsoluteLocaleUrlList()`](/en/reference/modules/astro-i18n/#getabsolutelocaleurllist) will use the options set in `i18n.domains`.

See the [Internationalization Guide](/en/guides/internationalization/#domains) for more details, including the limitations of this feature.


## env


[Section titled env](#env)

**Type:** `object` **Default:** `{}`

**Added in:** `astro@5.0.0`

Configuration options for type-safe environment variables.

See our guide for more information on [environment variables in Astro](/en/guides/environment-variables/).


### env.schema


[Section titled env.schema](#envschema)

**Type:** `EnvSchema` **Default:** `{}`

**Added in:** `astro@5.0.0`

An object that uses `envField` to define the data type and properties of your environment variables: `context` (client or server), `access` (public or secret), a `default` value to use, and whether or not this environment variable is `optional` (defaults to `false`).

astro.config.mjs

```
import { defineConfig, envField } from"astro/config"exportdefaultdefineConfig({env: {schema: {API_URL: envField.string({ context: "client", access: "public", optional: true }),PORT: envField.number({ context: "server", access: "public", default: 4321 }),API_SECRET: envField.string({ context: "server", access: "secret" }),}}})
```

`envField` supports four data types: string, number, enum, and boolean. `context` and `access` are required properties for all data types. The following shows the complete list of properties available for each data type:

```
import { envField } from"astro/config"envField.string({// context & accessoptional: true,default: "foo",max: 20,min: 1,length: 13,url: true,includes: "oo",startsWith: "f",endsWith: "o",})envField.number({// context & accessoptional: true,default: 15,gt: 2,min: 1,lt: 3,max: 4,int: true,})envField.boolean({// context & accessoptional: true,default: true,})envField.enum({// context & accessvalues: ['foo', 'bar', 'baz'], // requiredoptional: true,default: 'baz',})
```


### env.validateSecrets


[Section titled env.validateSecrets](#envvalidatesecrets)

**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.0.0`

Whether or not to validate secrets on the server when starting the dev server or running a build.

By default, only public variables are validated on the server when starting the dev server or a build, and private variables are validated at runtime only. If enabled, private variables will also be checked on start. This is useful in some continuous integration (CI) pipelines to make sure all your secrets are correctly set before deploying.

astro.config.mjs

```
import { defineConfig, envField } from"astro/config"exportdefaultdefineConfig({env: {schema: {// ...},validateSecrets: true}})
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 169. `en/reference/container-reference/.md`

```text
# Astro Container API (experimental)



# Astro Container API (experimental)


**Added in:** `astro@4.9.0`

The Container API allows you to render Astro components in isolation.

This experimental server-side API unlocks a variety of potential future uses, but is currently scoped to allow [testing of `.astro` component output](/en/guides/testing/#vitest-and-container-api) in `vite` environments such as `vitest`.

It also allows you to [manually load rendering scripts](#adding-a-renderer-manually) for creating containers in pages rendered on demand or other “shell” environments outside of `vite` (e.g. inside a PHP or Elixir application).

This API allows you to [create a new container](#create), and render an Astro component returning [a string](#rendertostring) or a [`Response`](#rendertoresponse).

This API is experimental and subject to breaking changes, even in [minor or patch releases](/en/upgrade-astro/#semantic-versioning). Please consult [the Astro CHANGELOG](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for changes as they occur. This page will always be updated with the most current information for the latest version of Astro.


## `create()`


[Section titled create()](#create)

Creates a new instance of the container.

```
import { experimental_AstroContainer } from"astro/container";const container = await experimental_AstroContainer.create();
```

It accepts an object with the following options:

```
exporttype AstroContainerOptions = {streaming?:boolean;renderers?:AddServerRenderer[];};exporttype AddServerRenderer =| {renderer:NamedSSRLoadedRendererValue;name:never;}| {renderer:SSRLoadedRendererValue;name:string;};
```


### `streaming` option


[Section titled streaming option](#streaming-option)

**Type:** `boolean`

Enables rendering components using [HTML streaming](/en/guides/on-demand-rendering/#html-streaming).


### `renderers` option


[Section titled renderers option](#renderers-option)

**Type:** `AddServerRenderer[]`

A list of loaded client renderers required by the component. Use this if your `.astro` component renders any [UI framework components](/en/guides/framework-components/) or MDX using an official Astro integration (e.g. React, Vue, etc.).

Renderers can be added through the Container API automatically for static applications, or cases where the container isn’t called at runtime (e.g. testing with `vitest`).

For [on-demand rendered applications](/en/guides/on-demand-rendering/), or cases where the container is called at runtime or inside other “shells” (e.g. PHP, Ruby, Java, etc.), renderers must be manually imported.


#### Adding a renderer through the Container API


[Section titled Adding a renderer through the Container API](#adding-a-renderer-through-the-container-api)

For each official Astro integration, import and use the `getContainerRenderer()` helper function to expose its client and server rendering scripts. These are available for `@astrojs/react`, `@astrojs/preact`, `@astrojs/solid-js`, `@astrojs/svelte`, `@astrojs/vue`, and `@astrojs/mdx`.

For renderer packages outside the `@astrojs` npm org, look in their documentation for `getContainerRenderer()` or a similar function provided.

When using `vite` (`vitest`, Astro integrations, etc.), the renderers are loaded with the function `loadRenderers()` from the virtual module `astro:container`.

Caution

Outside `vite` or for on-demand usage, you’ll have to [load the renderers manually](#adding-a-renderer-manually).

The following example provides the necessary object to render an Astro component that renders a React component and a Svelte component:

```
import { getContainerRendereras reactContainerRenderer } from"@astrojs/react";import { getContainerRendereras svelteContainerRenderer } from"@astrojs/svelte";import { loadRenderers } from"astro:container";const renderers = await loadRenderers([reactContainerRenderer(), svelteContainerRenderer()]);const container = await experimental_AstroContainer.create({renderers})const result = await container.renderToString(ReactWrapper);
```


#### Adding a renderer manually


[Section titled Adding a renderer manually](#adding-a-renderer-manually)

When the container is called at runtime, or inside other “shells”, the `astro:container` virtual module’s helper functions are not available. You must import the necessary server and client renderers manually and store them inside the container using `addServerRenderer` and `addClientRenderer`.

Server renderers are required to build your project, and must be stored in the container for every framework used. Client renderers are additionally needed to any hydrate client-side components using [`client:*` directives](/en/reference/directives-reference/#client-directives).

Only one import statement is needed per framework. Importing a renderer makes both the server and client renderers available to your container. However, **server renderers must be added to your container before client renderers**. This allows your entire container to render first, and then hydrate any interactive components.

The following example manually imports the necessary server renderers to be able to display static Vue components and `.mdx` pages. It additionally adds both server and client renderers for interactive React components.

```
import reactRenderer from"@astrojs/react/server.js";import vueRenderer from"@astrojs/vue/server.js";import mdxRenderer from"@astrojs/mdx/server.js";const container = await experimental_AstroContainer.create();container.addServerRenderer({renderer: vueRenderer});container.addServerRenderer({renderer: mdxRenderer});container.addServerRenderer({ renderer: reactRenderer });container.addClientRenderer({ name: "@astrojs/react", entrypoint: "@astrojs/react/client.js" });
```


## `renderToString()`


[Section titled renderToString()](#rendertostring)

This function renders a specified component inside a container. It takes an Astro component as an argument and it returns a string that represents the HTML/content rendered by the Astro component.

```
import { experimental_AstroContainer } from"astro/container";import Card from"../src/components/Card.astro";const container = await experimental_AstroContainer.create();const result = await container.renderToString(Card);
```

Under the hood, this function calls [`renderToResponse`](#rendertoresponse) and calls `Response.text()`.

It also accepts an object as a second argument that can contain a [number of options](#rendering-options).


## `renderToResponse()`


[Section titled renderToResponse()](#rendertoresponse)

It renders a component, and it returns a `Response` object.

```
import { experimental_AstroContainer } from"astro/container";import Card from"../src/components/Card.astro";const container = await experimental_AstroContainer.create();const result = await container.renderToResponse(Card);
```

It also accepts an object as a second argument that can contain a [number of options](#rendering-options).


## Rendering options


[Section titled Rendering options](#rendering-options)

Both [`renderToResponse`](#rendertoresponse) and [`renderToString`](#rendertostring) accept an object as their second argument:

```
exporttype ContainerRenderOptions = {slots?:Record<string, any>;props?:Record<string, unknown>;request?:Request;params?:Record<string, string|undefined>;locals?: App.Locals;routeType?:"page"|"endpoint";};
```

These optional values can be passed to the rendering function in order to provide additional information necessary for an Astro component to properly render.


### `slots`


[Section titled slots](#slots)

**Type**: `Record<string, any>`;

An option to pass content to be rendered with [`<slots>`](/en/basics/astro-components/#slots).

If your Astro component renders one default slot, pass an object with `default` as the key:

```
import Card from"../src/components/Card.astro";const result = await container.renderToString(Card, {slots: { default: "Some value" }});
```

If your component renders named slots, use the slot names as the object keys:

```
------<div><slotname="header" /><slotname="footer" /></div>
```

```
import Card from"../src/components/Card.astro";const result = await container.renderToString(Card, {slots: {header: "Header content",footer: "Footer"}});
```

You can also render components in cascade:

```
------<div><slotname="header" /><slotname="footer" /></div>
```

```
import Card from"../src/components/Card.astro";import CardHeader from"../src/components/CardHeader.astro";import CardFooter from"../src/components/CardFooter.astro";const result = await container.renderToString(Card, {slots: {header: await container.renderToString(CardHeader),footer:  await container.renderToString(CardFooter)}});
```


### `props` option


[Section titled props option](#props-option)

**Type**: `Record<string, unknown>`

An option to pass [properties](/en/basics/astro-components/#component-props) for Astro components.

```
import Card from"../src/components/Card.astro";const result = await container.renderToString(Card, {props: { name: "Hello, world!" }});
```

```
---// For TypeScript supportinterface Props {name:string;};const { name } = Astro.props;---<div>{name}</div>
```


### `request` option


[Section titled request option](#request-option)

**Type**: `Request`

An option to pass a `Request` with information about the path/URL the component will render.

Use this option when your component needs to read information like `Astro.url` or `Astro.request`.

You can also inject possible headers or cookies.

```
import Card from"../src/components/Card.astro";const result = await container.renderToString(Card, {request: newRequest("https://example.com/blog", {headers: {"x-some-secret-header": "test-value"}})});
```


### `params` option


[Section titled params option](#params-option)

**Type**: `Record<string, string | undefined>`;

An object to pass information about the path parameter to an Astro component responsible for [generating dynamic routes](/en/guides/routing/#dynamic-routes).

Use this option when your component needs a value for `Astro.params` in order to generate a single route dynamically.

```
---const { locale, slug } = Astro.params;---<div></div>
```

```
import LocaleSlug from"../src/components/[locale]/[slug].astro";const result = await container.renderToString(LocaleSlug, {params: {locale: "en",slug: "getting-started"}});
```


### `locals` options


[Section titled locals options](#locals-options)

**Type**: `App.Locals`

An option to pass information from [`Astro.locals`](/en/reference/api-reference/#locals) for rendering your component.

Use this option to when your component needs information stored during the lifecycle of a request in order to render, such as logged in status.

```
---const { checkAuth } = Astro.locals;const isAuthenticated = checkAuth();---{isAuthenticated ?<span>You're in</span>:<span>You're out</span>}
```

```
import Card from"../src/components/Card.astro";test("User is in", async()=> {const result = await container.renderToString(Card, {locals: {checkAuth() { return true; }}});// assert result contains "You're in"});test("User is out", async()=> {const result = await container.renderToString(Card, {locals: {checkAuth() { return false; }}});// assert result contains "You're out"});
```


### `routeType` option


[Section titled routeType option](#routetype-option)

**Type**: `"page" | "endpoint"`

An option available when using `renderToResponse` to specify that you are rendering an [endpoint](/en/guides/endpoints/):

```
container.renderToString(Endpoint, { routeType: "endpoint" });
```

```
import*as Endpoint from"../src/pages/api/endpoint.js";const response = await container.renderToResponse(Endpoint, {routeType: "endpoint"});const json = await response.json();
```

To test your endpoint on methods such as `POST`, `PATCH`, etc., use the `request` option to call the correct function:

```
exportfunctionGET() {}// need to test thisexportfunctionPOST() {}
```

```
import*as Endpoint from"../src/pages/api/endpoint.js";const response = await container.renderToResponse(Endpoint, {routeType: "endpoint",request: newRequest("https://example.com", {method: "POST"// Specify POST method for testing})});const json = await response.json();
```


### `partial` option


[Section titled partial option](#partial-option)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@4.16.6`

Whether or not the Container API renders components as if they were [page partials](/en/basics/astro-pages/#page-partials). This is usually the behavior you want when rendering `components.boolean` so you can render components without a full page shell.

To render a component as a full Astro page, including `<!DOCTYPE html>`, you can opt-out of this behavior by setting `partial` to `false`:

```
import Blog from"../src/pages/Blog.astro";const result = await container.renderToString(Card, {partial: false});console.log(result) // includes `<!DOCTYPE html>` at the beginning of the HTML
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 170. `en/reference/content-loader-reference/.md`

```text
# Astro Content Loader API



# Astro Content Loader API


Astro’s Content Loader API allows you to load your data from any source, local or remote, and interact with Astro’s content layer to manage your [content collections](/en/guides/content-collections/).


## What is a loader?


[Section titled What is a loader?](#what-is-a-loader)

Astro loaders allow you to load data into [content collections](/en/guides/content-collections/), which can then be used in pages and components. The [built-in `glob()` and `file()` loaders](/en/guides/content-collections/#built-in-loaders) are used to load content from the file system, and you can create your own loaders to load content from other sources.

Each collection needs [a loader defined in its schema](/en/guides/content-collections/#defining-the-collection-loader). You can define a loader inline in your project’s `src/content.config.ts` file, share one loader between multiple collections, or even [publish your loader to NPM as a package](/en/reference/publish-to-npm/) to share with others and be included in our integrations library.


## Built-in loaders


[Section titled Built-in loaders](#built-in-loaders)

Astro provides two built-in loaders to help you fetch your collections. Both offer options to suit a wide range of use cases.


### `glob()` loader


[Section titled glob() loader](#glob-loader)

**Type:** `(options: GlobOptions) => [Loader](#the-loader-object)`

**Added in:** `astro@5.0.0`

The `glob()` loader creates entries from directories of files from anywhere on the filesystem. The supported file types are Markdown, MDX, Markdoc, JSON, and YAML files.

This loader accepts an object with the following properties: `pattern`, `base` (optional), and `generateId` (optional).

src/content.config.ts

```
import { defineCollection } from'astro:content';import { glob } from'astro/loaders';const pages = defineCollection({/* Retrieve all Markdown files in your pages directory. */loader: glob({ pattern: "**/*.md", base: "./src/data/pages" }),schema: /* ... */});const blog = defineCollection({/* Retrieve all Markdown and MDX files in your blog directory. */loader: glob({ pattern: "**/*.(md|mdx)", base: "./src/data/blog" }),schema: /* ... */});const authors = defineCollection({/* Retrieve all JSON files in your authors directory while retaining* uppercase letters in the ID. */loader: glob({pattern: '**/*.json',base: "./src/data/authors",generateId: ({ entry }) => entry.replace(/\.json$/, ''),}),schema: /* ... */});
```


#### `pattern`


[Section titled pattern](#pattern)

**Type:** `string | string[]`

The `pattern` property accepts a string or an array of strings using glob matching (e.g. wildcards, globstars). The patterns must be relative to the base directory of entry files to match.

You can learn more about the syntax to use in the [micromatch documentation](https://github.com/micromatch/micromatch#matching-features). You can also verify the validity of your pattern using an online tool like the [DigitalOcean Glob Tool](https://www.digitalocean.com/community/tools/glob).


#### `base`


[Section titled base](#base)

**Type:** `string | URL` **Default:** `"."`

A relative path or [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) to the directory from which to resolve the `pattern`.


#### `generateId()`


[Section titled generateId()](#generateid)

**Type:** `(options: GenerateIdOptions) => string`

A callback function that returns a unique string per entry in a collection. It accepts an object as parameter with the following properties:

-   `entry` - the path to the entry file, relative to the base directory
-   `base` - the base directory [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)
-   `data` - the parsed, unvalidated data of the entry

By default it uses [`github-slugger`](https://github.com/Flet/github-slugger) to generate a slug with [kebab-cased](https://developer.mozilla.org/en-US/docs/Glossary/Kebab_case) words.


### `file()` loader


[Section titled file() loader](#file-loader)

**Type:** `(fileName: string, options?: FileOptions) => [Loader](#the-loader-object)`

**Added in:** `astro@5.0.0`

The `file()` loader creates entries from a single file that contains an array of objects with a unique `id` field, or an object with IDs as keys and entries as values. It supports JSON or YAML, and you can provide a custom `parser` for data files it cannot parse by default.

This loader accepts a `fileName` property and an optional object as second argument:

src/content.config.ts

```
import { defineCollection } from'astro:content';import { file } from'astro/loaders';const authors = defineCollection({/* Retrieve all entries from a JSON file. */loader: file("src/data/authors.json"),schema: /* ... */});const products = defineCollection({/* Retrieve all entries from a CSV file using a custom parser. */loader: file("src/data/products.csv", {parser: (fileContent) => { /* your parser logic */ },}),schema: /* ... */});
```


#### `fileName`


[Section titled fileName](#filename)

**Type:** `string`

Sets the path to the file to load, relative to the root directory.


#### Options


[Section titled Options](#options)

**Type:** `FileOptions`

An optional object with the following properties:


##### `parser()`


[Section titled parser()](#parser)

**Type:** `(text: string) => Record<string, Record<string, unknown>> | Array<Record<string, unknown>>`

A callback function to create a collection from a file’s contents. Use it when you need to process file not supported by default (e.g. `.csv`) or when using [nested `.json` documents](/en/guides/content-collections/#nested-json-documents).


## Loader types


[Section titled Loader types](#loader-types)

Loaders can be defined either as a simple function that returns an array of entries or with the more powerful object Content Loader API for more control over the loading process.


### Inline loaders


[Section titled Inline loaders](#inline-loaders)

An inline loader is an async function that returns an array or object containing entries. Use this for simple loaders, particularly those that are defined inline in the `src/content.config.ts` file.

The function can be async and must return either an array of entries that each contain a unique `id` field, or an object where each key is a unique ID and each value is the entry. Whenever the loader is invoked, it will clear the store and reload all the entries.

src/content.config.ts

```
const countries = defineCollection({loader: async () => {const response = await fetch("https://restcountries.com/v3.1/all");const data = await response.json();// Must return an array of entries with an id property// or an object with IDs as keys and entries as valuesreturn data.map((country) => ({id: country.cca3,...country,}));},schema: /* ... */});
```


### Object loaders


[Section titled Object loaders](#object-loaders)

A loader is an object with a `load()` method that is called at build time to fetch data and update the data store. It allows entries to be updated incrementally, or for the store to be cleared only when necessary. It can also define a schema for the entries, which can be used to validate the data and generate static types.

The recommended pattern is to define a function that accepts configuration options and returns the loader object, in the same way that you would normally define an Astro integration or Vite plugin.

loader.ts

```
importtype { Loader, LoaderContext } from'astro/loaders';import { z } from'astro:content';import { loadFeedData } from"./feed.js";// Define any options that the loader needsexportfunctionmyLoader(options: { url:string, apiKey:string }):Loader {// Configure the loaderconst feedUrl = newURL(options.url);// Return a loader objectreturn {name: "my-loader",// Called when updating the collection.load: async(context:LoaderContext):Promise<void> => {// Load data and update the storeconst response = await loadFeedData(feedUrl,options.apiKey);},// Optionally, define the schema of an entry.// It will be overridden by user-defined schema.schema: async()=> z.object({// ...})};}
```

These configuration options can then be set when defining a collection:

src/content.config.ts

```
import { defineCollection, z } from'astro:content';import myLoader from'../../loader.ts';const blog = defineCollection({loader: myLoader({url: "https://api.example.com/posts",apiKey: "my-secret",}),schema: /* ... */});
```


## Object loader API


[Section titled Object loader API](#object-loader-api)

The API for [inline loaders](#inline-loaders) is very simple, and is shown above. This section shows the API for defining an object loader.


### The `Loader` object


[Section titled The Loader object](#the-loader-object)

The loader object has the following properties:


#### `name`


[Section titled name](#name)

**Type**: `string`

A unique name for the loader, used in logs and [for conditional loading](/en/reference/integrations-reference/#refreshcontent-option).


#### `load`


[Section titled load](#load)

**Type**: `(context: [LoaderContext](#loadercontext)) => Promise<void>`

An async function that is called at build time to load data and update the store. See [`LoaderContext`](#loadercontext) for more information.


#### `schema`


[Section titled schema](#schema)

**Type**: `ZodSchema | Promise<ZodSchema> | (() => ZodSchema | Promise<ZodSchema>)`

An optional [Zod schema](/en/guides/content-collections/#defining-datatypes-with-zod) that defines the shape of the entries. It is used to both validate the data and also to generate TypeScript types for the collection.

If a function is provided, it will be called at build time before `load()` to generate the schema. You can use this to dynamically generate the schema based on the configuration options or by introspecting an API.


### `LoaderContext`


[Section titled LoaderContext](#loadercontext)

This object is passed to the `load()` method of the loader, and contains the following properties:


#### `collection`


[Section titled collection](#collection)

**Type**: `string`

The unique name of the collection. This is the key in the `collections` object in the `src/content.config.ts` file.


#### `store`


[Section titled store](#store)

**Type**: [`DataStore`](#datastore)

A database to store the actual data. Use this to update the store with new entries. See [`DataStore`](#datastore) for more information.


#### `meta`


[Section titled meta](#meta)

**Type**: `MetaStore`

A key-value store scoped to the collection, designed for things like sync tokens and last-modified times. This metadata is persisted between builds alongside the collection data but is only available inside the loader.

```
const lastModified = meta.get("lastModified");// ...meta.set("lastModified", newDate().toISOString());
```


#### `logger`


[Section titled logger](#logger)

**Type**: [`AstroIntegrationLogger`](/en/reference/integrations-reference/#astrointegrationlogger)

A logger that can be used to log messages to the console. Use this instead of `console.log` for more helpful logs that include the loader name in the log message. See [`AstroIntegrationLogger`](/en/reference/integrations-reference/#astrointegrationlogger) for more information.


#### `config`


[Section titled config](#config)

**Type**: `AstroConfig`

The full, resolved Astro configuration object with all defaults applied. See [the configuration reference](/en/reference/configuration-reference/) for more information.


#### `parseData`


[Section titled parseData](#parsedata)

**Type**: `(props: ParseDataOptions<TData>) => Promise<TData>`

Validates and parses the data according to the collection schema. Pass data to this function to validate and parse it before storing it in the data store.

loader.ts

```
importtype { Loader } from"astro/loaders";import { loadFeed } from"./feed.js";exportfunctionfeedLoader({ url }):Loader {const feedUrl = newURL(url);return {name: "feed-loader",load: async({ store,logger,parseData,meta,generateDigest })=> {logger.info("Loading posts");const feed = loadFeed(feedUrl);store.clear();for (const itemof feed.items) {const data = await parseData({id: item.guid,data: item,});store.set({id,data,});}},};}
```


#### `generateDigest`


[Section titled generateDigest](#generatedigest)

**Type**: `(data: Record<string, unknown> | string) => string`

Generates a non-cryptographic content digest of an object or string. This can be used to track if the data has changed by setting [the `digest` field](#digest) of an entry.

loader.ts

```
importtype { Loader } from"astro/loaders";import { loadFeed } from"./feed.js";exportfunctionfeedLoader({ url }):Loader {const feedUrl = newURL(url);return {name: "feed-loader",load: async({ store,logger,parseData,meta,generateDigest })=> {logger.info("Loading posts");const feed = loadFeed(feedUrl);store.clear();for (const itemof feed.items) {const data = await parseData({id: item.guid,data: item,});const digest = generateDigest(data);store.set({id,data,digest,});}},};}
```


#### `watcher`


[Section titled watcher](#watcher)

**Type**: `FSWatcher`

When running in dev mode, this is a filesystem watcher that can be used to trigger updates. See [`ViteDevServer`](https://vite.dev/guide/api-javascript.html#vitedevserver) for more information.

Extract from the file() loader

```
return {name: 'file-loader',load: async({ config, store, watcher })=> {const url = newURL(fileName, config.root);const filePath = fileURLToPath(url);awaitsyncData(filePath, store);watcher?.on('change', async(changedPath)=> {if (changedPath === filePath) {logger.info(`Reloading data from ${fileName}`);awaitsyncData(filePath, store);}});},};
```


#### `refreshContextData`


[Section titled refreshContextData](#refreshcontextdata)

**Type**: `Record<string, unknown>`

If the loader has been triggered by an integration, this may optionally contain extra data set by that integration. It is only set when the loader is triggered by an integration. See the [`astro:server:setup`](/en/reference/integrations-reference/#refreshcontent-option) hook reference for more information.

loader.ts

```
exportfunctionmyLoader(options: { url:string }):Loader {return {name: "my-loader",load: async({ refreshContextData,store,logger })=> {if(refreshContextData?.webhookBody) {logger.info("Webhook triggered with body");processWebhook(store, refreshContextData.webhookBody);}// ...},};}
```


### `DataStore`


[Section titled DataStore](#datastore)

The data store is a loader’s interface to the content collection data. It is a key-value (KV) store, scoped to the collection, and therefore a loader can only access the data for its own collection.


#### `get`


[Section titled get](#get)

**Type**: `(key: string) => [DataEntry](#dataentry) | undefined`

Get an entry from the store by its ID. Returns `undefined` if the entry does not exist.

```
const existingEntry = store.get("my-entry");
```

The returned object is a [`DataEntry`](#dataentry) object.


#### `set`


[Section titled set](#set)

**Type**: `(entry: [DataEntry](#dataentry)) => boolean`

Used after data has been [validated and parsed](#parsedata) to add an entry to the store, returning `true` if the entry was set. This returns `false` when the [`digest`](#digest) property determines that an entry has not changed and should not be updated.

loader.ts

```
for (const itemof feed.items) {const data = await parseData({id: item.guid,data: item,});const digest = generateDigest(data);store.set({id,data,rendered: {html: data.description??"",},digest,});}
```


#### `entries`


[Section titled entries](#entries)

**Type**: `() => Array<[id: string, DataEntry]>`

Get all entries in the collection as an array of key-value pairs.


#### `keys`


[Section titled keys](#keys)

**Type**: `() => Array<string>`

Get all the keys of the entries in the collection.


#### `values`


[Section titled values](#values)

**Type**: `() => Array<DataEntry>`

Get all entries in the collection as an array.


#### `delete`


[Section titled delete](#delete)

**Type**: `(key: string) => void`

Delete an entry from the store by its ID.


#### `clear`


[Section titled clear](#clear)

**Type**: `() => void`

Clear all entries from the collection.


#### `has`


[Section titled has](#has)

**Type**: `(key: string) => boolean`

Check if an entry exists in the store by its ID.


### `DataEntry`


[Section titled DataEntry](#dataentry)

This is the type of the object that is stored in the data store. It has the following properties:


#### `id`


[Section titled id](#id)

**Type**: `string`

An identifier for the entry, which must be unique within the collection. This is used to look up the entry in the store and is the key used with `getEntry` for that collection.


#### `data`


[Section titled data](#data)

**Type**: `Record<string, unknown>`

The actual data for the entry. When a user accesses the collection, this will have TypeScript types generated according to the collection schema.

It is the loader’s responsibility to use [`parseData`](#parsedata) to validate and parse the data before storing it in the data store: no validation is done when getting or setting the data.


#### `filePath`


[Section titled filePath](#filepath)

**Type**: `string | undefined`

A path to the file that is the source of this entry, relative to the root of the site. This only applies to file-based loaders and is used to resolve paths such as images or other assets.

If not set, then any fields in the schema that use [the `image()` helper](/en/guides/images/#images-in-content-collections) will be treated as [public paths](/en/guides/images/#where-to-store-images) and not transformed.


#### `body`


[Section titled body](#body)

**Type**: `string | undefined`

The raw body of the entry, if applicable. If the entry includes [rendered content](#rendered), then this field can be used to store the raw source. This is optional and is not used internally.


#### `digest`


[Section titled digest](#digest)

**Type**: `string | undefined`

An optional content digest for the entry. This can be used to check if the data has changed.

When [setting an entry](#set), the entry will only update if the digest does not match an existing entry with the same ID.

The format of the digest is up to the loader, but it must be a string that changes when the data changes. This can be done with the [`generateDigest`](#generatedigest) function.


#### `rendered`


[Section titled rendered](#rendered)

**Type**: `RenderedContent | undefined`

Stores an object with an entry’s rendered content and metadata if it has been rendered to HTML. For example, this can be used to store the rendered content of a Markdown entry, or HTML from a CMS.

If this field is provided, then [the `render()` function and `<Content />` component](/en/guides/content-collections/#rendering-body-content) are available to render the entry in a page.

The format of the `RenderedContent` object is:

```
{/** Rendered HTML string. If present then `render(entry)` will return a component that renders this HTML. */html: string;metadata?: {/** Any images that are present in this entry. Relative to the {@linkDataEntry} filePath. */imagePaths?: Array<string>;/** Any headings that are present in this file. Returned as `headings` from `render()` */headings?: MarkdownHeading[];/** Raw frontmatter, parsed from the file. This may include data from remark plugins. */frontmatter?: Record<string, any>;/** Any other metadata that is present in this file. */[key: string]: unknown;};}
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 171. `en/reference/dev-toolbar-app-reference/.md`

```text
# Dev Toolbar App API



# Dev Toolbar App API


The Astro Dev Toolbar App API allows you to create [Astro Integrations](/en/reference/integrations-reference/) that add apps to the Astro Dev Toolbar. This allows you to add new features and integrations with third-party services.

**Related recipe:** [Create a dev toolbar app](/en/recipes/making-toolbar-apps/)


## Toolbar app integration setup


[Section titled Toolbar app integration setup](#toolbar-app-integration-setup)

Integrations can add apps to the dev toolbar in [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup).

my-integration.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "my-integration",hooks: {"astro:config:setup": ({ addDevToolbarApp })=> {addDevToolbarApp({id: "my-app",name: "My App",icon: "<svg>...</svg>",entrypoint: "./my-app.js",});},},});
```


### `addDevToolbarApp()`


[Section titled addDevToolbarApp()](#adddevtoolbarapp)

A function available to [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup) that adds dev toolbar apps. It takes an object with the following required properties to define the toolbar app: [`id`](#id), [`name`](#name), [`icon`](#icon), and [`entrypoint`](#entrypoint).


### `id`


[Section titled id](#id)

A unique identifier for the app. This will be used to uniquely identify the app in hooks and events.

my-integration.js

```
{id: 'my-app',// ...}
```


### `name`


[Section titled name](#name)

The name of the app. This will be shown to users whenever the app needs to be referenced using a human-readable name.

my-integration.js

```
{// ...name: 'My App',// ...}
```


### `icon`


[Section titled icon](#icon)

The icon used to display the app in the toolbar. This can either be an icon from [the icon list](#icons), or a string containing the SVG markup of the icon.

my-integration.js

```
{// ...icon: '<svg>...</svg>', // or, e.g. 'astro:logo'// ...}
```


### `entrypoint`


[Section titled entrypoint](#entrypoint)

The path to the file that exports the dev toolbar app.

my-integration.js

```
{// ...entrypoint: './my-app.js',}
```

**Added in:** `astro@5.0.0`

The function also accepts a `URL` as `entrypoint`:

my-integration.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "my-integration",hooks: {"astro:config:setup": ({ addDevToolbarApp })=> {addDevToolbarApp({id: "my-app",name: "My App",icon: "<svg>...</svg>",entrypoint: newURL("./my-app.js", import.meta.url),});},},});
```


## Structure of a Dev Toolbar App


[Section titled Structure of a Dev Toolbar App](#structure-of-a-dev-toolbar-app)

A Dev Toolbar App is a `.js` or `.ts` file that default exports an object using the [`defineToolbarApp()` function](#definetoolbarapp) available from the `astro/toolbar` module.

src/my-app.js

```
import { defineToolbarApp } from"astro/toolbar";exportdefaultdefineToolbarApp({init(canvas) {consttext = document.createTextNode('Hello World!');canvas.appendChild(text);},beforeTogglingOff() {constconfirmation = window.confirm('Really exit?');return confirmation;}});
```


### `defineToolbarApp()`


[Section titled defineToolbarApp()](#definetoolbarapp)

**Added in:** `astro@4.7.0`

A function that defines the logic of your toolbar app when it is loaded and toggled off.

This function takes an object with an [`init()`](#init) function that will be called when the dev toolbar app is loaded. It can also take a [`beforeTogglingOff()`](#beforetogglingoff) function that will run when the toolbar app is clicked to toggle off its active status.


### `init()`


[Section titled init()](#init)

**Signature:** `init(canvas: ShadowRoot, app: ToolbarAppEventTarget, server: ToolbarServerHelpers) => void`

Although not required, most apps will use this function to define the core behavior of the app. This function will be called only once when the app is loaded, which will either be when the browser is idle or when the user clicks on the app in the UI, depending on which one comes first.

The function receives three arguments to define your app logic: [`canvas`](#canvas) (to render elements to the screen), [`app`](#app) (to send and receive client-side events from the dev toolbar), and [`server`](#server) (to communicate with the server).


#### `canvas`


[Section titled canvas](#canvas)

A standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot) that the app can use to render its UI. Elements can be created and added to the ShadowRoot using the standard DOM APIs.

Every app receives its own dedicated ShadowRoot for rendering its UI. Additionally, the parent element is positioned using `position: absolute;` so the app UI will not affect the layout of an Astro page.

src/my-app.js

```
exportdefaultdefineToolbarApp({init(canvas) {canvas.appendChild(document.createTextNode('Hello World!'))}});
```


#### `app`


[Section titled app](#app)

**Added in:** `astro@4.7.0`

A standard [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) with a few additional [helpers for client-side events](#client-side-events) that can be used to send and receive events from the Dev toolbar.

src/my-app.js

```
exportdefaultdefineToolbarApp({init(canvas, app) {app.onToggled(({ state })=> {consttext = document.createTextNode(`The app is now ${state?"enabled":"disabled"}!`,);canvas.appendChild(text);});},});
```


#### `server`


[Section titled server](#server)

**Added in:** `astro@4.7.0`

An object that can be used to [communicate with the server](#client-server-communication).

src/my-app.js

```
exportdefaultdefineToolbarApp({init(canvas, app, server) {server.send('my-message', { message: 'Hello!' });server.on('server-message', (data)=> {console.log(data.message);});},});
```


### `beforeTogglingOff()`


[Section titled beforeTogglingOff()](#beforetogglingoff)

**Signature:** `beforeTogglingOff(canvas: ShadowRoot): boolean | void`

**Added in:** `astro@4.7.0`

This optional function will be called when the user clicks on the app icon in the UI to toggle off the app. This function can be used, for example, to perform cleanup operations, or to ask the user for confirmation before toggling off the app.

If a falsy value is returned, the toggling off will be cancelled and the app will stay enabled.

src/my-app.js

```
exportdefaultdefineToolbarApp({// ...beforeTogglingOff() {constconfirmation = window.confirm('Are you sure you want to disable this app?');return confirmation;}});
```


#### canvas


[Section titled canvas](#canvas-1)

The ShadowRoot of the app, can be used to render any UI needed before closing. Same as the [`canvas` argument of the `init` function](#canvas).


## Client-side Events


[Section titled Client-side Events](#client-side-events)

In addition to the standard methods of an `EventTarget` ([`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget), [`dispatchEvent`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent), [`removeEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)etc.), the [`app`](#app) object also has the following methods:


### `onToggled()`


[Section titled onToggled()](#ontoggled)

**Signature:** `onToggled(callback: (options: {state: boolean})) => void`

**Added in:** `astro@4.7.0`

Registers a callback to be called when the user clicks on the app icon in the UI to toggle the app on or off.

src/my-app.js

```
app.onToggled((options)=> {console.log(`The app is now ${options.state?'enabled':'disabled'}!`);});
```


### `onToolbarPlacementUpdated()`


[Section titled onToolbarPlacementUpdated()](#ontoolbarplacementupdated)

**Signature:** `onToolbarPlacementUpdated(callback: (options: {placement: 'bottom-left' | 'bottom-center' | 'bottom-right'})) => void`

**Added in:** `astro@4.7.0`

This event is fired when the user changes the placement of the Dev Toolbar. This can, for example, be used to reposition the app’s UI when the toolbar is moved.

src/my-app.js

```
app.onToolbarPlacementUpdated((options)=> {console.log(`The toolbar is now placed at ${options.placement}!`);});
```


### `toggleState()`


[Section titled toggleState()](#togglestate)

**Signature:** `toggleState(options: {state: boolean}) => void`

**Added in:** `astro@4.7.0`

Changes the state of the app. This can be used to enable or disable the app programmatically, for example, when the user clicks on a button in the app’s UI.

src/my-app.js

```
app.toggleState({ state: false });
```


### `toggleNotification()`


[Section titled toggleNotification()](#togglenotification)

**Signature:** `toggleNotification(options: {state?: boolean, level?: 'error' | 'warning' | 'info'}) => void`

**Added in:** `astro@4.7.0`

Toggles a notification on the app icon. This can be used to inform the user that the app requires attention, or remove the current notification.

src/my-app.js

```
app.toggleNotification({state: true,level: 'warning',});
```


#### `state: boolean`


[Section titled state: boolean](#state-boolean)

Indicates whether or not the app has a notification for the user. When `true`, the app icon will be highlighted. Conversely, when `false`, the highlight will be removed. If this property is not specified, `true` will be assumed.


#### `level: 'error' | 'warning' | 'info'`


[Section titled level: &#39;error&#39; | &#39;warning&#39; | &#39;info&#39;](#level-error--warning--info)

Indicates the level of the notification. This will be used to determine the color and shape (dark pink circle, gold triangle, or blue square) of the highlight on the app icon. If this property is not specified, `'error'` will be assumed.


## Client-Server Communication


[Section titled Client-Server Communication](#client-server-communication)

Using [Vite’s methods for client-server communication](https://vite.dev/guide/api-plugin.html#client-server-communication), Dev Toolbar Apps and the server can communicate with each other. In order to facilitate sending and receiving custom messages, helper methods are provided for use both in your toolbar app (on the client) and in your integration (on the server).


### On the client


[Section titled On the client](#on-the-client)

In your app, use the [`server` object on the `init()` hook](#server) to send and receive messages to and from the server.

src/my-app.js

```
exportdefaultdefineToolbarApp({init(canvas, app, server) {server.send('my-message', { message: 'Hello!' });server.on('server-message', (data)=> {console.log(data.message);});},});
```


#### `send()`


[Section titled send()](#send)

**Signature:** `send<T>(event: stringify, data: T) => void`

**Added in:** `astro@4.7.0`

Sends data to the server from logic defined in your toolbar app.

src/my-app.js

```
init(canvas, app, server) {server.send('my-app:my-message', { message: 'Hello!' });}
```

When sending messages from the client to the server, it is good practice to prefix the event name with the app ID or other namespaces to avoid conflicts with other apps or other integrations that may be listening for messages.


#### `on()`


[Section titled on()](#on)

**Signature:** `on<T>(event: string, callback: (data: T) => void) => void`

**Added in:** `astro@4.7.0`

Registers a callback to be called when the server sends a message with the specified event.

src/my-app.js

```
init(canvas, app, server) {server.on('server-message', (data)=> {console.log(data.message);});}
```


### On the server


[Section titled On the server](#on-the-server)

In an integration, such as [the integration that adds your toolbar app](#toolbar-app-integration-setup), use the [`astro:server:setup` hook](/en/reference/integrations-reference/#astroserversetup) to access the `toolbar` object to send and receive messages to and from your apps.

my-integration.js

```
exportdefault()=> ({name: "my-integration",hooks: {"astro:config:setup": ({ addDevToolbarApp })=> {},"astro:server:setup": ({ toolbar })=> {},},});
```


#### `send()`


[Section titled send()](#send-1)

**Signature:** `send<T>(event: string, data: T) => void`

**Added in:** `astro@4.7.0`

Sends data to the client.

my-integration.js

```
'astro:server:setup': ({ toolbar })=> {toolbar.send('server-message', { message: 'Hello!' });},
```


#### `on()`


[Section titled on()](#on-1)

**Signature:** `on<T>(event: string, callback: (data: T) => void) => void`

**Added in:** `astro@4.7.0`

Registers a callback to be called when the client sends a message with the specified event.

my-integration.js

```
'astro:server:setup': ({ toolbar })=> {toolbar.on('my-app:my-message', (data)=> {console.log(data.message);});},
```


#### `onInitialized()`


[Section titled onInitialized()](#oninitialized)

**Signature:** `onInitialized(appId: string, callback: () => void) => void`

**Added in:** `astro@4.7.0`

Registers a callback to be called when the app is initialized.

my-integration.js

```
'astro:server:setup': ({ toolbar })=> {toolbar.onInitialized('my-app', ()=> {console.log('The app is now initialized!');});},
```

Note

The built-in `connection` event from Vite fires **before** Dev Toolbar apps are initialized and therefore cannot be used directly by apps. Use the `onInitialized` method to ensure that the app is fully initialized before sending messages to it.


#### `onAppToggled()`


[Section titled onAppToggled()](#onapptoggled)

**Signature:** `onAppToggled(appId: string, callback: (options: {state: boolean}) => void) => void`

**Added in:** `astro@4.7.0`

Registers a callback to be called when the user clicks on the app icon in the UI to toggle the app on or off.

my-integration.js

```
'astro:server:setup': ({ toolbar })=> {toolbar.onAppToggled('my-app', ({ state })=> {console.log(`The app is now ${state?'enabled':'disabled'}!`);});},
```


## Component Library


[Section titled Component Library](#component-library)

The Dev Toolbar includes a set of web components that can be used to build apps with a consistent look and feel.


### `astro-dev-toolbar-window`


[Section titled astro-dev-toolbar-window](#astro-dev-toolbar-window)

Shows a window.

The slot of the component will be used as the content of the window.

```
<astro-dev-toolbar-window><p>My content</p></astro-dev-toolbar-window>
```

When building a window using JavaScript, slotted content must go inside the light DOM of the component.

```
const myWindow = document.createElement('astro-dev-toolbar-window');const myContent = document.createElement('p');myContent.textContent='My content';// use appendChild directly on `window`, not `myWindow.shadowRoot`myWindow.appendChild(myContent);
```


### `astro-dev-toolbar-button`


[Section titled astro-dev-toolbar-button](#astro-dev-toolbar-button)

Shows a button.

The slot of the component will be used as the content of the button.

```
const myButton = document.createElement('astro-dev-toolbar-button');myButton.textContent='Click me!';myButton.buttonStyle="purple";myButton.size="medium";myButton.addEventListener('click', ()=> {console.log('Clicked!');});
```


#### `size`


[Section titled size](#size)

The size of the button (`small`, `medium`, `large`).


#### `button-style`


[Section titled button-style](#button-style)

The style of the button (`ghost`, `outline`, `purple`, `gray`, `red`, `green`, `yellow`, `blue`). When using `ghost`, the button itself is invisible and only the content of the button will be shown.

In JavaScript, set this property using the `buttonStyle` property to avoid conflict with the native `style` property.


#### `button-border-radius`


[Section titled button-border-radius](#button-border-radius)

**Added in:** `astro@4.8.0`

The border radius of the button (`normal`, `rounded`). When using `rounded`, the button will have rounded corners and uniform padding on all sides.

In JavaScript, set this property using the `buttonBorderRadius` property.


### `astro-dev-toolbar-badge`


[Section titled astro-dev-toolbar-badge](#astro-dev-toolbar-badge)

Shows a badge.

The slot of the component will be used as the content of the badge.

```
<astro-dev-toolbar-badge>My badge</astro-dev-toolbar-badge>
```


#### `size`


[Section titled size](#size-1)

The size of the badge (`small`, `large`).


#### `badge-style`


[Section titled badge-style](#badge-style)

The style (color) of the badge (`purple`, `gray`, `red`, `green`, `yellow`, `blue`).

In JavaScript, set this property using the `badgeStyle` property to avoid conflict with the native `style` property.


### `astro-dev-toolbar-card`


[Section titled astro-dev-toolbar-card](#astro-dev-toolbar-card)

Shows a card. Specify an optional `link` attribute to make the card act like an `<a>` element.

When making a card using JavaScript, a `clickAction` property can be specified to make the card act like a `<button>` element.

The slot of the component will be used as the content of the card.

```
<astro-dev-toolbar-cardicon="astro:logo"link="https://github.com/withastro/astro/issues/new/choose">Report an issue</astro-dev-toolbar-card>
```


#### `card-style`


[Section titled card-style](#card-style)

The style of the card (`purple`, `gray`, `red`, `green`, `yellow`, `blue`). The color is only applied to the border of the card on hover.

In JavaScript, set this property using the `cardStyle`.


### `astro-dev-toolbar-toggle`


[Section titled astro-dev-toolbar-toggle](#astro-dev-toolbar-toggle)

Shows a toggle element, acting as a checkbox. This element internally is a simple wrapper around a native `<input type="checkbox">` element. The checkbox element can be accessed using the `input` property.

```
const toggle = document.createElement('astro-dev-toolbar-toggle');toggle.input.addEventListener('change', (evt)=> {console.log(`The toggle is now ${evt.currentTarget.checked?'enabled':'disabled'}!`);});
```


### `astro-dev-toolbar-radio-checkbox`


[Section titled astro-dev-toolbar-radio-checkbox](#astro-dev-toolbar-radio-checkbox)

**Added in:** `astro@4.8.0`

Shows a radio checkbox. Similar to the `astro-dev-toolbar-toggle` component, this element is a simple wrapper around a native `<input type="radio">` element. The radio element can be accessed using the `input` property.

```
const radio = document.createElement('astro-dev-toolbar-radio-checkbox');radio.input.addEventListener('change', (evt)=> {console.log(`The radio is now ${evt.currentTarget.checked?'enabled':'disabled'}!`);});
```


#### `toggle-style`


[Section titled toggle-style](#toggle-style)

The style of the toggle (`purple`, `gray`, `red`, `green`, `yellow`, `blue`).

In JavaScript, set this property using the `toggleStyle` property.


### `astro-dev-toolbar-highlight`


[Section titled astro-dev-toolbar-highlight](#astro-dev-toolbar-highlight)

Can be used to highlight an element on the page. In most cases, you’ll want to position and resize this element using the `top`, `left`, `width` and `height` CSS properties to match the element you want to highlight.

```
<!-- Highlight the entire page --><astro-dev-toolbar-highlightstyle="top: 0; left: 0; width: 100%; height: 100%;"></astro-dev-toolbar-highlight>
```

```
const elementToHighlight = document.querySelector('h1');const rect = elementToHighlight.getBoundingClientRect();const highlight = document.createElement('astro-dev-toolbar-highlight');highlight.style.top=`${Math.max(rect.top+window.scrollY-10, 0)}px`;highlight.style.left=`${Math.max(rect.left+window.scrollX-10, 0)}px`;highlight.style.width=`${rect.width+15}px`;highlight.style.height=`${rect.height+15}px`;highlight.icon='astro:logo';
```


#### `style`


[Section titled style](#style)

The style of the highlight (`purple`, `gray`, `red`, `green`, `yellow`, `blue`).


#### `icon`


[Section titled icon](#icon-1)

An [icon](#icons) to show in the top right corner of the highlight.


### `astro-dev-toolbar-tooltip`


[Section titled astro-dev-toolbar-tooltip](#astro-dev-toolbar-tooltip)

Shows a tooltip with different sections. This component is set to `display: none;` by default and can be made visible using a `data-show="true"` attribute.

Sections are defined using the `sections` property. This property is an array of objects with the following shape:

```
{title?: string; // Title of the sectioninlineTitle?: string; // Title of the section, shown inline next to the titleicon?: Icon; // Icon of the sectioncontent?: string; // Content of the sectionclickAction?:()=>void|Promise<void>; // Action to perform when clicking on the sectionclickDescription?: string; // Description of the action to perform when clicking on the section}
```

```
const tooltip = document.createElement('astro-dev-toolbar-tooltip');tooltip.sections= [{title: 'My section',icon: 'astro:logo',content: 'My content',clickAction: ()=> {console.log('Clicked!')},clickDescription: 'Click me!'}]
```

This component is often combined with the `astro-dev-toolbar-highlight` component to show a tooltip when hovering a highlighted element:

```
const highlight = document.createElement('astro-dev-toolbar-highlight');// Position the highlight...const tooltip = document.createElement('astro-dev-toolbar-tooltip');// Add sections to the tooltip...highlight.addEventListener('mouseover', ()=> {tooltip.dataset.show='true';});highlight.addEventListener('mouseout', ()=> {tooltip.dataset.show='false';});
```


### `astro-dev-toolbar-icon`


[Section titled astro-dev-toolbar-icon](#astro-dev-toolbar-icon)

Shows an icon. An icon from [the icon list](#icons) can be specified using the `icon` attribute, or the SVG markup of an icon can be passed as a slot.

```
<astro-dev-toolbar-iconicon="astro:logo" />
```

```
<astro-dev-toolbar-icon><svg>...</svg></astro-dev-toolbar-icon>
```


#### Icons


[Section titled Icons](#icons)

Currently, the following icons are available and can be used in any component that accepts an icon:

-   `astro:logo`
-   `warning`
-   `arrow-down`
-   `bug`
-   `file-search`
-   `check-circle`
-   `gear`
-   `lightbulb`
-   `checkmark`
-   `dots-three`
-   `copy`

All of the above icons have `fill="currentColor"` set by default and will inherit their color from the parent element.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 172. `en/reference/directives-reference/.md`

```text
# Template directives reference



# Template directives reference


**Template directives** are a special kind of HTML attribute available inside of any Astro component template (`.astro` files), and some can also be used in `.mdx` files.

Template directives are used to control an element or component’s behavior in some way. A template directive could enable some compiler feature that makes your life easier (like using `class:list` instead of `class`). Or, a directive could tell the Astro compiler to do something special with that component (like hydrating with `client:load`).

This page describes all of the template directives available to you in Astro, and how they work.


## Rules


[Section titled Rules](#rules)

For a template directive to be valid, it must:

-   Include a colon `:` in its name, using the form `X:Y` (ex: `client:load`).
-   Be visible to the compiler (ex: `<X {...attr}>` would not work if `attr` contained a directive).

Some template directives, but not all, can take a custom value:

-   `<X client:load />` (takes no value)
-   `<X class:list={['some-css-class']} />` (takes an array)

A template directive is never included directly in the final HTML output of a component.


## Common Directives


[Section titled Common Directives](#common-directives)


### `class:list`


[Section titled class:list](#classlist)

`class:list={...}` takes an array of class values and converts them into a class string. This is powered by @lukeed’s popular [clsx](https://github.com/lukeed/clsx) helper library.

`class:list` takes an array of several different possible value kinds:

-   `string`: Added to the element `class`
-   `Object`: All truthy keys are added to the element `class`
-   `Array`: flattened
-   `false`, `null`, or `undefined`: skipped

```
<!-- This --><spanclass:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} /><!-- Becomes --><spanclass="hello goodbye world friend"></span>
```


### `set:html`


[Section titled set:html](#sethtml)

`set:html={string}` injects an HTML string into an element, similar to setting `el.innerHTML`.

**The value is not automatically escaped by Astro!** Be sure that you trust the value, or that you have escaped it manually before passing it to the template. Forgetting to do this will open you up to [Cross Site Scripting (XSS) attacks.](https://owasp.org/www-community/attacks/xss/)

```
---const rawHTMLString = "Hello <strong>World</strong>"---<h1>{rawHTMLString}</h1><!-- Output: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> --><h1set:html={rawHTMLString} /><!-- Output: <h1>Hello <strong>World</strong></h1> -->
```

You can also use `set:html` on a `<Fragment>` to avoid adding an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS.

```
---const cmsContent = await fetchHTMLFromMyCMS();---<Fragmentset:html={cmsContent}>
```

`set:html={Promise<string>}` injects an HTML string into an element that is wrapped in a Promise.

This can be used to inject HTML stored externally, such as in a database.

```
---import api from'../db/api.js';---<articleset:html={api.getArticle(Astro.props.id)}></article>
```

`set:html={Promise<Response>}` injects a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) into an element.

This is most helpful when using `fetch()`. For example, fetching old posts from a previous static-site generator.

```
<articleset:html={fetch('http://example/old-posts/making-soup.html')}></article>
```

`set:html` can be used on any tag and does not have to include HTML. For example, use with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) on a `<script>` tag to add a [JSON-LD](https://json-ld.org/) schema to your page.

```
<scripttype="application/ld+json"set:html={JSON.stringify({"@context": "https://schema.org/","@type": "Person",name: "Houston",hasOccupation: {"@type": "Occupation",name: "Astronaut"}})}/>
```


### `set:text`


[Section titled set:text](#settext)

`set:text={string}` injects a text string into an element, similar to setting `el.innerText`. Unlike `set:html`, the `string` value that is passed is automatically escaped by Astro.

This is equivalent to just passing a variable into a template expression directly (ex: `<div>{someText}</div>`) and therefore this directive is not commonly used.


## Client Directives


[Section titled Client Directives](#client-directives)

These directives control how [UI Framework components](/en/guides/framework-components/) are hydrated on the page.

By default, a UI Framework component is not hydrated in the client. If no `client:*` directive is provided, its HTML is rendered onto the page without JavaScript.

A client directive can only be used on a UI framework component that is directly imported into a `.astro` component. Hydration directives are not supported when using [dynamic tags](/en/reference/astro-syntax/#dynamic-tags) and [custom components passed via the `components` prop](/en/guides/integrations-guide/mdx/#custom-components-with-imported-mdx).


### `client:load`


[Section titled client:load](#clientload)

-   **Priority:** High
-   **Useful for:** Immediately-visible UI elements that need to be interactive as soon as possible.

Load and hydrate the component JavaScript immediately on page load.

```
<BuyButtonclient:load />
```


### `client:idle`


[Section titled client:idle](#clientidle)

-   **Priority:** Medium
-   **Useful for:** Lower-priority UI elements that don’t need to be immediately interactive.

Load and hydrate the component JavaScript once the page is done with its initial load and the `requestIdleCallback` event has fired. If you are in a browser that doesn’t support [`requestIdleCallback`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), then the document [`load`](https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event) event is used.

```
<ShowHideButtonclient:idle />
```


#### `timeout`


[Section titled timeout](#timeout)

**Added in:** `astro@4.15.0`

The maximum time to wait, in milliseconds, before hydrating the component, even if the page is not yet done with its initial load.

This allows you to pass a value for [the `timeout` option from the `requestIdleCallback()` specification](https://www.w3.org/TR/requestidlecallback/#the-requestidlecallback-method). This means you can delay hydration for lower-priority UI elements with more control to ensure your element is interactive within a specified time frame.

```
<ShowHideButtonclient:idle={{timeout: 500}} />
```


### `client:visible`


[Section titled client:visible](#clientvisible)

-   **Priority:** Low
-   **Useful for:** Low-priority UI elements that are either far down the page (“below the fold”) or so resource-intensive to load that you would prefer not to load them at all if the user never saw the element.

Load and hydrate the component JavaScript once the component has entered the user’s viewport. This uses an `IntersectionObserver` internally to keep track of visibility.

```
<HeavyImageCarouselclient:visible />
```


#### `client:visible={{rootMargin}}`


[Section titled client:visible={{rootMargin}}](#clientvisiblerootmargin)

**Added in:** `astro@4.1.0`

Optionally, a value for `rootMargin` can be passed to the underlying `IntersectionObserver`. When `rootMargin` is specified, the component JavaScript will hydrate when a specified margin (in pixels) around the component enters the viewport, rather than the component itself.

```
<HeavyImageCarouselclient:visible={{rootMargin: "200px"}} />
```

Specifying a `rootMargin` value can reduce layout shifts (CLS), allow more time for a component to hydrate on slower internet connections, and make components interactive sooner, enhancing the stability and responsiveness of the page.


### `client:media`


[Section titled client:media](#clientmedia)

-   **Priority:** Low
-   **Useful for:** Sidebar toggles, or other elements that might only be visible on certain screen sizes.

`client:media={string}` loads and hydrates the component JavaScript once a certain CSS media query is met.

Note

If the component is already hidden and shown by a media query in your CSS, then it can be easier to just use `client:visible` and not pass that same media query into the directive.

```
<SidebarToggleclient:media="(max-width: 50em)" />
```


### `client:only`


[Section titled client:only](#clientonly)

`client:only={string}` **skips** HTML server rendering, and renders only on the client. It acts similarly to `client:load` in that it loads, renders, and hydrates the component immediately on page load.

**You must pass the component’s correct framework as a value!** Because Astro doesn’t run the component during your build / on the server, Astro doesn’t know what framework your component uses unless you tell it explicitly.

```
<SomeReactComponentclient:only="react" /><SomePreactComponentclient:only="preact" /><SomeSvelteComponentclient:only="svelte" /><SomeVueComponentclient:only="vue" /><SomeSolidComponentclient:only="solid-js" />
```


#### Display loading content


[Section titled Display loading content](#display-loading-content)

For components that render only on the client, it is also possible to display fallback content while they are loading. Use `slot="fallback"` on any child element to create content that will be displayed only until your client component is available:

```
<ClientComponentclient:only="vue"><divslot="fallback">Loading</div></ClientComponent>
```


### Custom Client Directives


[Section titled Custom Client Directives](#custom-client-directives)

Since Astro 2.6.0, integrations can also add custom `client:*` directives to change how and when components should be hydrated.

Visit the [`addClientDirective` API](/en/reference/integrations-reference/#addclientdirective-option) page to learn more about creating a custom client directive.


## Server Directives


[Section titled Server Directives](#server-directives)

These directives control how server island components are rendered.


### `server:defer`


[Section titled server:defer](#serverdefer)

The `server:defer` directive transforms the component into a server island, causing it to be rendered on demand, outside the scope of the rest of the page rendering.

See more about using [server island components](/en/guides/server-islands/).

```
<Avatarserver:defer />
```


## Script & Style Directives


[Section titled Script &amp; Style Directives](#script--style-directives)

These directives can only be used on HTML `<script>` and `<style>` tags, to control how your client-side JavaScript and CSS are handled on the page.


### `is:global`


[Section titled is:global](#isglobal)

By default, Astro automatically scopes `<style>` CSS rules to the component. You can opt-out of this behavior with the `is:global` directive.

`is:global` makes the contents of a `<style>` tag apply globally on the page when the component is included. This disables Astro’s CSS scoping system. This is equivalent to wrapping all of the selectors within a `<style>` tag with `:global()`.

You can combine `<style>` and `<style is:global>` together in the same component, to create some global style rules while still scoping most of your component CSS.

See the [Styling & CSS](/en/guides/styling/#global-styles) page for more details about how global styles work.

```
<styleis:global>bodya { color: red; }</style>
```


### `is:inline`


[Section titled is:inline](#isinline)

By default, Astro will process, optimize, and bundle any `<script>` and `<style>` tags that it sees on the page. You can opt-out of this behavior with the `is:inline` directive.

`is:inline` tells Astro to leave the `<script>` or `<style>` tag as-is in the final output HTML. The contents will not be processed, optimized, or bundled. This limits some Astro features, like importing an npm package or using a compile-to-CSS language like Sass.

The `is:inline` directive means that `<style>` and `<script>` tags:

-   Will not be bundled into an external file. This means that [attributes like `defer`](https://javascript.info/script-async-defer) which control the loading of an external file will have no effect.
-   Will not be deduplicated—the element will appear as many times as it is rendered.
-   Will not have its `import`/`@import`/`url()` references resolved relative to the `.astro` file.
-   Will be rendered in the final output HTML exactly where it is authored.
-   Styles will be global and not scoped to the component.

Caution

The `is:inline` directive is implied whenever any attribute other than `src` is used on a `<script>` or `<style>` tag. The one exception is using the [`define:vars` directive](/en/reference/directives-reference/#definevars) on the `<style>` tag, which does not automatically imply `is:inline`.

```
<styleis:inline>/* inline: relative & npm package imports are not supported. */@import'/assets/some-public-styles.css';span { color: green; }</style><scriptis:inline>/* inline: relative & npm package imports are not supported. */console.log('I am inlined right here in the final output HTML.');</script>
```

See how [client-side scripts](/en/guides/client-side-scripts/) work in Astro components.


### `define:vars`


[Section titled define:vars](#definevars)

`define:vars={...}` can pass server-side variables from your component frontmatter into the client `<script>` or `<style>` tags. Any JSON-serializable frontmatter variable is supported, including `props` passed to your component through `Astro.props`. Values are serialized with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

```
---const foregroundColor = "rgb(221 243 228)";const backgroundColor = "rgb(24 121 78)";const message = "Astro is awesome!";---<styledefine:vars={{ textColor: foregroundColor, backgroundColor }}>h1 {background-color: var(--backgroundColor);color: var(--textColor);}</style><scriptdefine:vars={{ message }}>alert(message);</script>
```

Caution

Using `define:vars` on a `<script>` tag implies the [`is:inline` directive](#isinline), which means your scripts won’t be bundled and will be inlined directly into the HTML.

This is because when Astro bundles a script, it includes and runs the script once even if you include the component containing the script multiple times on one page. `define:vars` requires a script to rerun with each set of values, so Astro creates an inline script instead.

For scripts, try [passing variables to scripts manually](/en/guides/client-side-scripts/#pass-frontmatter-variables-to-scripts) instead.


## Advanced Directives


[Section titled Advanced Directives](#advanced-directives)


### `is:raw`


[Section titled is:raw](#israw)

`is:raw` instructs the Astro compiler to treat any children of that element as text. This means that all special Astro templating syntax will be ignored inside of this component.

For example, if you had a custom Katex component that converted some text to HTML, you could have users do this:

```
---import Katex from'../components/Katex.astro';---<Katexis:raw>Some conflicting {syntax} here</Katex>
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 173. `en/reference/error-reference/.md`

```text
# Error reference



# Error reference


The following reference is a complete list of the errors you may encounter while using Astro. For additional assistance, including common pitfalls, please also see our [Troubleshooting Guide](/en/guides/troubleshooting/).


## Astro Errors


[Section titled Astro Errors](#astro-errors)

-   [**UnknownCompilerError**](/en/reference/errors/unknown-compiler-error/)Unknown compiler error.
-   [**ClientAddressNotAvailable**](/en/reference/errors/client-address-not-available/)`Astro.clientAddress` is not available in current adapter.
-   [**PrerenderClientAddressNotAvailable**](/en/reference/errors/prerender-client-address-not-available/)`Astro.clientAddress` cannot be used inside prerendered routes.
-   [**StaticClientAddressNotAvailable**](/en/reference/errors/static-client-address-not-available/)`Astro.clientAddress` is not available in prerendered pages.
-   [**NoMatchingStaticPathFound**](/en/reference/errors/no-matching-static-path-found/)No static path found for requested path.
-   [**OnlyResponseCanBeReturned**](/en/reference/errors/only-response-can-be-returned/)Invalid type returned by Astro page.
-   [**MissingMediaQueryDirective**](/en/reference/errors/missing-media-query-directive/)Missing value for `client:media` directive.
-   [**NoMatchingRenderer**](/en/reference/errors/no-matching-renderer/)No matching renderer found.
-   [**NoClientEntrypoint**](/en/reference/errors/no-client-entrypoint/)No client entrypoint specified in renderer.
-   [**NoClientOnlyHint**](/en/reference/errors/no-client-only-hint/)Missing hint on `client:only` directive.
-   [**InvalidGetStaticPathParam**](/en/reference/errors/invalid-get-static-path-param/)Invalid value returned by a `getStaticPaths` path.
-   [**InvalidGetStaticPathsEntry**](/en/reference/errors/invalid-get-static-paths-entry/)Invalid entry inside getStaticPath’s return value
-   [**InvalidGetStaticPathsReturn**](/en/reference/errors/invalid-get-static-paths-return/)Invalid value returned by getStaticPaths.
-   [**GetStaticPathsExpectedParams**](/en/reference/errors/get-static-paths-expected-params/)Missing params property on `getStaticPaths` route.
-   [**GetStaticPathsInvalidRouteParam**](/en/reference/errors/get-static-paths-invalid-route-param/)Invalid value for `getStaticPaths` route parameter.
-   [**GetStaticPathsRequired**](/en/reference/errors/get-static-paths-required/)`getStaticPaths()` function required for dynamic routes.
-   [**ReservedSlotName**](/en/reference/errors/reserved-slot-name/)Invalid slot name.
-   [**NoAdapterInstalled**](/en/reference/errors/no-adapter-installed/)Cannot use Server-side Rendering without an adapter.
-   [**AdapterSupportOutputMismatch**](/en/reference/errors/adapter-support-output-mismatch/)Adapter does not support server output.
-   [**NoAdapterInstalledServerIslands**](/en/reference/errors/no-adapter-installed-server-islands/)Cannot use Server Islands without an adapter.
-   [**NoMatchingImport**](/en/reference/errors/no-matching-import/)No import found for component.
-   [**InvalidPrerenderExport**](/en/reference/errors/invalid-prerender-export/)Invalid prerender export.
-   [**InvalidComponentArgs**](/en/reference/errors/invalid-component-args/)Invalid component arguments.
-   [**PageNumberParamNotFound**](/en/reference/errors/page-number-param-not-found/)Page number param not found.
-   [**ImageMissingAlt**](/en/reference/errors/image-missing-alt/)Image missing required “alt” property.
-   [**InvalidImageService**](/en/reference/errors/invalid-image-service/)Error while loading image service.
-   [**MissingImageDimension**](/en/reference/errors/missing-image-dimension/)Missing image dimensions
-   [**FailedToFetchRemoteImageDimensions**](/en/reference/errors/failed-to-fetch-remote-image-dimensions/)Failed to retrieve remote image dimensions
-   [**UnsupportedImageFormat**](/en/reference/errors/unsupported-image-format/)Unsupported image format
-   [**UnsupportedImageConversion**](/en/reference/errors/unsupported-image-conversion/)Unsupported image conversion
-   [**PrerenderDynamicEndpointPathCollide**](/en/reference/errors/prerender-dynamic-endpoint-path-collide/)Prerendered dynamic endpoint has path collision.
-   [**ExpectedImage**](/en/reference/errors/expected-image/)Expected src to be an image.
-   [**ExpectedImageOptions**](/en/reference/errors/expected-image-options/)Expected image options.
-   [**ExpectedNotESMImage**](/en/reference/errors/expected-not-esmimage/)Expected image options, not an ESM-imported image.
-   [**IncompatibleDescriptorOptions**](/en/reference/errors/incompatible-descriptor-options/)Cannot set both `densities` and `widths`
-   [**ImageNotFound**](/en/reference/errors/image-not-found/)Image not found.
-   [**NoImageMetadata**](/en/reference/errors/no-image-metadata/)Could not process image metadata.
-   [**CouldNotTransformImage**](/en/reference/errors/could-not-transform-image/)Could not transform image.
-   [**ResponseSentError**](/en/reference/errors/response-sent-error/)Unable to set response.
-   [**MiddlewareNoDataOrNextCalled**](/en/reference/errors/middleware-no-data-or-next-called/)The middleware didn’t return a `Response`.
-   [**MiddlewareNotAResponse**](/en/reference/errors/middleware-not-aresponse/)The middleware returned something that is not a `Response` object.
-   [**EndpointDidNotReturnAResponse**](/en/reference/errors/endpoint-did-not-return-aresponse/)The endpoint did not return a `Response`.
-   [**LocalsNotAnObject**](/en/reference/errors/locals-not-an-object/)Value assigned to `locals` is not accepted.
-   [**LocalsReassigned**](/en/reference/errors/locals-reassigned/)`locals` must not be reassigned.
-   [**AstroResponseHeadersReassigned**](/en/reference/errors/astro-response-headers-reassigned/)`Astro.response.headers` must not be reassigned.
-   [**MiddlewareCantBeLoaded**](/en/reference/errors/middleware-cant-be-loaded/)Can’t load the middleware.
-   [**LocalImageUsedWrongly**](/en/reference/errors/local-image-used-wrongly/)Local images must be imported.
-   [**AstroGlobUsedOutside**](/en/reference/errors/astro-glob-used-outside/)Astro.glob() used outside of an Astro file.
-   [**AstroGlobNoMatch**](/en/reference/errors/astro-glob-no-match/)Astro.glob() did not match any files.
-   [**RedirectWithNoLocation**](/en/reference/errors/redirect-with-no-location/)A redirect must be given a location with the `Location` header.
-   [**UnsupportedExternalRedirect**](/en/reference/errors/unsupported-external-redirect/)Unsupported or malformed URL.
-   [**InvalidDynamicRoute**](/en/reference/errors/invalid-dynamic-route/)Invalid dynamic route.
-   [**MissingSharp**](/en/reference/errors/missing-sharp/)Could not find Sharp.
-   [**UnknownViteError**](/en/reference/errors/unknown-vite-error/)Unknown Vite Error.
-   [**FailedToLoadModuleSSR**](/en/reference/errors/failed-to-load-module-ssr/)Could not import file.
-   [**InvalidGlob**](/en/reference/errors/invalid-glob/)Invalid glob pattern.
-   [**FailedToFindPageMapSSR**](/en/reference/errors/failed-to-find-page-map-ssr/)Astro couldn’t find the correct page to render
-   [**MissingLocale**](/en/reference/errors/missing-locale/)The provided locale does not exist.
-   [**MissingIndexForInternationalization**](/en/reference/errors/missing-index-for-internationalization/)Index page not found.
-   [**IncorrectStrategyForI18n**](/en/reference/errors/incorrect-strategy-for-i18n/)You can’t use the current function with the current strategy
-   [**NoPrerenderedRoutesWithDomains**](/en/reference/errors/no-prerendered-routes-with-domains/)Prerendered routes aren’t supported when internationalization domains are enabled.
-   [**MissingMiddlewareForInternationalization**](/en/reference/errors/missing-middleware-for-internationalization/)Enabled manual internationalization routing without having a middleware.
-   [**CantRenderPage**](/en/reference/errors/cant-render-page/)Astro can’t render the route.
-   [**UnhandledRejection**](/en/reference/errors/unhandled-rejection/)Unhandled rejection
-   [**i18nNotEnabled**](/en/reference/errors/i18n-not-enabled/)i18n Not Enabled
-   [**i18nNoLocaleFoundInPath**](/en/reference/errors/i18n-no-locale-found-in-path/)The path doesn’t contain any locale
-   [**RouteNotFound**](/en/reference/errors/route-not-found/)Route not found.
-   [**EnvInvalidVariables**](/en/reference/errors/env-invalid-variables/)Invalid Environment Variables
-   [**ServerOnlyModule**](/en/reference/errors/server-only-module/)Module is only available server-side
-   [**RewriteWithBodyUsed**](/en/reference/errors/rewrite-with-body-used/)Cannot use Astro.rewrite after the request body has been read
-   [**ForbiddenRewrite**](/en/reference/errors/forbidden-rewrite/)Forbidden rewrite to a static route.
-   [**UnknownFilesystemError**](/en/reference/errors/unknown-filesystem-error/)An unknown error occurred while reading or writing files to disk.
-   [**CannotExtractFontType**](/en/reference/errors/cannot-extract-font-type/)Cannot extract the font type from the given URL.
-   [**CannotDetermineWeightAndStyleFromFontFile**](/en/reference/errors/cannot-determine-weight-and-style-from-font-file/)Cannot determine weight and style from font file.
-   [**CannotFetchFontFile**](/en/reference/errors/cannot-fetch-font-file/)Cannot fetch the given font file.
-   [**CannotLoadFontProvider**](/en/reference/errors/cannot-load-font-provider/)Cannot load font provider
-   [**ExperimentalFontsNotEnabled**](/en/reference/errors/experimental-fonts-not-enabled/)Experimental fonts are not enabled
-   [**FontFamilyNotFound**](/en/reference/errors/font-family-not-found/)Font family not found


## CSS Errors


[Section titled CSS Errors](#css-errors)

-   [**UnknownCSSError**](/en/reference/errors/unknown-csserror/)Unknown CSS Error.
-   [**CSSSyntaxError**](/en/reference/errors/csssyntax-error/)CSS Syntax Error.


## Markdown Errors


[Section titled Markdown Errors](#markdown-errors)

-   [**UnknownMarkdownError**](/en/reference/errors/unknown-markdown-error/)Unknown Markdown Error.
-   [**MarkdownFrontmatterParseError**](/en/reference/errors/markdown-frontmatter-parse-error/)Failed to parse Markdown frontmatter.
-   [**InvalidFrontmatterInjectionError**](/en/reference/errors/invalid-frontmatter-injection-error/)Invalid frontmatter injection.
-   [**MdxIntegrationMissingError**](/en/reference/errors/mdx-integration-missing-error/)MDX integration missing.
-   [**UnknownConfigError**](/en/reference/errors/unknown-config-error/)Unknown configuration error.
-   [**ConfigNotFound**](/en/reference/errors/config-not-found/)Specified configuration file not found.
-   [**ConfigLegacyKey**](/en/reference/errors/config-legacy-key/)Legacy configuration detected.


## CLI Errors


[Section titled CLI Errors](#cli-errors)

-   [**UnknownCLIError**](/en/reference/errors/unknown-clierror/)Unknown CLI Error.
-   [**GenerateContentTypesError**](/en/reference/errors/generate-content-types-error/)Failed to generate content types.


## Content Collection Errors


[Section titled Content Collection Errors](#content-collection-errors)

-   [**UnknownContentCollectionError**](/en/reference/errors/unknown-content-collection-error/)Unknown Content Collection Error.
-   [**RenderUndefinedEntryError**](/en/reference/errors/render-undefined-entry-error/)Attempted to render an undefined content collection entry.
-   [**GetEntryDeprecationError**](/en/reference/errors/get-entry-deprecation-error/)Invalid use of `getDataEntryById` or `getEntryBySlug` function.
-   [**InvalidContentEntryFrontmatterError**](/en/reference/errors/invalid-content-entry-frontmatter-error/)Content entry frontmatter does not match schema.
-   [**InvalidContentEntryDataError**](/en/reference/errors/invalid-content-entry-data-error/)Content entry data does not match schema.
-   [**ContentLoaderReturnsInvalidId**](/en/reference/errors/content-loader-returns-invalid-id/)Content loader returned an entry with an invalid `id`.
-   [**ContentEntryDataError**](/en/reference/errors/content-entry-data-error/)Content entry data does not match schema.
-   [**ContentLoaderInvalidDataError**](/en/reference/errors/content-loader-invalid-data-error/)Content entry is missing an ID
-   [**InvalidContentEntrySlugError**](/en/reference/errors/invalid-content-entry-slug-error/)Invalid content entry slug.
-   [**ContentSchemaContainsSlugError**](/en/reference/errors/content-schema-contains-slug-error/)Content Schema should not contain `slug`.
-   [**MixedContentDataCollectionError**](/en/reference/errors/mixed-content-data-collection-error/)Content and data cannot be in same collection.
-   [**ContentCollectionTypeMismatchError**](/en/reference/errors/content-collection-type-mismatch-error/)Collection contains entries of a different type.
-   [**DataCollectionEntryParseError**](/en/reference/errors/data-collection-entry-parse-error/)Data collection entry failed to parse.
-   [**DuplicateContentEntrySlugError**](/en/reference/errors/duplicate-content-entry-slug-error/)Duplicate content entry slug.
-   [**UnsupportedConfigTransformError**](/en/reference/errors/unsupported-config-transform-error/)Unsupported transform in content config.
-   [**FileParserNotFound**](/en/reference/errors/file-parser-not-found/)File parser not found
-   [**FileGlobNotSupported**](/en/reference/errors/file-glob-not-supported/)Glob patterns are not supported in the file loader


## Action Errors


[Section titled Action Errors](#action-errors)

-   [**ActionsWithoutServerOutputError**](/en/reference/errors/actions-without-server-output-error/)Actions must be used with server output.
-   [**ActionsReturnedInvalidDataError**](/en/reference/errors/actions-returned-invalid-data-error/)Action handler returned invalid data.
-   [**ActionNotFoundError**](/en/reference/errors/action-not-found-error/)Action not found.
-   [**ActionCalledFromServerError**](/en/reference/errors/action-called-from-server-error/)Action unexpected called from the server.
-   [**ActionsCantBeLoaded**](/en/reference/errors/actions-cant-be-loaded/)Can’t load the Astro actions.


## Session Errors


[Section titled Session Errors](#session-errors)

-   [**SessionStorageInitError**](/en/reference/errors/session-storage-init-error/)Session storage could not be initialized.
-   [**SessionStorageSaveError**](/en/reference/errors/session-storage-save-error/)Session data could not be saved.
-   [**SessionWithoutSupportedAdapterOutputError**](/en/reference/errors/session-without-supported-adapter-output-error/)Sessions cannot be used with an adapter that doesn’t support server output.
-   [**SessionConfigMissingError**](/en/reference/errors/session-config-missing-error/)Session storage was enabled but not configured.
-   [**SessionConfigWithoutFlagError**](/en/reference/errors/session-config-without-flag-error/)Session flag not set

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 174. `en/reference/experimental-flags/.md`

```text
# Configuring experimental flags



# Configuring experimental flags


Experimental features are available only after enabling a flag in the Astro configuration file.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({experimental: {// enable experimental flags// to try out new features},});
```

Astro offers experimental flags to give users early access to new features for testing and feedback.

These flags allow you to participate in feature development by reporting issues and sharing your opinions. These features are not guaranteed to be stable and may include breaking changes even in small `patch` releases while the feature is actively developed.

We recommend [updating Astro](/en/upgrade-astro/#upgrade-to-the-latest-version) frequently, and keeping up with release notes in the [Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) which will inform you of any changes needed to your project code. The experimental feature documentation will always be updated for the current released version only.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 175. `en/reference/experimental-flags/client-prerender/.md`

```text
# Experimental client prerendering



# Experimental client prerendering


**Type:** `boolean` **Default:** `false`

**Added in:** `astro@4.2.0`

Enables pre-rendering your prefetched pages on the client in supported browsers.

This feature uses the experimental [Speculation Rules Web API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API) and enhances the default `prefetch` behavior globally to prerender links on the client. You may wish to review the [possible risks when prerendering on the client](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API#unsafe_prefetching) before enabling this feature.

Enable client side prerendering in your `astro.config.mjs` along with any desired `prefetch` configuration options:

astro.config.mjs

```
{prefetch: {prefetchAll: true,defaultStrategy: 'viewport',},experimental: {clientPrerender: true,},}
```

Continue to use the `data-astro-prefetch` attribute on any `<a />` link on your site to opt in to prefetching. Instead of appending a `<link>` tag to the head of the document or fetching the page with JavaScript, a `<script>` tag will be appended with the corresponding speculation rules.

Client side prerendering requires browser support. If the Speculation Rules API is not supported, `prefetch` will fallback to the supported strategy.

See the [Prefetch Guide](/en/guides/prefetch/) for more `prefetch` options and usage.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 176. `en/reference/experimental-flags/content-intellisense/.md`

```text
# Experimental Intellisense for content collections



# Experimental Intellisense for content collections


**Type:** `boolean` **Default:** `false`

**Added in:** `astro@4.14.0`

Enables Intellisense features (e.g. code completion, quick hints) for your content collection entries in compatible editors.

When enabled, this feature will generate and add JSON schemas to the `.astro` directory in your project. These files can be used by the Astro language server to provide Intellisense inside content files (`.md`, `.mdx`, `.mdoc`).

```
{experimental: {contentIntellisense: true,},}
```

To use this feature with the Astro VS Code extension, you must also enable the `astro.content-intellisense` option in your VS Code settings. For editors using the Astro language server directly, pass the `contentIntellisense: true` initialization parameter to enable this feature.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 177. `en/reference/experimental-flags/fonts/.md`

```text
# Experimental fonts API



# Experimental fonts API


**Type:** `FontFamily[]`

**Added in:** `astro@5.7.0`

This experimental feature allows you to use fonts from your filesystem and various font providers (eg. Google, Fontsource, Bunny) through a unified, fully customizable, and type-safe API.

Web fonts can impact page performance at both load time and rendering time. This API helps you keep your site performant with automatic [web font optimizations](https://web.dev/learn/performance/optimize-web-fonts) including preload links, optimized fallbacks, and opinionated defaults. [See common usage examples](#usage-examples).

To enable this feature, configure an `experimental.fonts` object with at least one font:

astro.config.mjs

```
import { defineConfig, fontProviders } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: fontProviders.google(),name: "Roboto",cssVariable: "--font-roboto"}]}});
```

Then, add the `<Font />` component and site-wide styling in your `<head>`:

src/components/Head.astro

```
---import { Font } from'astro:assets';---<FontcssVariable='--font-roboto'preload /><style>body {font-family: var(--font-roboto);}</style>
```


## Usage


[Section titled Usage](#usage)

1.  `experimental.fonts` accepts an array of font objects. For each font, you must specify a `provider`, the family `name`, and define a `cssVariable` to refer to your font.

    -   [`provider`](#provider): You can choose from the list of [built-in remote providers](#available-remote-font-providers), build your own [custom font provider](#build-your-own-font-provider), or use the [local provider](#local-font-variants) to register local font files.
    -   [`name`](#name): Choose a font family supported by your provider.
    -   [`cssVariable`](#cssvariable-1): Must be a valid [ident](https://developer.mozilla.org/en-US/docs/Web/CSS/ident) in the form of a CSS variable.

    The following example configures the [“Roboto” family from Google Fonts](https://fonts.google.com/specimen/Roboto):

    astro.config.mjs

    ```
    import { defineConfig, fontProviders } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: fontProviders.google(),name: "Roboto",cssVariable: "--font-roboto"}]}});
    ```

    More configuration options, such as defining [fallback font families](#fallbacks) and which [`weights`](#weights) and [`styles`](#styles) to download, are available and some will depend on your chosen provider.

    See the full [configuration reference](#font-configuration-reference) to learn more.

2.  Apply styles using the `<Font />` component. It must be imported and added to your page `<head>`. Providing the font’s [`cssVariable`](#cssvariable) is required, and you can optionally [output preload links](#preload):

    src/components/Head.astro

    ```
    ---import { Font } from'astro:assets';---<FontcssVariable="--font-roboto"preload />
    ```

    This is commonly done in a component such as `Head.astro` that is used in a common site layout.

    See the full [`<Font>` component reference](#font--component-reference) for more information.

    Since the `<Font />` component generates CSS with font declarations, you can reference the font family using the `cssVariable`:

    -   [CSS](#tab-panel-3415)
    -   [Tailwind CSS 4.0](#tab-panel-3416)
    -   [Tailwind CSS 3.0](#tab-panel-3417)

    ```
    <style>body {font-family: var(--font-roboto);}</style>
    ```

    src/styles/global.css

    ```
    @import'tailwindcss';@themeinline {--font-sans: var(--font-roboto);}
    ```

    tailwind.config.mjs

    ```
    /** @type{import("tailwindcss").Config} */exportdefault {content: ["./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}"],theme: {extend: {},fontFamily: {sans: ["var(--font-roboto)"]}},plugins: []};
    ```



## Available remote font providers


[Section titled Available remote font providers](#available-remote-font-providers)

Astro re-exports most [unifont](https://github.com/unjs/unifont/) providers. The following have built-in support:

-   [Adobe](https://fonts.adobe.com/)
-   [Bunny](https://fonts.bunny.net/)
-   [Fontshare](https://www.fontshare.com/)
-   [Fontsource](https://fontsource.org/)
-   [Google](https://fonts.google.com/)

To use a built-in remote provider, configure `provider` with the appropriate value for your chosen font provider:

-   [Adobe](#tab-panel-3418)
-   [Bunny](#tab-panel-3419)
-   [Fontshare](#tab-panel-3420)
-   [Fontsource](#tab-panel-3421)
-   [Google](#tab-panel-3422)

```
provider: fontProviders.adobe({ id: process.env.ADOBE_ID })
```

```
provider: fontProviders.bunny()
```

```
provider: fontProviders.fontshare()
```

```
provider: fontProviders.fontsource()
```

```
provider: fontProviders.google()
```

Additionally, the `google()` font provider accepts all options available for the [unifont Google `ProviderOption`](https://github.com/unjs/unifont/blob/main/src/providers/google.ts#L10-L26):

```
provider: fontProviders.google({glyphs: {Roboto: ["a"]}})
```

You can also [make a custom Astro font provider](#build-your-own-font-provider) for any unifont provider.


## Usage examples


[Section titled Usage examples](#usage-examples)

astro.config.mjs

```
import { defineConfig, fontProviders } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{name: "Roboto",cssVariable: "--font-roboto"provider: fontProviders.google(),// Default included:// weights: [400] ,// styles: ["normal", "italics"],// subsets: ["cyrillic-ext", "cyrillic", "greek-ext", "greek", "vietnamese", "latin-ext", "latin"],// fallbacks: ["sans-serif"],},{name: "Inter",cssVariable: "--font-inter",provider: fontProviders.fontsource(),// Specify weights that are actually usedweights: [400, 500, 600, 700],// Specify styles that are actually usedstyles: ["normal"],// Download only font files for characters used on the pagesubsets: ["cyrillic"],},{name: "JetBrains Mono",cssVariable: "--font-jetbrains-mono",provider: fontProviders.fontsource(),// Download only font files for characters used on the pagesubsets: ["latin"],// Use a fallback font family matching the intended appearancefallbacks: ["monospace"],},{name: "Poppins",cssVariable: "--font-poppins",provider: "local",// Weight and style are not specified so Astro// will try to infer them for each variantvariants: [{src: ["./src/assets/fonts/Poppins-regular.woff2","./src/assets/fonts/Poppins-regular.woff",]},{src: ["./src/assets/fonts/Poppins-bold.woff2","./src/assets/fonts/Poppins-bold.woff",]},]}],}});
```


## `<Font />` component reference


[Section titled &lt;Font /&gt; component reference](#font--component-reference)

This component outputs style tags and can optionally output preload links for a given font family.

It must be imported and added to your page `<head>`. This is commonly done in a component such as `Head.astro` that is used in a common site layout for global use but may be added to individual pages as needed.

With this component, you have control over which font family is used on which page, and which fonts are preloaded.


### cssVariable


[Section titled cssVariable](#cssvariable)

**Example type:** `"--font-roboto" | "--font-comic-sans" | ...`

The [`cssVariable`](#cssvariable-1) registered in your Astro configuration:

src/components/Head.astro

```
---import { Font } from'astro:assets';---<FontcssVariable="--font-roboto" />
```


### preload


[Section titled preload](#preload)

**Type:** `boolean` **Default:** `false`

Whether to output [preload links](https://web.dev/learn/performance/optimize-web-fonts#preload) or not:

src/components/Head.astro

```
---import { Font } from'astro:assets';---<FontcssVariable="--font-roboto"preload />
```


## Font configuration reference


[Section titled Font configuration reference](#font-configuration-reference)

All properties of your fonts must be configured in the Astro config. Some properties are common to both remote and local fonts, and other properties are available depending on your chosen font provider.


### Common properties


[Section titled Common properties](#common-properties)

The following properties are available for remote and local fonts. `provider`, `name`, and `cssVariable` are required.

astro.config.mjs

```
import { defineConfig, fontProviders } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: fontProviders.google(),name: "Roboto",cssVariable: "--font-roboto"}]}});
```


#### provider


[Section titled provider](#provider)

**Type:** `AstroFontProvider | "local"`

The source of your font files. You can use a [built-in provider](#available-remote-font-providers), write your own [custom provider](#build-your-own-font-provider), or set to `"local"` to use local font files:

astro.config.mjs

```
import { defineConfig, fontProviders } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: fontProviders.google(),name: "Roboto",cssVariable: "--font-roboto"}]}});
```


#### name


[Section titled name](#name)

**Type:** `string`

The font family name, as identified by your font provider:

```
name: "Roboto"
```


#### cssVariable


[Section titled cssVariable](#cssvariable-1)

**Type:** `string`

A valid [ident](https://developer.mozilla.org/en-US/docs/Web/CSS/ident) of your choosing in the form of a CSS variable (i.e. starting with `--`):

```
cssVariable: "--font-roboto"
```


#### fallbacks


[Section titled fallbacks](#fallbacks)

**Type:** `string[]` **Default:** `["sans-serif"]`

An array of fonts to use when your chosen font is unavailable, or loading. Fallback fonts will be chosen in the order listed. The first available font will be used:

```
fallbacks: ["CustomFont", "serif"]
```

To disable fallback fonts completely, configure an empty array:

```
fallbacks: []
```

Specify at least a [generic family name](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#generic-name) matching the intended appearance of your font. Astro will then attempt to generate [optimized fallbacks](https://developer.chrome.com/blog/font-fallbacks) using font metrics. To disable this optimization, set `optimizedFallbacks` to false.


#### optimizedFallbacks


[Section titled optimizedFallbacks](#optimizedfallbacks)

**Type:** `boolean` **Default:** `true`

Whether or not to enable Astro’s default optimization when generating fallback fonts. You may disable this default optimization to have full control over how [`fallbacks`](#fallbacks) are generated:

```
optimizedFallbacks: false
```


### Remote font properties


[Section titled Remote font properties](#remote-font-properties)

Further configuration options are available for remote fonts. Set these to customize the data loaded from your [font provider](#available-remote-font-providers), for example to only download certain font weights or styles.

Under the hood, these options are handled by [unifont](https://github.com/unjs/unifont/). Some properties may not be supported by some providers and may be handled differently by each provider.


#### weights


[Section titled weights](#weights)

**Type:** `(number | string)[]` **Default:** `[400]`

An array of [font weights](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight). If no value is specified in your configuration, only weight `400` is included by default to prevent unnecessary downloads. You will need to include this property to access any other font weights:

```
weights: [200, "400", "bold"]
```

If the associated font is a [variable font](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_fonts/Variable_fonts_guide), you can specify a range of weights:

```
weights: ["100 900"]
```


#### styles


[Section titled styles](#styles)

**Type:** `("normal" | "italic" | "oblique")[]` **Default:** `["normal", "italic"]`

An array of [font styles](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style):

```
styles: ["normal", "oblique"]
```


#### subsets


[Section titled subsets](#subsets)

**Type:** `string[]` **Default:** `["cyrillic-ext", "cyrillic", "greek-ext", "greek", "vietnamese", "latin-ext", "latin"]`

Defines a list of [font subsets](https://knaap.dev/posts/font-subsetting/) to preload.

```
subsets: ["latin"]
```


#### display


[Section titled display](#display)

**Type:** `"auto" | "block" | "swap" | "fallback" | "optional"` **Default:** `"swap"`

Defines [how a font displays](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display) based on when it is downloaded and ready for use:

```
display: "block"
```


#### unicodeRange


[Section titled unicodeRange](#unicoderange)

**Type:** `string[]` **Default:** `undefined`

Determines when a font must be downloaded and used based on a specific [range of unicode characters](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range). If a character on the page matches the configured range, the browser will download the font and all characters will be available for use on the page. To configure a subset of characters preloaded for a single font, see the [subsets](#subsets) property instead.

This can be useful for localization to avoid unnecessary font downloads when a specific part of your website uses a different alphabet and will be displayed with a separate font. For example, a website that offers both English and Japanese versions can prevent the browser from downloading the Japanese font on English versions of the page that do not contain any of the Japanese characters provided in `unicodeRange`.

```
unicodeRange: ["U+26"]
```


#### stretch


[Section titled stretch](#stretch)

**Type:** `string` **Default:** `undefined`

A [font stretch](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-stretch):

```
stretch: "condensed"
```


#### featureSettings


[Section titled featureSettings](#featuresettings)

**Type:** `string` **Default:** `undefined`

Controls the [typographic font features](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-feature-settings) (e.g. ligatures, small caps, or swashes):

```
featureSettings: "'smcp' 2"
```


#### variationSettings


[Section titled variationSettings](#variationsettings)

**Type:** `string` **Default:** `undefined`

Font [variation settings](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-variation-settings):

```
variationSettings: "'xhgt' 0.7"
```


### Local font `variants`


[Section titled Local font variants](#local-font-variants)

**Type:** `LocalFontFamily["variants"]`

The `variants` property is required when using local font files. Each variant represents a [`@font-face` declaration](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/) and requires a `weight`, `style`, and `src` value.

Additionally, [some other properties of remote fonts](#other-properties) may be specified within each variant.

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: "local",name: "Custom",cssVariable: "--font-custom",variants: [{weight: 400,style: "normal",src: ["./src/assets/fonts/custom-400.woff2"]},{weight: 700,style: "normal",src: ["./src/assets/fonts/custom-700.woff2"]}// ...]}]}});
```


#### weight


[Section titled weight](#weight)

**Type:** `number | string` **Default:** `undefined`

A [font weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight):

```
weight: 200
```

If the associated font is a [variable font](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_fonts/Variable_fonts_guide), you can specify a range of weights:

```
weight: "100 900"
```

When the value is not set, by default Astro will try to infer the value based on the first [`source`](#src).


#### style


[Section titled style](#style)

**Type:** `"normal" | "italic" | "oblique"` **Default:** `undefined`

A [font style](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style):

```
style: "normal"
```

When the value is not set, by default Astro will try to infer the value based on the first [`source`](#src).


#### src


[Section titled src](#src)

**Type:** `(string | URL | { url: string | URL; tech?: string })[]`

Font [sources](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src). It can be a path relative to the root, a package import or a URL. URLs are particularly useful if you inject local fonts through an integration:

-   [Relative path](#tab-panel-3423)
-   [URL](#tab-panel-3424)
-   [Package import](#tab-panel-3425)

```
src: ["./src/assets/fonts/MyFont.woff2", "./src/assets/fonts/MyFont.woff"]
```

```
src: [newURL("./custom.ttf", import.meta.url)]
```

```
src: ["my-package/SomeFont.ttf"]
```

Caution

We recommend not putting your font files in [the `public/` directory](/en/reference/configuration-reference/#publicdir). Since Astro will copy these files into that folder at build time, this will result in duplicated files in your build output. Instead, store them somewhere else in your project, such as in [`src/`](/en/reference/configuration-reference/#srcdir).

You can also specify a [tech](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src#tech) by providing objects:

```
src: [{ url:"./src/assets/fonts/MyFont.woff2", tech: "color-COLRv1" }]
```


#### Other properties


[Section titled Other properties](#other-properties)

The following options from remote font families are also available for local font families within variants:

-   [display](#display)
-   [unicodeRange](#unicoderange)
-   [stretch](#stretch)
-   [featureSettings](#featuresettings)
-   [variationSettings](#variationsettings)

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({experimental: {fonts: [{provider: "local",name: "Custom",cssVariable: "--font-custom",variants: [{weight: 400,style: "normal",src: ["./src/assets/fonts/custom-400.woff2"],display: "block"}]}]}});
```


## Build your own font provider


[Section titled Build your own font provider](#build-your-own-font-provider)

If you do not wish to use one of the [built-in providers](#available-remote-font-providers) (eg. you want to use a 3rd-party unifont provider or build something for a private registry), you can build your own.

An Astro font provider is made up of two parts: the config object and the actual implementation.

1.  Using the `defineAstroFontProvider()` type helper, create a function that returns a font provider config object containing:

    -   `entrypoint`: A URL, a path relative to the root, or a package import.
    -   `config`: An optional serializable object passed to the unifont provider.

    -   [Without config](#tab-panel-3426)
    -   [With config](#tab-panel-3427)

    provider/config.ts

    ```
    import { defineAstroFontProvider } from'astro/config';exportfunctionmyProvider() {returndefineAstroFontProvider({entrypoint: newURL('./implementation.js',import.meta.url)});};
    ```

    provider/config.ts

    ```
    import { defineAstroFontProvider } from'astro/config';interface Config {// ...};exportfunctionmyProvider(config:Config) {returndefineAstroFontProvider({entrypoint: newURL('./implementation.js',import.meta.url),config});};
    ```

2.  Create a second file to export your unifont `provider` implementation:

    implementation.ts

    ```
    import { defineFontProvider } from"unifont";export const provider = defineFontProvider("my-provider", async (options, ctx) => {// fetch/define your custom fonts// ...});
    ```

    Tip

    You can check out [the source code for unifont’s providers](https://github.com/unjs/unifont/blob/main/src/providers/) to learn more about how to create a unifont provider.

3.  Add your custom provider to your font configuration.

    astro.config.mjs

    ```
    fonts: [{provider: fontProviders.myProvider(),name: "Custom Font",cssVariable: "--font-custom"}]
    ```



## Caching


[Section titled Caching](#caching)

The Fonts API caching implementation was designed to be practical in development and efficient in production. During builds, font files are copied to the `_astro/fonts` output directory, so they can benefit from HTTP caching of static assets (usually a year).

To clear the cache in development, remove the `.astro/fonts` directory. To clear the build cache, remove the `node_modules/.astro/fonts` directory


## Further reading


[Section titled Further reading](#further-reading)

For full details and to give feedback on this experimental API, see [the Fonts RFC](https://github.com/withastro/roadmap/blob/rfc/fonts/proposals/0052-fonts.md).

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 178. `en/reference/experimental-flags/heading-id-compat/.md`

```text
# Experimental Markdown heading ID compatibility



# Experimental Markdown heading ID compatibility


**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.5.0`

The `experimental.headingIdCompat` flag makes the IDs generated by Astro for Markdown headings compatible with common platforms like GitHub and npm.

To enable heading ID compatibility, set the flag to `true` in your Astro configuration:

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({experimental: {headingIdCompat: true,}})
```


## Usage


[Section titled Usage](#usage)

This experimental flag allows you to retain the trailing hyphens on the end of IDs for Markdown headings ending in special characters, creating IDs compatible with those generated by other common platforms. It requires no specific usage and only affects how Astro generates the `id` for your headings written using Markdown syntax.

Astro, like many platforms, uses the popular [`github-slugger`](https://github.com/Flet/github-slugger) package to convert the text content of a Markdown heading to a slug to use in IDs. This experimental flag allows you to omit Astro’s additional default processing step that strips a trailing hyphen from the end of IDs for headings ending in special characters.

For example, the following Markdown heading:

```

## `<Picture />`

```

will generate the following HTML in Astro by default:

```
<h2id="picture"><code>&lt;Picture /&gt;</h2>
```

Using `experimental.headingIdCompat`, the same Markdown will generate the following HTML, which is identical to that of platforms such as GitHub:

```
<h2id="picture-"><code>&lt;Picture /&gt;</h2>
```

In a future major version, Astro will switch to use the compatible ID style by default, but you can opt in to the future behavior early using the `experimental.headingIdCompat` flag.


## Usage with `rehypeHeadingIds` plugin


[Section titled Usage with rehypeHeadingIds plugin](#usage-with-rehypeheadingids-plugin)

If you are [using the `rehypeHeadingIds` plugin](/en/guides/markdown-content/#heading-ids-and-plugins) directly, opt in to the compatibility mode when passing the plugin in your Astro configuration:

astro.config.mjs

```
import { defineConfig } from'astro/config';import { rehypeHeadingIds } from'@astrojs/markdown-remark';import { otherPluginThatReliesOnHeadingIDs } from'some/plugin/source';exportdefaultdefineConfig({markdown: {rehypePlugins: [[rehypeHeadingIds, { headingIdCompat: true }],otherPluginThatReliesOnHeadingIDs,],},});
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 179. `en/reference/experimental-flags/preserve-scripts-order/.md`

```text
# Experimental preserve scripts order



# Experimental preserve scripts order


**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.5.0`

Renders multiple `<style>` and `<script>` tags in the same order as they were declared in the source code.

To enable this behavior, add the `experimental.preserveScriptOrder` feature flag to your Astro config:

astro.config.mjs

```
import { defineConfig } from"astro/config"exportdefaultdefineConfig({experimental: {preserveScriptOrder: true}})
```


## Usage


[Section titled Usage](#usage)

This experimental flag requires no specific usage and only affects the order in which Astro renders your styles and scripts.

When rendering multiple `<style>` and `<script>` tags on the same page, Astro currently reverses their order in your generated HTML output. This can give unexpected results, for example, CSS styles being overridden by earlier defined style tags when your site is built. This experimental flag instead renders `<script>` and `<style>` tags in the order they are defined.

For example, the following component has two `<style>` tags and two `<script>` tags:

src/components/MyComponent.astro

```
<p>I am a component</p><style>body {background: red;}</style><style>body {background: yellow;}</style><script>console.log("hello")</script><script>console.log("world!")</script>
```

After compiling, Astro’s default behavior will create an inline style where `yellow` appears first, and then `red`. This means the `red` background is applied. Similarly with the two scripts, the word `world!` is logged first, and then `hello` second:

```
body {background:#ff0} body {background:red}
```

```
console.log("world!")console.log("hello")
```

When `experimental.preserveScriptOrder` is set to `true`, the rendering order of `<style>` and `<script>` tags matches the order in which they are written. For the same example component, the style generated `red` appears first, and then `yellow`; as for the scripts, `hello` is logged first, and then `world!`:

```
body {background:red} body {background:#ff0}
```

```
console.log("hello")console.log("world!")
```

In a future major version, Astro will preserve style and script order by default, but you can opt in to the future behavior early using the `experimental.preserveScriptOrder` flag.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 180. `en/reference/experimental-flags/responsive-images/.md`

```text
# Experimental responsive images



# Experimental responsive images


**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.0.0`

Enables support for automatic responsive images in your project.

The term [responsive images](https://developer.mozilla.org/en-US/docs/Web/HTML/Guides/Responsive_images) refers images that work well on different devices. This particularly applies to images that resize to fit their container, and that can be served in different sizes depending on the device’s screen size and resolution.

There are a number of additional properties that can be set to control how the image is displayed, but these can be complicated to handle manually. Incorrect handling of these properties can lead to images that are slow to download or that are not displayed correctly. This is one of the most common causes of poor Core Web Vitals and Lighthouse performance scores.

When this flag is enabled, Astro can automatically generate the required `srcset` and `sizes` values for images, and apply the correct styles to ensure they resize correctly. This behavior can be configured globally or on a per-image basis.

To enable the feature, first add the `responsiveImages` flag to your `astro.config.mjs` file:

astro.config.mjs

```
{experimental: {responsiveImages: true,},}
```

Enabling this flag will not change anything by default, but responsive images can then be configured by setting the [image layout](#image-layout) either globally or per image.

To do this, you have access to additional [`image` configuration settings](#configuration-settings) for controlling the default behavior of all images processed and optimized by Astro:

-   Local and remote images using [the Markdown `![]()` syntax](/en/guides/images/#images-in-markdown-files).
-   The [`<Image />`](/en/guides/images/#display-optimized-images-with-the-image--component) and [`<Picture />`](/en/guides/images/#create-responsive-images-with-the-picture--component) components.

Additionally, Astro’s image components can receive [responsive image props](#responsive-image-properties) to override these defaults on a per-image basis.

Images in your `public/` folder are never optimized, and responsive images are not supported.

Note

Enabling responsive images will generate additional image sizes for all affected images. For prerendered pages this happens during the build so may increase the build time of your project, especially if you have a large number of images.

For pages rendered on-demand the images are generated as-needed, so this has no impact on build times but may increase the number of transformations performed. Depending on your image service this may incur additional costs.


## Image layout


[Section titled Image layout](#image-layout)

In order to generate the correct `srcset` and `sizes` attributes, the `<Image />` and `<Picture />` components need to know how the image should resize when its container changes size. This is done by setting the `layout` prop, or `image.experimentalLayout` default. The supported values are:

-   `constrained` - The image will scale down to fit the container, maintaining its aspect ratio, but will not scale up beyond the specified `width` and `height`, or the image’s original dimensions. Use this if you want the image to display at the requested size where possible, but shrink to fit smaller screens. This matches the default behavior for images when using Tailwind. If you’re not sure, this is probably the layout you should choose.
-   `full-width` - The image will scale to fit the width of the container, maintaining its aspect ratio. Use this for hero images or other images that should take up the full width of the page.
-   `fixed` - The image will maintain the requested dimensions and not resize. It will generate a `srcset` to support high density displays, but not for different screen sizes. Use this if the image will not resize, for example icons or logos smaller than any screen width, or other images in a fixed-width container.
-   `none` - The image will not be responsive. No `srcset` or `sizes` will be automatically generated, and no styles will be applied. This is useful if you have enabled a default layout, but want to disable it for a specific image.

The chosen `layout` will be used to generate the correct `srcset` and `sizes` attributes for the image, and will define the default styles applied to that `<img>` tag.


## Configuration settings


[Section titled Configuration settings](#configuration-settings)

Set [`image.experimentalLayout`](/en/reference/configuration-reference/#imageexperimentallayout) with a default value to enable responsive images throughout your project.

If this value is not configured, you can still pass a `layout` prop to any `<Image />` or `<Picture />` component to create a responsive image. However, Markdown images will not be responsive.

Optionally, you can configure [`image.experimentalObjectFit`](/en/reference/configuration-reference/#imageexperimentalobjectfit) and [`image.experimentalObjectPosition`](/en/reference/configuration-reference/#imageexperimentalobjectposition) which will apply to all processed images by default.

Each of these settings can be overridden on any individual `<Image />` or `<Picture />` component with a prop, but Markdown images will always use the default settings.

astro.config.mjs

```
{image: {// Used for all Markdown images; not configurable per-image// Used for all `<Image />` and `<Picture />` components unless overridden with a propexperimentalLayout: 'constrained',},experimental: {responsiveImages: true,},}
```


## Responsive image properties


[Section titled Responsive image properties](#responsive-image-properties)

These are additional properties available to the `<Image />` and `<Picture />` components when responsive images are enabled:

-   `layout`: The [layout type](#image-layout) for the image. Can be `constrained`, `fixed`, `full-width`, or `none`. If set to `none`, responsive behavior is disabled for this image and all other options are ignored. Defaults to `none`, or the value of [`image.experimentalLayout`](/en/reference/configuration-reference/#imageexperimentallayout) if set.
-   `fit`: Defines how the image should be cropped if the aspect ratio is changed. Values match those of CSS `object-fit`. Defaults to `cover`, or the value of [`image.experimentalObjectFit`](/en/reference/configuration-reference/#imageexperimentalobjectfit) if set.
-   `position`: Defines the position of the image crop if the aspect ratio is changed. Values match those of CSS `object-position`. Defaults to `center`, or the value of [`image.experimentalObjectPosition`](/en/reference/configuration-reference/#imageexperimentalobjectposition) if set.
-   `priority`: If set, eagerly loads the image. Otherwise, images will be lazy-loaded. Use this for your largest above-the-fold image. Defaults to `false`.

The `widths` and `sizes` attributes are automatically generated based on the image’s dimensions and the layout type, and in most cases should not be set manually. The generated `sizes` attribute for `constrained` and `full-width` images is based on the assumption that the image is displayed at close to the full width of the screen when the viewport is smaller than the image’s width. If it is significantly different (e.g. if it’s in a multi-column layout on small screens) you may need to adjust the `sizes` attribute manually for best results.

The `densities` attribute is not compatible with responsive images and will be ignored if set.

For example, with `constrained` set as the default layout, you can override any individual image’s `layout` property:

```
---import { Image } from'astro:assets';import myImage from'../assets/my_image.png';---<Imagesrc={myImage}alt="This will use responsive layout"width={800}height={600} /><Imagesrc={myImage}alt="This will use full-width layout"layout="full-width" /><Imagesrc={myImage}alt="This will disable responsive images"layout="none" />
```


## Generated HTML output for responsive images


[Section titled Generated HTML output for responsive images](#generated-html-output-for-responsive-images)

When a layout is set, either by default or on an individual component, images have automatically generated `srcset` and `sizes` attributes based on the image’s dimensions and the layout type. Images with `constrained` and `full-width` layouts will have styles applied to ensure they resize according to their container.

MyComponent.astro

```
---import { Image, Picture } from'astro:assets';import myImage from'../assets/my_image.png';---<Imagesrc={myImage}alt="A description of my image."layout='responsive'width={800}height={600} /><Picturesrc={myImage}alt="A description of my image."layout='full-width'formats={['avif', 'webp', 'jpeg']} />
```

This `<Image />` component will generate the following HTML output:

```
<imgsrc="/_astro/my_image.hash3.webp"srcset="/_astro/my_image.hash1.webp 640w,/_astro/my_image.hash2.webp 750w,/_astro/my_image.hash3.webp 800w,/_astro/my_image.hash4.webp 828w,/_astro/my_image.hash5.webp 1080w,/_astro/my_image.hash6.webp 1280w,/_astro/my_image.hash7.webp 1600w"alt="A description of my image"sizes="(min-width: 800px) 800px, 100vw"loading="lazy"decoding="async"fetchpriority="auto"width="800"height="600"style="--fit: cover; --pos: center;"data-astro-image="constrained">
```


## Default responsive image styles


[Section titled Default responsive image styles](#default-responsive-image-styles)

The responsive image component applies a small number of styles to ensure they resize correctly. The applied styles depend on the layout type, and are designed to give the best behavior for the generated `srcset` and `sizes` attributes:

Responsive Image Styles

```
:where([data-astro-image]) {object-fit: var(--fit);object-position: var(--pos);}:where([data-astro-image='full-width']) {width: 100%;}:where([data-astro-image='constrained']) {max-width: 100%;}
```


### Overriding default styles


[Section titled Overriding default styles](#overriding-default-styles)

The styles use the [`:where()` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:where), which has a [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity) of 0, meaning that it is easy to override with your own styles. Any CSS selector will have a higher specificity than `:where()`, so you can easily override the styles by adding your own styles to target the image.

You can override the `object-fit` and `object-position` styles on a per-image basis by setting the `fit` and `position` props on the `<Image />` or `<Picture />` component.

You can disable the default styles entirely by setting [`image.experimentalDefaultStyles`](/en/reference/configuration-reference/#imageexperimentaldefaultstyles) to `false` if you prefer to handle styling responsive images yourself.


#### Tailwind 4


[Section titled Tailwind 4](#tailwind-4)

Tailwind 4 is a special case, because it uses [cascade layers](https://developer.mozilla.org/en-US/docs/Web/CSS/@layer), meaning the Tailwind rules are always lower specificity than rules that don’t use layers. Astro supports browsers that do not support cascade layers, so it cannot use them for images. This means that [you should disable the default styles](/en/reference/configuration-reference/#imageexperimentaldefaultstyles) if you need to override them with Tailwind 4.

For a complete overview, and to give feedback on this experimental API, see the [Responsive Images RFC](https://github.com/withastro/roadmap/blob/responsive-images/proposals/0053-responsive-images.md).

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 181. `en/reference/image-service-reference/.md`

```text
# Image Service API



# Image Service API


`astro:assets` was designed to make it easy for any image optimization service to build a service on top of Astro.


## What is an Image Service?


[Section titled What is an Image Service?](#what-is-an-image-service)

Astro provides two types of image services: Local and External.

-   **Local services** handle image transformations directly at build for static sites, or at runtime both in development mode and for on-demand rendering. These are often wrappers around libraries like Sharp, ImageMagick, or Squoosh. In dev mode and in production routes rendered on demand, local services use an API endpoint to do the transformation.
-   **External services** point to URLs and can add support for services such as Cloudinary, Vercel, or any [RIAPI](https://github.com/riapi/riapi)\-compliant server.


## Building using the Image Services API


[Section titled Building using the Image Services API](#building-using-the-image-services-api)

Service definitions take the shape of an exported default object with various required methods (“hooks”).

External services provide a `getURL()` that points to the `src` of the output `<img>` tag.

Local services provide a `transform()` method to perform transformations on your image, and `getURL()` and `parseURL()` methods to use an endpoint for dev mode and when rendered on demand.

Both types of services can provide `getHTMLAttributes()` to determine the other attributes of the output `<img>` and `validateOptions()` to validate and augment the passed options.


### External Services


[Section titled External Services](#external-services)

An external service points to a remote URL to be used as the `src` attribute of the final `<img>` tag. This remote URL is responsible for downloading, transforming, and returning the image.

```
importtype { ExternalImageService, ImageTransform, AstroConfig } from"astro";const service:ExternalImageService = {validateOptions(options:ImageTransform, imageConfig:AstroConfig['image']) {constserviceConfig = imageConfig.service.config;// Enforce the user set max width.if (options.width > serviceConfig.maxWidth) {console.warn(`Image width ${options.width} exceeds max width ${serviceConfig.maxWidth}. Falling back to max width.`);options.width = serviceConfig.maxWidth;}return options;},getURL(options, imageConfig) {return `https://mysupercdn.com/${options.src}?q=${options.quality}&w=${options.width}&h=${options.height}`;},getHTMLAttributes(options, imageConfig) {const { src, format, quality, ...attributes } = options;return {...attributes,loading: options.loading ?? 'lazy',decoding: options.decoding ?? 'async',};}};exportdefaultservice;
```


### Local Services


[Section titled Local Services](#local-services)

To create your own local service, you can point to the [built-in endpoint](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) (`/_image`), or you can additionally create your own endpoint that can call the service’s methods.

```
importtype { LocalImageService, AstroConfig } from"astro";const service:LocalImageService = {getURL(options:ImageTransform, imageConfig:AstroConfig['image']) {constsearchParams = newURLSearchParams();searchParams.append('href', typeofoptions.src === "string" ? options.src : options.src.src);options.width && searchParams.append('w', options.width.toString());options.height && searchParams.append('h', options.height.toString());options.quality && searchParams.append('q', options.quality.toString());options.format && searchParams.append('f', options.format);return `/my_custom_endpoint_that_transforms_images?${searchParams}`;// Or use the built-in endpoint, which will call your parseURL and transform functions:// return `/_image?${searchParams}`;},parseURL(url:URL, imageConfig) {return {src: params.get('href')!,width: params.has('w') ? parseInt(params.get('w')!) : undefined,height: params.has('h') ? parseInt(params.get('h')!) : undefined,format: params.get('f'),quality: params.get('q'),};},transform(buffer:Uint8Array, options: { src:string, [key:string]:any }, imageConfig): { data:Uint8Array, format:OutputFormat } {const { buffer } = mySuperLibraryThatEncodesImages(options);return {data: buffer,format: options.format,};},getHTMLAttributes(options, imageConfig) {lettargetWidth = options.width;lettargetHeight = options.height;if (typeofoptions.src === "object") {constaspectRatio = options.src.width / options.src.height;if (targetHeight && !targetWidth) {targetWidth = Math.round(targetHeight * aspectRatio);} else if (targetWidth && !targetHeight) {targetHeight = Math.round(targetWidth / aspectRatio);}}const { src, width, height, format, quality, ...attributes } = options;return {...attributes,width: targetWidth,height: targetHeight,loading: attributes.loading ?? 'lazy',decoding: attributes.decoding ?? 'async',};},propertiesToHash: ['src', 'width', 'height', 'format', 'quality'],};exportdefaultservice;
```

At build time for static sites and pre-rendered routes, both `<Image />` and `getImage(options)` call the `transform()` function. They pass options either through component attributes or an `options` argument, respectively. The transformed images will be built to a `dist/_astro` folder. Their file names will contain a hash of the properties passed to `propertiesToHash`. This property is optional and will default to `['src', 'width', 'height', 'format', 'quality']`. If your custom image service has more options that change the generated images, add these to the array.

In dev mode and when using an adapter to render on demand, Astro doesn’t know ahead of time which images need to be optimized. Astro uses a GET endpoint (by default, `/_image`) to process the images at runtime. `<Image />` and `getImage()` pass their options to `getURL()`, which will return the endpoint URL. Then, the endpoint calls `parseURL()` and passes the resulting properties to `transform()`.


#### getConfiguredImageService & imageConfig


[Section titled getConfiguredImageService &amp; imageConfig](#getconfiguredimageservice--imageconfig)

If you implement your own endpoint as an Astro endpoint, you can use `getConfiguredImageService` and `imageConfig` to call your service’s `parseURL` and `transform` methods and provide the image config.

To access the image service config ([`image.service.config`](/en/reference/configuration-reference/#imageservice)), you can use `imageConfig.service.config`.

src/api/my\_custom\_endpoint\_that\_transforms\_images.ts

```
importtype { APIRoute } from"astro";import { getConfiguredImageService, imageConfig } from'astro:assets';export const GET:APIRoute = async ({ request }) => {const imageService = await getConfiguredImageService();const imageTransform = imageService.parseURL(newURL(request.url), imageConfig);// ... fetch the image from imageTransform.src and store it in inputBufferconst { data, format } = await imageService.transform(inputBuffer, imageTransform, imageConfig);return newResponse(data, {status: 200,headers: {'Content-Type': mime.getType(format) | ''}});}
```

[See the built-in endpoint](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) for a full example.


## Hooks


[Section titled Hooks](#hooks)


### `getURL()`


[Section titled getURL()](#geturl)

**Required for local and external services**

`getURL(options: ImageTransform, imageConfig: AstroConfig['image']): string`

For local services, this hook returns the URL of the endpoint that generates your image (for on-demand rendering and in dev mode). It is unused during build. The local endpoint that `getURL()` points to may call both `parseURL()` and `transform()`.

For external services, this hook returns the final URL of the image.

For both types of services, `options` are the properties passed by the user as attributes of the `<Image />` component or as options to `getImage()`. They are of the following type:

```
exporttype ImageTransform = {// ESM imported images | remote/public image pathssrc:ImageMetadata|string;width?:number;height?:number;widths?:number[] |undefined;densities?: (number|`${number}x`)[] |undefined;quality?:ImageQuality;format?:OutputFormat;alt?:string;[key:string]:any;};
```


### `parseURL()`


[Section titled parseURL()](#parseurl)

**Required for local services; unavailable for external services**

`parseURL(url: URL, imageConfig: AstroConfig['image']): { src: string, [key: string]: any}`

This hook parses the generated URLs by `getURL()` back into an object with the different properties to be used by `transform` (for on-demand rendering and in dev mode). It is unused during build.


### `transform()`


[Section titled transform()](#transform)

**Required for local services only; unavailable for external services**

`transform(buffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig: AstroConfig['image']): { data: Uint8Array, format: OutputFormat }`

This hook transforms and returns the image and is called during the build to create the final asset files.

You must return a `format` to ensure that the proper MIME type is served to users for on-demand rendering and development mode.


### `getHTMLAttributes()`


[Section titled getHTMLAttributes()](#gethtmlattributes)

**Optional for both local and external services**

`getHTMLAttributes(options: ImageTransform, imageConfig: AstroConfig['image']): Record<string, any>`

This hook returns all additional attributes used to render the image as HTML, based on the parameters passed by the user (`options`).


### `getSrcSet()`


[Section titled getSrcSet()](#getsrcset)

**Added in:** `astro@3.3.0`

**Optional for both local and external services.**

`getSrcSet?: (options: ImageTransform, imageConfig: AstroConfig['image']): SrcSetValue[] | Promise<SrcSetValue[]>;`

This hook generates multiple variants of the specified image, for example, to generate a `srcset` attribute on an `<img>` or `<picture>`’s `source`.

This hook returns an array of objects with the following properties:

```
exporttype SrcSetValue = {transform:ImageTransform;descriptor?:string;attributes?:Record<string, any>;};
```


### `validateOptions()`


[Section titled validateOptions()](#validateoptions)

**Optional for both local and external services**

`validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']): ImageTransform`

This hook allows you to validate and augment the options passed by the user. This is useful for setting default options, or telling the user that a parameter is required.

[See how `validateOptions()` is used in Astro built-in services](https://github.com/withastro/astro/blob/0ab6bad7dffd413c975ab00e545f8bc150f6a92f/packages/astro/src/assets/services/service.ts#L124).


## User configuration


[Section titled User configuration](#user-configuration)

Configure the image service to use in `astro.config.mjs`. The config takes the following form:

astro.config.mjs

```
import { defineConfig } from"astro/config";exportdefaultdefineConfig({image: {service: {entrypoint: "your-entrypoint", // 'astro/assets/services/sharp' | string,config: {// ... service-specific config. Optional.}}},});
```


## Utilities


[Section titled Utilities](#utilities)

Astro exposes a number of helper functions that can be used to develop a custom image service. These utilities can be imported from `astro/assets/utils`:

```
import {isRemoteAllowed,matchHostname,matchPathname,matchPattern,matchPort,matchProtocol,isESMImportedImage,isRemoteImage,resolveSrc,imageMetadata,emitESMImage,getOrigQueryParams,inferRemoteSize,propsToFilename,hashTransform} from"astro/assets/utils";
```


### `isRemoteAllowed()`


[Section titled isRemoteAllowed()](#isremoteallowed)

**Type:** `(src: string, { domains, remotePatterns }: {domains: string[], remotePatterns: RemotePattern[] }): boolean`

**Added in:** `astro@4.0.0`

Determines whether a given remote resource, identified by its source URL, is allowed based on specified domains and remote patterns.

```
import { isRemoteAllowed } from'astro/assets/utils';const testImageURL = 'https://example.com/images/test.jpg';const domains = ['example.com', 'anotherdomain.com'];const remotePatterns = [{ protocol: 'https', hostname: 'images.example.com', pathname: '/**' }, // Allow any path under this hostname];const url = newURL(testImageURL);const isAllowed = isRemoteAllowed(url.href, { domains, remotePatterns });console.log(`Is the remote image allowed? ${isAllowed}`);
```


### `matchHostname()`


[Section titled matchHostname()](#matchhostname)

**Type:** `(url: URL, hostname?: string, allowWildcard = false): boolean`

**Added in:** `astro@4.0.0`

Matches a given URL’s hostname against a specified hostname, with optional support for wildcard patterns.

```
import { matchHostname } from'astro/assets/utils';const testURL = newURL('https://sub.example.com/path/to/resource');// Example usage of matchHostnameconst hostnameToMatch = 'example.com';// Match without wildcardconst isMatchWithoutWildcard = matchHostname(testURL, hostnameToMatch);console.log(`Does the hostname match without wildcard? ${isMatchWithoutWildcard}`); // Output: false// Match with wildcardconst isMatchWithWildcard = matchHostname(testURL, hostnameToMatch, true);console.log(`Does the hostname match with wildcard? ${isMatchWithWildcard}`); // Output: true
```


### `matchPathname()`


[Section titled matchPathname()](#matchpathname)

**Type:** `(url: URL, pathname?: string, allowWildcard = false): boolean`

**Added in:** `astro@4.0.0`

Matches a given URL’s pathname against a specified pattern, with optional support for wildcards.

```
import { matchPathname } from'astro/assets/utils';const testURL = newURL('https://example.com/images/photo.jpg');// Example pathname to matchconst pathnameToMatch = '/images/photo.jpg';// Match without wildcardconst isMatchWithoutWildcard = matchPathname(testURL, pathnameToMatch);console.log(`Does the pathname match without wildcard? ${isMatchWithoutWildcard}`); // Output: true// Match with wildcardconst wildcardPathname = '/images/*';const isMatchWithWildcard = matchPathname(testURL, wildcardPathname, true);console.log(`Does the pathname match with wildcard? ${isMatchWithWildcard}`); // Output: true
```


### `matchPattern()`


[Section titled matchPattern()](#matchpattern)

**Type:** `(url: URL, remotePattern: RemotePattern): boolean`

**Added in:** `astro@4.0.0`

Evaluates whether a given URL matches the specified remote pattern based on protocol, hostname, port, and pathname.

```
import { matchPattern } from'astro/assets/utils';const testURL = newURL('https://images.example.com/photos/test.jpg');// Define a remote pattern to match the URLconst remotePattern = {protocol: 'https',hostname: 'images.example.com',pathname: '/photos/**', // Wildcard to allow all files under /photos/port: '', // Optional: Match any port or leave empty for default};// Check if the URL matches the remote patternconst isPatternMatched = matchPattern(testURL, remotePattern);console.log(`Does the URL match the remote pattern? ${isPatternMatched}`); // Output: true
```


### `matchPort()`


[Section titled matchPort()](#matchport)

**Type:** `(url: URL, port?: string): boolean`

**Added in:** `astro@4.0.0`

Checks if the given URL’s port matches the specified port. If no port is provided, it returns `true`.

```
import { matchPort } from'astro/assets/utils';const testURL1 = newURL('https://example.com:8080/resource');const testURL2 = newURL('https://example.com/resource');// Example usage of matchPortconst portToMatch = '8080';// Match a URL with a port specifiedconst isPortMatch1 = matchPort(testURL1, portToMatch);console.log(`Does the port match? ${isPortMatch1}`); // Output: true// Match a URL without a port specified (default port will be assumed)const isPortMatch2 = matchPort(testURL2, portToMatch);console.log(`Does the port match? ${isPortMatch2}`); // Output: false// Check a URL without explicitly providing a port (defaults to true if port is undefined)const isPortMatch3 = matchPort(testURL1);console.log(`Does the port match (no port specified)? ${isPortMatch3}`); // Output: true
```


### `matchProtocol()`


[Section titled matchProtocol()](#matchprotocol)

**Type:** `(url: URL, protocol?: string): boolean`

**Added in:** `astro@4.0.0`

Compares the protocol of the provided URL with a specified protocol.

```
import { matchProtocol } from'astro/assets/utils';const testURL1 = newURL('https://example.com/resource');const testURL2 = newURL('http://example.com/resource');// Example usage of matchProtocolconst protocolToMatch = 'https';// Match a URL with correct protocolconst isProtocolMatch1 = matchProtocol(testURL1, protocolToMatch);console.log(`Does the protocol match for testURL1? ${isProtocolMatch1}`); // Output: true// Match a URL with incorrect protocolconst isProtocolMatch2 = matchProtocol(testURL2, protocolToMatch);console.log(`Does the protocol match for testURL2? ${isProtocolMatch2}`); // Output: false// Match a URL without explicitly providing a protocol (defaults to true if protocol is undefined)const isProtocolMatch3 = matchProtocol(testURL1);console.log(`Does the protocol match (no protocol specified)? ${isProtocolMatch3}`); // Output: true
```


### `isESMImportedImage()`


[Section titled isESMImportedImage()](#isesmimportedimage)

**Type:** `(src: ImageMetadata | string): boolean`

**Added in:** `astro@4.0.0`

Determines if the given source is an ECMAScript Module (ESM) imported image.

```
import { isESMImportedImage } from'astro/assets/utils';// Example usage of isESMImportedImageconst imageMetadataExample = {src: '/images/photo.jpg',width: 800,height: 600,format: 'jpg',};const filePathExample = '/images/photo.jpg';// Check if the input is an ESM imported imageconst isMetadataImage = isESMImportedImage(imageMetadataExample);console.log(`Is imageMetadataExample an ESM imported image? ${isMetadataImage}`); // Output: trueconst isFilePathImage = isESMImportedImage(filePathExample);console.log(`Is filePathExample an ESM imported image? ${isFilePathImage}`); // Output: false
```


### `isRemoteImage()`


[Section titled isRemoteImage()](#isremoteimage)

**Type:** `(src: ImageMetadata | string): boolean`

**Added in:** `astro@4.0.0`

Determines if the provided source is a remote image URL in the form of a string.

```
import { isRemoteImage } from'astro/assets/utils';// Example usage of isRemoteImageconst remoteImageUrl = 'https://example.com/images/photo.jpg';const localImageMetadata = {src: '/images/photo.jpg',width: 800,height: 600,format: 'jpg',};// Check if the input is a remote image URLconst isRemote1 = isRemoteImage(remoteImageUrl);console.log(`Is remoteImageUrl a remote image? ${isRemote1}`); // Output: trueconst isRemote2 = isRemoteImage(localImageMetadata);console.log(`Is localImageMetadata a remote image? ${isRemote2}`); // Output: false
```


### `resolveSrc()`


[Section titled resolveSrc()](#resolvesrc)

**Type:** `(src: UnresolvedImageTransform['src']): Promise<string | ImageMetadata>`

**Added in:** `astro@4.0.0`

Returns the image source. This function ensures that if `src` is a Promise (e.g., a dynamic `import()`), it is awaited and the correct `src` is extracted. If `src` is already a resolved value, it is returned as-is.

```
import { resolveSrc } from'astro/assets/utils';import localImage from"./images/photo.jpg";const resolvedLocal = await resolveSrc(localImage);// will be `{ src: '/images/photo.jpg', width: 800, height: 600, format: 'jpg' }`const resolvedRemote = await resolveSrc("https://example.com/remote-img.jpg");// will be `"https://example.com/remote-img.jpg"`const resolvedDynamic = await resolveSrc(import("./images/dynamic-image.jpg"))// will be `{ src: '/images/dynamic-image.jpg', width: 800, height: 600, format: 'jpg' }`
```


### `imageMetadata()`


[Section titled imageMetadata()](#imagemetadata)

**Type:** `(data: Uint8Array, src?: string): Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>`

**Added in:** `astro@4.0.0`

Extracts image metadata such as dimensions, format, and orientation from the provided image data.

```
import { imageMetadata } from'astro/assets/utils';asyncfunctionextractImageMetadata() {// Example image data (Uint8Array)const exampleImageData = newUint8Array([/* ...binary image data... */]);// Optional source path (useful for debugging or additional metadata context)const sourcePath = '/images/photo.jpg';try {// Extract metadata from the image dataconst metadata = await imageMetadata(exampleImageData,sourcePath);console.log('Extracted Image Metadata:', metadata);// Example output:// {//   width: 800,//   height: 600,//   format: 'jpg',//   orientation: undefined// }} catch (error) {console.error('Failed to extract metadata from image:', error);}}awaitextractImageMetadata();
```


### `emitESMImage()`


[Section titled emitESMImage()](#emitesmimage)

Deprecated

Use the [`emitImageMetadata`](#emitimagemetadata) function instead.

**Type:** `(id: string | undefined, _watchMode: boolean, experimentalSvgEnabled: boolean, fileEmitter?: FileEmitter): Promise<ImageMetadataWithContents | undefined>`

**Added in:** `astro@4.0.0`

Processes an image file and emits its metadata and optionally its contents. In build mode, the function uses `fileEmitter` to generate an asset reference. In development mode, it resolves to a local file URL with query parameters for metadata.

```
import { emitESMImage } from'astro/assets/utils';const imageId = '/images/photo.jpg';const unusedWatchMode = false; // Deprecated, unusedconst unusedExperimentalSvgEnabled = false; // Set to `true` only if you are using SVG and want the file data to be embeddedtry {const result = await emitESMImage(imageId, unusedWatchMode, unusedExperimentalSvgEnabled);if (result) {console.log('Image metadata with contents:', result);// Example output:// {//   width: 800,//   height: 600,//   format: 'jpg',//   contents: Uint8Array([...])// }} else {console.log('No metadata was emitted for this image.');}} catch (error) {console.error('Failed to emit ESM image:', error);}
```


### `emitImageMetadata()`


[Section titled emitImageMetadata()](#emitimagemetadata)

**Type:** `(id: string | undefined, fileEmitter?: FileEmitter): Promise<ImageMetadataWithContents | undefined>`

**Added in:** `astro@5.7.0`

Processes an image file and emits its metadata and optionally its contents. In build mode, the function uses `fileEmitter` to generate an asset reference. In development mode, it resolves to a local file URL with query parameters for metadata.

```
import { emitImageMetadata } from'astro/assets/utils';const imageId = '/images/photo.jpg';try {const result = await emitImageMetadata(imageId);if (result) {console.log('Image metadata with contents:', result);// Example output:// {//   width: 800,//   height: 600,//   format: 'jpg',//   contents: Uint8Array([...])// }} else {console.log('No metadata was emitted for this image.');}} catch (error) {console.error('Failed to emit ESM image:', error);}
```


### `getOrigQueryParams()`


[Section titled getOrigQueryParams()](#getorigqueryparams)

**Type:** `(params: URLSearchParams): Pick<ImageMetadata, 'width' | 'height' | 'format'> | undefined`

**Added in:** `astro@4.0.0`

Retrieves the `width`, `height`, and `format` of an image from a [`URLSearchParams` object](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). If any of these parameters are missing or invalid, the function returns `undefined`.

```
import { getOrigQueryParams } from'astro/assets/utils';const url = newURL('https://example.com/image.jpg?width=800&height=600&format=jpg');const queryParams = url.searchParams;// Extract the original query parametersconst origParams = getOrigQueryParams(queryParams);if (origParams) {console.log('Original query parameters:', origParams);// Example output:// {//   width: 800,//   height: 600,//   format: 'jpg'// }} else {console.log('Failed to extract original query parameters.');}
```


### `inferRemoteSize()`


[Section titled inferRemoteSize()](#inferremotesize)

**Type:** `(url: string): Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>`

**Added in:** `astro@4.0.0`

Infers the dimensions of a remote image by streaming its data and analyzing it progressively until sufficient metadata is available.

```
import { inferRemoteSize } from'astro/assets/utils';asyncfunctiongetRemoteImageSize() {const remoteImageUrl = 'https://example.com/image.jpg';try {// Infer remote image size from the URLconst imageSize = await inferRemoteSize(remoteImageUrl);console.log('Inferred remote image size:', imageSize);// Example output:// {//   width: 1920,//   height: 1080,//   format: 'jpg'// }} catch (error) {console.error('Failed to infer the size of the remote image:', error);}}awaitgetRemoteImageSize();
```


### `propsToFilename()`


[Section titled propsToFilename()](#propstofilename)

**Type:** `(filePath: string, transform: ImageTransform, hash: string): string`

**Added in:** `astro@4.0.0`

Generates a formatted filename for an image based on its source path, transformation properties, and a unique hash.

The formatted filename follows this structure:

`<prefixDirname>/<baseFilename>_<hash><outputExtension>`

-   `prefixDirname`: If the image is an ESM imported image, this is the directory name of the original file path; otherwise, it will be an empty string.
-   `baseFilename`: The base name of the file or a hashed short name if the file is a `data:` URI.
-   `hash`: A unique hash string generated to distinguish the transformed file.
-   `outputExtension`: The desired output file extension derived from the `transform.format` or the original file extension.

```
import { propsToFilename } from'astro/assets/utils';functiongenerateTransformedFilename() {const filePath = '/images/photo.jpg';const transform = {format: 'png',src: '/images/photo.jpg'};const hash = 'abcd1234';// Generate the transformed filename based on the file path, transformation, and hashconst filename = propsToFilename(filePath,transform,hash);console.log('Generated transformed filename:', filename);// Example output: '/images/photo_abcd1234.png'}generateTransformedFilename();
```


### `hashTransform()`


[Section titled hashTransform()](#hashtransform)

**Type:** `(transform: ImageTransform, imageService: string, propertiesToHash: string[]): string`

**Added in:** `astro@4.0.0`

Transforms the provided `transform` object into a hash string based on selected properties and the specified `imageService`.

```
import { hashTransform } from'astro/assets/utils';functiongenerateTransformHash() {const transform = {width: 800,height: 600,format: 'jpg',};const imageService = 'astroImageService';const propertiesToHash = ['width','height','format'];// Generate the hash based on the transform, image service, and propertiesconst hash = hashTransform(transform,imageService,propertiesToHash);console.log('Generated transform hash:', hash);// Example output: 'd41d8cd98f00b204e9800998ecf8427e'}generateTransformHash();
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 182. `en/reference/integrations-reference/.md`

```text
# Astro Integration API



# Astro Integration API


**Astro Integrations** add new functionality and behaviors for your project with only a few lines of code.

This reference page is for anyone writing their own integration. To learn how to use an integration in your project, check out our [Using Integrations](/en/guides/integrations-guide/) guide instead.


## Examples


[Section titled Examples](#examples)

The official Astro integrations can act as reference for you as you go to build your own integrations.

-   **Renderers:** [`svelte`](/en/guides/integrations-guide/svelte/), [`react`](/en/guides/integrations-guide/react/), [`preact`](/en/guides/integrations-guide/preact/), [`vue`](/en/guides/integrations-guide/vue/), [`solid`](/en/guides/integrations-guide/solid-js/)
-   **Libraries:** [`partytown`](/en/guides/integrations-guide/partytown/)
-   **Features:** [`sitemap`](/en/guides/integrations-guide/sitemap/)


## Quick API Reference


[Section titled Quick API Reference](#quick-api-reference)

```
interface AstroIntegration {name:string;hooks: {'astro:config:setup'?:(options: {config:AstroConfig;command:'dev'|'build'|'preview'|'sync';isRestart:boolean;updateConfig:(newConfig:DeepPartial<AstroConfig>)=>AstroConfig;addRenderer:(renderer:AstroRenderer)=>void;addWatchFile:(path:URL|string)=>void;addClientDirective:(directive:ClientDirectiveConfig)=>void;addMiddleware:(middleware:AstroIntegrationMiddleware)=>void;addDevToolbarApp:(entrypoint:DevToolbarAppEntry)=>void;injectScript:(stage:InjectedScriptStage, content:string)=>void;injectRoute:(injectedRoute:InjectedRoute)=>void;createCodegenDir:()=>URL;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:route:setup'?:(options: {route:RouteOptions;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:routes:resolved'?:(options: {routes:IntegrationResolvedRoute[];logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:config:done'?:(options: {config:AstroConfig;setAdapter:(adapter:AstroAdapter)=>void;injectTypes:(injectedType:InjectedType)=>URL;logger:AstroIntegrationLogger;buildOutput:'static'|'server';})=>void|Promise<void>;'astro:server:setup'?:(options: {server: vite.ViteDevServer;logger:AstroIntegrationLogger;toolbar:ReturnType<typeof getToolbarServerCommunicationHelpers>;refreshContent?:(options:RefreshContentOptions)=>Promise<void>;})=>void|Promise<void>;'astro:server:start'?:(options: {address:AddressInfo;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:server:done'?:(options: {logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:build:start'?:(options: {logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:build:setup'?:(options: {vite: vite.InlineConfig;pages:Map<string, PageBuildData>;target:'client'|'server';updateConfig:(newConfig: vite.InlineConfig)=>void;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:build:ssr'?:(options: {manifest:SerializedSSRManifest;entryPoints:Map<IntegrationRouteData, URL>;middlewareEntryPoint:URL|undefined;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:build:generated'?:(options: {dir:URL;logger:AstroIntegrationLogger;})=>void|Promise<void>;'astro:build:done'?:(options: {pages: { pathname:string }[];dir:URL;assets:Map<string, URL[]>;logger:AstroIntegrationLogger;})=>void|Promise<void>;// ... any custom hooks from integrations};}
```


## Hooks


[Section titled Hooks](#hooks)

Astro provides hooks that integrations can implement to execute during certain parts of Astro’s lifecycle. Astro hooks are defined in the `IntegrationHooks` interface, which is part of the global `Astro` namespace. Each hook has a [`logger` option](#astrointegrationlogger) that allows you to use the Astro logger to write logs.

The following hooks are built in to Astro:


### `astro:config:setup`


[Section titled astro:config:setup](#astroconfigsetup)

**Next hook:** [`astro:route:setup`](#astroroutesetup)

**When:** On initialization, before either the [Vite](https://vite.dev/config/) or [Astro config](/en/reference/configuration-reference/) have resolved.

**Why:** To extend the project config. This includes updating the [Astro config](/en/reference/configuration-reference/), applying [Vite plugins](https://vite.dev/guide/api-plugin.html), adding component renderers, and injecting scripts onto the page.

```
'astro:config:setup'?:(options: {config:AstroConfig;command:'dev'|'build'|'preview'|'sync';isRestart:boolean;updateConfig:(newConfig:DeepPartial<AstroConfig>)=>AstroConfig;addRenderer:(renderer:AstroRenderer)=>void;addClientDirective:(directive:ClientDirectiveConfig)=>void;addMiddleware:(middleware:AstroIntegrationMiddleware)=>void;addDevToolbarApp:(entrypoint:DevToolbarAppEntry)=>void;addWatchFile:(path:URL|string)=>void;injectScript:(stage:InjectedScriptStage, content:string)=>void;injectRoute:(injectedRoute:InjectedRoute)=>void;createCodegenDir:()=>URL;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `config` option


[Section titled config option](#config-option)

**Type:** `AstroConfig`

A read-only copy of the user-supplied [Astro config](/en/reference/configuration-reference/). This is resolved *before* any other integrations have run. If you need a copy of the config after all integrations have completed their config updates, [see the `astro:config:done` hook](#astroconfigdone).


#### `command` option


[Section titled command option](#command-option)

**Type:** `'dev' | 'build' | 'preview' | 'sync'`

-   `dev` - Project is executed with `astro dev`
-   `build` - Project is executed with `astro build`
-   `preview` - Project is executed with `astro preview`
-   `sync` - Project is executed with `astro sync`


#### `isRestart` option


[Section titled isRestart option](#isrestart-option)

**Type:** `boolean`

**Added in:** `astro@1.5.0`

`false` when the dev server starts, `true` when a reload is triggered. Useful to detect when this function is called more than once.


#### `updateConfig()` option


[Section titled updateConfig() option](#updateconfig-option)

**Type:** `(newConfig: DeepPartial<AstroConfig>) => AstroConfig;`

A callback function to update the user-supplied [Astro config](/en/reference/configuration-reference/). Any config you provide **will be merged with the user config + other integration config updates,** so you are free to omit keys!

For example, say you need to supply a [Vite](https://vite.dev/) plugin to the user’s project:

```
import bananaCSS from'@vitejs/official-banana-css-plugin';exportdefault {name: 'banana-css-integration',hooks: {'astro:config:setup': ({ updateConfig })=> {updateConfig({vite: {plugins: [bananaCSS()],}})}}}
```


#### `addRenderer()` option


[Section titled addRenderer() option](#addrenderer-option)

**Type:** `(renderer:` [`AstroRenderer`](https://github.com/withastro/astro/blob/fdd607c5755034edf262e7b275732519328a33b2/packages/astro/src/%40types/astro.ts#L872-L883) `) => void;` **Examples:** [`svelte`](https://github.com/withastro/astro/blob/main/packages/integrations/svelte/src/index.ts), [`react`](https://github.com/withastro/astro/blob/main/packages/integrations/react/src/index.ts), [`preact`](https://github.com/withastro/astro/blob/main/packages/integrations/preact/src/index.ts), [`vue`](https://github.com/withastro/astro/blob/main/packages/integrations/vue/src/index.ts), [`solid`](https://github.com/withastro/astro/blob/main/packages/integrations/solid/src/index.ts)

A callback function to add a component framework renderer (i.e. React, Vue, Svelte, etc). You can browse the examples and type definition above for more advanced options, but here are the 2 main options to be aware of:

-   `clientEntrypoint` - path to a file that executes on the client whenever your component is used. This is mainly for rendering or hydrating your component with JS.
-   `serverEntrypoint` - path to a file that executes during server-side requests or static builds whenever your component is used. These should render components to static markup, with hooks for hydration where applicable. [React’s `renderToString` callback](https://react.dev/reference/react-dom/server/renderToString) is a classic example.

**Added in:** `astro@5.0.0`

The functions `clientEntrypoint` and `serverEntrypoint` accept a `URL`.


#### `addWatchFile()` option


[Section titled addWatchFile() option](#addwatchfile-option)

**Type:** `(path: URL | string) => void`

**Added in:** `astro@1.5.0`

If your integration depends on some configuration file that Vite doesn’t watch and/or needs a full dev server restart to take effect, add it with `addWatchFile`. Whenever that file changes, the Astro dev server will be reloaded (you can check when a reload happens with `isRestart`).

Example usage:

```
// Must be an absolute path!addWatchFile('/home/user/.../my-config.json');addWatchFile(newURL('./ec.config.mjs', config.root));
```


#### `addClientDirective()` option


[Section titled addClientDirective() option](#addclientdirective-option)

**Type:** `(directive:` [`ClientDirectiveConfig`](https://github.com/withastro/astro/blob/00327c213f74627ac9ca1dec774efa5bf71e9375/packages/astro/src/%40types/astro.ts#L1872-L1875) `) => void;`

**Added in:** `astro@2.6.0`

Adds a [custom client directive](/en/reference/directives-reference/#custom-client-directives) to be used in `.astro` files.

Note that directive entrypoints are only bundled through esbuild and should be kept small so they don’t slow down component hydration.

Example usage:

astro.config.mjs

```
import { defineConfig } from'astro/config';import clickDirective from'./astro-click-directive/register.js'// https://astro.build/configexportdefaultdefineConfig({integrations: [clickDirective()],});
```

astro-click-directive/register.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "client:click",hooks: {"astro:config:setup": ({ addClientDirective })=> {addClientDirective({name: "click",entrypoint: "./astro-click-directive/click.js",});},},});
```

astro-click-directive/click.js

```
/*** Hydrate on first click on the window* @type{import('astro').ClientDirective}*/exportdefault(load, opts, el)=> {window.addEventListener('click', async()=> {const hydrate = await load()awaithydrate()}, { once: true })}
```

You can also add types for the directives in your library’s type definition file:

astro-click-directive/index.d.ts

```
import'astro'declaremodule'astro' {interface AstroClientDirectives {'client:click'?:boolean}}
```


#### `addDevToolbarApp()` option


[Section titled addDevToolbarApp() option](#adddevtoolbarapp-option)

**Type:** `(entrypoint: DevToolbarAppEntry) => void;`

**Added in:** `astro@3.4.0`

Adds a [custom dev toolbar app](/en/reference/dev-toolbar-app-reference/).

Example usage:

astro.config.mjs

```
import { defineConfig } from'astro/config';import devToolbarIntegration from'./astro-dev-toolbar-app/integration.js'// https://astro.build/configexportdefaultdefineConfig({integrations: [devToolbarIntegration()],});
```

astro-dev-toolbar-app/integration.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "dev-toolbar-app",hooks: {"astro:config:setup": ({ addDevToolbarApp })=> {addDevToolbarApp({entrypoint: "./astro-dev-toolbar-app/plugin.js",id: "my-plugin",name: "My Plugin"});},},});
```

astro-dev-toolbar-app/plugin.js

```
/*** @type{import('astro').DevToolbarApp}*/exportdefault {id: "my-plugin",name: "My Plugin",icon: "<svg>...</svg>",init() {console.log("I'm a dev toolbar app!")},};
```


#### `addMiddleware()` option


[Section titled addMiddleware() option](#addmiddleware-option)

**Type:** `(middleware:` [`AstroIntegrationMiddleware`](https://github.com/withastro/astro/blob/852ac0f75dfca1b2602e9cdbfa0447d9998e2449/packages/astro/src/%40types/astro.ts#L2124-L2127) `) => void;`

**Added in:** `astro@3.5.0`

Adds [middleware](/en/guides/middleware/) to run on each request. Takes the `entrypoint` module that contains the middleware, and an `order` to specify whether it should run before (`pre`) other middleware or after (`post`).

@my-package/integration.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "my-middleware-package",hooks: {"astro:config:setup": ({ addMiddleware })=> {addMiddleware({entrypoint: '@my-package/middleware',order: 'pre'});},},});
```

Middleware is defined in a package with an `onRequest` function, as with user-defined middleware.

@my-package/middleware.js

```
import { defineMiddleware } from'astro:middleware';export const onRequest = defineMiddleware(async (context, next) => {if(context.url.pathname === '/some-test-path') {return Response.json({ok: true});}return next();});
```

**Added in:** `astro@5.0.0`

The function also accepts a `URL` for `entrypoint`:

@my-package/integration.js

```
/*** @type{() => import('astro').AstroIntegration}*/exportdefault()=> ({name: "my-middleware-package",hooks: {"astro:config:setup": ({ addMiddleware })=> {addMiddleware({entrypoint: newURL('./middleware.js', import.meta.url),order: 'pre'});},},});
```


#### `injectRoute()` option


[Section titled injectRoute() option](#injectroute-option)

**Type:** `({ pattern: string; entrypoint: string | URL; prerender?: boolean }) => void;`

A callback function to inject routes into an Astro project. Injected routes can be [`.astro` pages](/en/basics/astro-pages/) or [`.js` and `.ts` route handlers](/en/guides/endpoints/#static-file-endpoints).

`injectRoute` takes an object with a `pattern` and an `entrypoint`.

-   `pattern` - where the route should be output in the browser, for example `/foo/bar`. A `pattern` can use Astro’s filepath syntax for denoting dynamic routes, for example `/foo/[bar]` or `/foo/[...bar]`. Note that a file extension is **not** needed in the `pattern`.
-   `entrypoint` - a bare module specifier pointing towards the `.astro` page or `.js`/`.ts` route handler that handles the route denoted in the `pattern`.
-   `prerender` - a boolean to set if Astro can’t detect your `prerender` export.


##### Example usage


[Section titled Example usage](#example-usage)

```
injectRoute({// Use Astro’s pattern syntax for dynamic routes.pattern: '/subfolder/[dynamic]',// Use relative path syntax for a local route.entrypoint: './src/dynamic-page.astro',// Use only if Astro can't detect your prerender exportprerender: false});
```

For an integration designed to be installed in other projects, use its package name to refer to the route entrypoint. The following example shows a package published to npm as `@fancy/dashboard` injecting a dashboard route:

```
injectRoute({pattern: '/fancy-dashboard',entrypoint: '@fancy/dashboard/dashboard.astro'});
```

When publishing your package (`@fancy/dashboard`, in this case) to npm, you must export `dashboard.astro` in your `package.json`:

package.json

```
{"name": "@fancy/dashboard",// ..."exports": { "./dashboard.astro": "./dashboard.astro" }}
```

**Added in:** `astro@5.0.0`

The function also accepts a `URL` for `entrypoint`:

```
injectRoute({pattern: '/fancy-dashboard',entrypoint: newURL('./dashboard.astro', import.meta.url)});
```


#### `injectScript()` option


[Section titled injectScript() option](#injectscript-option)

**Type:** `(stage: InjectedScriptStage, content: string) => void;`

A callback function to inject a string of JavaScript content onto every page.

The **`stage`** denotes how this script (the `content`) should be inserted. Some stages allow inserting scripts without modification, while others allow optimization during [Vite’s bundling step](https://vite.dev/guide/build.html):

-   `"head-inline"`: Injected into a script tag in the `<head>` of every page. **Not** optimized or resolved by Vite.

-   `"before-hydration"`: Imported client-side, before the hydration script runs. Optimized and resolved by Vite.

-   `"page"`: Similar to `head-inline`, except that the injected snippet is handled by Vite and bundled with any other `<script>` tags defined inside of Astro components on the page. The script will be loaded with a `<script type="module">` in the final page output, optimized and resolved by Vite.

-   `"page-ssr"`: Imported as a separate module in the frontmatter of every Astro page component. Because this stage imports your script, the `Astro` global is not available and your script will only be run once when the `import` is first evaluated.

    The main use for the `page-ssr` stage is injecting a CSS `import` into every page to be optimized and resolved by Vite:

    ```
    injectScript('page-ssr', 'import "global-styles.css";');
    ```



#### `createCodegenDir`


[Section titled createCodegenDir](#createcodegendir)

**Type:** `() => URL;`

**Added in:** `astro@5.0.0`

A function that creates the `<root>/.astro/integrations/<normalized_integration_name>` folder and returns its path.

It allows you to have a dedicated folder, avoiding conflicts with another integration or Astro itself. This directory is created by calling this function so it’s safe to write files to it directly:

my-integration.ts

```
import { writeFileSync } from'node:fs'const integration = {name: 'my-integration',hooks: {'astro:config:setup': ({ createCodegenDir }) => {const codegenDir = createCodegenDir()writeFileSync(newURL('cache.json', codegenDir), '{}', 'utf-8')}}}
```


### `astro:route:setup`


[Section titled astro:route:setup](#astroroutesetup)

**Added in:** `astro@4.14.0`

**Previous hook:** [`astro:config:setup`](#astroconfigsetup)

**Next hook:** [`astro:routes:resolved`](#astroroutesresolved)

**When:** In `astro build`, before bundling starts. In `astro dev`, while building the module graph and on every change to a file based route (added/removed/updated).

**Why:** To set options for a route at build or request time, such as enabling [on-demand server rendering](/en/guides/on-demand-rendering/#enabling-on-demand-rendering).

```
'astro:route:setup'?:(options: {route:RouteOptions;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `route` option


[Section titled route option](#route-option)

**Type:** [`RouteOptions`](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/types/public/integrations.ts#L14-L27)

An object with a `component` property to identify the route and the following additional values to allow you to configure the generated route: `prerender`.


##### `route.component`


[Section titled route.component](#routecomponent)

**Type:** `string`

**Added in:** `astro@4.14.0`

The `component` property indicates the entrypoint that will be rendered on the route. You can access this value before the routes are built to configure on-demand server rendering for that page.


##### `route.prerender`


[Section titled route.prerender](#routeprerender)

**Type:** `boolean` **Default:** `undefined`

**Added in:** `astro@4.14.0`

The `prerender` property is used to configure [on-demand server rendering](/en/guides/on-demand-rendering/#enabling-on-demand-rendering) for a route. If the route file contains an explicit `export const prerender` value, the value will be used as the default instead of `undefined`.

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({integrations: [setPrerender()],});functionsetPrerender() {return {name: 'set-prerender',hooks: {'astro:route:setup': ({ route })=> {if (route.component.endsWith('/blog/[slug].astro')) {route.prerender=true;}},},};}
```

If the final value after running all the hooks is `undefined`, the route will fall back to a prerender default based on the [`output` option](/en/reference/configuration-reference/#output): prerendered for `static` mode, and on-demand rendered for `server` mode.


### `astro:routes:resolved`


[Section titled astro:routes:resolved](#astroroutesresolved)

**Added in:** `astro@5.0.0`

**Previous hook:** [`astro:route:setup`](#astroroutesetup)

**Next hook:** [`astro:config:done`](#astroconfigdone) (only during setup)

**When:** In `astro dev`, it also runs on every change to a file based route (added/removed/updated).

**Why:** To access routes and their metadata

```
'astro:routes:resolved'?:(options: {routes:IntegrationResolvedRoute[];logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `routes` option


[Section titled routes option](#routes-option)

**Type:** [`IntegrationResolvedRoute[]`](#integrationresolvedroute-type-reference)

A list of all routes with their associated metadata.

Example use:

my-integration.mjs

```
const integration = () => {return {name: 'my-integration',hooks: {'astro:routes:resolved': ({ routes }) => {const projectRoutes = routes.filter(r => r.origin === 'project').map(r => r.pattern)console.log(projectRoutes)},}}}
```


### `astro:config:done`


[Section titled astro:config:done](#astroconfigdone)

**Previous hook:** [`astro:routes:resolved`](#astroroutesresolved)

**Next hook:** [`astro:server:setup`](#astroserversetup) when running in “dev” mode, or [`astro:build:start`](#astrobuildstart) during production builds

**When:** After the Astro config has resolved and other integrations have run their `astro:config:setup` hooks.

**Why:** To retrieve the final config for use in other hooks.

```
'astro:config:done'?:(options: {config:AstroConfig;setAdapter:(adapter:AstroAdapter)=>void;injectTypes:(injectedType:InjectedType)=>URL;logger:AstroIntegrationLogger;buildOutput:'static'|'server';})=>void|Promise<void>;
```


#### `config` option


[Section titled config option](#config-option-1)

**Type:** `AstroConfig`

A read-only copy of the user-supplied [Astro config](/en/reference/configuration-reference/). This is resolved *after* other integrations have run.


#### `setAdapter()` option


[Section titled setAdapter() option](#setadapter-option)

**Type:** `(adapter: AstroAdapter) => void;`

Makes the integration an adapter. Read more in the [adapter API](/en/reference/adapter-reference/).


#### `injectTypes()` option


[Section titled injectTypes() option](#injecttypes-option)

**Type:** `(injectedType: { filename: string; content: string }) => URL`

**Added in:** `astro@4.14.0`

Allows you to inject types into your user’s project by adding a new `*.d.ts` file.

The `filename` property will be used to generate a file at `/.astro/integrations/<normalized_integration_name>/<normalized_filename>.d.ts` and must end with `".d.ts"`.

The `content` property will create the body of the file and must be valid TypeScript.

Additionally, `injectTypes()` returns a URL to the normalized path so you can overwrite its content later on, or manipulate it in any way you want.

```
const path = injectTypes({filename: "types.d.ts",content: "declare module 'virtual:integration' {}"})console.log(path) // URL
```


#### `buildOutput` option


[Section titled buildOutput option](#buildoutput-option)

**Type:** `'static' | 'server'`

**Added in:** `astro@5.0.0`

Allows you to adapt the logic of your integration depending on the user’s project output.


### `astro:server:setup`


[Section titled astro:server:setup](#astroserversetup)

**Previous hook:** [`astro:config:done`](#astroconfigdone)

**Next hook:** [`astro:server:start`](#astroserverstart)

**When:** Just after the Vite server is created in “dev” mode, but before the `listen()` event is fired. [See Vite’s createServer API](https://vite.dev/guide/api-javascript.html#createserver) for more.

**Why:** To update Vite server options and middleware, or enable support for refreshing the content layer.

```
'astro:server:setup'?:(options: {server:vite.ViteDevServer;logger:AstroIntegrationLogger;toolbar:ReturnType<typeofgetToolbarServerCommunicationHelpers>;refreshContent:(options: {loaders?:Array<string>;context?:Record<string, any>;})=>Promise<void>;})=>void|Promise<void>;
```


#### `server` option


[Section titled server option](#server-option)

**Type:** [`ViteDevServer`](https://vite.dev/guide/api-javascript.html#vitedevserver)

A mutable instance of the Vite server used in “dev” mode. For instance, this is [used by our Partytown integration](/en/guides/integrations-guide/partytown/) to inject the Partytown server as middleware:

```
exportdefault {name: 'partytown',hooks: {'astro:server:setup': ({ server })=> {server.middlewares.use(functionmiddleware(req, res, next) {// handle requests});}}}
```


#### `toolbar` option


[Section titled toolbar option](#toolbar-option)

**Type:** `ReturnType<typeof getToolbarServerCommunicationHelpers>`

**Added in:** `astro@4.7.0`

An object providing callback functions to interact with the [dev toolbar](/en/reference/dev-toolbar-app-reference/):


##### `on()`


[Section titled on()](#on)

**Type:** `<T>(event: string, callback: (data: T) => void) => void`

A function that takes an event name as first argument and a callback function as second argument. This allows you to receive a message from a dev toolbar app with data associated to that event.


##### `onAppInitialized()`


[Section titled onAppInitialized()](#onappinitialized)

**Type:** `(appId: string, callback: (data: Record<string, never>) => void) => void`

A function fired when a dev toolbar app is initialized. The first argument is the id of the app that was initialized. The second argument is a callback function to run when the app is initialized.


##### `onAppToggled()`


[Section titled onAppToggled()](#onapptoggled)

**Type:** `(appId: string, callback: (data: { state: boolean; }) => void) => void`

A function fired when a dev toolbar app is toggled on or off. The first argument is the id of the app that was toggled. The second argument is a callback function providing the state to execute when the application is toggled.


##### `send()`


[Section titled send()](#send)

**Type:** `<T>(event: string, payload: T) => void`

A function that sends a message to the dev toolbar that an app can listen for. This takes an event name as the first argument and a payload as the second argument which can be any serializable data.


#### `refreshContent()` option


[Section titled refreshContent() option](#refreshcontent-option)

**Type:** `(options: { loaders?: Array<string>; context?: Record<string, any>; }) => Promise<void>`

**Added in:** `astro@5.0.0`

A function for integrations to trigger an update to the content layer during `astro dev`. This can be used, for example, to register a webhook endpoint during dev, or to open a socket to a CMS to listen for changes.

By default, `refreshContent` will refresh all collections. You can optionally pass a `loaders` property, which is an array of loader names. If provided, only collections that use those loaders will be refreshed. For example, A CMS integration could use this property to only refresh its own collections.

You can also pass a `context` object to the loaders. This can be used to pass arbitrary data such as the webhook body, or an event from the websocket.

my-integration.ts

```
{name: 'my-integration',hooks: {'astro:server:setup': async({ server, refreshContent })=> {// Register a dev server webhook endpointserver.middlewares.use('/_refresh', async(req, res)=> {if(req.method!=='POST') {res.statusCode=405res.end('Method Not Allowed');return}let body = '';req.on('data', chunk=> {body += chunk.toString();});req.on('end', async()=> {try {const webhookBody = JSON.parse(body);awaitrefreshContent({context: { webhookBody },loaders: ['my-loader']});res.writeHead(200, { 'Content-Type': 'application/json' });res.end(JSON.stringify({ message: 'Content refreshed successfully' }));} catch (error) {res.writeHead(500, { 'Content-Type': 'application/json' });res.end(JSON.stringify({ error: 'Failed to refresh content: '+ error.message }));}});});}}}
```

The loader can then access the `refreshContextData` property to get the webhook body. See the [`refreshContextData`](/en/reference/content-loader-reference/#refreshcontextdata) property for more information.


### `astro:server:start`


[Section titled astro:server:start](#astroserverstart)

**Previous hook:** [`astro:server:setup`](#astroserversetup)

**Next hook:** [`astro:server:done`](#astroserverdone)

**When:** Just after the server’s `listen()` event has fired.

**Why:** To intercept network requests at the specified address. If you intend to use this address for middleware, consider using `astro:server:setup` instead.

```
'astro:server:start'?:(options: {address:AddressInfo;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `address` option


[Section titled address option](#address-option)

**Type:** [`AddressInfo`](https://microsoft.github.io/PowerBI-JavaScript/interfaces/_node_modules__types_node_net_d_._net_.addressinfo.html)

The address, family and port number supplied by the [Node.js Net module](https://nodejs.org/api/net.html).


### `astro:server:done`


[Section titled astro:server:done](#astroserverdone)

**Previous hook:** [`astro:server:start`](#astroserverstart)

**When:** Just after the dev server is closed.

**Why:** To run any cleanup events you may trigger during the `astro:server:setup` or `astro:server:start` hooks.

```
'astro:server:done'?:(options: {logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


### `astro:build:start`


[Section titled astro:build:start](#astrobuildstart)

**Previous hook:** [`astro:config:done`](#astroconfigdone)

**Next hook:** [`astro:build:setup`](#astrobuildsetup)

**When:** After the `astro:config:done` event, but before the production build begins.

**Why:** To set up any global objects or clients needed during a production build. This can also extend the build configuration options in the [adapter API](/en/reference/adapter-reference/).

```
'astro:build:start'?:(options: {logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


### `astro:build:setup`


[Section titled astro:build:setup](#astrobuildsetup)

**Previous hook:** [`astro:build:start`](#astrobuildstart)

**Next hook:** [`astro:build:ssr`](#astrobuildssr)

**When:** After the `astro:build:start` hook, runs immediately before the build.

**Why:** At this point, the Vite config for the build has been completely constructed, this is your final chance to modify it. This can be useful for example to overwrite some defaults. If you’re not sure whether you should use this hook or `astro:build:start`, use `astro:build:start` instead.

```
'astro:build:setup'?:(options: {vite:vite.InlineConfig;pages:Map<string, PageBuildData>;target:'client'|'server';updateConfig:(newConfig:vite.InlineConfig)=>void;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `vite` option


[Section titled vite option](#vite-option)

**Type:** [`InlineConfig`](https://vite.dev/guide/api-javascript.html#inlineconfig)

An object that allows you to access the Vite configuration used in the build.

This can be useful if you need to access configuration options in your integration:

```
exportdefault {name: 'my-integration',hooks: {'astro:build:setup': ({ vite })=> {const { publicDir, root } = vite;},}}
```


#### `pages` option


[Section titled pages option](#pages-option)

**Type:** `Map<string, [PageBuildData](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/core/build/types.ts#L17-L23)>`

A `Map` with a list of pages as key and their build data as value.

This can be used to perform an action if a route matches a criteria:

```
exportdefault {name: 'my-integration',hooks: {'astro:build:setup': ({ pages })=> {pages.forEach((data)=> {if (data.route.pattern.test("/blog")) {console.log(data.route.type);}});},}}
```


#### `target` option


[Section titled target option](#target-option)

**Type:** `'client' | 'server'`

Builds are separated in two distinct phases: `client` and `server`. This option allow you to determine the current build phase.

This can be used to perform an action only in a specific phase:

```
exportdefault {name: 'my-integration',hooks: {'astro:build:setup': ({ target })=> {if (target==="server") {// do something in server build phase}},}}
```


#### `updateConfig()` option


[Section titled updateConfig() option](#updateconfig-option-1)

**Type:** `(newConfig: [InlineConfig](https://vite.dev/guide/api-javascript.html#inlineconfig)) => void`

A callback function to update the [Vite](https://vite.dev/) options used in the build. Any config you provide **will be merged with the user config + other integration config updates**, so you are free to omit keys!

For example, this can be used to supply a plugin to the user’s project:

```
import awesomeCssPlugin from'awesome-css-vite-plugin';exportdefault {name: 'my-integration',hooks: {'astro:build:setup': ({ updateConfig })=> {updateConfig({plugins: [awesomeCssPlugin()],})}}}
```


### `astro:build:ssr`


[Section titled astro:build:ssr](#astrobuildssr)

**Previous hook:** [`astro:build:setup`](#astrobuildsetup)

**Next hook:** [`astro:build:generated`](#astrobuildgenerated)

**When:** After a production SSR build has completed.

**Why:** To access the SSR manifest and map of the emitted entry points. This is useful when creating custom SSR builds in plugins or integrations.

-   `entryPoints` maps a page route to the physical file emitted after the build;
-   `middlewareEntryPoint` is the file system path of the middleware file;

```
'astro:build:ssr'?:(options: {manifest:SerializedSSRManifest;entryPoints:Map<IntegrationRouteData, URL>;middlewareEntryPoint:URL|undefined;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `manifest` option


[Section titled manifest option](#manifest-option)

**Type:** [`SerializedSSRManifest`](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/core/app/types.ts#L91-L109)

Allows you to create a custom build by accessing the SSR manifest.

```
exportdefault {name: 'my-integration',hooks: {'astro:build:ssr': ({ manifest })=> {const { i18n } = manifest;if (i18n?.strategy==="domains-prefix-always") {// do something}},},}
```


#### `entryPoints` option


[Section titled entryPoints option](#entrypoints-option)

**Type:** `Map<[IntegrationRouteData](#integrationroutedata-type-reference), URL>`

**Added in:** `astro@2.7.0`

A `Map` of the emitted entry points with the `IntegrationRouteData` as key and the physical file URL as value.

```
exportdefault {name: 'my-integration',hooks: {'astro:build:ssr': ({ entryPoints })=> {entryPoints.forEach((url)=> {console.log(url.href);});},},}
```


#### `middlewareEntryPoint` option


[Section titled middlewareEntryPoint option](#middlewareentrypoint-option)

**Type:** `URL | undefined`

**Added in:** `astro@2.8.0`

Exposes the [middleware](/en/guides/middleware/) file path.

```
exportdefault {name: 'my-integration',hooks: {'astro:build:ssr': ({ middlewareEntryPoint })=> {if (middlewareEntryPoint) {// do some operations if a middleware exist}},},}
```


### `astro:build:generated`


[Section titled astro:build:generated](#astrobuildgenerated)

**Added in:** `astro@1.3.0`

**Previous hook:** [`astro:build:ssr`](#astrobuildssr)

**Next hook:** [`astro:build:done`](#astrobuilddone)

**When:** After a static production build has finished generating routes and assets.

**Why:** To access generated routes and assets **before** build artifacts are cleaned up. This is a very uncommon use case. We recommend using [`astro:build:done`](#astrobuilddone) unless you really need to access the generated files before cleanup.

```
'astro:build:generated'?:(options: {dir:URL;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `dir` option


[Section titled dir option](#dir-option)

**Type:** [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL)

A URL path to the build output directory. Note that if you need a valid absolute path string, you should use Node’s built-in [`fileURLToPath`](https://nodejs.org/api/url.html#urlfileurltopathurl-options) utility.

```
import { fileURLToPath } from'node:url';exportdefault {name: 'my-integration',hooks: {'astro:build:generated': ({ dir })=> {const outFile = fileURLToPath(newURL('./my-integration.json', dir));}}}
```


### `astro:build:done`


[Section titled astro:build:done](#astrobuilddone)

**Previous hook:** [`astro:build:generated`](#astrobuildgenerated)

**When:** After a production build (SSG or SSR) has completed.

**Why:** To access generated routes and assets for extension (ex. copy content into the generated `/assets` directory). If you plan to transform generated assets, we recommend exploring the [Vite Plugin API](https://vite.dev/guide/api-plugin.html) and [configuring via `astro:config:setup`](#updateconfig-option) instead.

```
'astro:build:done'?:(options: {pages: { pathname:string }[];dir:URL;/** @deprecated Use the `assets` map and the new `astro:routes:resolved` hook */routes:IntegrationRouteData[];assets:Map<string, URL[]>;logger:AstroIntegrationLogger;})=>void|Promise<void>;
```


#### `dir` option


[Section titled dir option](#dir-option-1)

**Type:** [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL)

A URL path to the build output directory. Note that if you need a valid absolute path string, you should use Node’s built-in [`fileURLToPath`](https://nodejs.org/api/url.html#urlfileurltopathurl-options) utility.

```
import { writeFile } from'node:fs/promises';import { fileURLToPath } from'node:url';exportdefaultfunctionmyIntegration() {return {hooks: {'astro:build:done': async({ dir })=> {const metadata = await getIntegrationMetadata();// Use fileURLToPath to get a valid, cross-platform absolute path stringconst outFile = fileURLToPath(newURL('./my-integration.json',dir));awaitwriteFile(outFile,JSON.stringify(metadata));}}}}
```


#### `routes` option


[Section titled routes option](#routes-option-1)

Caution

This property is deprecated since v5.0. Check the [migration guide](/en/guides/upgrade-to/v5/#deprecated-routes-on-astrobuilddone-hook-integration-api).

**Type:** [`IntegrationRouteData[]`](#integrationroutedata-type-reference)

A list of all generated routes alongside their associated metadata.

You can reference the full `IntegrationRouteData` type below, but the most common properties are:

-   `component` - the input file path relative to the project root
-   `pathname` - the output file URL (undefined for routes using `[dynamic]` and `[...spread]` params)


#### `assets` option


[Section titled assets option](#assets-option)

**Type:** `Map<string, URL[]>`

**Added in:** `astro@5.0.0`

Contains URLs to output files paths, grouped by [`IntegrationResolvedRoute`](#integrationresolvedroute-type-reference) `pattern` property.


#### `pages` option


[Section titled pages option](#pages-option-1)

**Type:** `{ pathname: string }[]`

A list of all generated pages. It is an object with one property.

-   `pathname` - the finalized path of the page.


### Custom hooks


[Section titled Custom hooks](#custom-hooks)

Custom hooks can be added to integrations by extending the `IntegrationHooks` interface through [global augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation).

```
declare global {namespace Astro {exportinterface IntegrationHook {'your:hook':(params:YourHookParameters)=>Promise<void>}}}
```

Astro reserves the `astro:` prefix for future built-in hooks. Please choose a different prefix when naming your custom hook.


## Integration types reference


[Section titled Integration types reference](#integration-types-reference)


### `AstroIntegrationLogger`


[Section titled AstroIntegrationLogger](#astrointegrationlogger)

An instance of the Astro logger, useful to write logs. This logger uses the same [log level](/en/reference/cli-reference/#--verbose) configured via CLI.

**Methods available** to write to terminal:

-   `logger.info("Message")`;
-   `logger.warn("Message")`;
-   `logger.error("Message")`;
-   `logger.debug("Message")`;

All the messages are prepended with a label that has the same value as the name of the integration.

integration.ts

```
importtype { AstroIntegration } from"astro";exportfunctionformatIntegration():AstroIntegration {return {name: "astro-format",hooks: {"astro:build:done": ({ logger })=> {// do somethinglogger.info("Integration ready.");}}}}
```

The example above will log a message that includes the provided `info` message:

Terminal window

```
[astro-format] Integration ready.
```

To log some messages with a different label, use the `.fork` method to specify an alternative to the default `name`:

integration.ts

```
importtype { AstroIntegration } from"astro";exportfunctionformatIntegration():AstroIntegration {return {name: "astro-format",hooks: {"astro:config:done": ({ logger })=> {// do somethinglogger.info("Integration ready.");},"astro:build:done": ({ logger })=> {const buildLogger = logger.fork("astro-format/build");// do somethingbuildLogger.info("Build finished.")}}}}
```

The example above will produce logs with `[astro-format]` by default, and `[astro-format/build]` when specified:

Terminal window

```
[astro-format] Integration ready.[astro-format/build] Build finished.
```


### `HookParameters`


[Section titled HookParameters](#hookparameters)

You can get the type of a hook’s arguments by passing the hook’s name to the `HookParameters` utility type. In the following example, a function’s `options` argument is typed to match the parameters of the `astro:config:setup` hook:

```
importtype { HookParameters } from'astro';functionmySetup(options:HookParameters<'astro:config:setup'>) {options.updateConfig({ /* ... */ });}
```


### `IntegrationResolvedRoute` type reference


[Section titled IntegrationResolvedRoute type reference](#integrationresolvedroute-type-reference)

```
interface IntegrationResolvedRoute {pattern:RouteData['route'];patternRegex:RouteData['pattern'];entrypoint:RouteData['component'];isPrerendered:RouteData['prerender'];redirectRoute?:IntegrationResolvedRoute;generate:(data?:any)=>string;params:string[];pathname?:string;segments:RoutePart[][];type:RouteType;redirect?:RedirectConfig;origin:'internal'|'external'|'project';}
```


#### `pattern`


[Section titled pattern](#pattern)

**Type:** `string`

Allows you to identify the type of route based on its path. Here are some examples of paths associated with their pattern:

-   `src/pages/index.astro` will be `/`
-   `src/pages/blog/[...slug].astro` will be `/blog/[...slug]`
-   `src/pages/site/[blog]/[...slug].astro` will be `/site/[blog]/[...slug]`


#### `patternRegex`


[Section titled patternRegex](#patternregex)

**Type:** `RegExp`

Allows you to access a regex used for matching an input URL against a requested route.

For example, given a `[fruit]/about.astro` path, the regex will be `/^\/([^/]+?)\/about\/?$/`. Using `pattern.test("banana/about")` will return `true`.


#### `entrypoint`


[Section titled entrypoint](#entrypoint)

**Type:** `string`

The URL pathname of the source component.


#### `isPrerendered`


[Section titled isPrerendered](#isprerendered)

**Type:** `boolean`

Determines whether the route use [on demand rendering](/en/guides/on-demand-rendering/). The value will be `true` for projects configured with:

-   `output: 'static'` when the route does not export `const prerender = true`
-   `output: 'server'` when the route exports `const prerender = false`


#### `redirectRoute`


[Section titled redirectRoute](#redirectroute)

**Type:** `IntegrationResolvedRoute | undefined`

When the value of `IntegrationResolvedRoute.type` is `redirect`, the value will be the `IntegrationResolvedRoute` to redirect to. Otherwise, the value will be undefined.


#### `generate()`


[Section titled generate()](#generate)

**Type:** `(data?: any) => string`

A function that provides the optional parameters of the route, interpolates them with the route pattern, and returns the path name of the route.

For example, with a route such as `/blog/[...id].astro`, the `generate` function could return:

```
console.log(generate({ id: 'presentation' })) // will log `/blog/presentation`
```


#### `params`


[Section titled params](#params)

**Type:** `string[]`

Allows you to access the route `params`. For example, when a project uses the following [dynamic routes](/en/guides/routing/#dynamic-routes) `/pages/[lang]/[...slug].astro`, the value will be `['lang', '...slug']`.


#### `pathname`


[Section titled pathname](#pathname)

**Type:** `string | undefined`

For regular routes, the value will be the URL pathname where this route will be served. When the project uses [dynamic routes](/en/guides/routing/#dynamic-routes) (ie. `[dynamic]` or `[...spread]`), the pathname will be undefined.


#### `segments`


[Section titled segments](#segments)

**Type:** `[RoutePart](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/types/public/internal.ts#L154-L158)[][]`

Allows you to access the route [`params`](#params) with additional metadata. Each object contains the following properties:

-   `content`: the `param` name,
-   `dynamic`: whether the route is dynamic or not,
-   `spread`: whether the dynamic route uses the spread syntax or not.

For example, the following route `/pages/[blog]/[...slug].astro` will output the segments:

```
[[ { content: 'pages', dynamic: false, spread: false } ],[ { content: 'blog', dynamic: true, spread: false } ],[ { content: '...slug', dynamic: true, spread: true } ]]
```


#### `type`


[Section titled type](#type)

**Type:** `RouteType`

Allows you to identify the type of route. Possible values are:

-   `page`: a route that lives in the file system, usually an Astro component
-   `endpoint`: a route that lives in the file system, usually a JS file that exposes endpoints methods
-   `redirect`: a route points to another route that lives in the file system
-   `fallback`: a route that doesn’t exist in the file system that needs to be handled with other means, usually the middleware


#### `redirect`


[Section titled redirect](#redirect)

**Type:** `[RedirectConfig](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/types/public/config.ts#L39-L44) | undefined`

Allows you to access the route to redirect to. This can be a string or an object containing information about the status code and its destination.


#### `origin`


[Section titled origin](#origin)

**Type:** `'internal' | 'external' | 'project'`

Determines if a route comes from Astro core (`internal`), an integration (`external`) or the user’s project (`project`).


### `IntegrationRouteData` type reference


[Section titled IntegrationRouteData type reference](#integrationroutedata-type-reference)

Caution

This type is deprecated since v5.0. Use [`IntegrationResolvedRoute`](#integrationresolvedroute-type-reference) instead.

A smaller version of the `RouteData` that is used in the integrations.

```
interface IntegrationRouteData {type:RouteType;component:string;pathname?:string;pattern:RegExp;params:string[];segments: { content:string; dynamic:boolean; spread:boolean; }[][];generate:(data?:any)=>string;prerender:boolean;distURL?:URL[];redirect?:RedirectConfig;redirectRoute?:IntegrationRouteData;}
```


#### `type`


[Section titled type](#type-1)

**Type:** `RouteType`

Allows you to identify the type of the route. The value can be:

-   `page`: a route that lives in the file system, usually an Astro component
-   `endpoint`: a route that lives in the file system, usually a JS file that exposes endpoints methods
-   `redirect`: a route that points to another route that lives in the file system
-   `fallback`: a route that doesn’t exist in the file system and needs to be handled with other means, usually middleware


#### `component`


[Section titled component](#component)

**Type:** `string`

Allows you to access the source component URL pathname.


#### `pathname`


[Section titled pathname](#pathname-1)

**Type:** `string | undefined`

For regular routes, the value will be the URL pathname where this route will be served. When the project uses [dynamic routes](/en/guides/routing/#dynamic-routes) (ie. `[dynamic]` or `[...spread]`), the pathname will be undefined.


#### `pattern`


[Section titled pattern](#pattern-1)

**Type:** `RegExp`

Allows you to access a regex used for matching an input URL against a requested route.

For example, given a `[fruit]/about.astro` path, the regex will be `/^\/([^/]+?)\/about\/?$/`. Using `pattern.test("banana/about")` will return `true`.


#### `params`


[Section titled params](#params-1)

**Type:** `string[]`

Allows you to access the route `params`. For example, when a project uses the following [dynamic routes](/en/guides/routing/#dynamic-routes) `/pages/[lang]/[...slug].astro`, the value will be `['lang', '...slug']`.


#### `segments`


[Section titled segments](#segments-1)

**Type:** `{ content: string; dynamic: boolean; spread: boolean; }[][]`

Allows you to access the route [`params`](#params-1) with additional metadata. Each object contains the following properties:

-   `content`: the `param`,
-   `dynamic`: whether the route is dynamic or not,
-   `spread`: whether the dynamic route uses the spread syntax or not.

For example, the following route `/pages/[lang]/index.astro` will output the segments `[[ { content: 'lang', dynamic: true, spread: false } ]]`.


#### `generate()`


[Section titled generate()](#generate-1)

**Type:** `(data?: any) => string`

A function that provides the optional parameters of the route, interpolates them with the route pattern, and returns the path name of the route.

For example, with a route such as `/blog/[...id].astro`, the `generate` function could return:

```
console.log(generate({ id: 'presentation' })) // will log `/blog/presentation`
```


#### `prerender`


[Section titled prerender](#prerender)

**Type:** `boolean`

Determines whether the route is prerendered or not.


#### `distURL`


[Section titled distURL](#disturl)

**Type:** `URL[] | undefined`

The paths of the physical files emitted by this route. When a route **isn’t** prerendered, the value is either `undefined` or an empty array.


#### `redirect`


[Section titled redirect](#redirect-1)

**Type:** `[RedirectConfig](https://github.com/withastro/astro/blob/3b10b97a4fecd1dfd959b160a07b5b8427fe40a7/packages/astro/src/types/public/config.ts#L39-L44) | undefined`

Allows you to access the route to redirect to. This can be a string or an object containing information about the status code and its destination.


#### `redirectRoute`


[Section titled redirectRoute](#redirectroute-1)

**Type:** `IntegrationRouteData | undefined`

When the value of `RouteData.type` is `redirect`, the value will contains the `IntegrationRouteData` of the route to redirect to. Otherwise, the value will be undefined.


## Allow installation with `astro add`


[Section titled Allow installation with astro add](#allow-installation-with-astro-add)

[The `astro add` command](/en/reference/cli-reference/#astro-add) allows users to easily add integrations and adapters to their project. If you want *your* integration to be installable with this tool, **add `astro-integration` to the `keywords` field in your `package.json`**:

```
{"name": "example","keywords": ["astro-integration"],}
```

Once you [publish your integration to npm](https://docs.npmjs.com/cli/v8/commands/npm-publish), running `astro add example` will install your package with any peer dependencies specified in your `package.json`. This will also apply your integration to the user’s `astro.config.*` like so:

astro.config.mjs

```
import { defineConfig } from'astro/config';import example from'example';exportdefaultdefineConfig({integrations: [example()],})
```

Caution

This assumes your integration definition is 1) a `default` export and 2) a function. Ensure this is true before adding the `astro-integration` keyword!


## Integration Ordering


[Section titled Integration Ordering](#integration-ordering)

All integrations are run in the order that they are configured. For instance, for the array `[react(), svelte()]` in a user’s `astro.config.*`, `react` will run before `svelte`.

Your integration should ideally run in any order. If this isn’t possible, we recommend documenting that your integration needs to come first or last in your user’s `integrations` configuration array.


## Combine integrations into presets


[Section titled Combine integrations into presets](#combine-integrations-into-presets)

An integration can also be written as a collection of multiple, smaller integrations. We call these collections **presets.** Instead of creating a factory function that returns a single integration object, a preset returns an *array* of integration objects. This is useful for building complex features out of multiple integrations.

```
integrations: [// Example: where examplePreset() returns: [integrationOne, integrationTwo, ...etc]examplePreset()]
```


## Community Resources


[Section titled Community Resources](#community-resources)

-   [Build your own Astro Integrations](https://www.freecodecamp.org/news/how-to-use-the-astro-ui-framework/#chapter-8-build-your-own-astro-integrations-1) - by Emmanuel Ohans on FreeCodeCamp
-   [Astro Integration Template](https://github.com/florian-lefebvre/astro-integration-template) - by Florian Lefebvre on GitHub

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 183. `en/reference/legacy-flags/.md`

```text
# Legacy flags



# Legacy flags


To help some users migrate between versions of Astro, we occasionally introduce `legacy` flags.

These flags allow you to opt in to some deprecated or otherwise outdated behavior of Astro in the latest version, so that you can continue to upgrade and take advantage of new Astro releases until you are able to fully update your project code.


## Collections


[Section titled Collections](#collections)

**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.0.0`

Enable legacy behavior for content collections (as used in Astro v2 through v4)

astro.config.mjs

```
import { defineConfig } from'astro/config';exportdefaultdefineConfig({legacy: {collections: true}});
```

If enabled, `data` and `content` collections (only) are handled using the legacy content collections implementation. Collections with a `loader` (only) will continue to use the Content Layer API instead. Both kinds of collections may exist in the same project, each using their respective implementations.

The following limitations continue to exist:

-   Any legacy (`type: 'content'` or `type: 'data'`) collections must continue to be located in the `src/content/` directory.
-   These legacy collections will not be transformed to implicitly use the `glob()` loader, and will instead be handled by legacy code.
-   Collections using the Content Layer API (with a `loader` defined) are forbidden in `src/content/`, but may exist anywhere else in your project.

When you are ready to remove this flag and migrate to the new Content Layer API for your legacy collections, you must define a collection for any directories in `src/content/` that you want to continue to use as a collection. It is sufficient to declare an empty collection, and Astro will implicitly generate an appropriate definition for your legacy collections:

src/content/config.ts

```
import { defineCollection, z } from'astro:content';const blog = defineCollection({ })export const collections = { blog };
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 184. `en/reference/modules/astro-actions/.md`

```text
# Actions API Reference



# Actions API Reference


**Added in:** `astro@4.15.0`

Actions help you build a type-safe backend you can call from client code and HTML forms. All utilities to define and call actions are exposed by the `astro:actions` module. For examples and usage instructions, [see the Actions guide](/en/guides/actions/).


## Imports from `astro:actions`


[Section titled Imports from astro:actions](#imports-from-astroactions)

```
import {actions,defineAction,isInputError,isActionError,ActionError,} from'astro:actions';
```


### `defineAction()`


[Section titled defineAction()](#defineaction)

**Added in:** `astro@4.15.0`

The `defineAction()` utility is used to define new actions from the `src/actions/index.ts` file. This accepts a [`handler()`](#handler-property) function containing the server logic to run, and an optional [`input`](#input-validator) property to validate input parameters at runtime.

src/actions/index.ts

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {getGreeting: defineAction({input: z.object({name: z.string(),}),handler: async (input, context) => {return `Hello, ${input.name}!`}})}
```


#### `handler()` property


[Section titled handler() property](#handler-property)

**Type:** `(input, context) => any`

`defineAction()` requires a `handler()` function containing the server logic to run when the action is called. Data returned from the handler is automatically serialized and sent to the caller.

The `handler()` is called with user input as its first argument. If an [`input`](#input-validator) validator is set, the user input will be validated before being passed to the handler. The second argument is a `context` object containing most of Astro’s [standard endpoint context](/en/reference/api-reference/), excluding `getActionResult()`, `callAction()`, and `redirect()`.

Return values are parsed using the [devalue library](https://github.com/Rich-Harris/devalue). This supports JSON values and instances of `Date()`, `Map()`, `Set()`, and `URL()`.


#### `input` validator


[Section titled input validator](#input-validator)

**Type:** `ZodType | undefined`

The optional `input` property accepts a Zod validator (e.g. Zod object, Zod discriminated union) to validate handler inputs at runtime. If the action fails to validate, [a `BAD_REQUEST` error](#actionerror) is returned and the `handler` is not called.

If `input` is omitted, the `handler` will receive an input of type `unknown` for JSON requests and type `FormData` for form requests.


##### Use with `accept: 'form'`


[Section titled Use with accept: &#39;form&#39;](#use-with-accept-form)

If your action accepts form inputs, use the `z.object()` validator to automatically parse form data to a typed object. The following validators are supported for form data fields:

-   Inputs of type `number` can be validated using `z.number()`
-   Inputs of type `checkbox` can be validated using `z.coerce.boolean()`
-   Inputs of type `file` can be validated using `z.instanceof(File)`
-   Multiple inputs of the same `name` can be validated using `z.array(/* validator */)`
-   All other inputs can be validated using `z.string()`

Extension functions including `.refine()`, `.transform()`, and `.pipe()` are also supported on the `z.object()` validator.

To apply a union of different validators, use the `z.discriminatedUnion()` wrapper to narrow the type based on a specific form field. This example accepts a form submission to either “create” or “update” a user, using the form field with the name `type` to determine which object to validate against:

```
import { defineAction } from'astro:actions';import { z } from'astro:schema';export const server = {changeUser: defineAction({accept: 'form',input: z.discriminatedUnion('type', [z.object({// Matches when the `type` field has the value `create`type: z.literal('create'),name: z.string(),email: z.string().email(),}),z.object({// Matches when the `type` field has the value `update`type: z.literal('update'),id: z.number(),name: z.string(),email: z.string().email(),}),]),async handler(input) {if (input.type === 'create') {// input is { type: 'create', name: string, email: string }} else {// input is { type: 'update', id: number, name: string, email: string }}},}),};
```


### `isInputError()`


[Section titled isInputError()](#isinputerror)

**Type:** `(error?: unknown | [ActionError](#actionerror)) => boolean`

**Added in:** `astro@4.15.0`

The `isInputError()` utility is used to check whether an `ActionError` is an input validation error. When the `input` validator is a `z.object()`, input errors include a `fields` object with error messages grouped by name.

See the [form input errors guide](/en/guides/actions/#displaying-form-input-errors) for more on using `isInputError()`.


### `isActionError()`


[Section titled isActionError()](#isactionerror)

**Type:** `(error?: unknown | [ActionError](#actionerror)) => boolean`

**Added in:** `astro@4.15.0`

The `isActionError()` utility is used to check whether your action raised an `ActionError` within the [handler property](/en/reference/modules/astro-actions/#handler-property). This is useful when narrowing the type of a generic error in a `try / catch` block.


### `ActionError`


[Section titled ActionError](#actionerror)

**Added in:** `astro@4.15.0`

The `ActionError()` constructor is used to create errors thrown by an action `handler`. This accepts a `code` property describing the error that occurred (example: `"UNAUTHORIZED"`), and an optional `message` property with further details.


#### `code`


[Section titled code](#code)

**Added in:** `astro@4.15.0`

The `code` property accepts human-readable versions of all HTTP status codes. The following codes are supported:

-   `BAD_REQUEST` (400): The client sent invalid input. This error is thrown when an action `input` validator fails to validate.
-   `UNAUTHORIZED` (401): The client lacks valid authentication credentials.
-   `FORBIDDEN` (403): The client is not authorized to access a resource.
-   `NOT_FOUND` (404): The server cannot find the requested resource.
-   `METHOD_NOT_SUPPORTED` (405): The server does not support the requested method.
-   `TIMEOUT` (408): The server timed out while processing the request.
-   `CONFLICT` (409): The server cannot update a resource due to a conflict.
-   `PRECONDITION_FAILED` (412): The server does not meet a precondition of the request.
-   `PAYLOAD_TOO_LARGE` (413): The server cannot process the request because the payload is too large.
-   `UNSUPPORTED_MEDIA_TYPE` (415): The server does not support the request’s media type. Note: Actions already check [the `Content-Type` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) for JSON and form requests, so you likely won’t need to raise this code manually.
-   `UNPROCESSABLE_CONTENT` (422): The server cannot process the request due to semantic errors.
-   `TOO_MANY_REQUESTS` (429): The server has exceeded a specified rate limit.
-   `CLIENT_CLOSED_REQUEST` (499): The client closed the request before the server could respond.
-   `INTERNAL_SERVER_ERROR` (500): The server failed unexpectedly.
-   `NOT_IMPLEMENTED` (501): The server does not support the requested feature.
-   `BAD_GATEWAY` (502): The server received an invalid response from an upstream server.
-   `SERVICE_UNAVAILABLE` (503): The server is temporarily unavailable.
-   `GATEWAY_TIMEOUT` (504): The server received a timeout from an upstream server.


#### `message`


[Section titled message](#message)

**Added in:** `astro@4.15.0`

The `message` property accepts a string. (e.g. “User must be logged in.“)


### `getActionContext()`


[Section titled getActionContext()](#getactioncontext)

**Type:** `(context: APIContext) => ActionMiddlewareContext`

**Added in:** `astro@5.0.0`

`getActionContext()` is a function called from your middleware handler to retrieve information about inbound action requests.

This function returns an `action` object with information about the request, and the `setActionResult()` and `serializeActionResult()` functions to programmatically set the value returned by `Astro.getActionResult()`.

`getActionContext()` lets you programmatically get and set action results using middleware, allowing you to persist action results from HTML forms, gate action requests with added security checks, and more.

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action, setActionResult, serializeActionResult } = getActionContext(context);if (action?.calledFrom === 'form') {const result = await action.handler();setActionResult(action.name, serializeActionResult(result));}return next();});
```


#### `action`


[Section titled action](#action)

**Type:** `{ calledFrom: 'rpc' | 'form', name: string, handler: () => Promise<SafeResult<any, any>> } | undefined`

`action` is an object containing information about an inbound action request.

It is available from `getActionContext()`, and provides the action name, handler, and whether the action was called from an client-side RPC function (e.g. `actions.newsletter()`) or an HTML form action.

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action, setActionResult, serializeActionResult } = getActionContext(context);if (action?.calledFrom === 'rpc' && action.name.startsWith('private')) {// Check for a valid session token}// ...});
```


#### `setActionResult()`


[Section titled setActionResult()](#setactionresult)

**Type:** `(actionName: string, actionResult: SerializedActionResult) => void`

`setActionResult()` is a function to programmatically set the value returned by `Astro.getActionResult()` in middleware. It is passed the action name and an action result serialized by [`serializeActionResult()`](#serializeactionresult).

This is useful when calling actions from an HTML form to persist and load results from a session.

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action, setActionResult, serializeActionResult } = getActionContext(context);if (action?.calledFrom === 'form') {const result = await action.handler();// ... handle the action resultsetActionResult(action.name, serializeActionResult(result));}return next();});
```

See the [advanced sessions guide](/en/guides/actions/#advanced-persist-action-results-with-a-session) for a sample implementation using Netlify Blob.


#### `serializeActionResult()`


[Section titled serializeActionResult()](#serializeactionresult)

**Type:** `(result: SafeResult<any, any>) => SerializedActionResult`

`serializeActionResult()` will serialize an action result to JSON for persistence. This is required to properly handle non-JSON return values like `Map` or `Date` as well as the `ActionError` object.

Call this function when serializing an action result to be passed to `setActionResult()`:

src/middleware.ts

```
import { defineMiddleware } from'astro:middleware';import { getActionContext } from'astro:actions';export const onRequest = defineMiddleware(async (context, next) => {const { action, setActionResult, serializeActionResult } = getActionContext(context);if (action) {const result = await action.handler();setActionResult(action.name, serializeActionResult(result));}// ...});
```


#### `deserializeActionResult()`


[Section titled deserializeActionResult()](#deserializeactionresult)

**Type:** `(result: SerializedActionResult) => SafeResult<any, any>`

`deserializeActionResult()` will reverse the effect of `serializeActionResult()` and return an action result to its original state. This is useful to access the `data` and `error` objects on a serialized action result.


### `getActionPath()`


[Section titled getActionPath()](#getactionpath)

**Type:** `(action: ActionClient<any, any, any>) => string`

**Added in:** `astro@5.1.0`

The `getActionPath()` utility accepts an action and returns a URL path so you can execute an action call as a `fetch()` operation directly. This allows you to provide details such as custom headers when you call your action. Then, you can [handle the custom-formatted returned data](/en/guides/actions/#handling-returned-data) as needed, just as if you had called an action directly.

This example shows how to call a defined `like` action passing the `Authorization` header and the [`keepalive`](https://developer.mozilla.org/en-US/docs/Web/API/Request/keepalive) option:

src/components/my-component.astro

```
<script>import { actions, getActionPath } from'astro:actions'awaitfetch(getActionPath(actions.like), {method: 'POST',headers: {'Content-Type': 'application/json',Authorization: 'Bearer YOUR_TOKEN'},body: JSON.stringify({ id: 'YOUR_ID' }),keepalive: true})</script>
```

This example shows how to call the same `like` action using the [`sendBeacon`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon) API:

src/components/my-component.astro

```
<script>import { actions, getActionPath } from'astro:actions'navigator.sendBeacon(getActionPath(actions.like),newBlob([JSON.stringify({ id: 'YOUR_ID' })], {type: 'application/json'}))</script>
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 185. `en/reference/modules/astro-assets/.md`

```text
# Image and Assets API Reference



# Image and Assets API Reference


**Added in:** `astro@3.0.0`

Astro provides built-in components and helper functions for optimizing and displaying your images. For features and usage examples, [see our image guide](/en/guides/images/).


## Imports from `astro:assets`


[Section titled Imports from astro:assets](#imports-from-astroassets)

```
import {Image,Picture,getImage,inferRemoteSize,} from'astro:assets';
```


### `<Image />`


[Section titled &lt;Image /&gt;](#image-)

src/components/MyComponent.astro

```
---// import the Image component and the imageimport { Image } from'astro:assets';import myImage from"../assets/my_image.png"; // Image is 1600x900---<!-- `alt` is mandatory on the Image component --><Imagesrc={myImage}alt="A description of my image." />
```

```
<!-- Output --><!-- Image is optimized, proper attributes are enforced --><imgsrc="/_astro/my_image.hash.webp"width="1600"height="900"decoding="async"loading="lazy"alt="A description of my image."/>
```


#### Image properties


[Section titled Image properties](#image-properties)

The `<Image />` component accepts all properties accepted by the HTML `<img>` tag in addition to the properties described below.


##### src (required)


[Section titled src (required)](#src-required)

**Type:** `ImageMetadata | string | Promise<{ default: ImageMetadata }>`

The format of the `src` value of your image file depends on where your image file is located:

-   **Local images in `src/`** - you must **also import the image** using a relative file path or configure and use an [import alias](/en/guides/imports/#aliases). Then use the import name as the `src` value:

    src/pages/index.astro

    ```
    ---import { Image } from'astro:assets';importmyImportedImagefrom'../assets/my-local-image.png';---<Imagesrc={myImportedImage}alt="descriptive text" />
    ```

-   **Images in the `public/` folder** - use the image’s **file path relative to the public folder**:

    src/pages/index.astro

    ```
    ---import { Image } from'astro:assets';---<Imagesrc="/images/my-public-image.png"alt="descriptive text"width="200"height="150"/>
    ```

-   **Remote images** - use the image’s **full URL** as the property value:

    src/pages/index.astro

    ```
    ---import { Image } from'astro:assets';---<Imagesrc="https://example.com/remote-image.jpg"alt="descriptive text"width="200"height="150"/>
    ```



##### alt (required)


[Section titled alt (required)](#alt-required)

**Type:** `string`

Use the required `alt` attribute to provide a string of [descriptive alt text](https://www.w3.org/WAI/tutorials/images/) for images.

If an image is merely decorative (i.e. doesn’t contribute to the understanding of the page), set `alt=""` so that screen readers and other assistive technologies know to ignore the image.


##### width and height (required for images in `public/`)


[Section titled width and height (required for images in public/)](#width-and-height-required-for-images-in-public)

**Type:** `number | undefined`

These properties define the dimensions to use for the image.

When using images in their original aspect ratio, `width` and `height` are optional. These dimensions can be automatically inferred from image files located in `src/`. For remote images, add [the `inferSize` attribute set to `true`](#infersize) on the `<Image />` or `<Picture />` component or use [`inferRemoteSize()` function](#inferremotesize).

However, both of these properties are required for images stored in your `public/` folder as Astro is unable to analyze these files.


##### densities


[Section titled densities](#densities)

**Type:** ``(number | `${number}x`)[] | undefined``

**Added in:** `astro@3.3.0`

A list of pixel densities to generate for the image.

If provided, this value will be used to generate a `srcset` attribute on the `<img>` tag. Do not provide a value for `widths` when using this value.

Densities that are equal to widths larger than the original image will be ignored to avoid upscaling the image.

src/components/MyComponent.astro

```
---import { Image } from'astro:assets';import myImage from'../assets/my_image.png';---<Imagesrc={myImage}width={myImage.width/2}densities={[1.5, 2]}alt="A description of my image."/>
```

```
<!-- Output --><imgsrc="/_astro/my_image.hash.webp"srcset="/_astro/my_image.hash.webp 1.5x/_astro/my_image.hash.webp 2x"alt="A description of my image."width="800"height="450"loading="lazy"decoding="async"/>
```


##### widths


[Section titled widths](#widths)

**Type:** `number[] | undefined`

**Added in:** `astro@3.3.0`

A list of widths to generate for the image.

If provided, this value will be used to generate a `srcset` attribute on the `<img>` tag. A [`sizes` property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/sizes) must also be provided.

Do not provide a value for `densities` when using this value. Only one of these two values can be used to generate a `srcset`.

Widths that are larger than the original image will be ignored to avoid upscaling the image.

```
---import { Image } from'astro:assets';import myImage from'../assets/my_image.png'; // Image is 1600x900---<Imagesrc={myImage}widths={[240, 540, 720, myImage.width]}sizes={`(max-width: 360px) 240px, (max-width: 720px) 540px, (max-width: 1600px) 720px, ${myImage.width}px`}alt="A description of my image."/>
```

```
<!-- Output --><imgsrc="/_astro/my_image.hash.webp"srcset="/_astro/my_image.hash.webp 240w,/_astro/my_image.hash.webp 540w,/_astro/my_image.hash.webp 720w,/_astro/my_image.hash.webp 1600w"sizes="(max-width: 360px) 240px,(max-width: 720px) 540px,(max-width: 1600px) 720px,1600px"alt="A description of my image."width="1600"height="900"loading="lazy"decoding="async"/>
```


##### format


[Section titled format](#format)

**Type:** `ImageOutputFormat | undefined`

You can optionally state the [image file type](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#common_image_file_types) output to be used.

By default, the `<Image />` component will produce a `.webp` file.


##### quality


[Section titled quality](#quality)

**Type:** `ImageQuality | undefined`

`quality` is an optional property that can either be:

-   a preset (`low`, `mid`, `high`, `max`) that is automatically normalized between formats.
-   a number from `0` to `100` (interpreted differently between formats).


##### inferSize


[Section titled inferSize](#infersize)

**Type:** `boolean`

**Added in:** `astro@4.4.0`

Allows you to set the original `width` and `height` of a remote image automatically.

By default, this value is set to `false` and you must manually specify both dimensions for your remote image.

Add `inferSize` to the `<Image />` component (or `inferSize: true` to `getImage()`) to infer these values from the image content when fetched. This is helpful if you don’t know the dimensions of the remote image, or if they might change:

```
---import { Image } from'astro:assets';---<Imagesrc="https://example.com/cat.png"inferSizealt="A cat sleeping in the sun." />
```

`inferSize` can fetch the dimensions of a [remote image from a domain that has not been authorized](/en/guides/images/#authorizing-remote-images), however the image itself will remain unprocessed.


### `<Picture />`


[Section titled &lt;Picture /&gt;](#picture-)

**Added in:** `astro@3.3.0`

Use the built-in `<Picture />` Astro component to display a responsive image with multiple formats and/or sizes.

src/pages/index.astro

```
---import { Picture } from'astro:assets';import myImage from"../assets/my_image.png"; // Image is 1600x900---<!-- `alt` is mandatory on the Picture component --><Picturesrc={myImage}formats={['avif', 'webp']}alt="A description of my image." />
```

```
<!-- Output --><picture><sourcesrcset="/_astro/my_image.hash.avif"type="image/avif" /><sourcesrcset="/_astro/my_image.hash.webp"type="image/webp" /><imgsrc="/_astro/my_image.hash.png"width="1600"height="900"decoding="async"loading="lazy"alt="A description of my image."/></picture>
```


#### Picture properties


[Section titled Picture properties](#picture-properties)

`<Picture />` accepts all the properties of [the `<Image />` component](#image-properties), plus the following:


##### `formats`


[Section titled formats](#formats)

**Type:** `ImageOutputFormat[]`

An array of image formats to use for the `<source>` tags. Entries will be added as `<source>` elements in the order they are listed, and this order determines which format is displayed. For the best performance, list the most modern format first (e.g. `webp` or `avif`). By default, this is set to `['webp']`.


##### `fallbackFormat`


[Section titled fallbackFormat](#fallbackformat)

**Type:** `ImageOutputFormat`

Format to use as a fallback value for the `<img>` tag. Defaults to `.png` for static images (or `.jpg` if the image is a JPG), `.gif` for animated images, and `.svg` for SVG files.


##### `pictureAttributes`


[Section titled pictureAttributes](#pictureattributes)

**Type:** `HTMLAttributes<'picture'>`

An object of attributes to be added to the `<picture>` tag.

Use this property to apply attributes to the outer `<picture>` element itself. Attributes applied to the `<Picture />` component directly will apply to the inner `<img>` element, except for those used for image transformation.

src/components/MyComponent.astro

```
---import { Picture } from"astro:assets";import myImage from"../my_image.png"; // Image is 1600x900---<Picturesrc={myImage}alt="A description of my image."pictureAttributes={{ style: "background-color: red;" }}/>
```

```
<!-- Output --><picturestyle="background-color: red;"><sourcesrcset="/_astro/my_image.hash.webp"type="image/webp" /><imgsrc="/_astro/my_image.hash.png"alt="A description of my image."width="1600"height="900"loading="lazy"decoding="async"/></picture>
```


### `getImage()`


[Section titled getImage()](#getimage)

**Type:** `(options: UnresolvedImageTransform) => Promise<GetImageResult>`

Caution

`getImage()` relies on server-only APIs and breaks the build when used on the client.

The `getImage()` function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an [API Route](/en/guides/endpoints/#server-endpoints-api-routes). It also allows you to create your own custom `<Image />` component.

`getImage()` takes an options object with the [same properties as the Image component](#image-properties) (except `alt`).

```
---import { getImage } from"astro:assets";import myBackground from"../background.png"const optimizedBackground = await getImage({src: myBackground, format: 'avif'})---<divstyle={`background-image: url(${optimizedBackground.src});`}></div>
```

It returns an object with the following type:

```
type GetImageResult = {/* Additional HTML attributes needed to render the image (width, height, style, etc..) */attributes:Record<string, any>;/* Validated parameters passed */options:ImageTransform;/* Original parameters passed */rawOptions:ImageTransform;/* Path to the generated image */src:string;srcSet: {/* Generated values for srcset, every entry has a url and a size descriptor */values:SrcSetValue[];/* A value ready to use in`srcset` attribute */attribute:string;};}
```


### inferRemoteSize()


[Section titled inferRemoteSize()](#inferremotesize)

**Type:** `(url: string) => Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>`

**Added in:** `astro@4.12.0`

A function to infer the dimensions of remote images. This can be used as an alternative to passing the `inferSize` property.

```
import { inferRemoteSize } from'astro:assets';const {width, height} = await inferRemoteSize("https://example.com/cat.png");
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 186. `en/reference/modules/astro-config/.md`

```text
# Config imports API Reference



# Config imports API Reference


**Added in:** `astro@5.7.0`

This virtual module `astro:config` exposes a non-exhaustive, serializable, type-safe version of the Astro configuration. There are two submodules for accessing different subsets of your configuration values: [`/client`](#imports-from-astroconfigclient) and [`/server`](#imports-from-astroconfigserver).

All available config values can be accessed from `astro:config/server`. However, for code executed on the client, only those values exposed by `astro:config/client` will be available. This protects your information by only making some data available to the client.


## Imports from `astro:config/client`


[Section titled Imports from astro:config/client](#imports-from-astroconfigclient)

```
import {i18n,trailingSlash,base,build,site,} from"astro:config/client";
```

Use this submodule for client-side code:

src/utils.js

```
import { trailingSlash } from"astro:config/client";functionaddForwardSlash(path) {if (trailingSlash==="always") {returnpath.endsWith("/") ?path:path+"/"} else {returnpath}}
```

See more about the configuration imports available from `astro:config/client`:

-   [`i18n`](/en/reference/configuration-reference/#i18n)
-   [`trailingSlash`](/en/reference/configuration-reference/#trailingslash)
-   [`base`](/en/reference/configuration-reference/#base)
-   [`build.format`](/en/reference/configuration-reference/#buildformat)
-   [`site`](/en/reference/configuration-reference/#site)


## Imports from `astro:config/server`


[Section titled Imports from astro:config/server](#imports-from-astroconfigserver)

```
import {i18n,trailingSlash,base,build,site,srcDir,cacheDir,outDir,publicDir,root,} from"astro:config/server";
```

These imports include everything available from `astro:config/client` as well as additional sensitive information about your file system configuration that is not safe to expose to the client.

Use this submodule for server side code:

astro.config.mjs

```
import { integration } from"./integration.mjs";exportdefaultdefineConfig({integrations: [integration(),]});
```

integration.mjs

```
import { outDir } from"astro:config/server";import { writeFileSync } from"node:fs";import { fileURLToPath } from"node:url";exportdefaultfunction() {return {name: "internal-integration",hooks: {"astro:build:done": ()=> {let file = newURL("result.json",outDir);// generate data from some operationlet data = JSON.stringify([]);writeFileSync(fileURLToPath(file),data,"utf-8");}}}}
```

See more about the configuration imports available from `astro:config/server`:

-   [`i18n`](/en/reference/configuration-reference/#i18n)
-   [`trailingSlash`](/en/reference/configuration-reference/#trailingslash)
-   [`base`](/en/reference/configuration-reference/#base)
-   [`build.format`](/en/reference/configuration-reference/#buildformat)
-   [`build.client`](/en/reference/configuration-reference/#buildclient)
-   [`build.server`](/en/reference/configuration-reference/#buildserver)
-   [`build.serverEntry`](/en/reference/configuration-reference/#buildserverentry)
-   [`build.assetsPrefix`](/en/reference/configuration-reference/#buildassetsprefix)
-   [`site`](/en/reference/configuration-reference/#site)
-   [`srcDir`](/en/reference/configuration-reference/#srcdir)
-   [`cacheDir`](/en/reference/configuration-reference/#cachedir)
-   [`outDir`](/en/reference/configuration-reference/#outdir)
-   [`publicDir`](/en/reference/configuration-reference/#publicdir)
-   [`root`](/en/reference/configuration-reference/#root)

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 187. `en/reference/modules/astro-content/.md`

```text
# Content Collections API Reference



# Content Collections API Reference


**Added in:** `astro@2.0.0`

Content collections offer APIs to configure and query your Markdown or MDX documents in `src/content/`. For features and usage examples, [see our content collections guide](/en/guides/content-collections/).


## Imports from `astro:content`


[Section titled Imports from astro:content](#imports-from-astrocontent)

```
import {z,defineCollection,getCollection,getEntry,getEntries,reference,render} from'astro:content';
```


### `defineCollection()`


[Section titled defineCollection()](#definecollection)

**Type:** `(input: CollectionConfig) => CollectionConfig`

**Added in:** `astro@2.0.0`

`defineCollection()` is a utility to configure a collection in a `src/content.config.*` file.

src/content.config.ts

```
import { z, defineCollection } from'astro:content';import { glob } from'astro/loaders';const blog = defineCollection({loader: glob({ pattern: '**/*.md', base: './src/data/blog' }),schema: z.object({title: z.string(),permalink: z.string().optional(),}),});// Expose your defined collection to Astro// with the `collections` exportexport const collections = { blog };
```

This function accepts the following properties:


#### `loader`


[Section titled loader](#loader)

**Type:** `() => Promise<Array<{ id: string, [key: string]: any }> | Record<string, Record<string, any>>> | [Loader](/en/reference/content-loader-reference/#object-loader-api)`

**Added in:** `astro@5.0.0`

A `loader` is either an object or a function that allows you to load data from any source, local or remote, into content collections.

[See the `Content Collection` guide](/en/guides/content-collections/#defining-the-collection-loader) for example usage.


#### `schema`


[Section titled schema](#schema)

**Type:** `ZodType | (context: [SchemaContext](#schemacontext)) => ZodType`

**Added in:** `astro@2.0.0`

`schema` is an optional Zod object to configure the type and shape of document frontmatter for a collection. Each value must use [a Zod validator](https://github.com/colinhacks/zod).

[See the `Content Collection` guide](/en/guides/content-collections/#defining-the-collection-schema) for example usage.


### `reference()`


[Section titled reference()](#reference)

**Type:** `(collection: string) => ZodEffects<ZodString, { collection, id: string }>`

**Added in:** `astro@2.5.0`

The `reference()` function is used in the content config to define a relationship, or “reference,” from one collection to another. This accepts a collection name and transforms the reference into an object containing the collection name and the reference id.

This example defines references from a blog author to the `authors` collection and an array of related posts to the same `blog` collection:

```
import { defineCollection, reference, z } from'astro:content';import { glob, file } from'astro/loaders';const blog = defineCollection({loader: glob({ pattern: '**/*.md', base: './src/data/blog' }),schema: z.object({// Reference a single author from the `authors` collection by `id`author: reference('authors'),// Reference an array of related posts from the `blog` collection by `slug`relatedPosts: z.array(reference('blog')),})});const authors = defineCollection({loader: file("src/data/authors.json"),schema: z.object({ /* ... */ })});export const collections = { blog, authors };
```

Validation of referenced entries happens at runtime when using `getEntry()` or `getEntries()`:

src/pages/\[posts\].astro

```
// if a referenced entry is invalid, this will return undefined.const relatedPosts = await getEntries(blogPost.data.relatedPosts);
```

[See the `Content Collection` guide](/en/guides/content-collections/#defining-collection-references) for example usage.


### `getCollection()`


[Section titled getCollection()](#getcollection)

**Type:** `(collection: string, filter?: (entry: CollectionEntry<collection>) => boolean) => CollectionEntry<collection>[]`

**Added in:** `astro@2.0.0`

`getCollection()` is a function that retrieves a list of content collection entries by collection name.

It returns all items in the collection by default, and accepts an optional `filter` function to narrow by entry properties. This allows you to query for only some items in a collection based on `id` or frontmatter values via the `data` object.

```
---import { getCollection } from'astro:content';// Get all `src/content/blog/` entriesconst allBlogPosts = await getCollection('blog');// Only return posts with `draft: true` in the frontmatterconst draftBlogPosts = await getCollection('blog', ({ data }) => {return data.draft === true;});---
```

[See the `Content Collection` guide](/en/guides/content-collections/#querying-collections) for example usage.


### `getEntry()`


[Section titled getEntry()](#getentry)

**Types:**

-   `(collection: string, id: string) => Promise<CollectionEntry<collection> | undefined>`
-   `({ collection: string, id: string }) => Promise<CollectionEntry<collection> | undefined>`

**Added in:** `astro@2.5.0`

`getEntry()` is a function that retrieves a single collection entry by collection name and the entry `id`. `getEntry()` can also be used to get referenced entries to access the `data` or `body` properties:

```
---import { getEntry } from'astro:content';// Get `src/content/blog/enterprise.md`const enterprisePost = await getEntry('blog', 'enterprise');// Get `src/content/captains/picard.json`const picardProfile = await getEntry('captains', 'picard');// Get the profile referenced by `data.captain`const enterpriseCaptainProfile = await getEntry(enterprisePost.data.captain);---
```

See the `Content Collections` guide for examples of [querying collection entries](/en/guides/content-collections/#querying-collections).


### `getEntries()`


[Section titled getEntries()](#getentries)

**Type:** `(Array<{ collection: string, id: string }>) => Array<CollectionEntry<collection>>`

**Added in:** `astro@2.5.0`

`getEntries()` is a function that retrieves multiple collection entries from the same collection. This is useful for [returning an array of referenced entries](/en/guides/content-collections/#defining-collection-references) to access their associated `data` and `body` properties.

```
---import { getEntries, getEntry } from'astro:content';const enterprisePost = await getEntry('blog', 'enterprise');// Get related posts referenced by `data.relatedPosts`const enterpriseRelatedPosts = await getEntries(enterprisePost.data.relatedPosts);---
```


### `render()`


[Section titled render()](#render)

**Type:** `(entry: CollectionEntry) => Promise<RenderedEntry>`

**Added in:** `astro@5.0.0`

A function to compile a given entry for rendering. This returns the following properties:

-   `<Content />` - A component used to render the document’s contents in an Astro file.
-   `headings` - A generated list of headings, [mirroring Astro’s `getHeadings()` utility](/en/guides/markdown-content/#available-properties) on Markdown and MDX imports.
-   `remarkPluginFrontmatter` \- The modified frontmatter object after any [remark or rehype plugins have been applied](/en/guides/markdown-content/#modifying-frontmatter-programmatically). Set to type `any`.

```
---import { getEntry, render } from'astro:content';const entry = await getEntry('blog', 'entry-1');if (!entry) {// Handle Error, for example:thrownewError('Could not find blog post 1');}const { Content, headings, remarkPluginFrontmatter } = await render(entry);---
```

[See the `Content Collection` guide](/en/guides/content-collections/#rendering-body-content) for example usage.


## `astro:content` types


[Section titled astro:content types](#astrocontent-types)

```
importtype {CollectionEntry,CollectionKey,ContentCollectionKey,DataCollectionKey,SchemaContext,} from'astro:content';
```


### `CollectionEntry`


[Section titled CollectionEntry](#collectionentry)

Query functions including [`getCollection()`](#getcollection), [`getEntry()`](#getentry), and [`getEntries()`](#getentries) each return entries with the `CollectionEntry` type. This type is available as a utility from `astro:content`:

```
importtype { CollectionEntry } from'astro:content';
```

`CollectionEntry` is a generic type. Use it with the name of the collection you’re querying. For example, an entry in your `blog` collection would have the type `CollectionEntry<'blog'>`.

Each `CollectionEntry` is an object with the following values:


#### `id`


[Section titled id](#id)

**Type:** `string`

A unique ID. Note that all IDs from Astro’s built-in `glob()` loader are slugified.


#### `collection`


[Section titled collection](#collection)

**Example Type:** `'blog' | 'authors' | ...`

The name of a collection in which entries are located. This is the name used to reference the collection in your schema, and in querying functions.


#### `data`


[Section titled data](#data)

**Type:** `CollectionSchema<TCollectionName>`

An object of frontmatter properties inferred from your collection schema ([see `defineCollection()` reference](#definecollection)). Defaults to `any` if no schema is configured.


#### `body`


[Section titled body](#body)

**Type:** `string`

A string containing the raw, uncompiled body of the Markdown or MDX document.


### `CollectionKey`


[Section titled CollectionKey](#collectionkey)

**Added in:** `astro@3.1.0`

A string union of all collection names defined in your `src/content.config.*` file. This type can be useful when defining a generic function wrapping the built-in `getCollection()`.

```
import { type CollectionKey, getCollection } from'astro:content';asyncfunctionqueryCollection(collection:CollectionKey) {returngetCollection(collection,({ data })=> {return data.draft!==true;});}
```


### `SchemaContext`


[Section titled SchemaContext](#schemacontext)

The `context` object that `defineCollection` uses for the function shape of `schema`. This type can be useful when building reusable schemas for multiple collections.

This includes the following property:

-   `image` - The `image()` schema helper that allows you [to use local images in Content Collections](/en/guides/images/#images-in-content-collections)

```
import { defineCollection, z, type SchemaContext } from"astro:content";export const imageSchema = ({ image }:SchemaContext) =>z.object({image: image(),description: z.string().optional(),});const blog = defineCollection({loader: /* ... */,schema: ({ image }) => z.object({title: z.string(),permalink: z.string().optional(),image: imageSchema({ image })}),});
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 188. `en/reference/modules/astro-env/.md`

```text
# Environment Variables API Reference



# Environment Variables API Reference


**Added in:** `astro@5.0.0`

The `astro:env` API lets you configure a type-safe schema for environment variables you have set. This allows you to indicate whether they should be available on the server or the client, and define their data type and additional properties. For examples and usage instructions, [see the `astro:env` guide](/en/guides/environment-variables/#type-safe-environment-variables).


## Imports from `astro:env`


[Section titled Imports from astro:env](#imports-from-astroenv)

```
import {getSecret,} from'astro:env/server';
```


### `getSecret()`


[Section titled getSecret()](#getsecret)

**Added in:** `astro@5.0.0`

The `getSecret()` helper function allows retrieving the raw value of an environment variable by its key.

For example, you can retrieve a boolean value as a string:

```
import {FEATURE_FLAG, // booleangetSecret} from'astro:env/server'getSecret('FEATURE_FLAG') // string | undefined
```

This can also be useful to get a secret not defined in your schema, for example one that depends on dynamic data from a database or API.

If you need to retrieve environment variables programmatically, we recommend using `getSecret()` instead of `process.env` (or equivalent). Because its implementation is provided by your adapter, you won’t need to update all your calls if you switch adapters. It defaults to `process.env` in dev and build.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 189. `en/reference/modules/astro-i18n/.md`

```text
# Internationalization API Reference



# Internationalization API Reference


**Added in:** `astro@3.5.0`

This module provides functions to help you create URLs using your project’s configured locales.

Creating routes for your project with the i18n router will depend on certain configuration values you have set that affect your page routes. When creating routes with these functions, be sure to take into account your individual settings for:

-   [`base`](/en/reference/configuration-reference/#base)
-   [`trailingSlash`](/en/reference/configuration-reference/#trailingslash)
-   [`build.format`](/en/reference/configuration-reference/#buildformat)
-   [`site`](/en/reference/configuration-reference/#site)

Also, note that the returned URLs created by these functions for your `defaultLocale` will reflect your `i18n.routing` configuration.

For features and usage examples, [see our i18n routing guide](/en/guides/internationalization/).


## Imports from `astro:i18n`


[Section titled Imports from astro:i18n](#imports-from-astroi18n)

```
import {getRelativeLocaleUrl,getAbsoluteLocaleUrl,getRelativeLocaleUrlList,getAbsoluteLocaleUrlList,getPathByLocale,getLocaleByPath,redirectToDefaultLocale,redirectToFallback,notFound,middleware,requestHasLocale,} from'astro:i18n';
```


### `getRelativeLocaleUrl()`


[Section titled getRelativeLocaleUrl()](#getrelativelocaleurl)

**Type:** `(locale: string, path?: string, options?: GetLocaleOptions) => string`

Use this function to retrieve a relative path for a locale. If the locale doesn’t exist, Astro throws an error.

```
---import { getRelativeLocaleUrl } from'astro:i18n';getRelativeLocaleUrl("fr");// returns /frgetRelativeLocaleUrl("fr", "");// returns /fr/getRelativeLocaleUrl("fr", "getting-started");// returns /fr/getting-startedgetRelativeLocaleUrl("fr_CA", "getting-started", {prependWith: "blog"});// returns /blog/fr-ca/getting-startedgetRelativeLocaleUrl("fr_CA", "getting-started", {prependWith: "blog",normalizeLocale: false});// returns /blog/fr_CA/getting-started---
```


### `getAbsoluteLocaleUrl()`


[Section titled getAbsoluteLocaleUrl()](#getabsolutelocaleurl)

**Type:** `(locale: string, path?: string, options?: GetLocaleOptions) => string`

Use this function to retrieve an absolute path for a locale when \[`site`\] has a value. If \[`site`\] isn’t configured, the function returns a relative URL. If the locale doesn’t exist, Astro throws an error.

src/pages/index.astro

```
---import { getAbsoluteLocaleUrl } from'astro:i18n';// If `site` is set to be `https://example.com`getAbsoluteLocaleUrl("fr");// returns https://example.com/frgetAbsoluteLocaleUrl("fr", "");// returns https://example.com/fr/getAbsoluteLocaleUrl("fr", "getting-started");// returns https://example.com/fr/getting-startedgetAbsoluteLocaleUrl("fr_CA", "getting-started", {prependWith: "blog"});// returns https://example.com/blog/fr-ca/getting-startedgetAbsoluteLocaleUrl("fr_CA", "getting-started", {prependWith: "blog",normalizeLocale: false});// returns https://example.com/blog/fr_CA/getting-started---
```


### `getRelativeLocaleUrlList()`


[Section titled getRelativeLocaleUrlList()](#getrelativelocaleurllist)

**Type:** `(path?: string, options?: GetLocaleOptions) => string[]`

Use this like [`getRelativeLocaleUrl`](#getrelativelocaleurl) to return a list of relative paths for all the locales.


### `getAbsoluteLocaleUrlList()`


[Section titled getAbsoluteLocaleUrlList()](#getabsolutelocaleurllist)

**Type:** `(path?: string, options?: GetLocaleOptions) => string[]`

Use this like [`getAbsoluteLocaleUrl`](/en/guides/internationalization/#custom-locale-paths) to return a list of absolute paths for all the locales.


### `getPathByLocale()`


[Section titled getPathByLocale()](#getpathbylocale)

**Type:** `(locale: string) => string`

A function that returns the `path` associated to one or more `codes` when [custom locale paths](/en/guides/internationalization/#custom-locale-paths) are configured.

astro.config.mjs

```
exportdefaultdefineConfig({i18n: {locales: ["es", "en", {path: "french",codes: ["fr", "fr-BR", "fr-CA"]}]}})
```

src/pages/index.astro

```
---import { getPathByLocale } from'astro:i18n';getPathByLocale("fr"); // returns "french"getPathByLocale("fr-CA"); // returns "french"---
```


### `getLocaleByPath()`


[Section titled getLocaleByPath()](#getlocalebypath)

**Type:** `(path: string) => string`

A function that returns the `code` associated to a locale `path`.

astro.config.mjs

```
exportdefaultdefineConfig({i18n: {locales: ["es", "en", {path: "french",codes: ["fr", "fr-BR", "fr-CA"]}]}})
```

src/pages/index.astro

```
---import { getLocaleByPath } from'astro:i18n';getLocaleByPath("french"); // returns "fr" because that's the first code configured---
```


### `redirectToDefaultLocale()`


[Section titled redirectToDefaultLocale()](#redirecttodefaultlocale)

**Type:** `(context: APIContext, statusCode?: ValidRedirectStatus) => Promise<Response>`

**Added in:** `astro@4.6.0`

Note

Available only when `i18n.routing` is set to `"manual"`

A function that returns a `Response` that redirects to the `defaultLocale` configured. It accepts an optional valid redirect status code.

middleware.js

```
import { defineMiddleware } from"astro:middleware";import { redirectToDefaultLocale } from"astro:i18n";export const onRequest = defineMiddleware((context, next) => {if (context.url.pathname.startsWith("/about")) {return next();} else {return redirectToDefaultLocale(context, 302);}})
```


### `redirectToFallback()`


[Section titled redirectToFallback()](#redirecttofallback)

**Type:** `(context: APIContext, response: Response) => Promise<Response>`

**Added in:** `astro@4.6.0`

Note

Available only when `i18n.routing` is set to `"manual"`

A function that allows you to use your [`i18n.fallback` configuration](/en/reference/configuration-reference/#i18nfallback) in your own middleware.

middleware.js

```
import { defineMiddleware } from"astro:middleware";import { redirectToFallback } from"astro:i18n";export const onRequest = defineMiddleware(async (context, next) => {const response = await next();if (response.status >= 300) {return redirectToFallback(context, response)}return response;})
```


### `notFound()`


[Section titled notFound()](#notfound)

**Type:** `(context: APIContext, response?: Response) => Promise<Response> | undefined`

**Added in:** `astro@4.6.0`

Note

Available only when `i18n.routing` is set to `"manual"`

Use this function in your routing middleware to return a 404 when:

-   the current path isn’t a root. e.g. `/` or `/<base>`
-   the URL doesn’t contain a locale

When a `Response` is passed, the new `Response` emitted by this function will contain the same headers of the original response.

middleware.js

```
import { defineMiddleware } from"astro:middleware";import { notFound } from"astro:i18n";export const onRequest = defineMiddleware((context, next) => {const pathNotFound = notFound(context);if (pathNotFound) {return pathNotFound;}return next();})
```


### `middleware()`


[Section titled middleware()](#middleware)

**Type:** `(options: { prefixDefaultLocale: boolean, redirectToDefaultLocale: boolean }) => MiddlewareHandler`

**Added in:** `astro@4.6.0`

Note

Available only when `i18n.routing` is set to `"manual"`

A function that allows you to programmatically create the Astro i18n middleware.

This is useful when you still want to use the default i18n logic, but add only a few exceptions to your website.

middleware.js

```
import { middleware } from"astro:i18n";import { sequence, defineMiddleware } from"astro:middleware";const customLogic = defineMiddleware(async (context, next) => {const response = await next();// Custom logic after resolving the response.// It's possible to catch the response coming from Astro i18n middleware.return response;});export const onRequest = sequence(customLogic, middleware({prefixDefaultLocale: true,redirectToDefaultLocale: false}))
```


### `requestHasLocale()`


[Section titled requestHasLocale()](#requesthaslocale)

**Type:** `(context: APIContext) => boolean`

**Added in:** `astro@4.6.0`

Note

Available only when `i18n.routing` is set to `"manual"`

Checks whether the current URL contains a configured locale. Internally, this function will use `APIContext#url.pathname`.

middleware.js

```
import { defineMiddleware } from"astro:middleware";import { requestHasLocale } from"astro:i18n";export const onRequest = defineMiddleware(async (context, next) => {if (requestHasLocale(context)) {return next();}return newResponse("Not found", { status: 404 });})
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 190. `en/reference/modules/astro-middleware/.md`

```text
# Middleware API Reference



# Middleware API Reference


**Added in:** `astro@2.6.0`

Middleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. For features and usage examples, [see our middleware guide](/en/guides/middleware/).


## Imports from `astro:middleware`


[Section titled Imports from astro:middleware](#imports-from-astromiddleware)

```
import {sequence,createContext,trySerializeLocals,defineMiddleware,} from'astro:middleware';
```


### `defineMiddleware()`


[Section titled defineMiddleware()](#definemiddleware)

You can import and use the utility function `defineMiddleware()` to take advantage of type safety:

src/middleware.ts

```
import { defineMiddleware } from"astro:middleware";// `context` and `next` are automatically typedexport const onRequest = defineMiddleware((context, next) => {});
```


### `sequence()`


[Section titled sequence()](#sequence)

**Type:** `(...handlers: MiddlewareHandler[]) => MiddlewareHandler`

A function that accepts middleware functions as arguments, and will execute them in the order in which they are passed.

src/middleware.js

```
import { sequence } from"astro:middleware";asyncfunctionvalidation(_, next) {...}asyncfunctionauth(_, next) {...}asyncfunctiongreeting(_, next) {...}export const onRequest = sequence(validation, auth, greeting);
```


### `createContext()`


[Section titled createContext()](#createcontext)

**Type:** `(context: CreateContext) => APIContext`

**Added in:** `astro@2.8.0`

A low-level API to create an [`APIContext`](/en/reference/api-reference/)to be passed to an Astro middleware `onRequest()` function.

This function can be used by integrations/adapters to programmatically execute the Astro middleware.


### `trySerializeLocals()`


[Section titled trySerializeLocals()](#tryserializelocals)

**Type:** `(value: unknown) => string`

**Added in:** `astro@2.8.0`

A low-level API that takes in any value and tries to return a serialized version (a string) of it. If the value cannot be serialized, the function will throw a runtime error.


## Middleware exports


[Section titled Middleware exports](#middleware-exports)

When defining your project’s middleware in `src/middleware.js`, export the following user-defined functions:


### `onRequest()`


[Section titled onRequest()](#onrequest)

**Type:** `(context: APIContext, next: MiddlewareNext) => Promise<Response> | Response | Promise<void> | void`

A required exported function from `src/middleware.js` that will be called before rendering every page or API route. It receives two arguments: [context](#context) and [next()](#next). `onRequest()` must return a `Response`: either directly, or by calling `next()`.

src/middleware.js

```
exportfunctiononRequest(context, next) {// intercept response data from a request// optionally, transform the response// return a Response directly, or the result of calling `next()`returnnext();};
```

Your `onRequest()` function will be called with the following arguments:


#### `context`


[Section titled context](#context)

**Type:** `APIContext`

The first argument of `onRequest()` is a context object. It mirrors many of the `Astro` global properties.

See [Endpoint contexts](/en/reference/api-reference/) for more information about the context object.


#### `next()`


[Section titled next()](#next)

**Type:** `(rewritePayload?: string | URL | Request) => Promise<Response>`

The second argument of `onRequest()` is a function that calls all the subsequent middleware in the chain and returns a `Response`. For example, other middleware could modify the HTML body of a response and awaiting the result of `next()` would allow your middleware to respond to those changes.

Since Astro v4.13.0, `next()` accepts an optional URL path parameter in the form of a string, `URL`, or `Request` to [rewrite](/en/guides/routing/#rewrites) the current request without retriggering a new rendering phase.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 191. `en/reference/modules/astro-transitions/.md`

```text
# View Transitions Router API Reference



# View Transitions Router API Reference


**Added in:** `astro@3.0.0`

These modules provide functions to control and interact with the View Transitions API and client-side router.

Note

This API is compatible with the `<ClientRouter />` included in `astro:transitions`, but can’t be used with native browser MPA routing.

For features and usage examples, [see our View Transitions guide](/en/guides/view-transitions/).


## Imports from `astro:transitions`


[Section titled Imports from astro:transitions](#imports-from-astrotransitions)

```
import { ClientRouter, fade, slide } from'astro:transitions';
```


### `<ClientRouter />`


[Section titled &lt;ClientRouter /&gt;](#clientrouter-)

**Added in:** `astro@3.0.0`

Opt in to using view transitions on individual pages by importing and adding the `<ClientRouter />` routing component to `<head>` on every desired page.

src/pages/index.astro

```
---import { ClientRouter } from'astro:transitions';---<htmllang="en"><head><title>My Homepage</title><ClientRouter /></head><body><h1>Welcome to my website!</h1></body></html>
```

See more about how to [control the router](/en/guides/view-transitions/#router-control) and [add transition directives](/en/guides/view-transitions/#transition-directives) to page elements and components.


### `fade`


[Section titled fade](#fade)

**Type:** `(opts: { duration?: string | number }) => TransitionDirectionalAnimations`

**Added in:** `astro@3.0.0`

Utility function to support customizing the duration of the built-in `fade` animation.

```
---import { fade } from'astro:transitions';---<!-- Fade transition with the default duration --><divtransition:animate="fade" /><!-- Fade transition with a duration of 400 milliseconds --><divtransition:animate={fade({ duration: '0.4s' })} />
```


### `slide`


[Section titled slide](#slide)

**Type:** `(opts: { duration?: string | number }) => TransitionDirectionalAnimations`

**Added in:** `astro@3.0.0`

Utility function to support customizing the duration of the built-in `slide` animation.

```
---import { slide } from'astro:transitions';---<!-- Slide transition with the default duration --><divtransition:animate="slide" /><!-- Slide transition with a duration of 400 milliseconds --><divtransition:animate={slide({ duration: '0.4s' })} />
```


## Imports from `astro:transitions/client`


[Section titled Imports from astro:transitions/client](#imports-from-astrotransitionsclient)

```
<script>import {navigate,supportsViewTransitions,transitionEnabledOnThisPage,getFallback,swapFunctions,} from'astro:transitions/client';</script>
```


### `navigate()`


[Section titled navigate()](#navigate)

**Type:** `(href: string, options?: Options) => void`

**Added in:** `astro@3.2.0`

A function that executes a navigation to the given `href` using the View Transitions API.

This function signature is based on the [`navigate` function from the browser Navigation API](https://developer.mozilla.org/en-US/docs/Web/API/Navigation/navigate). Although based on the Navigation API, this function is implemented on top of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to allow for navigation without reloading the page.


#### `history` option


[Section titled history option](#history-option)

**Type:** `'auto' | 'push' | 'replace'` **Default:** `'auto'`

**Added in:** `astro@3.2.0`

Defines how this navigation should be added to the browser history.

-   `'push'`: the router will use `history.pushState` to create a new entry in the browser history.
-   `'replace'`: the router will use `history.replaceState` to update the URL without adding a new entry into navigation.
-   `'auto'` (default): the router will attempt `history.pushState`, but if the URL cannot be transitioned to, the current URL will remain with no changes to the browser history.

This option follows the [`history` option](https://developer.mozilla.org/en-US/docs/Web/API/Navigation/navigate#history) from the browser Navigation API but simplified for the cases that can happen on an Astro project.


#### `formData` option


[Section titled formData option](#formdata-option)

**Type:** `FormData`

**Added in:** `astro@3.5.0`

A `FormData` object for `POST` requests.

When this option is provided, the requests to the navigation target page will be sent as a `POST` request with the form data object as the content.

Submitting an HTML form with view transitions enabled will use this method instead of the default navigation with page reload. Calling this method allows triggering the same behavior programmatically.


#### `info` option


[Section titled info option](#info-option)

**Type:** `any`

**Added in:** `astro@3.6.0`

Arbitrary data to be included in the `astro:before-preparation` and `astro:before-swap` events caused by this navigation.

This option mimics the [`info` option](https://developer.mozilla.org/en-US/docs/Web/API/Navigation/navigate#info) from the browser Navigation API.


#### `state` option


[Section titled state option](#state-option)

**Type:** `any`

**Added in:** `astro@3.6.0`

Arbitrary data to be associated with the `NavitationHistoryEntry` object created by this navigation. This data can then be retrieved using the [`history.getState` function](https://developer.mozilla.org/en-US/docs/Web/API/NavigationHistoryEntry/getState) from the History API.

This option mimics the [`state` option](https://developer.mozilla.org/en-US/docs/Web/API/Navigation/navigate#state) from the browser Navigation API.


#### `sourceElement` option


[Section titled sourceElement option](#sourceelement-option)

**Type:** `Element`

**Added in:** `astro@3.6.0`

The element that triggered this navigation, if any. This element will be available in the following events:

-   `astro:before-preparation`
-   `astro:before-swap`


### `supportsViewTransitions`


[Section titled supportsViewTransitions](#supportsviewtransitions)

**Type:** `boolean`

**Added in:** `astro@3.2.0`

Whether or not view transitions are supported and enabled in the current browser.


### `transitionEnabledOnThisPage`


[Section titled transitionEnabledOnThisPage](#transitionenabledonthispage)

**Type:** `boolean`

**Added in:** `astro@3.2.0`

Whether or not the current page has view transitions enabled for client-side navigation. This can be used to make components that behave differently when they are used on pages with view transitions.


### `getFallback()`


[Section titled getFallback()](#getfallback)

**Type:** `() => 'none' | 'animate' | 'swap'`

**Added in:** `astro@3.6.0`

Returns the fallback strategy to use in browsers that do not support view transitions.

See the guide on [Fallback control](/en/guides/view-transitions/#fallback-control) for how to choose and configure the fallback behavior.


### `swapFunctions`


[Section titled swapFunctions](#swapfunctions)

**Added in:** `astro@4.15.0`

An object containing the utility functions used to build Astro’s default swap function. These can be useful when [building a custom swap function](/en/guides/view-transitions/#building-a-custom-swap-function).

`swapFunctions` provides the following methods:


#### `deselectScripts()`


[Section titled deselectScripts()](#deselectscripts)

**Type:** `(newDocument: Document) => void`

Marks scripts in the new document that should not be executed. Those scripts are already in the current document and are not flagged for re-execution using [`data-astro-rerun`](/en/guides/view-transitions/#data-astro-rerun).


#### `swapRootAttributes()`


[Section titled swapRootAttributes()](#swaprootattributes)

**Type:** `(newDocument: Document) => void`

Swaps the attributes between the document roots, like the `lang` attribute. This also includes Astro-injected internal attributes like `data-astro-transition`, which makes the transition direction available to Astro-generated CSS rules.

When making a custom swap function, it is important to call this function so as not to break the view transition’s animations.


#### `swapHeadElements()`


[Section titled swapHeadElements()](#swapheadelements)

**Type:** `(newDocument: Document) => void`

Removes every element from the current document’s `<head>` that is not persisted to the new document. Then appends all new elements from the new document’s `<head>` to the current document’s `<head>`.


#### `saveFocus()`


[Section titled saveFocus()](#savefocus)

**Type:** `() => () => void`

Stores the element in focus on the current page and returns a function that when called, if the focused element was persisted, returns the focus to it.


#### `swapBodyElement()`


[Section titled swapBodyElement()](#swapbodyelement)

**Type:** `(newBody: Element, oldBody: Element) => void`

Replaces the old body with the new body. Then, goes through every element in the old body that should be persisted and have a matching element in the new body and swaps the old element back in place.


## Lifecycle events


[Section titled Lifecycle events](#lifecycle-events)


### `astro:before-preparation` event


[Section titled astro:before-preparation event](#astrobefore-preparation-event)

An event dispatched at the beginning of a navigation using the View Transitions router. This event happens before any request is made and any browser state is changed.

This event has the attributes:

-   [`info`](#info)
-   [`sourceElement`](#sourceelement)
-   [`navigationType`](#navigationtype)
-   [`direction`](#direction)
-   [`from`](#from)
-   [`to`](#to)
-   [`formData`](#formdata)
-   [`loader()`](#loader)

Read more about how to use this event on the [View Transitions guide](/en/guides/view-transitions/#astrobefore-preparation).


### `astro:after-preparation` event


[Section titled astro:after-preparation event](#astroafter-preparation-event)

An event dispatched after the next page in a navigation using View Transitions router is loaded.

This event has no attributes.

Read more about how to use this event on the [View Transitions guide](/en/guides/view-transitions/#astroafter-preparation).


### `astro:before-swap` event


[Section titled astro:before-swap event](#astrobefore-swap-event)

An event dispatched after the next page is parsed, prepared, and linked into a document in preparation for the transition but before any content is swapped between the documents.

This event can’t be canceled. Calling `preventDefault()` is a no-op.

This event has the attributes:

-   [`info`](#info)
-   [`sourceElement`](#sourceelement)
-   [`navigationType`](#navigationtype)
-   [`direction`](#direction)
-   [`from`](#from)
-   [`to`](#to)
-   [`viewTransition`](#viewtransition)
-   [`swap()`](#swap)

Read more about how to use this event on the [View Transitions guide](/en/guides/view-transitions/#astrobefore-swap).


### `astro:after-swap` event


[Section titled astro:after-swap event](#astroafter-swap-event)

An event dispatched after the contents of the page have been swapped but before the view transition ends.

The history entry and scroll position have already been updated when this event is triggered.


### `astro:page-load` event


[Section titled astro:page-load event](#astropage-load-event)

An event dispatched after a page completes loading, whether from a navigation using view transitions or native to the browser.

When view transitions is enabled on the page, code that would normally execute on `DOMContentLoaded` should be changed to execute on this event.


### Lifecycle events attributes


[Section titled Lifecycle events attributes](#lifecycle-events-attributes)

**Added in:** `astro@3.6.0`


#### `info`


[Section titled info](#info)

**Type:** `URL`

Arbitrary data defined during navigation.

This is the literal value passed on the [`info` option](#info-option) of the [`navigate()` function](#navigate).


#### `sourceElement`


[Section titled sourceElement](#sourceelement)

**Type:** `Element | undefined`

The element that triggered the navigation. This can be, for example, an `<a>` element that was clicked.

When using the [`navigate()` function](#navigate), this will be the element specified in the call.


#### `newDocument`


[Section titled newDocument](#newdocument)

**Type:** `Document`

The document for the next page in the navigation. The contents of this document will be swapped in place of the contents of the current document.


#### `navigationType`


[Section titled navigationType](#navigationtype)

**Type:** `'push' | 'replace' | 'traverse'`

Which kind of history navigation is happening.

-   `push`: a new `NavigationHistoryEntry` is being created for the new page.
-   `replace`: the current `NavigationHistoryEntry` is being replaced with an entry for the new page.
-   `traverse`: no `NavigationHistoryEntry` is created. The position in the history is changing. The direction of the traversal is given on the [`direction` attribute](#direction)


#### `direction`


[Section titled direction](#direction)

**Type:** `Direction`

The direction of the transition.

-   `forward`: navigating to the next page in the history or to a new page.
-   `back`: navigating to the previous page in the history.
-   Anything else some other listener might have set.


#### `from`


[Section titled from](#from)

**Type:** `URL`

The URL of the page initiating the navigation.


#### `to`


[Section titled to](#to)

**Type:** `URL`

The URL of the page being navigated to. This property can be modified, the value at the end of the lifecycle will be used in the `NavigationHistoryEntry` for the next page.


#### `formData`


[Section titled formData](#formdata)

**Type:** `FormData | undefined`

A `FormData` object for `POST` requests.

When this attribute is set, a `POST` request will be sent to the [`to` URL](#to) with the given form data object as the content instead of the normal `GET` request.

When submitting an HTML form with view transitions enabled, this field is automatically set to the data in the form. When using the [`navigate()` function](#navigate), this value is the same as given in the options.


#### `loader()`


[Section titled loader()](#loader)

**Type:** `() => Promise<void>`

Implementation of the following phase in the navigation (loading the next page). This implementation can be overridden to add extra behavior.


#### `viewTransition`


[Section titled viewTransition](#viewtransition)

**Type:** [`ViewTransition`](https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition)

The view transition object used in this navigation. On browsers that do not support the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API), this is an object implementing the same API for convenience but without the DOM integration.


#### `swap()`


[Section titled swap()](#swap)

**Type:** `() => void`

Implementation of the document swap logic.

Read more about [building a custom swap function](/en/guides/view-transitions/#building-a-custom-swap-function) in the View Transitions guide.

By default, this implementation will call the following functions in order:

1.  [`deselectScripts()`](#deselectscripts)
2.  [`swapRootAttributes()`](#swaprootattributes)
3.  [`swapHeadElements()`](#swapheadelements)
4.  [`saveFocus()`](#savefocus)
5.  [`swapBodyElement()`](#swapbodyelement)

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 192. `en/reference/programmatic-reference/.md`

```text
# Programmatic Astro API (experimental)



# Programmatic Astro API (experimental)


If you need more control when running Astro, the `"astro"` package exports APIs to programmatically run the CLI commands.

These APIs are experimental and their API signature may change. Any updates will be mentioned in the [Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) and the information below will always show the current, up-to-date information.


## `AstroInlineConfig`


[Section titled AstroInlineConfig](#astroinlineconfig)

The `AstroInlineConfig` type is used by all of the command APIs below. It extends from the user [Astro config](/en/reference/configuration-reference/) type:

```
interface AstroInlineConfig extendsAstroUserConfig {configFile?:string|false;mode?:string;logLevel?:"debug"|"info"|"warn"|"error"|"silent";}
```


### `configFile`


[Section titled configFile](#configfile)

**Type:** `string | false` **Default:** `undefined`

A custom path to the Astro config file.

If this value is undefined (default) or unset, Astro will search for an `astro.config.(js,mjs,ts,mts)` file relative to the `root` and load the config file if found.

If a relative path is set, it will resolve based on the `root` option.

Set to `false` to disable loading any config files.

The inline config passed in this object will take highest priority when merging with the loaded user config.


### `mode`


[Section titled mode](#mode)

**Type:** `string` **Default:** `"development"` when running `astro dev`, `"production"` when running `astro build`

**Added in:** `astro@5.0.0`

The mode used when developing or building your site (e.g. `"production"`, `"testing"`).

This value is passed to Vite using [the `--mode` flag](/en/reference/cli-reference/#--mode-string) when the `astro build` or `astro dev` commands are run to determine the value of `import.meta.env.MODE`. This also determines which `.env` files are loaded, and therefore the values of `astro:env`. See the [environment variables page](/en/guides/environment-variables/) for more details.

To output a development-based build, you can run `astro build` with the [`--devOutput` flag](/en/reference/cli-reference/#--devoutput).


### `logLevel`


[Section titled logLevel](#loglevel)

**Type:** `"debug" | "info" | "warn" | "error" | "silent"` **Default:** `"info"`

The logging level to filter messages logged by Astro.

-   `"debug"`: Log everything, including noisy debugging diagnostics.
-   `"info"`: Log informational messages, warnings, and errors.
-   `"warn"`: Log warnings and errors.
-   `"error"`: Log errors only.
-   `"silent"`: No logging.


## `dev()`


[Section titled dev()](#dev)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<DevServer>`

Similar to [`astro dev`](/en/reference/cli-reference/#astro-dev), it runs Astro’s development server.

```
import { dev } from"astro";const devServer = await dev({root: "./my-project",});// Stop the server if neededawaitdevServer.stop();
```


### `DevServer`


[Section titled DevServer](#devserver)

```
exportinterface DevServer {address:AddressInfo;handle:(req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>)=>void;watcher: vite.FSWatcher;stop():Promise<void>;}
```


#### `address`


[Section titled address](#address)

**Type:** `AddressInfo`

The address the dev server is listening on.

This property contains the value returned by Node’s [`net.Server#address()` method](https://nodejs.org/api/net.html#serveraddress).


#### `handle()`


[Section titled handle()](#handle)

**Type:** `(req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void`

A handle for raw Node HTTP requests. You can call `handle()` with an [`http.IncomingMessage`](https://nodejs.org/api/http.html#class-httpincomingmessage) and an [`http.ServerResponse`](https://nodejs.org/api/http.html#class-httpserverresponse) instead of sending a request through the network.


#### `watcher`


[Section titled watcher](#watcher)

**Type:** `vite.FSWatcher`

The [Chokidar file watcher](https://github.com/paulmillr/chokidar#getting-started) as exposed by [Vite’s development server](https://vite.dev/guide/api-javascript#vitedevserver).


#### `stop()`


[Section titled stop()](#stop)

**Type:** `Promise<void>`

Stops the development server. This closes all idle connections and stops listening for new connections.

Returns a `Promise` that resolves once all pending requests have been fulfilled and all idle connections have been closed.


## `build()`


[Section titled build()](#build)

**Type:** `(inlineConfig: AstroInlineConfig, options?: BuildOptions) => Promise<void>`

Similar to [`astro build`](/en/reference/cli-reference/#astro-build), it builds your site for deployment.

```
import { build } from"astro";awaitbuild({root: "./my-project",});
```


### `BuildOptions`


[Section titled BuildOptions](#buildoptions)

```
exportinterface BuildOptions {devOutput?:boolean;teardownCompiler?:boolean;}
```


#### `devOutput`


[Section titled devOutput](#devoutput)

**Type:** `boolean` **Default:** `false`

**Added in:** `astro@5.4.0`

Output a development-based build similar to code transformed in `astro dev`. This can be useful to test build-only issues with additional debugging information included.


#### `teardownCompiler`


[Section titled teardownCompiler](#teardowncompiler)

**Type:** `boolean` **Default:** `true`

**Added in:** `astro@5.4.0`

Teardown the compiler WASM instance after build. This can improve performance when building once but may cause a performance hit if building multiple times in a row.

When building multiple projects in the same execution (e.g. during tests), disabling this option can greatly increase performance and reduce peak memory usage at the cost of higher sustained memory usage.


## `preview()`


[Section titled preview()](#preview)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<PreviewServer>`

Similar to [`astro preview`](/en/reference/cli-reference/#astro-preview), it starts a local server to serve your build output.

If no adapter is set in the configuration, the preview server will only serve the built static files. If an adapter is set in the configuration, the preview server is provided by the adapter. Adapters are not required to provide a preview server, so this feature may not be available depending on your adapter of choice.

```
import { preview } from"astro";const previewServer = await preview({root: "./my-project",});// Stop the server if neededawaitpreviewServer.stop();
```


### `PreviewServer`


[Section titled PreviewServer](#previewserver)

```
exportinterface PreviewServer {host?:string;port:number;closed():Promise<void>;stop():Promise<void>;}
```


#### `host`


[Section titled host](#host)

**Type:** `string`

The host where the server is listening for connections.

Adapters are allowed to leave this field unset. The value of `host` is implementation-specific.


#### `port`


[Section titled port](#port)

**Type:** `number`

The port where the server is listening for connections.


#### `stop()`


[Section titled stop()](#stop-1)

**Type:** `Promise<void>`

Asks the preview server to close, stop accepting requests, and drop idle connections.

The returned `Promise` resolves when the close request has been sent. This does not mean that the server has closed yet. Use the [`closed()`](#closed) method if you need to ensure the server has fully closed.


#### `closed()`


[Section titled closed()](#closed)

**Type:** `Promise<void>`

Returns a `Promise` that will resolve once the server is closed and reject if an error happens on the server.


## `sync()`


[Section titled sync()](#sync)

**Type:** `(inlineConfig: AstroInlineConfig) => Promise<void>`

Similar to [`astro sync`](/en/reference/cli-reference/#astro-sync), it generates TypeScript types for all Astro modules.

```
import { sync } from"astro";awaitsync({root: "./my-project",});
```


## `mergeConfig()`


[Section titled mergeConfig()](#mergeconfig)

**Type:** `<T extends AstroConfig | AstroInlineConfig>(config: T, overrides: DeepPartial<T>) => T`

**Added in:** `astro@5.4.0`

Imported from `astro/config`, merges a partial Astro configuration on top of an existing, valid, Astro configuration.

`mergeConfig()` accepts an Astro config object and a partial config (any set of valid Astro config options), and returns a valid Astro config combining both values such that:

-   Arrays are concatenated (including integrations and remark plugins).
-   Objects are merged recursively.
-   Vite options are merged using [Vite’s own `mergeConfig` function](https://vite.dev/guide/api-javascript#mergeconfig) with the default `isRoot` flag.
-   Options that can be provided as functions are wrapped into new functions that recursively merge the return values from both configurations with these same rules.
-   All other options override the existing config.

```
import { mergeConfig } from"astro/config";mergeConfig({output: 'static',site: 'https://example.com',integrations: [partytown()],server: ({command})=> ({port: command ==='dev'?4321:1234,}),build: {client: './custom-client',},},{output: 'server',base: '/astro',integrations: [mdx()],server: ({command})=> ({host: command ==='dev'?'localhost':'site.localhost',}),build: {server: './custom-server',},});// Result is equivalent to:{output: 'server',site: 'https://example.com',base: '/astro',integrations: [partytown(), mdx()],server: ({command})=> ({port: command ==='dev'?4321:1234,host: command ==='dev'?'localhost':'site.localhost',}),build: {client: './custom-client',server: './custom-server',},}
```


## `validateConfig()`


[Section titled validateConfig()](#validateconfig)

**Type:** `(userConfig: any, root: string, cmd: string): Promise<AstroConfig>`

**Added in:** `astro@5.4.0`

Imported from `astro/config`, validates an object as if it was exported from `astro.config.mjs` and imported by Astro.

It takes the following arguments:

-   The configuration to be validated.
-   The root directory of the project.
-   The Astro command that is being executed (`build`, `dev`, `sync`, etc.)

The returned promise resolves to the validated configuration, filled with all default values appropriate for the given Astro command.

```
import { validateConfig } from"astro/config";const config = await validateConfig({integrations: [partytown()],}, "./my-project", "build");// defaults are appliedawaitrm(config.outDir, { recursive: true, force: true });
```

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 193. `en/reference/publish-to-npm/.md`

```text
# Publish to NPM


---
url: https://docs.astro.build/en/reference/publish-to-npm/
description: Learn how to publish Astro components to NPM
---


# Publish to NPM


Building a new Astro component? **Publish it to [npm!](https://npmjs.com/)**

Publishing an Astro component is a great way to reuse your existing work across your projects, and to share with the wider Astro community at large. Astro components can be published directly to and installed from NPM, just like any other JavaScript package.

Looking for inspiration? Check out some of our favorite [themes](https://astro.build/themes/) and [components](https://astro.build/integrations/) from the Astro community. You can also [search npm](https://www.npmjs.com/search?q=keywords:astro-component,withastro) to see the entire public catalog.

Don’t want to go it alone?

Check out [Astro Community’s component template](https://github.com/astro-community/component-template) for a community-supported, out-of-the-box template!


## Quick Start


[Section titled Quick Start](#quick-start)

To get started developing your component quickly, you can use a template already set up for you.

Terminal window

```

# Initialize the Astro Component template in a new directorynpmcreateastro@latestmy-new-component-directory----templatecomponent# yarnyarncreateastromy-new-component-directory--templatecomponent# pnpmpnpmcreateastro@latestmy-new-component-directory----templatecomponent

```


## Creating a package


[Section titled Creating a package](#creating-a-package)

Prerequisites

Before diving in, it will help to have a basic understanding of:

-   [Node Modules](https://docs.npmjs.com/creating-node-js-modules)
-   [Package Manifest (`package.json`)](https://docs.npmjs.com/creating-a-package-json-file)
-   [Workspaces](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#workspaces)

To create a new package, configure your development environment to use **workspaces** within your project. This will allow you to develop your component alongside a working copy of Astro.

-   Directorymy-new-component-directory/

    -   Directorydemo/

        -   … for testing and demonstration

    -   package.json
    -   Directorypackages/

        -   Directorymy-component/

            -   index.js
            -   package.json
            -   … additional files used by the package




This example, named `my-project`, creates a project with a single package, named `my-component`, and a `demo/` directory for testing and demonstrating the component.

This is configured in the project root’s `package.json` file:

```
{"name": "my-project","workspaces": ["demo", "packages/*"]}
```

In this example, multiple packages can be developed together from the `packages` directory. These packages can also be referenced from `demo`, where you can install a working copy of Astro.

Terminal window

```
npmcreateastro@latestdemo----templateminimal# yarnyarncreateastrodemo--templateminimal# pnpmpnpmcreateastro@latestdemo----templateminimal
```

There are two initial files that will make up your individual package: `package.json` and `index.js`.


### `package.json`


[Section titled package.json](#packagejson)

The `package.json` in the package directory includes all of the information related to your package, including its description, dependencies, and any other package metadata.

```
{"name": "my-component","description": "Component description","version": "1.0.0","homepage": "https://github.com/owner/project#readme","type": "module","exports": {".": "./index.js","./astro": "./MyAstroComponent.astro","./react": "./MyReactComponent.jsx"},"files": ["index.js", "MyAstroComponent.astro", "MyReactComponent.jsx"],"keywords": ["astro", "withastro", "astro-component", "...", "..."]}
```


#### `description`


[Section titled description](#description)

A short description of your component used to help others know what it does.

```
{"description": "An Astro Element Generator"}
```


#### `type`


[Section titled type](#type)

The module format used by Node.js and Astro to interpret your `index.js` files.

```
{"type": "module"}
```

Use `"type": "module"` so that your `index.js` can be used as an entrypoint with `import` and `export` .


#### `homepage`


[Section titled homepage](#homepage)

The url to the project homepage.

```
{"homepage": "https://github.com/owner/project#readme"}
```

This is a great way to direct users to an online demo, documentation, or homepage for your project.


#### `exports`


[Section titled exports](#exports)

The entry points of a package when imported by name.

```
{"exports": {".": "./index.js","./astro": "./MyAstroComponent.astro","./react": "./MyReactComponent.jsx"}}
```

In this example, importing `my-component` would use `index.js`, while importing `my-component/astro` or `my-component/react` would use `MyAstroComponent.astro` or `MyReactComponent.jsx` respectively.


#### `files`


[Section titled files](#files)

An optional optimization to exclude unnecessary files from the bundle shipped to users via npm. Note that **only files listed here will be included in your package**, so if you add or change files necessary for your package to work, you must update this list accordingly.

```
{"files": ["index.js", "MyAstroComponent.astro", "MyReactComponent.jsx"]}
```


#### `keywords`


[Section titled keywords](#keywords)

An array of keywords relevant to your component, used to help others [find your component on npm](https://www.npmjs.com/search?q=keywords:astro-component,withastro) and in any other search catalogs.

Add `astro-component` or `withastro` as a special keyword to maximize its discoverability in the Astro ecosystem.

```
{"keywords": ["astro-component", "withastro", "... etc", "... etc"]}
```

Tip

Keywords are also used by our [integrations library](https://astro.build/integrations/)! [See below](#integrations-library) for a full list of keywords we look for in NPM.


### `index.js`


[Section titled index.js](#indexjs)

The main **package entrypoint** used whenever your package is imported.

```
export { defaultas MyAstroComponent } from'./MyAstroComponent.astro';export { defaultas MyReactComponent } from'./MyReactComponent.jsx';
```

This allows you to package multiple components together into a single interface.


#### Example: Using Named Imports


[Section titled Example: Using Named Imports](#example-using-named-imports)

```
---import { MyAstroComponent } from'my-component';import { MyReactComponent } from'my-component';---<MyAstroComponent /><MyReactComponent />
```


#### Example: Using Namespace Imports


[Section titled Example: Using Namespace Imports](#example-using-namespace-imports)

```
---import*as Example from'example-astro-component';---<Example.MyAstroComponent /><Example.MyReactComponent />
```


#### Example: Using Individual Imports


[Section titled Example: Using Individual Imports](#example-using-individual-imports)

```
---import MyAstroComponent from'example-astro-component/astro';import MyReactComponent from'example-astro-component/react';---<MyAstroComponent /><MyReactComponent />
```


## Developing your package


[Section titled Developing your package](#developing-your-package)

Astro does not have a dedicated “package mode” for development. Instead, you should use a demo project to develop and test your package inside of your project. This can be a private website only used for development, or a public demo/documentation website for your package.

If you are extracting components from an existing project, you can even continue to use that project to develop your now-extracted components.


## Testing your component


[Section titled Testing your component](#testing-your-component)

Astro does not currently ship a test runner. *(If you are interested in helping out with this, [join us on Discord!](https://astro.build/chat))*

In the meantime, our current recommendation for testing is:

1.  Add a test `fixtures` directory to your `demo/src/pages` directory.

2.  Add a new page for every test that you’d like to run.

3.  Each page should include some different component usage that you’d like to test.

4.  Run `astro build` to build your fixtures, then compare the output of the `dist/__fixtures__/` directory to what you expected.

    -   Directorymy-project/demo/src/pages/\_\_fixtures\_\_/

        -   test-name-01.astro
        -   test-name-02.astro
        -   test-name-03.astro




## Publishing your component


[Section titled Publishing your component](#publishing-your-component)

Once you have your package ready, you can publish it to npm using the `npm publish` command. If that fails, make sure that you have logged in via `npm login` and that your `package.json` is correct. If it succeeds, you’re done!

Notice that there was no `build` step for Astro packages. Any file type that Astro supports natively, such as `.astro`, `.ts`, `.jsx`, and `.css`, can be published directly without a build step.

If you need another file type that isn’t natively supported by Astro, add a build step to your package. This advanced exercise is left up to you.


## Integrations Library


[Section titled Integrations Library](#integrations-library)

Share your hard work by adding your integration to our [integrations library](https://astro.build/integrations/)!

Tip

Do you need some help building your integration, or just want to meet other integrations builders? We have a dedicated `#integrations` channel on our [Discord server](https://astro.build/chat). Come say hi!


### `package.json` data


[Section titled package.json data](#packagejson-data)

The library is automatically updated weekly, pulling in every package published to NPM with the `astro-component` or `withastro` keyword.

The integrations library reads the `name`, `description`, `repository`, and `homepage` data from your `package.json`.

Avatars are a great way to highlight your brand in the library! Once your package is published you can [file a GitHub issue](https://github.com/withastro/astro.build/issues/new/choose) with your avatar attached and we will add it to your listing.

Tip

Need to override the information our library reads from NPM? No problem! [File an issue](https://github.com/withastro/astro.build/issues/new/choose) with the updated information and we’ll make sure the custom `name`, `description`, or `homepage` is used instead.


### Categories


[Section titled Categories](#categories)

In addition to the required `astro-component` or `withastro` keyword, special keywords are also used to automatically organize packages. Including any of the keywords below will add your integration to the matching category in our integrations library.

category

keywords

Accessibility

`a11y`, `accessibility`

Adapters

`astro-adapter`

Analytics

`analytics`

CSS + UI

`css`, `ui`, `icon`, `icons`, `renderer`

Frameworks

`renderer`

Content Loaders

`astro-loader`

Images + Media

`media`, `image`, `images`, `video`, `audio`

Performance + SEO

`performance`, `perf`, `seo`, `optimization`

Dev Toolbar

`devtools`, `dev-overlay`, `dev-toolbar`

Utilities

`tooling`, `utils`, `utility`

Packages that don’t include any keyword matching a category will be shown as `Uncategorized`.


## Share


[Section titled Share](#share)

We encourage you to share your work, and we really do love seeing what our talented Astronauts create. Come and share what you create with us in our [Discord](https://astro.build/chat) or mention [@astrodotbuild](https://twitter.com/astrodotbuild) in a Tweet!

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 194. `en/reference/routing-reference/.md`

```text
# Routing Reference



# Routing Reference


There is no separate routing configuration in Astro.

Every [supported page file](/en/basics/astro-pages/#supported-page-files) located within the special `src/pages/` directory creates a route. When the file name contains a [parameter](#params), a route can create multiple pages dynamically, otherwise it creates a single page.

By default, all Astro page routes and endpoints are generated and prerendered at build time. [On-demand server rendering](/en/guides/on-demand-rendering/) can be set for individual routes, or as the default.


## `prerender`


[Section titled prerender](#prerender)

**Type:** `boolean` **Default:** `true` in static mode (default); `false` with `output: 'server'` configuration

**Added in:** `astro@1.0.0`

A value exported from each individual route to determine whether or not it is prerendered.

By default, all pages and endpoints are prerendered and will be statically generated at build time. You can opt out of prerendering on one or more routes, and you can have both static and on-demand rendered routes in the same project.


### Per-page override


[Section titled Per-page override](#per-page-override)

You can override the default value to enable [on demand rendering](/en/guides/on-demand-rendering/) for an individual route by exporting `prerender` with the value `false` from that file:

src/pages/rendered-on-demand.astro

```
---export const prerender = false---<!-- server-rendered content --><!-- the rest of my site is static -->
```


### Switch to `server` mode


[Section titled Switch to server mode](#switch-to-server-mode)

You can override the default value for all routes by configuring [`output: 'server'`](/en/reference/configuration-reference/#output). In this output mode, all pages and endpoints will be generated on the server upon request by default instead of being prerendered.

In `server` mode, enable prerendering for an individual route by exporting `prerender` with the value `true` from that file:

src/pages/static-about-page.astro

```
---// with `output: 'server'` configuredexport const prerender = true---<!-- My static about page --><!-- All other pages are rendered on demand -->
```


## `partial`


[Section titled partial](#partial)

**Type:** `boolean` **Default:** `false`

**Added in:** `astro@3.4.0`

A value exported from an individual route to determine whether or not it should be rendered as a full HTML page.

By default, all files located within the reserved `src/pages/` directory automatically include the `<!DOCTYPE html>` declaration and additional `<head>` content such as Astro’s scoped styles and scripts.

You can override the default value to designate the content as a [page partial](/en/basics/astro-pages/#page-partials) for an individual route by exporting a value for `partial` from that file:

src/pages/my-page-partial.astro

```
---export const partial = true---<!-- Generated HTML available at a URL --><!-- Available to a rendering library -->
```

The `export const partial` must be identifiable statically. It can have the value of:

-   The boolean **`true`**.
-   An environment variable using import.meta.env such as `import.meta.env.USE_PARTIALS`.


## `getStaticPaths()`


[Section titled getStaticPaths()](#getstaticpaths)

**Type:** `(options: GetStaticPathsOptions) => Promise<GetStaticPathsResult> | GetStaticPathsResult`

**Added in:** `astro@1.0.0`

A function to generate multiple, prerendered page routes from a single `.astro` page component with one or more [parameters](#params) in its file path. Use this for routes that will be created at build time, also known as static site building.

The `getStaticPaths()` function must return an array of objects to determine which URL paths will be prerendered by Astro. Each object must include a `params` object, to specify route paths. The object may optionally contain a `props` object with [data to be passed](#data-passing-with-props) to each page template.

src/pages/blog/\[post\].astro

```
---// In 'server' mode, opt in to prerendering:// export const prerender = trueexportasyncfunctiongetStaticPaths() {return [// { params: { /* required */ }, props: { /* optional */ } },{ params: { post: '1' } },// [post] is the parameter{ params: { post: '2' } },// must match the file name// ...];}---<!-- Your HTML template here. -->
```

`getStaticPaths()` can also be used in static file endpoints for [dynamic routing](/en/guides/endpoints/#params-and-dynamic-routing).

Tip

When using TypeScript, use the [`GetStaticPaths`](/en/guides/typescript/#infer-getstaticpaths-types) type utility to ensure type-safe access of your `params` and `props`.

Caution

The `getStaticPaths()` function executes in its own isolated scope once, before any page loads. Therefore you can’t reference anything from its parent scope, other than file imports. The compiler will warn you if you break this requirement.


### `params`


[Section titled params](#params)

The `params` key of each object in the array returned by `getStaticPaths()` tells Astro what routes to build.

The keys in `params` must match the parameters defined in your component file path. The value for each `params` object must match the parameters used in the page name. `params` are encoded into the URL, so only strings are supported as values.

For example,`src/pages/posts/[id].astro`has an `id` parameter in its file name. The following `getStaticPaths()` function in this `.astro` component tells Astro to statically generate `posts/1`, `posts/2`, and `posts/3` at build time.

src/pages/posts/\[id\].astro

```
---exportasyncfunctiongetStaticPaths() {return [{ params: { id: '1' } },{ params: { id: '2' } },{ params: { id: '3' } }];}const { id } = Astro.params;---<h1>{id}</h1>
```


### Data passing with `props`


[Section titled Data passing with props](#data-passing-with-props)

To pass additional data to each generated page, you can set a `props` value on each object in the array returned by `getStaticPaths()`. Unlike `params`, `props` are not encoded into the URL and so aren’t limited to only strings.

For example, if you generate pages with data fetched from a remote API, you can pass the full data object to the page component inside of `getStaticPaths()`. The page template can reference the data from each post using `Astro.props`.

src/pages/posts/\[id\].astro

```
---exportasyncfunctiongetStaticPaths() {const response = await fetch('...');const data = await response.json();return data.map((post)=> {return {params: { id: post.id },props: { post },};});}const { id } = Astro.params;const { post } = Astro.props;---<h1>{id}: {post.name}</h1>
```


### `paginate()`


[Section titled paginate()](#paginate)

**Added in:** `astro@1.0.0`

A function that can be returned from [`getStaticPaths()`](#getstaticpaths) to divide a collection of content items into separate pages.

`paginate()` will automatically generate the necessary array to return from `getStaticPaths()` to create one URL for every page of your paginated collection. The page number will be passed as a `param`, and the page data will be passed as a `page` prop.

The following example fetches and passes 150 items to the `paginate` function, and creates static, prerendered pages at build time that will display 10 items per page:

src/pages/pokemon/\[page\].astro

```
---exportasyncfunctiongetStaticPaths({ paginate }) {// Load your data with fetch(), getCollection(), etc.const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);const result = await response.json();const allPokemon = result.results;// Return a paginated collection of paths for all itemsreturnpaginate(allPokemon, { pageSize: 10 });}const { page } = Astro.props;---
```

`paginate()` has the following arguments:

-   `data` - array containing the page’s data passed to the `paginate()` function
-   `options` - Optional object with the following properties:
    -   `pageSize` - The number of items shown per page (`10` by default)
    -   `params` - Send additional parameters for creating dynamic routes
    -   `props` - Send additional props to be available on each page

`paginate()` assumes a file name of `[page].astro` or `[...page].astro`. The `page` param becomes the page number in your URL:

-   `/posts/[page].astro` would generate the URLs `/posts/1`, `/posts/2`, `/posts/3`, etc.
-   `/posts/[...page].astro` would generate the URLs `/posts`, `/posts/2`, `/posts/3`, etc.


#### The pagination `page` prop


[Section titled The pagination page prop](#the-pagination-page-prop)

**Type:** `Page<TData>`

Pagination will pass a `page` prop to every rendered page that represents a single page of data in the paginated collection. This includes the data that you’ve paginated (`page.data`) as well as metadata for the page (`page.url`, `page.start`, `page.end`, `page.total`, etc). This metadata is useful for things like a “Next Page” button or a “Showing 1-10 of 100” message.


##### `page.data`


[Section titled page.data](#pagedata)

**Type:** `Array<TData>`

Array of data returned from the `paginate()` function for the current page.


##### `page.start`


[Section titled page.start](#pagestart)

**Type:** `number`

Index of the first item on the current page, starting at `0`. (e.g. if `pageSize: 25`, this would be `0` on page 1, `25` on page 2, etc.)


##### `page.end`


[Section titled page.end](#pageend)

**Type:** `number`

Index of the last item on the current page.


##### `page.size`


[Section titled page.size](#pagesize)

**Type:** `number` **Default:** `10`

The total number of items per page.


##### `page.total`


[Section titled page.total](#pagetotal)

**Type:** `number`

The total number of items across all pages.


##### `page.currentPage`


[Section titled page.currentPage](#pagecurrentpage)

**Type:** `number`

The current page number, starting with `1`.


##### `page.lastPage`


[Section titled page.lastPage](#pagelastpage)

**Type:** `number`

The total number of pages.


##### `page.url.current`


[Section titled page.url.current](#pageurlcurrent)

**Type:** `string`

Get the URL of the current page (useful for canonical URLs). If a value is set for [`base`](/en/reference/configuration-reference/#base), the URL starts with that value.


##### `page.url.prev`


[Section titled page.url.prev](#pageurlprev)

**Type:** `string | undefined`

Get the URL of the previous page (will be `undefined` if on page 1). If a value is set for [`base`](/en/reference/configuration-reference/#base), prepend the base path to the URL.


##### `page.url.next`


[Section titled page.url.next](#pageurlnext)

**Type:** `string | undefined`

Get the URL of the next page (will be `undefined` if no more pages). If a value is set for [`base`](/en/reference/configuration-reference/#base), prepend the base path to the URL.


##### `page.url.first`


[Section titled page.url.first](#pageurlfirst)

**Type:** `string | undefined`

**Added in:** `astro@4.12.0`

Get the URL of the first page (will be `undefined` if on page 1). If a value is set for [`base`](/en/reference/configuration-reference/#base), prepend the base path to the URL.


##### `page.url.last`


[Section titled page.url.last](#pageurllast)

**Type:** `string | undefined`

**Added in:** `astro@4.12.0`

Get the URL of the last page (will be `undefined` if no more pages). If a value is set for [`base`](/en/reference/configuration-reference/#base), prepend the base path to the URL.

Reference


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 195. `en/tutorial/0-introduction/.md`

```text
# Build your first Astro Blog


---
url: https://docs.astro.build/en/tutorial/0-introduction/
description: Learn the basics of Astro with a project-based tutorial. All the background knowledge you need to get started!
---


# Build your first Astro Blog


In this tutorial, you’ll learn Astro’s key features by building a fully-functioning blog, from zero to full launch! 🚀

Along the way, you’ll:

-   Set up your development environment
-   Create pages and blog posts for your website
-   Build with Astro components
-   Query and work with local files
-   Add interactivity to your site
-   Deploy your site to the web

Want a preview of what you’re going to build? You can view the final project on [GitHub](https://github.com/withastro/blog-tutorial-demo) or open a working version in an online coding environment such as [IDX](https://idx.google.com/import?url=https:%2F%2Fgithub.com%2Fwithastro%2Fblog-tutorial-demo%2F) or [StackBlitz](https://stackblitz.com/github/withastro/blog-tutorial-demo/tree/complete?file=src%2Fpages%2Findex.astro).

Note

If you would rather start exploring Astro with a pre-built Astro site, you can visit [https://astro.new](https://astro.new) and choose a starter template to open and edit in an online editor.


## Checklist


[Section titled Checklist](#checklist)

-   Looks great! I’m ready to get started!

Tutorials


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 196. `en/upgrade-astro/.md`

```text
# Upgrade Astro


---
url: https://docs.astro.build/en/upgrade-astro/
description: Learn how to upgrade Astro
---

Astro v5 is here! [Learn how to upgrade your site](/en/guides/upgrade-to/v5/)


# Upgrade Astro


This guide covers how to update your version of Astro and related dependencies, how to learn what has changed from one version to the next, and how to understand Astro’s versioning system and corresponding documentation updates.


## What has changed?


[Section titled What has changed?](#what-has-changed)

The latest release of Astro is v5.8.1.

You can find an exhaustive list of all changes in [Astro’s changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md), and important instructions for upgrading to each new [major version](#major-changes) in our [upgrade guides](#upgrade-guides).


## Upgrade to the latest version


[Section titled Upgrade to the latest version](#upgrade-to-the-latest-version)

Update your project’s version of Astro and all official integrations to the latest versions with one command using your package manager:

-   [npm](#tab-panel-1301)
-   [pnpm](#tab-panel-1302)
-   [Yarn](#tab-panel-1303)

Terminal window

```

# Upgrade Astro and official integrations togethernpx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetherpnpmdlx@astrojs/upgrade

```

Terminal window

```

# Upgrade Astro and official integrations togetheryarndlx@astrojs/upgrade

```


### Manual Upgrading


[Section titled Manual Upgrading](#manual-upgrading)

To update Astro and integrations to their current versions manually, use the appropriate command for your package manager.

-   [npm](#tab-panel-1304)
-   [pnpm](#tab-panel-1305)
-   [Yarn](#tab-panel-1306)

Terminal window

```

# Example: upgrade Astro with React and Partytown integrationsnpminstallastro@latest@astrojs/react@latest@astrojs/partytown@latest

```

Terminal window

```

# Example: upgrade Astro with React and Partytown integrationspnpmaddastro@latest@astrojs/react@latest@astrojs/partytown@latest

```

Terminal window

```

# Example: upgrade Astro with React and Partytown integrationsyarnaddastro@latest@astrojs/react@latest@astrojs/partytown@latest

```


### Install a specific version number


[Section titled Install a specific version number](#install-a-specific-version-number)

To install a specific [version of Astro](https://www.npmjs.com/package/astro?activeTab=versions) or integrations, use the appropriate command for your package manager.

-   [npm](#tab-panel-1307)
-   [pnpm](#tab-panel-1308)
-   [Yarn](#tab-panel-1309)

Terminal window

```
npminstallastro@4.5.3@astrojs/react@3.0.10
```

Terminal window

```
pnpmaddastro@4.5.3@astrojs/react@3.0.10
```

Terminal window

```
yarnaddastro@4.5.3@astrojs/react@3.0.10
```


## Documentation updates


[Section titled Documentation updates](#documentation-updates)

This documentation is updated for each [minor release](#minor-changes) and [major version release](#major-changes). When new features are added, or existing usage changes, the docs will update to reflect the **current behavior of Astro**. If your project is not updated, then you may notice some behaviors do not match the up-to-date documentation.

New features are added to docs with the specific version number in which they were added. This means that if you have not updated to the latest release of Astro, some documented features may be unavailable. Always check the `Added in:` version number and make sure your project is updated before attempting to use new features!

If you have not upgraded to the latest major version of Astro, you may encounter significant differences between the Astro documentation and your project’s behavior. We strongly recommend upgrading to the current major version of Astro as soon as you are able. Both the code and the documentation for earlier versions is unsupported.


### Upgrade Guides


[Section titled Upgrade Guides](#upgrade-guides)

After every [major version release](#major-changes), you will find an **upgrade guide** with information about important changes and instructions for upgrading your project code.

The main Astro documentation pages are always **accurate for the latest released version of Astro**. They do not describe or compare to how things worked in previous versions, nor do they highlight updated or changed behavior.

See the upgrade guides below for an explanation of changes, comparing the new version to the old. The upgrade guides include everything that could require you to change your own code: breaking changes, deprecations, feature removals and replacements as well as updated usage guidance. Each change to Astro includes a “What should I do?” section to help you successfully update your project code.

-   [Upgrade to v5](/en/guides/upgrade-to/v5/)
-   [Upgrade to v4](/en/guides/upgrade-to/v4/)
-   [Upgrade to v3](/en/guides/upgrade-to/v3/)
-   [Upgrade to v2](/en/guides/upgrade-to/v2/)
-   [Upgrade to v1](/en/guides/upgrade-to/v1/)


### Older docs (unmaintained)


[Section titled Older docs (unmaintained)](#older-docs-unmaintained)

Documentation for older versions of Astro is not maintained, but is available as a static snapshot. Use these versions of docs if you are unable to upgrade your project, but still wish to consult guides and reference:

-   [unmaintained v4.16.17 snapshot](https://v4.docs.astro.build/en/getting-started/)
-   [unmaintained v3.6.3 snapshot](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/)
-   [unmaintained v2.10.15 snapshot](https://deploy-preview-4405--astro-docs-2.netlify.app/en/getting-started/)


## Semantic versioning


[Section titled Semantic versioning](#semantic-versioning)

Astro attempts to adhere as much as possible to [semantic versioning](https://semver.org/), which is a set of rules developers use to determine how to assign a version number to a release. Semantic version follows a predictable pattern to inform users of the kind of changes they can expect from one version to the next.

Semantic versioning enforces a pattern of `X.Y.Z` for software version numbers. These values represent **major (X)**, **minor (Y)**, and **patch (Z)** updates.


### Patch changes


[Section titled Patch changes](#patch-changes)

Patch changes are the least disruptive changes. They do not change the way you use Astro, and no change to your own code is required when you update.

When Astro issues a “patch” version, the last number increases. (e.g. `astro@4.3.14` -> `astro@4.3.15`)

Patches may be released for reasons such as:

-   Internal changes that do not change Astro’s functionality:
    -   refactors
    -   performance improvements
    -   increase or change in test coverage
    -   aligning with stated documentation and expected behavior
-   Improvements to logging and error messages.
-   Re-releases after a failed release.

Patch changes also include **most bug fixes**, even in cases where users were taking advantage of existing unintended or undesirable behavior.


### Minor changes


[Section titled Minor changes](#minor-changes)

Minor releases primarily introduce new features and improvements that you may wish to try, but require no changes to your code. Some existing features may also be **deprecated** (marked for deletion in a future version while continuing to function) in a minor release, giving you the opportunity to prepare for their eventual removal.

Minor releases include changes such as:

-   **Deprecations** of existing features/options with a warning that they will be removed in an upcoming major release.
-   Introduction of new functionalities.
-   Introduction of new options in the integration hooks.
-   Introduction of new functionalities in `astro/app`, notably used for creating new adapters.

A minor release may also include smaller, patch changes at the same time.


### Major changes


[Section titled Major changes](#major-changes)

Major releases will include breaking changes to at least some existing code. These breaking changes are always documented in an [“Upgrade to vX” guide](#upgrade-guides) in Astro.

Major releases allow Astro to make significant changes not only to internal logic, but also to intended behavior and usage. Documentation will be updated to reflect the latest version only, and **static, unmaintained snapshots of older docs** are available as a historical record for older projects that are not yet upgraded.

Major releases include changes such as:

-   Removal of previously deprecated functionalities.
-   Changes of existing functionalities.
-   Changes of existing options in the integration hooks.
-   Changes of existing options and functionalities in `astro/app`, notably used for creating new adapters.

A major release may also include some non-breaking changes and improvements that would normally be released separately in a minor or patch release.


### Exceptions


[Section titled Exceptions](#exceptions)

-   **Experimental features**. Releasing versions of Astro without adhering to semantic versioning allows Astro developers the greatest flexibility to explore, and even radically change course, during the development of experimental features. Therefore, the behavior of these features can break in minor and patch changes.

    These features are usually accompanied by an ongoing, public [Request for Consideration (RFC) stage 3](https://github.com/withastro/roadmap#stage-3-rfc--development). It is expected that beta users will follow for updates, and leave early feedback on the discussion to help guide development of these features.

    Once these features are out of their experimental period, they will follow the normal semantic versioning contract.

-   **Improvements to the documentation** (e.g. reference and error messages). They are built from source for the `docs` repository. This allows Astro to quickly update docs fixes and improvements in the cases where documentation source content is stored in the main `astro` repository.



### Node.js support and upgrade policies


[Section titled Node.js support and upgrade policies](#nodejs-support-and-upgrade-policies)


#### Support


[Section titled Support](#support)

-   Astro supports the [**latest *Maintenance* LTS** version of Node.js](https://nodejs.org/en/about/previous-releases#release-schedule).
-   Astro supports the [**current *Active* LTS** version of Node.js](https://nodejs.org/en/about/previous-releases#release-schedule)
-   Astro can support odd versions of Node.js.


#### Upgrade


[Section titled Upgrade](#upgrade)

The following rules define when Astro may deprecate, drop, or add support for versions of Node.js:

-   Odd versions of Node.js can be deprecated and/or dropped when the next even version of Node.js published. This change can occur in a **minor** release of Astro, after a reasonable period of extended support as decided by the Astro Core team.
-   Upgrading the minimum ***Maintenance* LTS** (within the same major range, e.g. from `v18.14.*` to `v18.20.*`) version of Node.js can occur in a **minor** release of Astro.
    -   Security exception: If a security flaw in Node.js that **affects Astro** is disclosed and fixed, the Core team can bump the minimum version of the ***Maintenance* LTS** in a **patch** release.
-   Upgrading minor or major versions of Node.js (**not** Maintenance LTS) occurs only in major versions of Astro.
    -   Security exception: If a security flaw in Node.js that **affects Astro** is disclosed and fixed, the Core team can bump the minimum version in a **minor** release.


### Extended maintenance


[Section titled Extended maintenance](#extended-maintenance)

The Core team will provide extended maintenance **for security fixes only** for one previous major version. This means that if the current major is `v4.*`, the Core team will back port security fixes and issue a new `v3.*` release.

Learn


## **Learn Astro** with James Q Quick


Build your first site with 35 interactive Scrimba lessons

[Get 20% off](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)
```

### 197. `scraping-summary.json`

```json
{
  "scrapingDate": "2025-05-31T10:05:28.763Z",
  "baseUrl": "https://docs.astro.build/en/getting-started/",
  "outputFormat": "markdown",
  "totalPages": 200,
  "pages": [
    {
      "title": "Astro Docs",
      "url": "https://docs.astro.build/en/getting-started/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/getting-started/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/getting-started/",
        "description": "Guides, resources, and API references to help you build with Astro — the web framework for content-driven websites."
      }
    },
    {
      "title": "Why Astro?",
      "url": "https://docs.astro.build/en/concepts/why-astro/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/concepts/why-astro/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/concepts/why-astro/",
        "description": "Astro is the web framework for building content-driven websites like blogs, marketing, and e-commerce. Learn why Astro might be a good choice for your next website."
      }
    },
    {
      "title": "Islands architecture",
      "url": "https://docs.astro.build/en/concepts/islands/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/concepts/islands/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/concepts/islands/",
        "description": "Learn about how Astro's islands architecture helps keep sites fast."
      }
    },
    {
      "title": "Build your first Astro Blog",
      "url": "https://docs.astro.build/en/tutorial/0-introduction/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/tutorial/0-introduction/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/tutorial/0-introduction/",
        "description": "Learn the basics of Astro with a project-based tutorial. All the background knowledge you need to get started!"
      }
    },
    {
      "title": "Install Astro",
      "url": "https://docs.astro.build/en/install-and-setup/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/install-and-setup/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/install-and-setup/",
        "description": "How to install Astro and start a new project."
      }
    },
    {
      "title": "Project structure",
      "url": "https://docs.astro.build/en/basics/project-structure/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/basics/project-structure/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/basics/project-structure/",
        "description": "An introduction to the basic file structure of an Astro project."
      }
    },
    {
      "title": "Develop and build",
      "url": "https://docs.astro.build/en/develop-and-build/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/develop-and-build/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/develop-and-build/",
        "description": "How to start working on a new project."
      }
    },
    {
      "title": "Configuration overview",
      "url": "https://docs.astro.build/en/guides/configuring-astro/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/configuring-astro/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/configuring-astro/",
        "description": "Get to know the ways you can configure and customize your new project and your development experience."
      }
    },
    {
      "title": "Editor setup",
      "url": "https://docs.astro.build/en/editor-setup/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/editor-setup/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/editor-setup/",
        "description": "Set up your code editor to build with Astro."
      }
    },
    {
      "title": "TypeScript",
      "url": "https://docs.astro.build/en/guides/typescript/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/typescript/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/typescript/",
        "description": "Learn how to use Astro's built-in TypeScript support."
      }
    },
    {
      "title": "Using environment variables",
      "url": "https://docs.astro.build/en/guides/environment-variables/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/environment-variables/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/environment-variables/",
        "description": "Learn how to use environment variables in an Astro project."
      }
    },
    {
      "title": "Dev toolbar",
      "url": "https://docs.astro.build/en/guides/dev-toolbar/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/dev-toolbar/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/dev-toolbar/",
        "description": "A guide to using the dev toolbar in Astro"
      }
    },
    {
      "title": "Migrate an existing project to Astro",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/",
        "description": "Some tips and tricks for converting your site to Astro."
      }
    },
    {
      "title": "Migrating from Create React App (CRA)",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-create-react-app/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-create-react-app/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-create-react-app/",
        "description": "Tips for migrating an existing Create React App project to Astro"
      }
    },
    {
      "title": "Migrating from Docusaurus",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-docusaurus/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-docusaurus/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-docusaurus/",
        "description": "Tips for migrating an existing Docusaurus project to Astro"
      }
    },
    {
      "title": "Migrating from Eleventy",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-eleventy/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-eleventy/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-eleventy/",
        "description": "Tips for migrating an existing Eleventy project to Astro"
      }
    },
    {
      "title": "Migrating from Gatsby",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gatsby/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-gatsby/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gatsby/",
        "description": "Tips for migrating an existing Gatsby project to Astro"
      }
    },
    {
      "title": "Migrating from GitBook",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gitbook/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-gitbook/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gitbook/",
        "description": "Tips for migrating an existing GitBook project to Astro"
      }
    },
    {
      "title": "Migrating from Gridsome",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gridsome/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-gridsome/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gridsome/",
        "description": "Tips for migrating an existing Gridsome project to Astro"
      }
    },
    {
      "title": "Migrating from Hugo",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-hugo/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-hugo/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-hugo/",
        "description": "Tips for migrating an existing Hugo project to Astro"
      }
    },
    {
      "title": "Migrating from Jekyll",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-jekyll/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-jekyll/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-jekyll/",
        "description": "Tips for migrating an existing Jekyll project to Astro"
      }
    },
    {
      "title": "Migrating from Next.js",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nextjs/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-nextjs/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nextjs/",
        "description": "Tips for migrating an existing Next.js project to Astro"
      }
    },
    {
      "title": "Migrating from NuxtJS",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nuxtjs/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-nuxtjs/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nuxtjs/",
        "description": "Tips for migrating an existing NuxtJS project to Astro"
      }
    },
    {
      "title": "Migrating from Pelican",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-pelican/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-pelican/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-pelican/",
        "description": "Tips for migrating an existing Pelican project to Astro"
      }
    },
    {
      "title": "Migrating from SvelteKit",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-sveltekit/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-sveltekit/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-sveltekit/",
        "description": "Tips for migrating an existing SvelteKit project to Astro"
      }
    },
    {
      "title": "Migrating from VuePress",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-vuepress/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-vuepress/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-vuepress/",
        "description": "Tips for migrating an existing VuePress project to Astro"
      }
    },
    {
      "title": "Migrating from WordPress",
      "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-wordpress/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/migrate-to-astro/from-wordpress/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-wordpress/",
        "description": "Tips for migrating an existing WordPress project to Astro"
      }
    },
    {
      "title": "Pages",
      "url": "https://docs.astro.build/en/basics/astro-pages/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/basics/astro-pages/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/basics/astro-pages/",
        "description": "An introduction to Astro pages."
      }
    },
    {
      "title": "Routing",
      "url": "https://docs.astro.build/en/guides/routing/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/routing/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/routing/",
        "description": "An intro to routing with Astro."
      }
    },
    {
      "title": "Endpoints",
      "url": "https://docs.astro.build/en/guides/endpoints/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/endpoints/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/endpoints/",
        "description": "Learn how to create endpoints that serve any kind of data"
      }
    },
    {
      "title": "Middleware",
      "url": "https://docs.astro.build/en/guides/middleware/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/middleware/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/middleware/",
        "description": "Learn how to use middleware in Astro."
      }
    },
    {
      "title": "Internationalization (i18n) Routing",
      "url": "https://docs.astro.build/en/guides/internationalization/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/internationalization/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/internationalization/",
        "description": "Learn how to use Astro’s i18n routing features to localize your site’s pages."
      }
    },
    {
      "title": "Prefetch",
      "url": "https://docs.astro.build/en/guides/prefetch/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/prefetch/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/prefetch/",
        "description": "Prefetch links for snappier navigation between pages."
      }
    },
    {
      "title": "View transitions",
      "url": "https://docs.astro.build/en/guides/view-transitions/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/view-transitions/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/view-transitions/",
        "description": "Enable seamless navigation between pages in Astro with view transitions."
      }
    },
    {
      "title": "Components",
      "url": "https://docs.astro.build/en/basics/astro-components/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/basics/astro-components/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/basics/astro-components/",
        "description": "An introduction to Astro components."
      }
    },
    {
      "title": "Layouts",
      "url": "https://docs.astro.build/en/basics/layouts/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/basics/layouts/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/basics/layouts/",
        "description": "An introduction to layouts in Astro."
      }
    },
    {
      "title": "Styles and CSS",
      "url": "https://docs.astro.build/en/guides/styling/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/styling/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/styling/",
        "description": "Learn how to style components in Astro with scoped styles, external CSS, and tooling like Sass and PostCSS."
      }
    },
    {
      "title": "Using custom fonts",
      "url": "https://docs.astro.build/en/guides/fonts/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/fonts/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/fonts/",
        "description": "Looking to add some custom typefaces to an Astro website? Use Google Fonts with Fontsource or add a font of your choice."
      }
    },
    {
      "title": "Syntax Highlighting",
      "url": "https://docs.astro.build/en/guides/syntax-highlighting/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/syntax-highlighting/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/syntax-highlighting/",
        "description": "Learn how to highlight your code blocks in Astro."
      }
    },
    {
      "title": "Scripts and event handling",
      "url": "https://docs.astro.build/en/guides/client-side-scripts/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/client-side-scripts/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/client-side-scripts/",
        "description": "How to add client-side interactivity to Astro components using native browser JavaScript APIs."
      }
    },
    {
      "title": "Front-end frameworks",
      "url": "https://docs.astro.build/en/guides/framework-components/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/framework-components/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/framework-components/",
        "description": "Build your Astro website with React, Svelte, and more."
      }
    },
    {
      "title": "Markdown in Astro",
      "url": "https://docs.astro.build/en/guides/markdown-content/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/markdown-content/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/markdown-content/",
        "description": "Learn about Astro's built-in support for Markdown."
      }
    },
    {
      "title": "Content collections",
      "url": "https://docs.astro.build/en/guides/content-collections/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/content-collections/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/content-collections/",
        "description": "Manage your content with type safety."
      }
    },
    {
      "title": "Images",
      "url": "https://docs.astro.build/en/guides/images/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/images/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/images/",
        "description": "Learn how to use images in Astro."
      }
    },
    {
      "title": "Data fetching",
      "url": "https://docs.astro.build/en/guides/data-fetching/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/data-fetching/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/data-fetching/",
        "description": "Learn how to fetch remote data with Astro using the fetch API."
      }
    },
    {
      "title": "Astro DB",
      "url": "https://docs.astro.build/en/guides/astro-db/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/astro-db/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/astro-db/",
        "description": "Learn how to use Astro DB, a fully-managed SQL database designed exclusively for Astro."
      }
    },
    {
      "title": "On-demand rendering",
      "url": "https://docs.astro.build/en/guides/on-demand-rendering/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/on-demand-rendering/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/on-demand-rendering/",
        "description": "Generate server-rendered pages and routes on demand with an adapter."
      }
    },
    {
      "title": "Server islands",
      "url": "https://docs.astro.build/en/guides/server-islands/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/server-islands/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/server-islands/",
        "description": "Combine high performance static HTML with dynamic server-rendered content."
      }
    },
    {
      "title": "Actions",
      "url": "https://docs.astro.build/en/guides/actions/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/actions/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/actions/",
        "description": "Learn how to create type-safe server functions you can call from anywhere."
      }
    },
    {
      "title": "Sessions",
      "url": "https://docs.astro.build/en/guides/sessions/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/sessions/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/sessions/",
        "description": "Share data between requests for on-demand rendered pages."
      }
    },
    {
      "title": "Upgrade Astro",
      "url": "https://docs.astro.build/en/upgrade-astro/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/upgrade-astro/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/upgrade-astro/",
        "description": "Learn how to upgrade Astro"
      }
    },
    {
      "title": "Upgrade to Astro v5",
      "url": "https://docs.astro.build/en/guides/upgrade-to/v5/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/upgrade-to/v5/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/upgrade-to/v5/",
        "description": "How to upgrade your project to Astro v5.0."
      }
    },
    {
      "title": "Upgrade to Astro v4",
      "url": "https://docs.astro.build/en/guides/upgrade-to/v4/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/upgrade-to/v4/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/upgrade-to/v4/",
        "description": "How to upgrade your project to the latest version of Astro (v4.0)."
      }
    },
    {
      "title": "Upgrade to Astro v3",
      "url": "https://docs.astro.build/en/guides/upgrade-to/v3/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/upgrade-to/v3/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/upgrade-to/v3/",
        "description": "How to upgrade your project to the latest version of Astro (v3.0)."
      }
    },
    {
      "title": "Upgrade to Astro v2",
      "url": "https://docs.astro.build/en/guides/upgrade-to/v2/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/upgrade-to/v2/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/upgrade-to/v2/",
        "description": "How to upgrade your project to the latest version of Astro."
      }
    },
    {
      "title": "Legacy v0.x Upgrade Guide",
      "url": "https://docs.astro.build/en/guides/upgrade-to/v1/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/upgrade-to/v1/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/upgrade-to/v1/",
        "description": "Archived guide documenting changes between pre-v1 versions of Astro"
      }
    },
    {
      "title": "Troubleshooting",
      "url": "https://docs.astro.build/en/guides/troubleshooting/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/troubleshooting/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/troubleshooting/",
        "description": "Need help? Stuck on something? We've got you covered."
      }
    },
    {
      "title": "Astro recipes",
      "url": "https://docs.astro.build/en/recipes/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/",
        "description": "Short, focused how-to guides."
      }
    },
    {
      "title": "Installing a Vite or Rollup plugin",
      "url": "https://docs.astro.build/en/recipes/add-yaml-support/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/add-yaml-support/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/add-yaml-support/",
        "description": "Learn how you can import YAML data by adding a Rollup plugin to your project."
      }
    },
    {
      "title": "Analyze bundle size",
      "url": "https://docs.astro.build/en/recipes/analyze-bundle-size/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/analyze-bundle-size/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/analyze-bundle-size/",
        "description": "Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`."
      }
    },
    {
      "title": "Build a custom image component",
      "url": "https://docs.astro.build/en/recipes/build-custom-img-component/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/build-custom-img-component/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/build-custom-img-component/",
        "description": "Learn how to build a custom image component that supports media queries using the getImage function."
      }
    },
    {
      "title": "Build HTML forms in Astro pages",
      "url": "https://docs.astro.build/en/recipes/build-forms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/build-forms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/build-forms/",
        "description": "Learn how to build HTML forms and handle submissions in your frontmatter."
      }
    },
    {
      "title": "Build forms with API routes",
      "url": "https://docs.astro.build/en/recipes/build-forms-api/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/build-forms-api/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/build-forms-api/",
        "description": "Learn how to use JavaScript to send form submissions to an API Route."
      }
    },
    {
      "title": "Use Bun with Astro",
      "url": "https://docs.astro.build/en/recipes/bun/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/bun/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/bun/",
        "description": "Learn how to use Bun with your Astro site."
      }
    },
    {
      "title": "Call endpoints from the server",
      "url": "https://docs.astro.build/en/recipes/call-endpoints/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/call-endpoints/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/call-endpoints/",
        "description": "Learn how to call endpoints from the server in Astro."
      }
    },
    {
      "title": "Verify a Captcha",
      "url": "https://docs.astro.build/en/recipes/captcha/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/captcha/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/captcha/",
        "description": "Learn how to create an API route and fetch it from the client."
      }
    },
    {
      "title": "Build your Astro site with Docker",
      "url": "https://docs.astro.build/en/recipes/docker/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/docker/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/docker/",
        "description": "Learn how to build your Astro site using Docker."
      }
    },
    {
      "title": "Dynamically import images",
      "url": "https://docs.astro.build/en/recipes/dynamically-importing-images/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/dynamically-importing-images/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/dynamically-importing-images/",
        "description": "Learn how to dynamically import images using Vite's import.meta.glob function."
      }
    },
    {
      "title": "Add icons to external links",
      "url": "https://docs.astro.build/en/recipes/external-links/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/external-links/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/external-links/",
        "description": "Learn how to install a rehype plugin to add icons to external links in your Markdown files."
      }
    },
    {
      "title": "Add i18n features",
      "url": "https://docs.astro.build/en/recipes/i18n/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/i18n/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/i18n/",
        "description": "Use dynamic routing and content collections to add internationalization support to your Astro site."
      }
    },
    {
      "title": "Create a dev toolbar app",
      "url": "https://docs.astro.build/en/recipes/making-toolbar-apps/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/making-toolbar-apps/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/making-toolbar-apps/",
        "description": "Learn how to create a dev toolbar app for your site."
      }
    },
    {
      "title": "Add last modified time",
      "url": "https://docs.astro.build/en/recipes/modified-time/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/modified-time/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/modified-time/",
        "description": "Build a remark plugin to add the last modified time to your Markdown and MDX."
      }
    },
    {
      "title": "Add reading time",
      "url": "https://docs.astro.build/en/recipes/reading-time/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/reading-time/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/reading-time/",
        "description": "Build a remark plugin to add reading time to your Markdown or MDX files."
      }
    },
    {
      "title": "Share state between Astro components",
      "url": "https://docs.astro.build/en/recipes/sharing-state/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/sharing-state/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/sharing-state/",
        "description": "Learn how to share state across Astro components with Nano Stores."
      }
    },
    {
      "title": "Share state between islands",
      "url": "https://docs.astro.build/en/recipes/sharing-state-islands/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/sharing-state-islands/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/sharing-state-islands/",
        "description": "Learn how to share state across framework components with Nano Stores."
      }
    },
    {
      "title": "Using streaming to improve page performance",
      "url": "https://docs.astro.build/en/recipes/streaming-improve-page-performance/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/streaming-improve-page-performance/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/streaming-improve-page-performance/",
        "description": "Learn how to use streaming to improve page performance."
      }
    },
    {
      "title": "Style rendered Markdown with Tailwind Typography",
      "url": "https://docs.astro.build/en/recipes/tailwind-rendered-markdown/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/recipes/tailwind-rendered-markdown/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/recipes/tailwind-rendered-markdown/",
        "description": "Learn how to use @tailwind/typography to style your rendered Markdown."
      }
    },
    {
      "title": "Contribute to Astro",
      "url": "https://docs.astro.build/en/contribute/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/contribute/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/contribute/",
        "description": "How to get involved and contribute to Astro."
      }
    },
    {
      "title": "Template expressions reference",
      "url": "https://docs.astro.build/en/reference/astro-syntax/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/astro-syntax/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/astro-syntax/"
      }
    },
    {
      "title": "Template directives reference",
      "url": "https://docs.astro.build/en/reference/directives-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/directives-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/directives-reference/"
      }
    },
    {
      "title": "Configuration Reference",
      "url": "https://docs.astro.build/en/reference/configuration-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/configuration-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/configuration-reference/"
      }
    },
    {
      "title": "CLI Commands",
      "url": "https://docs.astro.build/en/reference/cli-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/cli-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/cli-reference/"
      }
    },
    {
      "title": "Imports reference",
      "url": "https://docs.astro.build/en/guides/imports/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/imports/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/imports/",
        "description": "Learn how to import different file types into your Astro project."
      }
    },
    {
      "title": "Routing Reference",
      "url": "https://docs.astro.build/en/reference/routing-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/routing-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/routing-reference/"
      }
    },
    {
      "title": "Actions API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-actions/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-actions/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-actions/"
      }
    },
    {
      "title": "Image and Assets API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-assets/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-assets/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-assets/"
      }
    },
    {
      "title": "Config imports API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-config/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-config/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-config/"
      }
    },
    {
      "title": "Content Collections API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-content/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-content/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-content/"
      }
    },
    {
      "title": "Environment Variables API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-env/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-env/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-env/"
      }
    },
    {
      "title": "Internationalization API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-i18n/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-i18n/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-i18n/"
      }
    },
    {
      "title": "Middleware API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-middleware/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-middleware/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-middleware/"
      }
    },
    {
      "title": "View Transitions Router API Reference",
      "url": "https://docs.astro.build/en/reference/modules/astro-transitions/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/modules/astro-transitions/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/modules/astro-transitions/"
      }
    },
    {
      "title": "Astro Integration API",
      "url": "https://docs.astro.build/en/reference/integrations-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/integrations-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/integrations-reference/"
      }
    },
    {
      "title": "Astro Adapter API",
      "url": "https://docs.astro.build/en/reference/adapter-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/adapter-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/adapter-reference/"
      }
    },
    {
      "title": "Astro Content Loader API",
      "url": "https://docs.astro.build/en/reference/content-loader-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/content-loader-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/content-loader-reference/"
      }
    },
    {
      "title": "Image Service API",
      "url": "https://docs.astro.build/en/reference/image-service-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/image-service-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/image-service-reference/"
      }
    },
    {
      "title": "Dev Toolbar App API",
      "url": "https://docs.astro.build/en/reference/dev-toolbar-app-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/dev-toolbar-app-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/dev-toolbar-app-reference/"
      }
    },
    {
      "title": "Astro Container API (experimental)",
      "url": "https://docs.astro.build/en/reference/container-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/container-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/container-reference/"
      }
    },
    {
      "title": "Programmatic Astro API (experimental)",
      "url": "https://docs.astro.build/en/reference/programmatic-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/programmatic-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/programmatic-reference/"
      }
    },
    {
      "title": "Configuring experimental flags",
      "url": "https://docs.astro.build/en/reference/experimental-flags/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/"
      }
    },
    {
      "title": "Experimental responsive images",
      "url": "https://docs.astro.build/en/reference/experimental-flags/responsive-images/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/responsive-images/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/responsive-images/"
      }
    },
    {
      "title": "Experimental fonts API",
      "url": "https://docs.astro.build/en/reference/experimental-flags/fonts/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/fonts/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/fonts/"
      }
    },
    {
      "title": "Experimental client prerendering",
      "url": "https://docs.astro.build/en/reference/experimental-flags/client-prerender/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/client-prerender/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/client-prerender/"
      }
    },
    {
      "title": "Experimental Intellisense for content collections",
      "url": "https://docs.astro.build/en/reference/experimental-flags/content-intellisense/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/content-intellisense/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/content-intellisense/"
      }
    },
    {
      "title": "Experimental preserve scripts order",
      "url": "https://docs.astro.build/en/reference/experimental-flags/preserve-scripts-order/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/preserve-scripts-order/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/preserve-scripts-order/"
      }
    },
    {
      "title": "Experimental Markdown heading ID compatibility",
      "url": "https://docs.astro.build/en/reference/experimental-flags/heading-id-compat/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/experimental-flags/heading-id-compat/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/experimental-flags/heading-id-compat/"
      }
    },
    {
      "title": "Legacy flags",
      "url": "https://docs.astro.build/en/reference/legacy-flags/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/legacy-flags/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/legacy-flags/"
      }
    },
    {
      "title": "Error reference",
      "url": "https://docs.astro.build/en/reference/error-reference/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/error-reference/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/error-reference/"
      }
    },
    {
      "title": "Add Integrations",
      "url": "https://docs.astro.build/en/guides/integrations-guide/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/",
        "description": "Learn how to add integrations to your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\talpinejs",
      "url": "https://docs.astro.build/en/guides/integrations-guide/alpinejs/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/alpinejs/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/alpinejs/",
        "description": "Learn how to use the @astrojs/alpinejs framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tpreact",
      "url": "https://docs.astro.build/en/guides/integrations-guide/preact/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/preact/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/preact/",
        "description": "Learn how to use the @astrojs/preact framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\treact",
      "url": "https://docs.astro.build/en/guides/integrations-guide/react/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/react/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/react/",
        "description": "Learn how to use the @astrojs/react framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tsolid-js",
      "url": "https://docs.astro.build/en/guides/integrations-guide/solid-js/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/solid-js/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/solid-js/",
        "description": "Learn how to use the @astrojs/solid-js framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tsvelte",
      "url": "https://docs.astro.build/en/guides/integrations-guide/svelte/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/svelte/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/svelte/",
        "description": "Learn how to use the @astrojs/svelte framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tvue",
      "url": "https://docs.astro.build/en/guides/integrations-guide/vue/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/vue/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/vue/",
        "description": "Learn how to use the @astrojs/vue framework integration to extend component support in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tcloudflare",
      "url": "https://docs.astro.build/en/guides/integrations-guide/cloudflare/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/cloudflare/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/cloudflare/",
        "description": "Learn how to use the @astrojs/cloudflare adapter to deploy your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tnetlify",
      "url": "https://docs.astro.build/en/guides/integrations-guide/netlify/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/netlify/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/netlify/",
        "description": "Learn how to use the @astrojs/netlify adapter to deploy your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tnode",
      "url": "https://docs.astro.build/en/guides/integrations-guide/node/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/node/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/node/",
        "description": "Learn how to use the @astrojs/node adapter to deploy your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tvercel",
      "url": "https://docs.astro.build/en/guides/integrations-guide/vercel/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/vercel/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/vercel/",
        "description": "Learn how to use the @astrojs/vercel adapter to deploy your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tdb",
      "url": "https://docs.astro.build/en/guides/integrations-guide/db/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/db/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/db/",
        "description": "Learn how to use the @astrojs/db integration in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tmarkdoc",
      "url": "https://docs.astro.build/en/guides/integrations-guide/markdoc/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/markdoc/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/markdoc/",
        "description": "Learn how to use the @astrojs/markdoc integration in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tmdx",
      "url": "https://docs.astro.build/en/guides/integrations-guide/mdx/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/mdx/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/mdx/",
        "description": "Learn how to use the @astrojs/mdx integration in your Astro project."
      }
    },
    {
      "title": "@astrojs/\n\t\t\t\t\tpartytown",
      "url": "https://docs.astro.build/en/guides/integrations-guide/partytown/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/integrations-guide/partytown/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/integrations-guide/partytown/",
        "description": "Learn how to use the @astrojs/partytown integration in your Astro project."
      }
    },
    {
      "title": "Publish to NPM",
      "url": "https://docs.astro.build/en/reference/publish-to-npm/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/reference/publish-to-npm/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/reference/publish-to-npm/",
        "description": "Learn how to publish Astro components to NPM"
      }
    },
    {
      "title": "Deploy your Astro Site",
      "url": "https://docs.astro.build/en/guides/deploy/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/",
        "description": "How to deploy your Astro site to the web."
      }
    },
    {
      "title": "Deploy your Astro Site to AWS",
      "url": "https://docs.astro.build/en/guides/deploy/aws/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/aws/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/aws/",
        "description": "How to deploy your Astro site to the web using AWS."
      }
    },
    {
      "title": "Deploy your Astro Site to Azion",
      "url": "https://docs.astro.build/en/guides/deploy/azion/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/azion/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/azion/",
        "description": "How to deploy your Astro site to the web using Azion."
      }
    },
    {
      "title": "Deploy your Astro Site with Buddy",
      "url": "https://docs.astro.build/en/guides/deploy/buddy/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/buddy/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/buddy/",
        "description": "How to deploy your Astro site to the web using Buddy."
      }
    },
    {
      "title": "Deploy your Astro Site with Cleavr",
      "url": "https://docs.astro.build/en/guides/deploy/cleavr/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/cleavr/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/cleavr/",
        "description": "How to deploy your Astro site to your VPS server using Cleavr."
      }
    },
    {
      "title": "Deploy your Astro Site to Clever Cloud",
      "url": "https://docs.astro.build/en/guides/deploy/clever-cloud/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/clever-cloud/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/clever-cloud/",
        "description": "How to deploy your Astro site to the web on Clever Cloud."
      }
    },
    {
      "title": "Deploy your Astro Site to Cloudflare",
      "url": "https://docs.astro.build/en/guides/deploy/cloudflare/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/cloudflare/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/cloudflare/",
        "description": "How to deploy your Astro site to the web using Cloudflare"
      }
    },
    {
      "title": "Deploy your Astro Site with Deno",
      "url": "https://docs.astro.build/en/guides/deploy/deno/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/deno/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/deno/",
        "description": "How to deploy your Astro site to the web using Deno."
      }
    },
    {
      "title": "Deploy your Astro Site to Fleek",
      "url": "https://docs.astro.build/en/guides/deploy/fleek/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/fleek/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/fleek/",
        "description": "How to deploy your Astro site to the web on Fleek."
      }
    },
    {
      "title": "Deploy your Astro Site to AWS with Flightcontrol",
      "url": "https://docs.astro.build/en/guides/deploy/flightcontrol/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/flightcontrol/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/flightcontrol/",
        "description": "How to deploy your Astro site to AWS with Flightcontrol"
      }
    },
    {
      "title": "Deploy your Astro Site to Fly.io",
      "url": "https://docs.astro.build/en/guides/deploy/flyio/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/flyio/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/flyio/",
        "description": "How to deploy your Astro site to the web using Fly.io."
      }
    },
    {
      "title": "Deploy your Astro Site to GitHub Pages",
      "url": "https://docs.astro.build/en/guides/deploy/github/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/github/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/github/",
        "description": "How to deploy your Astro site to the web using GitHub Pages."
      }
    },
    {
      "title": "Deploy your Astro Site to GitLab Pages",
      "url": "https://docs.astro.build/en/guides/deploy/gitlab/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/gitlab/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/gitlab/",
        "description": "How to deploy your Astro site to the web using GitLab Pages."
      }
    },
    {
      "title": "Deploy your Astro Site to Google Cloud",
      "url": "https://docs.astro.build/en/guides/deploy/google-cloud/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/google-cloud/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/google-cloud/",
        "description": "How to deploy your Astro site to the web using Google Cloud."
      }
    },
    {
      "title": "Deploy your Astro Site to Google’s Firebase Hosting",
      "url": "https://docs.astro.build/en/guides/deploy/google-firebase/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/google-firebase/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/google-firebase/",
        "description": "How to deploy your Astro site to the web using Google’s Firebase Hosting."
      }
    },
    {
      "title": "Deploy your Astro Site to Heroku",
      "url": "https://docs.astro.build/en/guides/deploy/heroku/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/heroku/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/heroku/",
        "description": "How to deploy your Astro site to the web using Heroku."
      }
    },
    {
      "title": "Deploy your Astro Site to Kinsta Application Hosting",
      "url": "https://docs.astro.build/en/guides/deploy/kinsta/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/kinsta/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/kinsta/",
        "description": "How to deploy your Astro site to the web on Kinsta Application Hosting."
      }
    },
    {
      "title": "Deploy your Astro Site to Microsoft Azure",
      "url": "https://docs.astro.build/en/guides/deploy/microsoft-azure/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/microsoft-azure/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/microsoft-azure/",
        "description": "How to deploy your Astro site to the web using Microsoft Azure."
      }
    },
    {
      "title": "Deploy your Astro Site to Netlify",
      "url": "https://docs.astro.build/en/guides/deploy/netlify/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/netlify/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/netlify/",
        "description": "How to deploy your Astro site to the web on Netlify."
      }
    },
    {
      "title": "Deploy your Astro Site to Render",
      "url": "https://docs.astro.build/en/guides/deploy/render/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/render/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/render/",
        "description": "How to deploy your Astro site to the web using Render."
      }
    },
    {
      "title": "Deploy your Astro Site to AWS with SST",
      "url": "https://docs.astro.build/en/guides/deploy/sst/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/sst/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/sst/",
        "description": "How to deploy your Astro site to AWS with SST"
      }
    },
    {
      "title": "Deploy your Astro Site to Stormkit",
      "url": "https://docs.astro.build/en/guides/deploy/stormkit/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/stormkit/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/stormkit/",
        "description": "Deploy your Astro site to Stormkit"
      }
    },
    {
      "title": "Deploy your Astro Site to Surge",
      "url": "https://docs.astro.build/en/guides/deploy/surge/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/surge/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/surge/",
        "description": "How to deploy your Astro site to the web using Surge"
      }
    },
    {
      "title": "Deploy your Astro Site to Vercel",
      "url": "https://docs.astro.build/en/guides/deploy/vercel/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/vercel/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/vercel/",
        "description": "How to deploy your Astro site to the web on Vercel."
      }
    },
    {
      "title": "Deploy your Astro Site to Zeabur",
      "url": "https://docs.astro.build/en/guides/deploy/zeabur/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/zeabur/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/zeabur/",
        "description": "How to deploy your Astro site to the web on Zeabur."
      }
    },
    {
      "title": "Deploy your Astro Site to Zerops",
      "url": "https://docs.astro.build/en/guides/deploy/zerops/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/deploy/zerops/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/deploy/zerops/",
        "description": "How to deploy your Astro site to the web using Zerops."
      }
    },
    {
      "title": "Use a CMS with Astro",
      "url": "https://docs.astro.build/en/guides/cms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/",
        "description": "How to use a CMS to add content to Astro"
      }
    },
    {
      "title": "ApostropheCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/apostrophecms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/apostrophecms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/apostrophecms/",
        "description": "Edit content on the page in your Astro project using Apostrophe as your CMS."
      }
    },
    {
      "title": "Builder.io & Astro",
      "url": "https://docs.astro.build/en/guides/cms/builderio/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/builderio/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/builderio/",
        "description": "Add content to your Astro project using Builder.io’s visual CMS"
      }
    },
    {
      "title": "ButterCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/buttercms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/buttercms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/buttercms/",
        "description": "Add content to your Astro project using ButterCMS"
      }
    },
    {
      "title": "Caisy & Astro",
      "url": "https://docs.astro.build/en/guides/cms/caisy/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/caisy/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/caisy/",
        "description": "Add content to your Astro project using Caisy as a CMS"
      }
    },
    {
      "title": "CloudCannon & Astro",
      "url": "https://docs.astro.build/en/guides/cms/cloudcannon/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/cloudcannon/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/cloudcannon/",
        "description": "Add content to your Astro project using CloudCannon as a CMS"
      }
    },
    {
      "title": "Contentful & Astro",
      "url": "https://docs.astro.build/en/guides/cms/contentful/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/contentful/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/contentful/",
        "description": "Add content to your Astro project using Contentful as a CMS"
      }
    },
    {
      "title": "Cosmic & Astro",
      "url": "https://docs.astro.build/en/guides/cms/cosmic/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/cosmic/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/cosmic/",
        "description": "Add content to your Astro project using Cosmic as a CMS"
      }
    },
    {
      "title": "Craft CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/craft-cms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/craft-cms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/craft-cms/",
        "description": "Add content to your Astro project using Craft CMS as a CMS"
      }
    },
    {
      "title": "Crystallize & Astro",
      "url": "https://docs.astro.build/en/guides/cms/crystallize/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/crystallize/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/crystallize/",
        "description": "Add content to your Astro project using Crystallize as a CMS"
      }
    },
    {
      "title": "DatoCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/datocms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/datocms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/datocms/",
        "description": "Add content to your Astro project using DatoCMS"
      }
    },
    {
      "title": "Decap CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/decap-cms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/decap-cms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/decap-cms/",
        "description": "Add content to your Astro project using Decap as a CMS"
      }
    },
    {
      "title": "Directus & Astro",
      "url": "https://docs.astro.build/en/guides/cms/directus/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/directus/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/directus/",
        "description": "Add content to your Astro project using Directus as a CMS"
      }
    },
    {
      "title": "Drupal & Astro",
      "url": "https://docs.astro.build/en/guides/cms/drupal/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/drupal/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/drupal/",
        "description": "Add content to your Astro project using Drupal as a CMS"
      }
    },
    {
      "title": "Flotiq & Astro",
      "url": "https://docs.astro.build/en/guides/cms/flotiq/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/flotiq/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/flotiq/",
        "description": "Add content to your Astro project using Flotiq as a CMS"
      }
    },
    {
      "title": "Front Matter CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/frontmatter-cms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/frontmatter-cms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/frontmatter-cms/",
        "description": "Add content to your Astro project using Front Matter CMS"
      }
    },
    {
      "title": "Ghost & Astro",
      "url": "https://docs.astro.build/en/guides/cms/ghost/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/ghost/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/ghost/",
        "description": "Add content to your Astro project using Ghost as a CMS"
      }
    },
    {
      "title": "GitCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/gitcms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/gitcms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/gitcms/",
        "description": "Integrate GitCMS into your Astro project for seamless content management"
      }
    },
    {
      "title": "Hashnode & Astro",
      "url": "https://docs.astro.build/en/guides/cms/hashnode/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/hashnode/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/hashnode/",
        "description": "Add content to your Astro project using Hashnode as a CMS"
      }
    },
    {
      "title": "Hygraph & Astro",
      "url": "https://docs.astro.build/en/guides/cms/hygraph/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/hygraph/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/hygraph/",
        "description": "Add content to your Astro project using Hygraph as a CMS"
      }
    },
    {
      "title": "Keystatic & Astro",
      "url": "https://docs.astro.build/en/guides/cms/keystatic/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/keystatic/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/keystatic/",
        "description": "Add content to your Astro project using Keystatic as a CMS"
      }
    },
    {
      "title": "KeystoneJS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/keystonejs/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/keystonejs/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/keystonejs/",
        "description": "Add content to your Astro project using KeystoneJS as a CMS"
      }
    },
    {
      "title": "Kontent.ai & Astro",
      "url": "https://docs.astro.build/en/guides/cms/kontent-ai/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/kontent-ai/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/kontent-ai/",
        "description": "Add content to your Astro project using Kontent.ai as CMS"
      }
    },
    {
      "title": "microCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/microcms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/microcms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/microcms/",
        "description": "Add content to your Astro project using microCMS"
      }
    },
    {
      "title": "Payload CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/payload/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/payload/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/payload/",
        "description": "Add content to your Astro project using Payload as a CMS"
      }
    },
    {
      "title": "Prepr CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/preprcms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/preprcms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/preprcms/",
        "description": "Add content to your Astro project using Prepr as a CMS"
      }
    },
    {
      "title": "Prismic & Astro",
      "url": "https://docs.astro.build/en/guides/cms/prismic/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/prismic/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/prismic/",
        "description": "Add content to your Astro project using Prismic as a CMS"
      }
    },
    {
      "title": "Sanity & Astro",
      "url": "https://docs.astro.build/en/guides/cms/sanity/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/sanity/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/sanity/",
        "description": "Add content to your Astro project using Sanity as a CMS"
      }
    },
    {
      "title": "Sitecore Experience Manager & Astro",
      "url": "https://docs.astro.build/en/guides/cms/sitecore/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/sitecore/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/sitecore/",
        "description": "Add content to your project using Sitecore as your CMS."
      }
    },
    {
      "title": "Spinal & Astro",
      "url": "https://docs.astro.build/en/guides/cms/spinal/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/spinal/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/spinal/",
        "description": "Add content to your project using Spinal as your CMS."
      }
    },
    {
      "title": "Headless Statamic & Astro",
      "url": "https://docs.astro.build/en/guides/cms/statamic/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/statamic/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/statamic/",
        "description": "Add content to your Astro project using Statamic as a CMS"
      }
    },
    {
      "title": "Storyblok & Astro",
      "url": "https://docs.astro.build/en/guides/cms/storyblok/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/storyblok/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/storyblok/",
        "description": "Add content to your Astro project using Storyblok as a CMS"
      }
    },
    {
      "title": "Strapi & Astro",
      "url": "https://docs.astro.build/en/guides/cms/strapi/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/strapi/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/strapi/",
        "description": "Add content to your Astro project using Strapi Headless CMS"
      }
    },
    {
      "title": "StudioCMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/studiocms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/studiocms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/studiocms/",
        "description": "Build and manage content for your Astro project using StudioCMS, a headless CMS designed specifically for Astro."
      }
    },
    {
      "title": "Tina CMS & Astro",
      "url": "https://docs.astro.build/en/guides/cms/tina-cms/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/tina-cms/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/tina-cms/",
        "description": "Add content to your Astro project using Tina as a CMS"
      }
    },
    {
      "title": "Umbraco & Astro",
      "url": "https://docs.astro.build/en/guides/cms/umbraco/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/umbraco/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/umbraco/",
        "description": "Add content to your Astro project using Umbraco as a CMS"
      }
    },
    {
      "title": "Headless WordPress & Astro",
      "url": "https://docs.astro.build/en/guides/cms/wordpress/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/cms/wordpress/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/cms/wordpress/",
        "description": "Add content to your Astro project using WordPress as a CMS"
      }
    },
    {
      "title": "Use a backend service with Astro",
      "url": "https://docs.astro.build/en/guides/backend/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/",
        "description": "How to use a backend service to add authentication, storage and data"
      }
    },
    {
      "title": "Appwrite & Astro",
      "url": "https://docs.astro.build/en/guides/backend/appwriteio/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/appwriteio/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/appwriteio/",
        "description": "Add a backend to your project with Appwrite"
      }
    },
    {
      "title": "Firebase & Astro",
      "url": "https://docs.astro.build/en/guides/backend/google-firebase/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/google-firebase/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/google-firebase/",
        "description": "Add a backend to your project with Firebase"
      }
    },
    {
      "title": "Neon Postgres & Astro",
      "url": "https://docs.astro.build/en/guides/backend/neon/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/neon/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/neon/",
        "description": "Add a serverless Postgres database to your Astro project with Neon"
      }
    },
    {
      "title": "Monitor your Astro Site with Sentry",
      "url": "https://docs.astro.build/en/guides/backend/sentry/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/sentry/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/sentry/",
        "description": "How to monitor your Astro site with Sentry"
      }
    },
    {
      "title": "Supabase & Astro",
      "url": "https://docs.astro.build/en/guides/backend/supabase/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/supabase/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/supabase/",
        "description": "Add a backend to your project with Supabase"
      }
    },
    {
      "title": "Turso & Astro",
      "url": "https://docs.astro.build/en/guides/backend/turso/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/turso/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/turso/",
        "description": "Build locally with a SQLite file and deploy globally using Turso."
      }
    },
    {
      "title": "Xata & Astro",
      "url": "https://docs.astro.build/en/guides/backend/xata/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/backend/xata/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/backend/xata/",
        "description": "Add a serverless database with full-text search to your project with Xata"
      }
    },
    {
      "title": "Use a DAM with Astro",
      "url": "https://docs.astro.build/en/guides/media/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/media/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/media/",
        "description": "How to use a Digital Asset Manager (DAM) to add images and videos to Astro"
      }
    },
    {
      "title": "Cloudinary & Astro",
      "url": "https://docs.astro.build/en/guides/media/cloudinary/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/media/cloudinary/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/media/cloudinary/",
        "description": "Add images and videos to your Astro project using Cloudinary"
      }
    },
    {
      "title": "E-commerce",
      "url": "https://docs.astro.build/en/guides/ecommerce/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/ecommerce/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/ecommerce/",
        "description": "An introduction to adding e-commerce options to your Astro site"
      }
    },
    {
      "title": "Authentication",
      "url": "https://docs.astro.build/en/guides/authentication/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/authentication/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/authentication/",
        "description": "An intro to authentication in Astro"
      }
    },
    {
      "title": "Testing",
      "url": "https://docs.astro.build/en/guides/testing/",
      "outputPath": "/Users/serbinov/Desktop/projects/personal/doc_scrapper/scraped-docs/astro-test/en/guides/testing/.md",
      "metadata": {
        "url": "https://docs.astro.build/en/guides/testing/",
        "description": "An intro to testing in Astro"
      }
    }
  ]
}
```

---

*Generated by Doc Scrapper AI - Your Documentation Consolidation Tool*
